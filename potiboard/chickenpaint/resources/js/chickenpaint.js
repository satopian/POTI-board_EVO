(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.ChickenPaint = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; /*
                                                                                                                                                                                                                                                                                  ChickenPaint
                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                  ChickenPaint is a translation of ChibiPaint from Java to JavaScript
                                                                                                                                                                                                                                                                                  by Nicholas Sherlock / Chicken Smoothie.
                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                  ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                  ChickenPaint is free software: you can redistribute it and/or modify
                                                                                                                                                                                                                                                                                  it under the terms of the GNU General Public License as published by
                                                                                                                                                                                                                                                                                  the Free Software Foundation, either version 3 of the License, or
                                                                                                                                                                                                                                                                                  (at your option) any later version.
                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                  ChickenPaint is distributed in the hope that it will be useful,
                                                                                                                                                                                                                                                                                  but WITHOUT ANY WARRANTY; without even the implied warranty of
                                                                                                                                                                                                                                                                                  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                                                                                                                                                                                                                                                                  GNU General Public License for more details.
                                                                                                                                                                                                                                                                              
                                                                                                                                                                                                                                                                                  You should have received a copy of the GNU General Public License
                                                                                                                                                                                                                                                                                  along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
                                                                                                                                                                                                                                                                              */

exports.default = ChickenPaint;

var _CPBrushInfo = require("./engine/CPBrushInfo");

var _CPBrushInfo2 = _interopRequireDefault(_CPBrushInfo);

var _CPArtwork = require("./engine/CPArtwork");

var _CPArtwork2 = _interopRequireDefault(_CPArtwork);

var _CPResourceLoader = require("./engine/CPResourceLoader");

var _CPResourceLoader2 = _interopRequireDefault(_CPResourceLoader);

var _CPResourceSaver = require("./engine/CPResourceSaver");

var _CPResourceSaver2 = _interopRequireDefault(_CPResourceSaver);

var _CPSplashScreen = require("./gui/CPSplashScreen.js");

var _CPSplashScreen2 = _interopRequireDefault(_CPSplashScreen);

var _CPMainGUI = require("./gui/CPMainGUI");

var _CPMainGUI2 = _interopRequireDefault(_CPMainGUI);

var _CPAboutDialog = require("./gui/CPAboutDialog");

var _CPAboutDialog2 = _interopRequireDefault(_CPAboutDialog);

var _CPConfirmTransformDialog = require("./gui/CPConfirmTransformDialog");

var _CPConfirmTransformDialog2 = _interopRequireDefault(_CPConfirmTransformDialog);

var _CPShortcutsDialog = require("./gui/CPShortcutsDialog");

var _CPShortcutsDialog2 = _interopRequireDefault(_CPShortcutsDialog);

var _CPBoxBlurDialog = require("./gui/CPBoxBlurDialog");

var _CPBoxBlurDialog2 = _interopRequireDefault(_CPBoxBlurDialog);

var _CPTabletDialog = require("./gui/CPTabletDialog");

var _CPTabletDialog2 = _interopRequireDefault(_CPTabletDialog);

var _CPGridDialog = require("./gui/CPGridDialog");

var _CPGridDialog2 = _interopRequireDefault(_CPGridDialog);

var _CPSendDialog = require("./gui/CPSendDialog");

var _CPSendDialog2 = _interopRequireDefault(_CPSendDialog);

var _CPPolyfill = require("./util/CPPolyfill");

var _CPColor = require("./util/CPColor");

var _CPColor2 = _interopRequireDefault(_CPColor);

var _CPWacomTablet = require("./util/CPWacomTablet");

var _CPWacomTablet2 = _interopRequireDefault(_CPWacomTablet);

var _CPRect = require("./util/CPRect");

var _CPRect2 = _interopRequireDefault(_CPRect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function isBrowserSupported() {
    return (0, _CPPolyfill.isCanvasSupported)() && "Uint8Array" in window;
}

function createDrawingTools() {
    var tools = new Array(ChickenPaint.T_MAX);

    tools[ChickenPaint.T_PENCIL] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_PENCIL,
        size: 16,
        alpha: 255,
        isAA: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        type: _CPBrushInfo2.default.B_ROUND_AA,
        paintMode: _CPBrushInfo2.default.M_PAINT
    });

    tools[ChickenPaint.T_ERASER] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_ERASER,
        size: 16,
        alpha: 255,
        isAA: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: false,
        type: _CPBrushInfo2.default.B_ROUND_AA,
        paintMode: _CPBrushInfo2.default.M_ERASE
    });

    tools[ChickenPaint.T_PEN] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_PEN,
        size: 2,
        alpha: 128,
        isAA: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: true,
        pressureAlpha: false,
        type: _CPBrushInfo2.default.B_ROUND_AA,
        paintMode: _CPBrushInfo2.default.M_PAINT
    });

    tools[ChickenPaint.T_SOFTERASER] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_SOFTERASER,
        size: 16,
        alpha: 64,
        isAA: false,
        isAirbrush: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        type: _CPBrushInfo2.default.B_ROUND_AIRBRUSH,
        paintMode: _CPBrushInfo2.default.M_ERASE
    });

    tools[ChickenPaint.T_AIRBRUSH] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_AIRBRUSH,
        size: 50,
        alpha: 32,
        isAA: false,
        isAirbrush: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        type: _CPBrushInfo2.default.B_ROUND_AIRBRUSH,
        paintMode: _CPBrushInfo2.default.M_PAINT
    });

    tools[ChickenPaint.T_DODGE] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_DODGE,
        size: 30,
        alpha: 32,
        isAA: false,
        isAirbrush: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        type: _CPBrushInfo2.default.B_ROUND_AIRBRUSH,
        paintMode: _CPBrushInfo2.default.M_DODGE
    });

    tools[ChickenPaint.T_BURN] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_BURN,
        size: 30,
        alpha: 32,
        isAA: false,
        isAirbrush: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        type: _CPBrushInfo2.default.B_ROUND_AIRBRUSH,
        paintMode: _CPBrushInfo2.default.M_BURN
    });

    tools[ChickenPaint.T_WATER] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_WATER,
        size: 30,
        alpha: 70,
        isAA: false,
        isAirbrush: true,
        minSpacing: 0.5,
        spacing: 0.02,
        pressureSize: false,
        pressureAlpha: true,
        type: _CPBrushInfo2.default.B_ROUND_AA,
        paintMode: _CPBrushInfo2.default.M_WATER,
        resat: 0.3,
        bleed: 0.6
    });

    tools[ChickenPaint.T_BLUR] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_BLUR,
        size: 20,
        alpha: 255,
        isAA: false,
        isAirbrush: true,
        minSpacing: 0.5,
        spacing: 0.05,
        pressureSize: false,
        pressureAlpha: true,
        type: _CPBrushInfo2.default.B_ROUND_PIXEL,
        paintMode: _CPBrushInfo2.default.M_BLUR
    });

    tools[ChickenPaint.T_SMUDGE] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_SMUDGE,
        size: 20,
        alpha: 128,
        isAA: false,
        isAirbrush: true,
        minSpacing: 0.5,
        spacing: 0.01,
        pressureSize: false,
        pressureAlpha: true,
        type: _CPBrushInfo2.default.B_ROUND_AIRBRUSH,
        paintMode: _CPBrushInfo2.default.M_SMUDGE,
        resat: 0.0,
        bleed: 1.0
    });

    tools[ChickenPaint.T_BLENDER] = new _CPBrushInfo2.default({
        toolNb: ChickenPaint.T_BLENDER,
        size: 20,
        alpha: 60,
        isAA: false,
        isAirbrush: true,
        minSpacing: 0.5,
        spacing: 0.1,
        pressureSize: false,
        pressureAlpha: true,
        type: _CPBrushInfo2.default.B_ROUND_AIRBRUSH,
        paintMode: _CPBrushInfo2.default.M_OIL,
        resat: 0.0,
        bleed: 0.07
    });

    return tools;
}

/**
 * Creates an instance of the ChickenPaint drawing app. Options is an object with these keys:
 *
 * uiElem       - DOM element to insert ChickenPaint into (required)
 * canvasWidth  - Width in pixels to use when creating blank canvases (defaults to 800)
 * canvasHeight - Height in pixels to use when creating blank canvases (defaults to 600)
 * rotation     - Integer from [0..3], number of 90 degree right rotations that should be applied to the canvas after
 *                loading
 *
 * saveUrl   - URL to POST the drawing to to save it
 * postUrl   - URL to navigate to after saving is successful and the user chooses to see/publish their finished product
 * exitUrl   - URL to navigate to after saving is successful and the user chooses to exit (optional)
 * testUrl   - URL that ChickenPaint can simulate a drawing upload to to test the user's permissions/connection (optional)
 *
 * loadImageUrl     - URL of PNG/JPEG image to load for editing (optional)
 * loadChibiFileUrl - URL of .chi file to load for editing (optional). Used in preference to loadImage.
 * loadSwatchesUrl  - URL of an .aco palette to load (optional)
 *
 * allowMultipleSends - Allow the drawing to be sent to the server multiple times (saving does not immediately end drawing session).
 * allowDownload - Allow the drawing to be saved to the user's computer
 * allowFullScreen - Allow the drawing tool to enter "full screen" mode, where the rest of the page contents will be hidden
 *
 * disableBootstrapAPI - Disable Bootstrap's data API on the root of the document. This speeds up things considerably.
 * 
 * resourcesRoot - URL to the directory that contains the gfx/css etc directories (relative to the page that 
 *                 ChickenPaint is loaded on)
 *
 * @throws ChickenPaint.UnsupportedBrowserException if the web browser does not support ChickenPaint
 */
function ChickenPaint(options) {
    var that = this,
        uiElem = options.uiElem,
        canvas,
        mainGUI,
        curColor = new _CPColor2.default(0),
        curBrush = ChickenPaint.T_PENCIL,
        curMode = ChickenPaint.M_DRAW,
        preTransformMode = curMode,
        curGradient = [0xFF000000, 0xFFFFFFFF],
        fullScreenMode = false,
        tools = createDrawingTools(),
        boxBlurDialog,
        gridDialog,
        actions = {
        // GUI actions

        CPFullScreen: {
            action: function action() {
                fullScreenMode = !fullScreenMode;

                $("body").toggleClass("chickenpaint-full-screen", fullScreenMode);
                $(uiElem).toggleClass("chickenpaint-full-screen", fullScreenMode);

                setTimeout(function () {
                    mainGUI.setFullScreenMode(fullScreenMode);
                }, 200);
            },
            isSupported: function isSupported() {
                return options.allowFullScreen !== false;
            },
            modifies: { gui: true }
        },
        CPZoomIn: {
            action: function action() {
                canvas.zoomIn();
            },
            modifies: { gui: true }
        },
        CPZoomOut: {
            action: function action() {
                canvas.zoomOut();
            },
            modifies: { gui: true }
        },
        CPZoom100: {
            action: function action() {
                canvas.zoom100();
            },
            modifies: { gui: true }
        },

        // History actions

        CPUndo: {
            action: function action() {
                that.artwork.undo();
            },
            modifies: { document: true }
        },
        CPRedo: {
            action: function action() {
                that.artwork.redo();
            },
            modifies: { document: true }
        },
        CPClearHistory: {
            action: function action() {
                if (confirm("You're about to clear the current Undo/Redo history.\nThis operation cannot be undone, are you sure you want to do that?")) {
                    that.artwork.clearHistory();
                }
            },
            modifies: { document: true }
        },

        // Drawing tools

        CPPencil: new ToolChangeAction(ChickenPaint.T_PENCIL),
        CPPen: new ToolChangeAction(ChickenPaint.T_PEN),
        CPEraser: new ToolChangeAction(ChickenPaint.T_ERASER),
        CPSoftEraser: new ToolChangeAction(ChickenPaint.T_SOFTERASER),
        CPAirbrush: new ToolChangeAction(ChickenPaint.T_AIRBRUSH),
        CPDodge: new ToolChangeAction(ChickenPaint.T_DODGE),
        CPBurn: new ToolChangeAction(ChickenPaint.T_BURN),
        CPWater: new ToolChangeAction(ChickenPaint.T_WATER),
        CPBlur: new ToolChangeAction(ChickenPaint.T_BLUR),
        CPSmudge: new ToolChangeAction(ChickenPaint.T_SMUDGE),
        CPBlender: new ToolChangeAction(ChickenPaint.T_BLENDER),

        // Modes

        CPFloodFill: new ModeChangeAction(ChickenPaint.M_FLOODFILL),
        CPGradientFill: new ModeChangeAction(ChickenPaint.M_GRADIENTFILL),
        CPRectSelection: new ModeChangeAction(ChickenPaint.M_RECT_SELECTION),
        CPMoveTool: new ModeChangeAction(ChickenPaint.M_MOVE_TOOL),
        CPRotateCanvas: new ModeChangeAction(ChickenPaint.M_ROTATE_CANVAS),
        CPColorPicker: new ModeChangeAction(ChickenPaint.M_COLOR_PICKER),

        // Layer transform

        CPTransform: {
            action: function action() {
                var layer = that.artwork.getActiveLayer(),
                    layerIndex = that.artwork.getActiveLayerIndex();

                if (!layer.visible) {
                    that.showLayerNotification(layerIndex, "Whoops! This layer is currently hidden", "layer");
                } else if (layer.alpha == 0) {
                    that.showLayerNotification(layerIndex, "Whoops! This layer's opacity is currently 0%", "opacity");
                } else if (that.artwork.transformAffineBegin() == null) {
                    that.showLayerNotification(layerIndex, "Whoops! All of the selected pixels are transparent!", "layer");
                } else {
                    setMode(ChickenPaint.M_TRANSFORM);
                }
            },
            modifies: { mode: true }
        },
        CPTransformAccept: {
            action: function action() {
                if (curMode == ChickenPaint.M_TRANSFORM) {
                    that.artwork.transformAffineFinish();
                    setMode(preTransformMode);
                }
            },
            modifies: { mode: true }
        },
        CPTransformReject: {
            action: function action() {
                if (curMode == ChickenPaint.M_TRANSFORM) {
                    that.artwork.transformAffineAbort();
                    setMode(preTransformMode);
                }
            },
            modifies: { document: true, mode: true }
        },

        // Stroke modes

        CPFreeHand: {
            action: function action() {
                tools[curBrush].strokeMode = _CPBrushInfo2.default.SM_FREEHAND;
                callToolListeners();
            },
            modifies: { tool: true }
        },
        CPLine: {
            action: function action() {
                tools[curBrush].strokeMode = _CPBrushInfo2.default.SM_LINE;
                callToolListeners();
            },
            modifies: { tool: true }
        },
        CPBezier: {
            action: function action() {
                tools[curBrush].strokeMode = _CPBrushInfo2.default.SM_BEZIER;
                callToolListeners();
            },
            modifies: { tool: true }
        },

        // Help dialogs

        CPAbout: {
            action: function action() {
                new _CPAboutDialog2.default(uiElem).show();
            },
            modifies: {}
        },
        CPShortcuts: {
            action: function action() {
                new _CPShortcutsDialog2.default(uiElem).show();
            },
            modifies: {}
        },
        CPTabletSupport: {
            action: function action() {
                new _CPTabletDialog2.default(uiElem).show();
            },
            modifies: {}
        },

        // Layer actions

        CPLayerDuplicate: {
            action: function action() {
                that.artwork.duplicateLayer();
            },
            modifies: { document: true }
        },
        CPLayerMergeDown: {
            action: function action() {
                that.artwork.mergeDown(true);
            },
            modifies: { document: true }
        },
        CPLayerMergeAll: {
            action: function action() {
                that.artwork.mergeAllLayers(true);
            },
            modifies: { document: true }
        },
        CPFill: {
            action: function action() {
                that.artwork.fill(that.getCurColorRgb() | 0xff000000);
            },
            modifies: { document: true }
        },
        CPClear: {
            action: function action() {
                that.artwork.clear();
            },
            modifies: { document: true }
        },
        CPSelectAll: {
            action: function action() {
                that.artwork.rectangleSelection(that.artwork.getBounds());
                canvas.repaintAll();
            },
            modifies: { document: true }
        },
        CPDeselectAll: {
            action: function action() {
                that.artwork.rectangleSelection(new _CPRect2.default(0, 0, 0, 0));
                canvas.repaintAll();
            },
            modifies: { document: true }
        },
        CPHFlip: {
            action: function action() {
                that.artwork.hFlip();
            },
            modifies: { document: true }
        },
        CPVFlip: {
            action: function action() {
                that.artwork.vFlip();
            },
            modifies: { document: true }
        },
        CPMNoise: {
            action: function action() {
                that.artwork.monochromaticNoise();
            },
            modifies: { document: true }
        },
        CPCNoise: {
            action: function action() {
                that.artwork.colorNoise();
            },
            modifies: { document: true }
        },
        CPFXBoxBlur: {
            action: function action() {
                showBoxBlurDialog();
            },
            modifies: { document: true }
        },
        CPFXInvert: {
            action: function action() {
                that.artwork.invert();
            },
            modifies: { document: true }
        },

        CPCut: {
            action: function action() {
                that.artwork.cutSelection(true);
            },
            modifies: { document: true }
        },
        CPCopy: {
            action: function action() {
                that.artwork.copySelection();
            },
            modifies: { document: true }
        },
        CPCopyMerged: {
            action: function action() {
                that.artwork.copySelectionMerged();
            },
            modifies: { document: true }
        },
        CPPaste: {
            action: function action() {
                that.artwork.pasteClipboard(true);
            },
            modifies: { document: true }
        },

        CPToggleGrid: {
            action: function action(e) {
                canvas.showGrid(e.selected);
            },
            modifies: { gui: true }
        },
        CPGridOptions: {
            action: function action() {
                showGridOptionsDialog();
            },
            modifies: { gui: true }
        },

        CPLinearInterpolation: {
            action: function action(e) {
                canvas.setInterpolation(e.selected);
            },
            modifies: { gui: true },
            isSupported: function isSupported() {
                return (0, _CPPolyfill.isCanvasInterpolationSupported)();
            }
        },
        CPResetCanvasRotation: {
            action: function action() {
                canvas.resetRotation();
            },
            modifies: { gui: true }
        },

        // Layer palette

        CPAddLayer: {
            action: function action() {
                that.artwork.addLayer();
            },
            modifies: { document: true }
        },
        CPRemoveLayer: {
            action: function action() {
                if (!that.artwork.removeLayer()) {
                    alert("Sorry, you can't remove the last remaining layer in the drawing.");
                }
            },
            modifies: { document: true }
        },
        CPMoveLayer: {
            action: function action(e) {
                that.artwork.moveLayer(e.fromIndex, e.toIndex);
            },
            modifies: { document: true }
        },
        CPSetActiveLayerIndex: {
            action: function action(e) {
                that.artwork.setActiveLayerIndex(e.layerIndex);

                // Since this is a slow GUI operation, this is a good chance to get the canvas ready for drawing
                that.artwork.performIdleTasks();
            },
            modifies: { document: true }
        },
        CPSetLayerVisibility: {
            action: function action(e) {
                that.artwork.setLayerVisibility(e.layerIndex, e.visible);
            },
            modifies: { layerProp: true }
        },
        CPSetLayerName: {
            action: function action(e) {
                that.artwork.setLayerName(e.layerIndex, e.name);
            },
            modifies: { layerProp: true }
        },
        CPSetLayerBlendMode: {
            action: function action(e) {
                that.artwork.setLayerBlendMode(e.layerIndex, e.blendMode);
            },
            modifies: { layerProp: true }
        },
        CPSetLayerAlpha: {
            action: function action(e) {
                that.artwork.setLayerAlpha(e.layerIndex, e.alpha);
            },
            modifies: { layerProp: true }
        },

        // Palettes

        CPPalColor: new PaletteToggleAction("color"),
        CPPalBrush: new PaletteToggleAction("brush"),
        CPPalLayers: new PaletteToggleAction("layers"),
        CPPalStroke: new PaletteToggleAction("stroke"),
        CPPalSwatches: new PaletteToggleAction("swatches"),
        CPPalTool: new PaletteToggleAction("tool"),
        CPPalMisc: new PaletteToggleAction("misc"),
        CPPalTextures: new PaletteToggleAction("textures"),

        CPTogglePalettes: {
            action: function action() {
                mainGUI.togglePalettes();
            },
            modifies: { gui: true }
        },
        CPArrangePalettes: {
            action: function action() {
                mainGUI.arrangePalettes();
            },
            modifies: { gui: true }
        },

        // Saving

        CPSave: {
            action: function action() {
                saveDrawing();
            },
            isSupported: function isSupported() {
                return options.allowDownload !== false;
            },
            modifies: { document: true }
        },
        CPSend: {
            action: function action() {
                sendDrawing();
            },
            isSupported: function isSupported() {
                return !!options.saveUrl;
            },
            modifies: { document: true }
        },
        CPPost: {
            action: function action() {
                window.location = options.postUrl;
            },
            isSupported: function isSupported() {
                return !!options.postUrl;
            },
            modifies: { document: true }
        },
        CPContinue: {
            action: function action() {},
            isSupported: function isSupported() {
                return !!options.allowMultipleSends;
            }
        },
        CPExit: {
            action: function action() {
                // Exit the drawing session without posting the drawing to the forum
                window.location = options.exitUrl;
            },
            isSupported: function isSupported() {
                return !!options.exitUrl;
            },
            modifies: {}
        }
    };

    function PaletteToggleAction(palName) {
        this.palName = palName;
    }

    PaletteToggleAction.prototype.action = function (e) {
        mainGUI.showPalette(this.palName, e.selected);
    };
    PaletteToggleAction.prototype.modifies = { gui: true };

    function ToolChangeAction(toolNum) {
        this.toolNum = toolNum;
    }

    ToolChangeAction.prototype.action = function () {
        setTool(this.toolNum);
    };

    ToolChangeAction.prototype.modifies = { mode: true, tool: true };

    function ModeChangeAction(modeNum) {
        this.modeNum = modeNum;
    }

    ModeChangeAction.prototype.action = function () {
        setMode(this.modeNum);
    };
    ModeChangeAction.prototype.modifies = { mode: true };

    function showBoxBlurDialog() {
        if (!boxBlurDialog) {
            boxBlurDialog = new _CPBoxBlurDialog2.default(uiElem, that);
        }

        boxBlurDialog.show();
    }

    function showGridOptionsDialog() {
        if (!gridDialog) {
            gridDialog = new _CPGridDialog2.default(uiElem, canvas);
        }

        gridDialog.show();
    }

    function callToolListeners() {
        that.emitEvent('toolChange', [curBrush, tools[curBrush]]);
    }

    // TODO make me private
    this.callToolListeners = function () {
        callToolListeners();
    };

    function callModeListeners() {
        that.emitEvent('modeChange', [curMode]);
    }

    function callViewListeners(viewInfo) {
        that.emitEvent('viewChange', [viewInfo]);
    }

    this.getMainGUI = function () {
        return mainGUI;
    };

    this.getArtwork = function () {
        return this.artwork;
    };

    this.setCanvas = function (_canvas) {
        canvas = _canvas;
    };

    /**
        * Change the interpolation mode used by Free Transform operations
        * 
        * @param {string} interpolation - Either "sharp" or "smooth"
        */
    this.setTransformInterpolation = function (interpolation) {
        this.artwork.setTransformInterpolation(interpolation);
    };

    this.setCurColor = function (color) {
        if (!curColor.isEqual(color)) {
            this.artwork.setForegroundColor(color.getRgb());

            curColor.copyFrom(color);

            this.emitEvent('colorChange', [color]);
        }
    };

    this.getCurColor = function () {
        return curColor.clone();
    };

    this.getCurColorRgb = function () {
        return curColor.getRgb();
    };

    this.setCurColorRgb = function (color) {
        this.setCurColor(new _CPColor2.default(color));
    };

    this.setCurGradient = function (gradient) {
        curGradient = gradient.slice(0); // Clone

        this.emitEvent('gradientChange', [curGradient]);
    };

    this.getCurGradient = function () {
        return curGradient.slice(0); // Clone
    };

    this.setBrushSize = function (size) {
        tools[curBrush].size = Math.max(1, Math.min(200, size));
        callToolListeners();
    };

    this.getBrushSize = function () {
        return tools[curBrush].size;
    };

    this.setAlpha = function (alpha) {
        tools[curBrush].alpha = alpha;
        callToolListeners();
    };

    this.getAlpha = function () {
        return tools[curBrush].alpha;
    };

    this.getCurMode = function () {
        return curMode;
    };

    function setMode(newMode) {
        if (curMode != newMode) {
            if (newMode == ChickenPaint.M_TRANSFORM) {
                preTransformMode = curMode;
            }
            curMode = newMode;
            callModeListeners();
        }
    }

    this.getCurTool = function () {
        return curBrush;
    };

    function setTool(tool) {
        setMode(ChickenPaint.M_DRAW);
        curBrush = tool;
        that.artwork.setBrush(tools[tool]);
        callToolListeners();
    }

    this.getBrushInfo = function () {
        return tools[curBrush];
    };

    function saveDrawing() {
        var saver = new _CPResourceSaver2.default({
            artwork: that.getArtwork(),
            rotation: canvas.getRotation90(),
            swatches: mainGUI.getSwatches()
        });

        saver.on("savingComplete", function () {
            that.artwork.setHasUnsavedChanges(false);
        });

        saver.on("savingFailure", function () {
            alert("An error occured while trying to save your drawing! Please try again!");
        });

        saver.save();
    }

    function sendDrawing() {
        if (!that.isActionSupported("CPContinue") && !confirm('Are you sure you want to send your drawing to the server and finish drawing now?')) {
            return;
        }

        var saver = new _CPResourceSaver2.default({
            artwork: that.getArtwork(),
            rotation: canvas.getRotation90(),
            swatches: mainGUI.getSwatches(),
            url: options.saveUrl
        }),
            sendDialog = new _CPSendDialog2.default(that, uiElem, saver);

        saver.on("savingComplete", function () {
            that.artwork.setHasUnsavedChanges(false);

            // If we're not allowed to keep editing, we can only go straight to viewing the new post
            if (!that.isActionSupported("CPContinue") && that.isActionSupported("CPPost")) {
                that.actionPerformed({ action: "CPPost" });
            }
        });

        // Allow the dialog to show before we begin serialization
        sendDialog.on("shown", function () {
            saver.save();
        });

        sendDialog.show();
    }

    /**
     * Not all saving actions will be supported (depending on what options we're configured with). Use this function
     * to check for support for a given action.
     */
    this.isActionSupported = function (actionName) {
        if (actions[actionName]) {
            var supportedType = _typeof(actions[actionName].isSupported);

            if (supportedType == "function") {
                return actions[actionName].isSupported();
            } else if (supportedType == "undefined") {
                // If not otherwise specified, an action defaults to supported
                return true;
            } else {
                return actions[actionName].isSupported;
            }
        }

        return false;
    };

    this.showLayerNotification = function (layerIndex, message, where) {
        this.emitEvent("layerNotification", [layerIndex, message, where]);
    };

    this.actionPerformed = function (e) {
        if (this.artwork == null || canvas == null) {
            return; // this shouldn't happen, but just in case
        }

        var action = actions[e.action];

        if (action) {
            if (curMode == ChickenPaint.M_TRANSFORM && (action.modifies.document || action.modifies.mode) && ["CPTransformAccept", "CPTransformReject"].indexOf(e.action) == -1) {
                if (e.action == "CPUndo") {
                    actions.CPTransformReject.action();
                } else if (e.action == "CPTransform") {
                    // You're already transforming the selection!
                } else {
                    // Prompt the user to finish their transform before starting something else
                    var dialog = new _CPConfirmTransformDialog2.default(uiElem, this);

                    /* If they decide to finish up with the transform, we can apply the original action they
                     * attempted afterwards.
                     */
                    dialog.on("accept", this.actionPerformed.bind(this, e));
                    dialog.on("reject", this.actionPerformed.bind(this, e));

                    dialog.show();
                }
            } else {
                action.action(e);
            }
        }

        // callCPEventListeners(); TODO
    };

    function installUnsavedWarning() {
        if ((0, _CPPolyfill.isEventSupported)("onbeforeunload")) {
            window.addEventListener("beforeunload", function (e) {
                if (that.artwork.getHasUnsavedChanges()) {
                    var confirmMessage = "Your drawing has unsaved changes!";
                    e.returnValue = confirmMessage;
                    return confirmMessage;
                }
            });
        } else {
            // Fall back to just catching links
            $("a").click(function (e) {
                if (this.getAttribute("href") != "#" && that.artwork.getHasUnsavedChanges()) {
                    return confirm("Your drawing has unsaved changes! Are you sure to want to navigate away?");
                }
            });
        }
    }

    function startMainGUI(swatches, initialRotation90) {
        mainGUI = new _CPMainGUI2.default(that, uiElem);

        setTool(ChickenPaint.T_PEN);
        mainGUI.arrangePalettes();

        if (swatches) {
            mainGUI.setSwatches(swatches);
        }

        if (initialRotation90) {
            mainGUI.setRotation(initialRotation90 * Math.PI / 2);
        }

        _CPWacomTablet2.default.getRef().detectTablet();

        installUnsavedWarning();
    }

    this.getResourcesRoot = function () {
        return options.resourcesRoot;
    };

    if (!isBrowserSupported()) {
        throw new ChickenPaint.UnsupportedBrowserException();
    }

    if (typeof document.body.style.flexBasis != "string" && typeof document.body.style.msFlexDirection != "string" || /Presto/.test(navigator.userAgent)) {
        uiElem.className += " no-flexbox";
    }

    uiElem.className += " chickenpaint";

    options.resourcesRoot = options.resourcesRoot || "chickenpaint/";

    if (options.disableBootstrapAPI) {
        $(document).off('.data-api');
    }

    if (options.loadImageUrl || options.loadChibiFileUrl) {
        var loader = new _CPResourceLoader2.default(options);

        new _CPSplashScreen2.default(uiElem, loader, options.resourcesRoot);

        loader.on("loadingComplete", function (resources) {
            that.artwork = resources.layers || resources.flat;

            startMainGUI(resources.swatches, options.rotation);
        });

        loader.load();
    } else {
        this.artwork = new _CPArtwork2.default(options.canvasWidth || 800, options.canvasHeight || 600);
        this.artwork.addBackgroundLayer();

        startMainGUI();
    }
}

ChickenPaint.prototype = Object.create(EventEmitter.prototype);
ChickenPaint.prototype.constructor = ChickenPaint;

ChickenPaint.UnsupportedBrowserException = function () {};

ChickenPaint.UnsupportedBrowserException.prototype.toString = function () {
    return "Sorry, your web browser does not support ChickenPaint. Please try a modern browser like Chrome, Safari, Firefox, or Edge";
};

//
// Definition of all the modes available
//

ChickenPaint.M_DRAW = 0;
ChickenPaint.M_FLOODFILL = 1;
ChickenPaint.M_RECT_SELECTION = 2;
ChickenPaint.M_MOVE_TOOL = 3;
ChickenPaint.M_ROTATE_CANVAS = 4;
ChickenPaint.M_COLOR_PICKER = 5;
ChickenPaint.M_GRADIENTFILL = 6;
ChickenPaint.M_TRANSFORM = 7;

//
// Definition of all the standard tools available
//
ChickenPaint.T_PENCIL = 0;
ChickenPaint.T_ERASER = 1;
ChickenPaint.T_PEN = 2;
ChickenPaint.T_SOFTERASER = 3;
ChickenPaint.T_AIRBRUSH = 4;
ChickenPaint.T_DODGE = 5;
ChickenPaint.T_BURN = 6;
ChickenPaint.T_WATER = 7;
ChickenPaint.T_BLUR = 8;
ChickenPaint.T_SMUDGE = 9;
ChickenPaint.T_BLENDER = 10;
ChickenPaint.T_MAX = 11;
module.exports = exports["default"];

},{"./engine/CPArtwork":2,"./engine/CPBrushInfo":5,"./engine/CPResourceLoader":13,"./engine/CPResourceSaver":14,"./gui/CPAboutDialog":16,"./gui/CPBoxBlurDialog":17,"./gui/CPConfirmTransformDialog":25,"./gui/CPGridDialog":27,"./gui/CPMainGUI":29,"./gui/CPSendDialog":35,"./gui/CPShortcutsDialog":36,"./gui/CPSplashScreen.js":38,"./gui/CPTabletDialog":41,"./util/CPColor":47,"./util/CPPolyfill":49,"./util/CPRect":52,"./util/CPWacomTablet":55}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPArtwork;

var _CPLayer = require("./CPLayer");

var _CPLayer2 = _interopRequireDefault(_CPLayer);

var _CPBlend = require("./CPBlend");

var _CPBlend2 = _interopRequireDefault(_CPBlend);

var _CPGreyBmp = require("./CPGreyBmp");

var _CPGreyBmp2 = _interopRequireDefault(_CPGreyBmp);

var _CPColorBmp = require("./CPColorBmp");

var _CPColorBmp2 = _interopRequireDefault(_CPColorBmp);

var _CPBrushManager = require("./CPBrushManager");

var _CPBrushManager2 = _interopRequireDefault(_CPBrushManager);

var _CPBrushInfo = require("./CPBrushInfo");

var _CPBrushInfo2 = _interopRequireDefault(_CPBrushInfo);

var _CPUndo = require("./CPUndo");

var _CPUndo2 = _interopRequireDefault(_CPUndo);

var _CPClip = require("./CPClip");

var _CPClip2 = _interopRequireDefault(_CPClip);

var _CPColorFloat = require("../util/CPColorFloat");

var _CPColorFloat2 = _interopRequireDefault(_CPColorFloat);

var _CPRect = require("../util/CPRect");

var _CPRect2 = _interopRequireDefault(_CPRect);

var _CPRandom = require("../util/CPRandom");

var _CPRandom2 = _interopRequireDefault(_CPRandom);

var _CPTransform = require("../util/CPTransform");

var _CPTransform2 = _interopRequireDefault(_CPTransform);

var _CPPolyfill = require("../util/CPPolyfill");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Polyfill, used in duplicateLayer
if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
        var subjectString = this.toString();
        if (typeof position !== 'number' || !isFinite(position) || Math.floor(position) !== position || position > subjectString.length) {
            position = subjectString.length;
        }
        position -= searchString.length;
        var lastIndex = subjectString.indexOf(searchString, position);
        return lastIndex !== -1 && lastIndex === position;
    };
} /*
      ChickenPaint
      
      ChickenPaint is a translation of ChibiPaint from Java to JavaScript
      by Nicholas Sherlock / Chicken Smoothie.
      
      ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
      ChickenPaint is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      ChickenPaint is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

function CPArtwork(_width, _height) {

    _width = _width | 0;
    _height = _height | 0;

    var MAX_UNDO = 30,
        EMPTY_BACKGROUND_COLOR = 0xFFFFFFFF,
        EMPTY_LAYER_COLOR = 0x00FFFFFF,
        BURN_CONSTANT = 260,
        BLUR_MIN = 64,
        BLUR_MAX = 1;

    var layers = [],
        curLayer,
        hasUnsavedChanges = false,
        curSelection = new _CPRect2.default(0, 0, 0, 0),


    /**
     * Our buffer for storing all the layers merged together according to their blending modes.
     *
     * @type {CPLayer}
     */
    fusionBuffer = new _CPLayer2.default(_width, _height),


    /**
     * Points to the buffer which represents all the layers merged together (either fusionBuffer or curLayer
     * depending on if the document is single-layered or not).
     *
     * @type {CPLayer}
     */
    fusion = fusionBuffer,


    /**
     * A copy of the current layer's data that can be used for undo operations.
     * 
     * @type {CPLayer}
     */
    undoBuffer = new _CPLayer2.default(_width, _height),


    /**
     * The region of the undoBuffer which is out of date with respect to the content of the layer, and needs updated
     * with prepareForLayerUndo().
     *
     * @type {CPRect}
     */
    undoBufferInvalidRegion = new _CPRect2.default(0, 0, _width, _height),


    /**
     * We use this buffer so we can accurately accumulate small changes to layer opacity during a brush stroke.
     * 
     * Normally we use it as a 16-bit opacity channel per pixel, but some brushes use the full 32-bits per pixel
     * as ARGB.
     */
    opacityBuffer = new _CPGreyBmp2.default(_width, _height, 32),


    /**
     * The area of dirty data contained by opacityBuffer that should be merged by fusionLayers()
     */
    opacityArea = new _CPRect2.default(0, 0, 0, 0),


    /**
     * The area of dirty layer data that should be merged into the fusion by fusionLayers().
     */
    fusionArea = new _CPRect2.default(0, 0, _width, _height),


    /**
     * Used by CPUndoPaint to keep track of the area that has been dirtied by layer operations and should be
     * saved for undo.
     */
    undoArea = new _CPRect2.default(0, 0, 0, 0),
        rnd = new _CPRandom2.default(),
        previewOperation = null,
        clipboard = null,
        // A CPClip
    undoList = [],
        redoList = [],
        curBrush = null,
        brushManager = new _CPBrushManager2.default(),
        lastX = 0.0,
        lastY = 0.0,
        lastPressure = 0.0,
        brushBuffer = null,
        sampleAllLayers = false,
        lockAlpha = false,
        curColor = 0x000000,
        // Black
    transformInterpolation = "smooth",
        that = this;

    // FIXME: 2007-01-13 I'm moving this to the CPRect class
    // find where this version is used and change the
    // code to use the CPRect version
    function clipSourceDest(srcRect, dstRect) {
        // FIXME:
        // /!\ dstRect bottom and right are ignored and instead we clip
        // against the width, height of the layer. :/
        //

        // this version would be enough in most cases (when we don't need
        // srcRect bottom and right to be clipped)
        // it's left here in case it's needed to make a faster version
        // of this function
        // dstRect.right = Math.min(width, dstRect.left + srcRect.getWidth());
        // dstRect.bottom = Math.min(height, dstRect.top + srcRect.getHeight());

        // new dest bottom/right
        dstRect.right = dstRect.left + srcRect.getWidth();
        if (dstRect.right > that.width) {
            srcRect.right -= dstRect.right - that.width;
            dstRect.right = that.width;
        }

        dstRect.bottom = dstRect.top + srcRect.getHeight();
        if (dstRect.bottom > that.height) {
            srcRect.bottom -= dstRect.bottom - that.height;
            dstRect.bottom = that.height;
        }

        // new src top/left
        if (dstRect.left < 0) {
            srcRect.left -= dstRect.left;
            dstRect.left = 0;
        }

        if (dstRect.top < 0) {
            srcRect.top -= dstRect.top;
            dstRect.top = 0;
        }
    }

    function callListenersUpdateRegion(region) {
        that.emitEvent("updateRegion", [region]);
    }

    // layerIndex is optional, provide when only one layer has been updated
    function callListenersLayerChange(layerIndex) {
        that.emitEvent("changeLayer", [layerIndex]);
    }

    // When the selected rectangle changes
    function callListenersSelectionChange() {
        that.emitEvent("changeSelection", []);
    }

    this.getLayers = function () {
        return layers;
    };

    this.getLayerCount = function () {
        return layers.length;
    };

    //
    // Selection methods
    //

    /**
     * Gets the current selection rect or a rectangle covering the whole canvas if there are no selections
     * 
     * @returns CPRect
     */
    this.getSelectionAutoSelect = function () {
        var r;

        if (!curSelection.isEmpty()) {
            r = curSelection.clone();
        } else {
            r = this.getBounds();
        }

        return r;
    };

    this.getSelection = function () {
        return curSelection.clone();
    };

    /**
     * Mark the given rectangle on the canvas as needing to be re-fused (i.e. we've drawn in this region).
     * Listeners are notified about our updated canvas region.
     *
     * @param rect CPRect Rect to invalidate
     */
    function invalidateFusionRect(rect) {
        fusionArea.union(rect);

        // This updated area will need to be updated in our undo buffer later
        undoBufferInvalidRegion.union(rect);

        callListenersUpdateRegion(rect);
    };

    /**
     * Mark the entire canvas as needing to be re-fused (we've drawn to the whole canvas)
     */
    function invalidateFusion() {
        invalidateFusionRect(new _CPRect2.default(0, 0, that.width, that.height));
    };

    this.setHasUnsavedChanges = function (value) {
        hasUnsavedChanges = value;
    };

    this.getHasUnsavedChanges = function () {
        return hasUnsavedChanges;
    };

    this.setLayerVisibility = function (layerIndex, visible) {
        var layer = this.getLayer(layerIndex);

        addUndo(new CPUndoLayerVisible(layerIndex, layer.visible, visible));
        layer.visible = visible;

        invalidateFusion();
        callListenersLayerChange(layerIndex);
    };

    this.addLayer = function () {
        var newLayer = new _CPLayer2.default(this.width, this.height, this.getDefaultLayerName()),
            activeLayerIndex = this.getActiveLayerIndex();

        newLayer.clearAll(EMPTY_LAYER_COLOR); // Transparent white

        addUndo(new CPUndoAddLayer(activeLayerIndex));

        layers.splice(activeLayerIndex + 1, 0, newLayer);
        this.setActiveLayerIndex(activeLayerIndex + 1);

        invalidateFusion();
        callListenersLayerChange();
    };

    this.addLayerObject = function (layer) {
        layers.push(layer);

        if (layers.length == 1) {
            curLayer = layers[0];
        }

        invalidateFusion();
        callListenersLayerChange();
    };

    /**
     * Remove the currently selected layer.
     * 
     * Returns true if the layer was removed, or false when removal failed because there is currently only one layer in 
     * the document.
     */
    this.removeLayer = function () {
        if (layers.length > 1) {
            var activeLayerIndex = this.getActiveLayerIndex();

            addUndo(new CPUndoRemoveLayer(activeLayerIndex, curLayer));

            layers.splice(activeLayerIndex, 1);
            this.setActiveLayerIndex(activeLayerIndex < layers.length ? activeLayerIndex : activeLayerIndex - 1);

            invalidateFusion();
            callListenersLayerChange();

            return true;
        }

        return false;
    };

    this.duplicateLayer = function () {
        var copySuffix = " Copy",
            newLayer = new _CPLayer2.default(this.width, this.height),
            activeLayerIndex = this.getActiveLayerIndex();

        addUndo(new CPUndoDuplicateLayer(activeLayerIndex));

        newLayer.copyFrom(layers[activeLayerIndex]);

        if (!newLayer.name.endsWith(copySuffix)) {
            newLayer.name += copySuffix;
        }

        layers.splice(activeLayerIndex + 1, 0, newLayer);
        this.setActiveLayerIndex(activeLayerIndex + 1);

        invalidateFusion();
        callListenersLayerChange();
    };

    this.mergeDown = function (createUndo) {
        var activeLayerIndex = this.getActiveLayerIndex();

        if (layers.length > 1 && activeLayerIndex > 0) {
            if (createUndo) {
                addUndo(new CPUndoMergeDownLayer(activeLayerIndex));
            }

            _CPBlend2.default.fuseLayer(layers[activeLayerIndex - 1], true, layers[activeLayerIndex], this.getBounds());
            layers.splice(activeLayerIndex, 1);
            this.setActiveLayerIndex(activeLayerIndex - 1);

            invalidateFusion();
            callListenersLayerChange();
        }
    };

    this.mergeAllLayers = function (createUndo) {
        if (layers.length > 1) {
            if (createUndo) {
                addUndo(new CPUndoMergeAllLayers());
            }

            that.fusionLayers();
            layers = [];

            var layer = new _CPLayer2.default(that.width, that.height, this.getDefaultLayerName());

            layer.copyDataFrom(fusion);

            layers.push(layer);
            this.setActiveLayerIndex(0);

            invalidateFusion();
            callListenersLayerChange();
        }
    };

    function moveLayerReal(from, to) {
        var layer = layers.splice(from, 1)[0];

        if (to <= from) {
            layers.splice(to, 0, layer);
            that.setActiveLayerIndex(to);
        } else {
            layers.splice(to - 1, 0, layer);
            that.setActiveLayerIndex(to - 1);
        }

        invalidateFusion();
        callListenersLayerChange();
    }

    /**
     * Move a layer in the stack from one index to another.
     * 
     * @param from int
     * @param to int
     */
    this.moveLayer = function (from, to) {
        if (from < 0 || from >= this.getLayerCount() || to < 0 || to > this.getLayerCount() || from == to) {
            return;
        }

        addUndo(new CPUndoMoveLayer(from, to));
        moveLayerReal(from, to);
    };

    this.setLayerAlpha = function (layerIndex, alpha) {
        var layer = this.getLayer(layerIndex);

        if (layer.getAlpha() != alpha) {
            addUndo(new CPUndoLayerAlpha(layerIndex, alpha));
            layer.setAlpha(alpha);

            invalidateFusion();
            callListenersLayerChange(layerIndex);
        }
    };

    this.setLayerBlendMode = function (layerIndex, blendMode) {
        var layer = this.getLayer(layerIndex);

        if (layer.getBlendMode() != blendMode) {
            addUndo(new CPUndoLayerMode(layerIndex, blendMode));
            layer.setBlendMode(blendMode);

            invalidateFusion();
            callListenersLayerChange(layerIndex);
        }
    };

    this.setLayerName = function (layerIndex, name) {
        var layer = this.getLayer(layerIndex);

        if (layer && layer.name != name) {
            addUndo(new CPUndoLayerRename(layerIndex, name));
            layer.name = name;

            callListenersLayerChange(layerIndex);
        }
    };

    function CPBrushToolBase() {}

    CPBrushToolBase.prototype.beginStroke = function (x, y, pressure) {
        prepareForLayerUndo();
        undoArea.makeEmpty();

        opacityBuffer.clearAll(0);
        opacityArea.makeEmpty();

        lastX = x;
        lastY = y;
        lastPressure = pressure;

        this.createAndPaintDab(x, y, pressure);
    };

    CPBrushToolBase.prototype.continueStroke = function (x, y, pressure) {
        var dist = Math.sqrt((lastX - x) * (lastX - x) + (lastY - y) * (lastY - y)),
            spacing = Math.max(curBrush.minSpacing, curBrush.curSize * curBrush.spacing);

        if (dist > spacing) {
            var nx = lastX,
                ny = lastY,
                np = lastPressure,
                df = (spacing - 0.001) / dist;

            for (var f = df; f <= 1.0; f += df) {
                nx = f * x + (1.0 - f) * lastX;
                ny = f * y + (1.0 - f) * lastY;
                np = f * pressure + (1.0 - f) * lastPressure;
                this.createAndPaintDab(nx, ny, np);
            }
            lastX = nx;
            lastY = ny;
            lastPressure = np;
        }
    };

    CPBrushToolBase.prototype.endStroke = function () {
        undoArea.clip(that.getBounds());

        // Did we end up painting anything?
        if (!undoArea.isEmpty()) {
            mergeOpacityBuffer(curColor, false);
            addUndo(new CPUndoPaint());

            /* Eagerly update the undo buffer for next time so we can avoid this lengthy
             * prepare at the beginning of a paint stroke
             */
            prepareForLayerUndo();
        }
        brushBuffer = null;
    };

    /**
     * Create a paint dab at the given position using the current brush, and paint it.
     *
     * @param x float
     * @param y float
     * @param pressure float
     */
    CPBrushToolBase.prototype.createAndPaintDab = function (x, y, pressure) {
        curBrush.applyPressure(pressure);

        if (curBrush.scattering > 0.0) {
            x += rnd.nextGaussian() * curBrush.curScattering / 4.0;
            y += rnd.nextGaussian() * curBrush.curScattering / 4.0;
        }

        var dab = brushManager.getDab(x, y, curBrush);

        this.paintDab(dab);
    };

    /**
     * Paint a dab returned by brushManager.getDab()
     *
     * @param dab {byte[] brush; int x, y, alpha, width, height}
     */
    CPBrushToolBase.prototype.paintDab = function (dab) {
        var srcRect = new _CPRect2.default(0, 0, dab.width, dab.height),
            dstRect = new _CPRect2.default(0, 0, dab.width, dab.height);

        dstRect.translate(dab.x, dab.y);

        clipSourceDest(srcRect, dstRect);

        // drawing entirely outside the canvas
        if (dstRect.isEmpty()) {
            return;
        }

        undoArea.union(dstRect);
        opacityArea.union(dstRect);

        this.paintDabImplementation(srcRect, dstRect, dab);

        invalidateFusionRect(dstRect);
    };

    function CPBrushToolSimpleBrush() {}

    CPBrushToolSimpleBrush.prototype = Object.create(CPBrushToolBase.prototype);
    CPBrushToolSimpleBrush.prototype.constructor = CPBrushToolSimpleBrush;

    CPBrushToolSimpleBrush.prototype.paintDabImplementation = function (srcRect, dstRect, dab) {
        // FIXME: there should be no reference to a specific tool here
        // create a new brush parameter instead
        if (curBrush.isAirbrush) {
            this.paintFlow(srcRect, dstRect, dab.brush, dab.width, Math.max(1, dab.alpha / 8));
        } else if (curBrush.toolNb == ChickenPaint.T_PEN) {
            this.paintFlow(srcRect, dstRect, dab.brush, dab.width, Math.max(1, dab.alpha / 2));
        } else {
            this.paintOpacity(srcRect, dstRect, dab.brush, dab.width, dab.alpha);
        }
    };

    CPBrushToolSimpleBrush.prototype.mergeOpacityBuf = function (dstRect, color /* int */) {
        var opacityData = opacityBuffer.data,
            undoData = undoBuffer.data,
            red = color >> 16 & 0xFF,
            green = color >> 8 & 0xFF,
            blue = color & 0xFF,
            width = dstRect.getWidth() | 0,
            height = dstRect.getHeight() | 0,
            dstOffset = curLayer.offsetOfPixel(dstRect.left, dstRect.top),
            srcOffset = opacityBuffer.offsetOfPixel(dstRect.left, dstRect.top),
            srcYStride = opacityBuffer.width - width | 0,
            dstYStride = (curLayer.width - width) * _CPColorBmp2.default.BYTES_PER_PIXEL | 0;

        for (var y = 0; y < height; y++, srcOffset += srcYStride, dstOffset += dstYStride) {
            for (var x = 0; x < width; x++, srcOffset++, dstOffset += _CPColorBmp2.default.BYTES_PER_PIXEL) {
                var opacityAlpha = opacityData[srcOffset] / 255 | 0;

                if (opacityAlpha > 0) {
                    var destAlpha = undoData[dstOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET],
                        newLayerAlpha = opacityAlpha + destAlpha * (255 - opacityAlpha) / 255 | 0,
                        realAlpha = 255 * opacityAlpha / newLayerAlpha | 0,
                        invAlpha = 255 - realAlpha;

                    curLayer.data[dstOffset] = (red * realAlpha + undoData[dstOffset] * invAlpha) / 255 & 0xff;
                    curLayer.data[dstOffset + 1] = (green * realAlpha + undoData[dstOffset + 1] * invAlpha) / 255 & 0xff;
                    curLayer.data[dstOffset + 2] = (blue * realAlpha + undoData[dstOffset + 2] * invAlpha) / 255 & 0xff;
                    curLayer.data[dstOffset + 3] = newLayerAlpha;
                }
            }
        }
    };

    /**
     *
     * @param srcRect CPRect
     * @param dstRect CPRect
     * @param brush int[]
     * @param brushWidth int
     * @param alpha float
     */
    CPBrushToolSimpleBrush.prototype.paintOpacity = function (srcRect, dstRect, brush, brushWidth, alpha) {
        var opacityData = opacityBuffer.data,
            srcOffset = srcRect.left + srcRect.top * brushWidth,
            dstOffset = opacityBuffer.offsetOfPixel(dstRect.left, dstRect.top),
            dstWidth = dstRect.getWidth(),
            srcYStride = brushWidth - dstWidth,
            dstYStride = that.width - dstWidth;

        alpha = Math.min(255, alpha);

        for (var y = dstRect.top; y < dstRect.bottom; y++, srcOffset += srcYStride, dstOffset += dstYStride) {
            for (var x = 0; x < dstWidth; x++, srcOffset++, dstOffset++) {
                opacityData[dstOffset] = Math.max(brush[srcOffset] * alpha, opacityData[dstOffset]);
            }
        }
    };

    CPBrushToolSimpleBrush.prototype.paintFlow = function (srcRect, dstRect, brush, brushWidth, alpha) {
        var opacityData = opacityBuffer.data,
            srcOffset = srcRect.left + srcRect.top * brushWidth,
            dstOffset = opacityBuffer.offsetOfPixel(dstRect.left, dstRect.top),
            dstWidth = dstRect.getWidth(),
            srcYStride = brushWidth - dstWidth,
            dstYStride = that.width - dstWidth;

        for (var y = dstRect.top; y < dstRect.bottom; y++, srcOffset += srcYStride, dstOffset += dstYStride) {
            for (var x = 0; x < dstWidth; x++, srcOffset++, dstOffset++) {
                var brushAlpha = brush[srcOffset] * alpha;

                if (brushAlpha != 0) {
                    var opacityAlpha = Math.min(255 * 255, opacityData[dstOffset] + (255 - opacityData[dstOffset] / 255) * brushAlpha / 255);

                    opacityData[dstOffset] = opacityAlpha;
                }
            }
        }
    };

    /*CPBrushToolSimpleBrush.prototype.paintOpacityFlow = function(srcRect, dstRect, brush, brushWidth, opacity, flow) {
        var 
            opacityData = opacityBuffer.data,
             by = srcRect.top;
        
        for (var y = dstRect.top; y < dstRect.bottom; y++, by++) {
            var 
                srcOffset = srcRect.left + by * brushWidth,
                dstOffset = dstRect.left + y * width;
            
            for (var x = dstRect.left; x < dstRect.right; x++, srcOffset++, dstOffset++) {
                var 
                    brushAlpha = brush[srcOffset] * flow;
                
                if (brushAlpha != 0) {
                    var
                        opacityAlpha = opacityData[dstOffset],
                        newAlpha = Math.min(255 * 255, opacityAlpha + (opacity - opacityAlpha / 255) * brushAlpha / 255);
                    
                    newAlpha = Math.min(opacity * brush[srcOffset], newAlpha);
                    
                    if (newAlpha > opacityAlpha) {
                        opacityData[dstOffset] = newAlpha;
                    }
                }
            }
        }
    };*/

    function CPBrushToolEraser() {}

    CPBrushToolEraser.prototype = Object.create(CPBrushToolSimpleBrush.prototype);
    CPBrushToolEraser.prototype.constructor = CPBrushToolEraser;

    CPBrushToolEraser.prototype.mergeOpacityBuf = function (dstRect, color) {
        var opacityData = opacityBuffer.data,
            undoData = undoBuffer.data;

        for (var y = dstRect.top; y < dstRect.bottom; y++) {
            var dstOffset = curLayer.offsetOfPixel(dstRect.left, y) + _CPColorBmp2.default.ALPHA_BYTE_OFFSET,
                srcOffset = opacityBuffer.offsetOfPixel(dstRect.left, y);

            for (var x = dstRect.left; x < dstRect.right; x++, dstOffset += _CPColorBmp2.default.BYTES_PER_PIXEL) {
                var opacityAlpha = opacityData[srcOffset++] / 255 | 0;

                if (opacityAlpha > 0) {
                    var destAlpha = undoData[dstOffset],
                        realAlpha = destAlpha * (255 - opacityAlpha) / 255;

                    curLayer.data[dstOffset] = realAlpha;
                }
            }
        }
    };

    function CPBrushToolDodge() {}

    CPBrushToolDodge.prototype = Object.create(CPBrushToolSimpleBrush.prototype);
    CPBrushToolDodge.prototype.constructor = CPBrushToolDodge;

    CPBrushToolDodge.prototype.mergeOpacityBuf = function (dstRect, color) {
        var opacityData = opacityBuffer.data,
            undoData = undoBuffer.data;

        for (var y = dstRect.top; y < dstRect.bottom; y++) {
            var dstOffset = curLayer.offsetOfPixel(dstRect.left, y),
                srcOffset = opacityBuffer.offsetOfPixel(dstRect.left, y);

            for (var x = dstRect.left; x < dstRect.right; x++, srcOffset++, dstOffset += _CPColorBmp2.default.BYTES_PER_PIXEL) {
                var opacityAlpha = opacityData[srcOffset] / 255 | 0;

                if (opacityAlpha > 0 && undoData[dstOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] != 0) {
                    opacityAlpha += 255;

                    for (var i = 0; i < 3; i++) {
                        var channel = undoData[dstOffset + i] * opacityAlpha / 255 | 0;

                        if (channel > 255) {
                            channel = 255;
                        }

                        curLayer.data[dstOffset + i] = channel;
                    }
                }
            }
        }
    };

    function CPBrushToolBurn() {}

    CPBrushToolBurn.prototype = Object.create(CPBrushToolSimpleBrush.prototype);
    CPBrushToolBurn.prototype.constructor = CPBrushToolBurn;

    CPBrushToolBurn.prototype.mergeOpacityBuf = function (dstRect, color) {
        var opacityData = opacityBuffer.data,
            undoData = undoBuffer.data;

        for (var y = dstRect.top; y < dstRect.bottom; y++) {
            var dstOffset = curLayer.offsetOfPixel(dstRect.left, y),
                srcOffset = opacityBuffer.offsetOfPixel(dstRect.left, y);

            for (var x = dstRect.left; x < dstRect.right; x++, srcOffset++, dstOffset += _CPColorBmp2.default.BYTES_PER_PIXEL) {
                var opacityAlpha = opacityData[srcOffset] / 255 | 0;

                if (opacityAlpha > 0 && undoData[dstOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] != 0) {
                    for (var i = 0; i < 3; i++) {
                        var channel = undoData[dstOffset + i];

                        channel = channel - (BURN_CONSTANT - channel) * opacityAlpha / 255 | 0;

                        if (channel < 0) {
                            channel = 0;
                        }

                        curLayer.data[dstOffset + i] = channel;
                    }
                }
            }
        }
    };

    function CPBrushToolBlur() {}

    CPBrushToolBlur.prototype = Object.create(CPBrushToolSimpleBrush.prototype);
    CPBrushToolBlur.prototype.constructor = CPBrushToolBlur;

    CPBrushToolBlur.prototype.mergeOpacityBuf = function (dstRect, color) {
        var opacityData = opacityBuffer.data,
            undoData = undoBuffer.data,
            dstYStride = undoBuffer.width * _CPColorBmp2.default.BYTES_PER_PIXEL,
            r,
            g,
            b,
            a;

        function addSample(sampleOffset) {
            r += undoData[sampleOffset + _CPColorBmp2.default.RED_BYTE_OFFSET];
            g += undoData[sampleOffset + _CPColorBmp2.default.GREEN_BYTE_OFFSET];
            b += undoData[sampleOffset + _CPColorBmp2.default.BLUE_BYTE_OFFSET];
            a += undoData[sampleOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET];
        }

        for (var y = dstRect.top; y < dstRect.bottom; y++) {
            var dstOffset = undoBuffer.offsetOfPixel(dstRect.left, y),
                srcOffset = opacityBuffer.offsetOfPixel(dstRect.left, y);

            for (var x = dstRect.left; x < dstRect.right; x++, dstOffset += _CPColorBmp2.default.BYTES_PER_PIXEL, srcOffset++) {
                var opacityAlpha = opacityData[srcOffset] / 255 | 0;

                if (opacityAlpha > 0) {
                    var blur = BLUR_MIN + (BLUR_MAX - BLUR_MIN) * opacityAlpha / 255 | 0,
                        sum = blur + 4;

                    r = blur * undoData[dstOffset + _CPColorBmp2.default.RED_BYTE_OFFSET];
                    g = blur * undoData[dstOffset + _CPColorBmp2.default.GREEN_BYTE_OFFSET];
                    b = blur * undoData[dstOffset + _CPColorBmp2.default.BLUE_BYTE_OFFSET];
                    a = blur * undoData[dstOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET];

                    addSample(y > 0 ? dstOffset - dstYStride : dstOffset);
                    addSample(y < undoBuffer.height - 1 ? dstOffset + dstYStride : dstOffset);
                    addSample(x > 0 ? dstOffset - _CPColorBmp2.default.BYTES_PER_PIXEL : dstOffset);
                    addSample(x < undoBuffer.width - 1 ? dstOffset + _CPColorBmp2.default.BYTES_PER_PIXEL : dstOffset);

                    a /= sum;
                    r /= sum;
                    g /= sum;
                    b /= sum;

                    curLayer.data[dstOffset + _CPColorBmp2.default.RED_BYTE_OFFSET] = r | 0;
                    curLayer.data[dstOffset + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = g | 0;
                    curLayer.data[dstOffset + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = b | 0;
                    curLayer.data[dstOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = a | 0;
                }
            }
        }
    };

    /* Brushes derived from this class use the opacity buffer as a simple alpha layer (32-bit pixels in ARGB order) */
    function CPBrushToolDirectBrush() {}

    CPBrushToolDirectBrush.prototype = Object.create(CPBrushToolSimpleBrush.prototype);
    CPBrushToolDirectBrush.prototype.constructor = CPBrushToolDirectBrush;

    CPBrushToolDirectBrush.prototype.mergeOpacityBuf = function (dstRect, color) {
        var opacityData = opacityBuffer.data,
            undoData = undoBuffer.data,
            srcOffset = opacityBuffer.offsetOfPixel(dstRect.left, dstRect.top),
            dstOffset = curLayer.offsetOfPixel(dstRect.left, dstRect.top),
            width = dstRect.getWidth() | 0,
            height = dstRect.getHeight() | 0,
            srcYStride = opacityBuffer.width - width | 0,
            dstYStride = (curLayer.width - width) * _CPColorBmp2.default.BYTES_PER_PIXEL | 0;

        for (var y = 0; y < height; y++, srcOffset += srcYStride, dstOffset += dstYStride) {
            for (var x = 0; x < width; x++, srcOffset++, dstOffset += _CPColorBmp2.default.BYTES_PER_PIXEL) {
                var color1 = opacityData[srcOffset],
                    alpha1 = color1 >>> 24;

                if (alpha1 == 0) {
                    continue;
                }

                var
                // Pretty sure fusion.alpha is always 100 and the commented section is a copy/paste error
                alpha2 = undoData[dstOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] /* * fusion.alpha / 100 */
                ,
                    newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0;

                if (newAlpha > 0) {
                    var realAlpha = alpha1 * 255 / newAlpha | 0,
                        invAlpha = 255 - realAlpha;

                    curLayer.data[dstOffset] = ((color1 >> 16 & 0xFF) * realAlpha + undoData[dstOffset] * invAlpha) / 255 | 0;
                    curLayer.data[dstOffset + 1] = ((color1 >> 8 & 0xFF) * realAlpha + undoData[dstOffset + 1] * invAlpha) / 255 | 0;
                    curLayer.data[dstOffset + 2] = ((color1 & 0xFF) * realAlpha + undoData[dstOffset + 2] * invAlpha) / 255 | 0;
                    curLayer.data[dstOffset + 3] = newAlpha;
                }
            }
        }
    };

    function CPBrushToolWatercolor() {
        var WCMEMORY = 50,
            WXMAXSAMPLERADIUS = 64;

        var previousSamples = [];

        /**
         * Average out a bunch of samples around the given pixel (x, y).
         * 
         * dx, dy controls the spread of the samples.
         * 
         * @returns CPColorFloat
         */
        function sampleColor(x, y, dx, dy) {
            var samples = [],
                layerToSample = sampleAllLayers ? fusion : that.getActiveLayer();

            x = x | 0;
            y = y | 0;

            samples.push(_CPColorFloat2.default.createFromInt(layerToSample.getPixel(x, y)));

            for (var r = 0.25; r < 1.001; r += .25) {
                samples.push(_CPColorFloat2.default.createFromInt(layerToSample.getPixel(~~(x + r * dx), y)));
                samples.push(_CPColorFloat2.default.createFromInt(layerToSample.getPixel(~~(x - r * dx), y)));
                samples.push(_CPColorFloat2.default.createFromInt(layerToSample.getPixel(x, ~~(y + r * dy))));
                samples.push(_CPColorFloat2.default.createFromInt(layerToSample.getPixel(x, ~~(y - r * dy))));

                samples.push(_CPColorFloat2.default.createFromInt(layerToSample.getPixel(~~(x + r * 0.7 * dx), ~~(y + r * 0.7 * dy))));
                samples.push(_CPColorFloat2.default.createFromInt(layerToSample.getPixel(~~(x + r * 0.7 * dx), ~~(y - r * 0.7 * dy))));
                samples.push(_CPColorFloat2.default.createFromInt(layerToSample.getPixel(~~(x - r * 0.7 * dx), ~~(y + r * 0.7 * dy))));
                samples.push(_CPColorFloat2.default.createFromInt(layerToSample.getPixel(~~(x - r * 0.7 * dx), ~~(y - r * 0.7 * dy))));
            }

            var average = new _CPColorFloat2.default(0, 0, 0);

            for (var i = 0; i < samples.length; i++) {
                var sample = samples[i];

                average.r += sample.r;
                average.g += sample.g;
                average.b += sample.b;
            }

            average.r /= samples.length;
            average.g /= samples.length;
            average.b /= samples.length;

            return average;
        }

        // Blend the brush stroke with full color into the opacityBuffer
        function paintDirect(srcRect, dstRect, brush, brushWidth, alpha, color1) {
            var opacityData = opacityBuffer.data,
                by = srcRect.top;

            for (var y = dstRect.top; y < dstRect.bottom; y++, by++) {
                var srcOffset = srcRect.left + by * brushWidth,
                    dstOffset = opacityBuffer.offsetOfPixel(dstRect.left, y);

                for (var x = dstRect.left; x < dstRect.right; x++, srcOffset++, dstOffset++) {
                    var alpha1 = (brush[srcOffset] & 0xff) * alpha / 255 | 0;

                    if (alpha1 <= 0) {
                        continue;
                    }

                    var color2 = opacityData[dstOffset],
                        alpha2 = color2 >>> 24,
                        newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0;

                    if (newAlpha > 0) {
                        var realAlpha = alpha1 * 255 / newAlpha | 0,
                            invAlpha = 255 - realAlpha;

                        // The usual alpha blending formula C = A * alpha + B * (1 - alpha)
                        // has to rewritten in the form C = A + (1 - alpha) * B - (1 - alpha) *A
                        // that way the rounding up errors won't cause problems

                        var newColor = newAlpha << 24 | (color1 >>> 16 & 0xff) + ((color2 >>> 16 & 0xff) * invAlpha - (color1 >>> 16 & 0xff) * invAlpha) / 255 << 16 | (color1 >>> 8 & 0xff) + ((color2 >>> 8 & 0xff) * invAlpha - (color1 >>> 8 & 0xff) * invAlpha) / 255 << 8 | (color1 & 0xff) + ((color2 & 0xff) * invAlpha - (color1 & 0xff) * invAlpha) / 255;

                        opacityData[dstOffset] = newColor;
                    }
                }
            }
        }

        this.beginStroke = function (x, y, pressure) {
            previousSamples = null;

            CPBrushToolDirectBrush.prototype.beginStroke.call(this, x, y, pressure);
        };

        this.paintDabImplementation = function (srcRect, dstRect, dab) {
            if (previousSamples == null) {
                // Seed the previousSamples list to capacity with a bunch of copies of one sample to get us started
                var startColor = sampleColor(~~((dstRect.left + dstRect.right) / 2), ~~((dstRect.top + dstRect.bottom) / 2), Math.max(1, Math.min(WXMAXSAMPLERADIUS, dstRect.getWidth() * 2 / 6)), Math.max(1, Math.min(WXMAXSAMPLERADIUS, dstRect.getHeight() * 2 / 6)));

                previousSamples = [];

                for (var i = 0; i < WCMEMORY; i++) {
                    previousSamples.push(startColor);
                }
            }

            var wcColor = new _CPColorFloat2.default(0, 0, 0);

            for (var i = 0; i < previousSamples.length; i++) {
                var sample = previousSamples[i];

                wcColor.r += sample.r;
                wcColor.g += sample.g;
                wcColor.b += sample.b;
            }
            wcColor.r /= previousSamples.length;
            wcColor.g /= previousSamples.length;
            wcColor.b /= previousSamples.length;

            // resaturation
            wcColor.mixWith(_CPColorFloat2.default.createFromInt(curColor), curBrush.resat * curBrush.resat);

            var newColor = wcColor.toInt();

            // bleed
            wcColor.mixWith(sampleColor((dstRect.left + dstRect.right) / 2, (dstRect.top + dstRect.bottom) / 2, Math.max(1, Math.min(WXMAXSAMPLERADIUS, dstRect.getWidth() * 2 / 6)), Math.max(1, Math.min(WXMAXSAMPLERADIUS, dstRect.getHeight() * 2 / 6))), curBrush.bleed);

            previousSamples.push(wcColor);
            previousSamples.shift();

            paintDirect(srcRect, dstRect, dab.brush, dab.width, Math.max(1, dab.alpha / 4), newColor);
            mergeOpacityBuffer(0, false);

            if (sampleAllLayers) {
                that.fusionLayers();
            }
        };
    }

    CPBrushToolWatercolor.prototype = Object.create(CPBrushToolDirectBrush.prototype);
    CPBrushToolWatercolor.prototype.constructor = CPBrushToolWatercolor;

    function CPBrushToolOil() {

        function oilAccumBuffer(srcRect, dstRect, buffer, w, alpha) {
            var layerToSample = sampleAllLayers ? fusion : that.getActiveLayer(),
                by = srcRect.top;

            for (var y = dstRect.top; y < dstRect.bottom; y++, by++) {
                var srcOffset = srcRect.left + by * w,
                    dstOffset = layerToSample.offsetOfPixel(dstRect.left, y);

                for (var x = dstRect.left; x < dstRect.right; x++, srcOffset++, dstOffset += _CPColorBmp2.default.BYTES_PER_PIXEL) {
                    var alpha1 = layerToSample.data[dstOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] * alpha / 255 | 0;

                    if (alpha1 <= 0) {
                        continue;
                    }

                    var color2 = buffer[srcOffset],
                        alpha2 = color2 >>> 24,
                        newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0;

                    if (newAlpha > 0) {
                        var realAlpha = alpha1 * 255 / newAlpha | 0,
                            invAlpha = 255 - realAlpha,
                            color1Red = layerToSample.data[dstOffset + _CPColorBmp2.default.RED_BYTE_OFFSET],
                            color1Green = layerToSample.data[dstOffset + _CPColorBmp2.default.GREEN_BYTE_OFFSET],
                            color1Blue = layerToSample.data[dstOffset + _CPColorBmp2.default.BLUE_BYTE_OFFSET],
                            newColor = newAlpha << 24 | color1Red + ((color2 >>> 16 & 0xff) * invAlpha - color1Red * invAlpha) / 255 << 16 | color1Green + ((color2 >>> 8 & 0xff) * invAlpha - color1Green * invAlpha) / 255 << 8 | color1Blue + ((color2 & 0xff) * invAlpha - color1Blue * invAlpha) / 255;

                        buffer[srcOffset] = newColor;
                    }
                }
            }
        }

        function oilResatBuffer(srcRect, dstRect, buffer, w, alpha1, color1) {
            var by = srcRect.top;

            if (alpha1 <= 0) {
                return;
            }

            for (var y = dstRect.top; y < dstRect.bottom; y++, by++) {
                var srcOffset = srcRect.left + by * w;

                for (var x = dstRect.left; x < dstRect.right; x++, srcOffset++) {
                    var color2 = buffer[srcOffset],
                        alpha2 = color2 >>> 24,
                        newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0;

                    if (newAlpha > 0) {
                        var realAlpha = alpha1 * 255 / newAlpha | 0,
                            invAlpha = 255 - realAlpha,
                            newColor = newAlpha << 24 | (color1 >>> 16 & 0xff) + ((color2 >>> 16 & 0xff) * invAlpha - (color1 >>> 16 & 0xff) * invAlpha) / 255 << 16 | (color1 >>> 8 & 0xff) + ((color2 >>> 8 & 0xff) * invAlpha - (color1 >>> 8 & 0xff) * invAlpha) / 255 << 8 | (color1 & 0xff) + ((color2 & 0xff) * invAlpha - (color1 & 0xff) * invAlpha) / 255;

                        buffer[srcOffset] = newColor;
                    }
                }
            }
        }

        function oilPasteBuffer(srcRect, dstRect, buffer, brush, w, alpha) {
            var opacityData = opacityBuffer.data,
                by = srcRect.top;

            for (var y = dstRect.top; y < dstRect.bottom; y++, by++) {
                var bufferOffset = srcRect.left + by * w,
                    // Brush buffer is 1 integer per pixel
                opacityOffset = dstRect.left + y * that.width,
                    // Opacity buffer is 1 integer per pixel
                layerOffset = curLayer.offsetOfPixel(dstRect.left, y); // 4 bytes per pixel 

                for (var x = dstRect.left; x < dstRect.right; x++, bufferOffset++, layerOffset += _CPColorBmp2.default.BYTES_PER_PIXEL, opacityOffset++) {
                    var color1 = buffer[bufferOffset],
                        alpha1 = (color1 >>> 24) * (brush[bufferOffset] & 0xff) * alpha / (255 * 255) | 0;

                    if (alpha1 <= 0) {
                        continue;
                    }

                    var alpha2 = curLayer.data[layerOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET],
                        newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0;

                    if (newAlpha > 0) {
                        var color2Red = curLayer.data[layerOffset + _CPColorBmp2.default.RED_BYTE_OFFSET],
                            color2Green = curLayer.data[layerOffset + _CPColorBmp2.default.GREEN_BYTE_OFFSET],
                            color2Blue = curLayer.data[layerOffset + _CPColorBmp2.default.BLUE_BYTE_OFFSET],
                            realAlpha = alpha1 * 255 / newAlpha | 0,
                            invAlpha = 255 - realAlpha,
                            newColor = newAlpha << 24 | (color1 >>> 16 & 0xff) + (color2Red * invAlpha - (color1 >>> 16 & 0xff) * invAlpha) / 255 << 16 | (color1 >>> 8 & 0xff) + (color2Green * invAlpha - (color1 >>> 8 & 0xff) * invAlpha) / 255 << 8 | (color1 & 0xff) + (color2Blue * invAlpha - (color1 & 0xff) * invAlpha) / 255;

                        opacityData[opacityOffset] = newColor;
                    }
                }
            }
        }

        this.paintDabImplementation = function (srcRect, dstRect, dab) {
            if (brushBuffer == null) {
                brushBuffer = new Uint32Array(dab.width * dab.height); // Initialized to 0 for us by the browser

                oilAccumBuffer(srcRect, dstRect, brushBuffer, dab.width, 255);
            } else {
                oilResatBuffer(srcRect, dstRect, brushBuffer, dab.width, ~~(curBrush.resat <= 0.0 ? 0 : Math.max(1, curBrush.resat * curBrush.resat * 255)), curColor & 0xFFFFFF);
                oilPasteBuffer(srcRect, dstRect, brushBuffer, dab.brush, dab.width, dab.alpha);
                oilAccumBuffer(srcRect, dstRect, brushBuffer, dab.width, ~~(curBrush.bleed * 255));
            }

            mergeOpacityBuffer(0, false);

            if (sampleAllLayers) {
                that.fusionLayers();
            }
        };
    }

    CPBrushToolOil.prototype = Object.create(CPBrushToolDirectBrush.prototype);
    CPBrushToolOil.prototype.constructor = CPBrushToolOil;

    function CPBrushToolSmudge() {

        /**
         * 
         * @param srcRect
         * @param dstRect
         * @param buffer Uint32Array
         * @param w int
         * @param alpha int
         */
        function smudgeAccumBuffer(srcRect, dstRect, buffer, w, alpha) {
            var layerToSample = sampleAllLayers ? fusion : that.getActiveLayer(),
                by = srcRect.top;

            for (var y = dstRect.top; y < dstRect.bottom; y++, by++) {
                var srcOffset = srcRect.left + by * w,
                    dstOffset = layerToSample.offsetOfPixel(dstRect.left, y);

                for (var x = dstRect.left; x < dstRect.right; x++, srcOffset++, dstOffset += _CPColorBmp2.default.BYTES_PER_PIXEL) {
                    var layerRed = layerToSample.data[dstOffset + _CPColorBmp2.default.RED_BYTE_OFFSET],
                        layerGreen = layerToSample.data[dstOffset + _CPColorBmp2.default.GREEN_BYTE_OFFSET],
                        layerBlue = layerToSample.data[dstOffset + _CPColorBmp2.default.BLUE_BYTE_OFFSET],
                        layerAlpha = layerToSample.data[dstOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET],
                        opacityAlpha = 255 - alpha;

                    if (opacityAlpha > 0) {
                        var destColor = buffer[srcOffset],
                            destAlpha = 255,
                            newLayerAlpha = opacityAlpha + destAlpha * (255 - opacityAlpha) / 255 | 0,
                            realAlpha = 255 * opacityAlpha / newLayerAlpha | 0,
                            invAlpha = 255 - realAlpha,
                            newColor = (layerAlpha * realAlpha + (destColor >>> 24 & 0xff) * invAlpha) / 255 << 24 & 0xff000000 | (layerRed * realAlpha + (destColor >>> 16 & 0xff) * invAlpha) / 255 << 16 & 0xff0000 | (layerGreen * realAlpha + (destColor >>> 8 & 0xff) * invAlpha) / 255 << 8 & 0xff00 | (layerBlue * realAlpha + (destColor & 0xff) * invAlpha) / 255 & 0xff;

                        if (newColor == destColor) {
                            if (layerRed > (destColor & 0xff0000)) {
                                newColor += 1 << 16;
                            } else if (layerRed < (destColor & 0xff0000)) {
                                newColor -= 1 << 16;
                            }

                            if (layerGreen > (destColor & 0xff00)) {
                                newColor += 1 << 8;
                            } else if (layerGreen < (destColor & 0xff00)) {
                                newColor -= 1 << 8;
                            }

                            if (layerBlue > (destColor & 0xff)) {
                                newColor += 1;
                            } else if (layerBlue < (destColor & 0xff)) {
                                newColor -= 1;
                            }
                        }

                        buffer[srcOffset] = newColor;
                    }
                }
            }

            if (srcRect.left > 0) {
                var fill = srcRect.left;

                for (var y = srcRect.top; y < srcRect.bottom; y++) {
                    var offset = y * w,
                        fillColor = buffer[offset + srcRect.left];

                    for (var x = 0; x < fill; x++) {
                        buffer[offset++] = fillColor;
                    }
                }
            }

            if (srcRect.right < w) {
                var fill = w - srcRect.right;

                for (var y = srcRect.top; y < srcRect.bottom; y++) {
                    var offset = y * w + srcRect.right,
                        fillColor = buffer[offset - 1];

                    for (var x = 0; x < fill; x++) {
                        buffer[offset++] = fillColor;
                    }
                }
            }

            for (var y = 0; y < srcRect.top; y++) {
                var srcOffset = srcRect.top * w,
                    dstOffset = y * w;

                for (var x = 0; x < w; x++, srcOffset++, dstOffset++) {
                    buffer[dstOffset] = buffer[srcOffset];
                }
            }

            for (var y = srcRect.bottom; y < w; y++) {
                var srcOffset = (srcRect.bottom - 1) * w,
                    dstOffset = y * w;

                for (var x = 0; x < w; x++, srcOffset++, dstOffset++) {
                    buffer[dstOffset] = buffer[srcOffset];
                }
            }
        }

        /**
         * 
         * @param srcRect CPRect
         * @param dstRect CPRect
         * @param buffer Uint32Array
         * @param brush Uint8Array
         * @param w int
         * @param alpha int
         */
        function smudgePasteBuffer(srcRect, dstRect, buffer, brush, w, alpha) {
            var by = srcRect.top;

            for (var y = dstRect.top; y < dstRect.bottom; y++, by++) {
                var srcOffset = srcRect.left + by * w,
                    dstOffset = curLayer.offsetOfPixel(dstRect.left, y);

                for (var x = dstRect.left; x < dstRect.right; x++, srcOffset++, dstOffset += _CPColorBmp2.default.BYTES_PER_PIXEL) {
                    var bufferColor = buffer[srcOffset],
                        opacityAlpha = (bufferColor >>> 24) * (brush[srcOffset] & 0xff) / 255;

                    if (opacityAlpha > 0) {
                        curLayer.data[dstOffset + _CPColorBmp2.default.RED_BYTE_OFFSET] = bufferColor >> 16 & 0xff;
                        curLayer.data[dstOffset + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = bufferColor >> 8 & 0xff;
                        curLayer.data[dstOffset + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = bufferColor & 0xff;
                        curLayer.data[dstOffset + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = bufferColor >> 24 & 0xff;
                    }
                }
            }
        }

        /**
         * @param srcRect CPRect
         * @param dstRect CPRect
         * @param dab CPBrushDab
         */
        this.paintDabImplementation = function (srcRect, dstRect, dab) {
            if (brushBuffer == null) {
                brushBuffer = new Uint32Array(dab.width * dab.height);
                smudgeAccumBuffer(srcRect, dstRect, brushBuffer, dab.width, 0);
            } else {
                smudgeAccumBuffer(srcRect, dstRect, brushBuffer, dab.width, dab.alpha);
                smudgePasteBuffer(srcRect, dstRect, brushBuffer, dab.brush, dab.width, dab.alpha);

                if (lockAlpha) {
                    restoreAlpha(dstRect);
                }
            }

            opacityArea.makeEmpty();

            if (sampleAllLayers) {
                that.fusionLayers();
            }
        };
    }

    CPBrushToolSmudge.prototype = Object.create(CPBrushToolDirectBrush.prototype);
    CPBrushToolSmudge.prototype.constructor = CPBrushToolSmudge;

    CPBrushToolSmudge.prototype.mergeOpacityBuf = function (dstRect, color) {};

    var paintingModes = [new CPBrushToolSimpleBrush(), new CPBrushToolEraser(), new CPBrushToolDodge(), new CPBrushToolBurn(), new CPBrushToolWatercolor(), new CPBrushToolBlur(), new CPBrushToolSmudge(), new CPBrushToolOil()];

    this.width = _width;
    this.height = _height;

    this.getDefaultLayerName = function () {
        var prefix = "Layer ",
            highestLayerNb = 0;

        for (var i = 0; i < layers.length; i++) {
            var layer = layers[i];

            if (/^Layer [0-9]+$/.test(layer.name)) {
                highestLayerNb = Math.max(highestLayerNb, parseInt(layer.name.substring(prefix.length), 10));
            }
        }
        return prefix + (highestLayerNb + 1);
    };

    function restoreAlpha(rect) {
        that.getActiveLayer().copyAlphaFrom(undoBuffer, rect);
    }

    /**
     * Merge the opacity buffer from the current drawing operation to the active layer.
     */
    function mergeOpacityBuffer(color, clear) {
        if (!opacityArea.isEmpty()) {
            if (curBrush.paintMode != _CPBrushInfo2.default.M_ERASE || !lockAlpha) {
                paintingModes[curBrush.paintMode].mergeOpacityBuf(opacityArea, color);
            } else {
                // FIXME: it would be nice to be able to set the paper color
                paintingModes[_CPBrushInfo2.default.M_PAINT].mergeOpacityBuf(opacityArea, EMPTY_LAYER_COLOR);
            }

            if (lockAlpha) {
                restoreAlpha(opacityArea);
            }

            if (clear) {
                opacityBuffer.clearRect(opacityArea, 0);
            }

            opacityArea.makeEmpty();
        }
    }

    this.addBackgroundLayer = function () {
        var layer = new _CPLayer2.default(that.width, that.height, this.getDefaultLayerName());

        layer.clearAll(EMPTY_BACKGROUND_COLOR);

        this.addLayerObject(layer);
    };

    /**
     * Merge together the visible layers and return the resulting ImageData for display to the screen.
     * 
     * The image is cached, so repeat calls are cheap.
     */
    this.fusionLayers = function () {
        // Is there anything to update from last call?
        if (!fusionArea.isEmpty()) {
            // The current brush renders out its buffers to the layer stack for us
            mergeOpacityBuffer(curColor, false);

            // If the drawing is single-layered and opaque, just use the bottom-most layer as our fusion, we don't need to blend anything!
            if (layers.length == 1 && layers[0].alpha >= 100 && layers[0].visible) {
                fusion = layers[0];
            } else {
                // Fuse into the actual fusion buffer since we need to blend
                fusion = fusionBuffer;

                var fusionIsSemiTransparent = true,
                    first = true;

                layers.forEach(function (layer) {
                    if (!first) {
                        fusionIsSemiTransparent = fusionIsSemiTransparent && fusion.hasAlphaInRect(fusionArea);
                    }

                    if (layer.visible && layer.alpha > 0) {
                        if (first) {
                            first = false;

                            if (layer.alpha == 100) {
                                /*
                                 * Instead of blending the layer onto the empty transparent fusion, we can just copy the
                                 * layer data right into the fusion. This works for all of our blending modes.
                                 */

                                fusion.copyBitmapRect(layer, fusionArea.left, fusionArea.top, fusionArea);
                                return;
                            }

                            fusion.clearRect(fusionArea, 0x00FFFFFF); // Transparent white
                        }

                        _CPBlend2.default.fuseLayer(fusion, fusionIsSemiTransparent, layer, fusionArea);
                    }
                });

                if (first) {
                    // Didn't draw any layers? We have to clear the area, then
                    fusion.clearRect(fusionArea, 0x00FFFFFF); // Transparent white
                }
            }

            fusionArea.makeEmpty();
        }

        return fusion.getImageData();
    };

    this.setActiveLayerIndex = function (newIndex) {
        if (newIndex < 0 || newIndex >= layers.length) {
            return;
        }

        if (curLayer != layers[newIndex]) {
            var oldIndex = this.getActiveLayerIndex();

            curLayer = layers[newIndex];

            // Was the old layer deleted?
            if (oldIndex == -1) {
                callListenersLayerChange();
            } else {
                callListenersLayerChange(oldIndex); // Old layer has now been deselected
                callListenersLayerChange(newIndex); // New layer has now been selected
            }

            invalidateLayerUndo();
        }
    };

    this.getActiveLayerIndex = function () {
        for (var i = 0; i < layers.length; i++) {
            if (layers[i] == curLayer) {
                return i;
            }
        }

        return -1;
    };

    /*
     * Get the index of the topmost visible layer, or 0.
     */
    this.getTopmostVisibleLayer = function () {
        for (var i = layers.length - 1; i >= 0; i--) {
            if (layers[i].visible) {
                return i;
            }
        }

        return 0;
    };

    /**
        * Get the layer with the specified index (no bounds checking)
        *
        * @param {int} i
        * @returns {CPLayer}
        */
    this.getLayer = function (i) {
        return layers[i];
    };

    /**
        * Get the currently active layer (the layer that drawing operations will be applied to))
        *
        * @returns {CPLayer}
        */
    this.getActiveLayer = function () {
        return curLayer;
    };

    this.getDocMemoryUsed = function () {
        var total = fusionBuffer.getMemorySize() * (3 + layers.length);

        if (clipboard != null) {
            total += clipboard.bmp.getMemorySize();
        }

        return total;
    };

    this.getUndoMemoryUsed = function () {
        var total = 0;

        for (var i = 0; i < redoList.length; i++) {
            var undo = redoList[i];

            total += undo.getMemoryUsed(true, null);
        }

        for (var i = 0; i < undoList.length; i++) {
            var undo = undoList[i];

            total += undo.getMemoryUsed(false, null);
        }

        return total;
    };

    function canUndo() {
        return undoList.length > 0;
    }

    function canRedo() {
        return redoList.length > 0;
    }

    //
    // Undo / Redo
    //

    this.undo = function () {
        if (!canUndo()) {
            return;
        }
        hasUnsavedChanges = true;

        var undo = undoList.pop();

        undo.undo();

        redoList.push(undo);
    };

    this.redo = function () {
        if (!canRedo()) {
            return;
        }
        hasUnsavedChanges = true;

        var redo = redoList.pop();

        redo.redo();

        undoList.push(redo);
    };

    /**
     * Ensures that the state of the current layer has been stored in undoBuffer so it can be undone later.
     */
    function prepareForLayerUndo() {
        if (!undoBufferInvalidRegion.isEmpty()) {
            //console.log("Copying " + undoBufferInvalidRegion + " to the undo buffer");
            undoBuffer.copyBitmapRect(curLayer, undoBufferInvalidRegion.left, undoBufferInvalidRegion.top, undoBufferInvalidRegion);
            undoBufferInvalidRegion.makeEmpty();
        }
    }

    /**
     * Call when the undo buffer has become completely worthless (e.g. after the active layer index changes, the undo
     * buffer won't contain any data from the new layer to begin with).
     */
    function invalidateLayerUndo() {
        undoBufferInvalidRegion = that.getBounds();
    }

    /**
     * The result of some of our operations aren't needed until later, so we can defer them until the user is idle.
     *
     * You may call this routine at any time (or never, if you like) as a hint that the user is idle and we should
     * try to perform pending operations before we will need to block on their results.
     */
    this.performIdleTasks = function () {
        prepareForLayerUndo();
    };

    function addUndo(undo) {
        hasUnsavedChanges = true;

        if (redoList.length > 0) {
            redoList = [];
        }

        if (undoList.length == 0 || !undoList[undoList.length - 1].merge(undo)) {
            if (undoList.length >= MAX_UNDO) {
                undoList.unshift();
            }
            if (undoList.length > 0) {
                undoList[undoList.length - 1].compact();
            }
            undoList.push(undo);
        } else if (undoList[undoList.length - 1].noChange()) {
            // Two merged changes can mean no change at all
            // don't leave a useless undo in the list
            undoList.pop();
        }
    }

    this.clearHistory = function () {
        undoList = [];
        redoList = [];
    };

    this.colorPicker = function (x, y) {
        // not really necessary and could potentially the repaint
        // of the canvas to miss that area
        // this.fusionLayers();

        return fusion.getPixel(~~x, ~~y) & 0xFFFFFF;
    };

    this.setSelection = function (rect) {
        curSelection.set(rect);
        curSelection.clip(this.getBounds());
    };

    this.emptySelection = function () {
        curSelection.makeEmpty();
    };

    this.floodFill = function (x, y) {
        prepareForLayerUndo();
        undoArea = this.getBounds();

        curLayer.floodFill(~~x, ~~y, curColor | 0xff000000);

        addUndo(new CPUndoPaint());
        invalidateFusion();
    };

    this.gradientFill = function (fromX, fromY, toX, toY, gradientPoints) {
        var r = this.getSelectionAutoSelect();

        prepareForLayerUndo();
        undoArea = r;

        curLayer.gradient(r, fromX, fromY, toX, toY, gradientPoints);

        if (lockAlpha) {
            restoreAlpha(r);
        }

        addUndo(new CPUndoPaint());
        invalidateFusion();
    };

    this.fill = function (color) {
        var r = this.getSelectionAutoSelect();

        prepareForLayerUndo();
        undoArea = r;

        curLayer.clearRect(r, color);

        addUndo(new CPUndoPaint());
        invalidateFusion();
    };

    this.clear = function () {
        this.fill(0xffffff);
    };

    this.hFlip = function () {
        var r = this.getSelectionAutoSelect();

        prepareForLayerUndo();
        undoArea = r;

        curLayer.copyRegionHFlip(r, undoBuffer);

        addUndo(new CPUndoPaint());
        invalidateFusion();
    };

    this.vFlip = function () {
        var r = this.getSelectionAutoSelect();

        prepareForLayerUndo();
        undoArea = r;

        curLayer.copyRegionVFlip(r, undoBuffer);

        addUndo(new CPUndoPaint());
        invalidateFusion();
    };

    this.monochromaticNoise = function () {
        var r = this.getSelectionAutoSelect();

        prepareForLayerUndo();
        undoArea = r;

        curLayer.fillWithNoise(r);

        addUndo(new CPUndoPaint());
        invalidateFusion();
    };

    this.colorNoise = function () {
        var r = this.getSelectionAutoSelect();

        prepareForLayerUndo();
        undoArea = r;

        curLayer.fillWithColorNoise(r);

        addUndo(new CPUndoPaint());
        invalidateFusion();
    };

    this.invert = function () {
        var r = this.getSelectionAutoSelect();

        prepareForLayerUndo();
        undoArea = r;

        curLayer.invert(r);

        addUndo(new CPUndoPaint());
        invalidateFusion();
    };

    this.boxBlur = function (radiusX, radiusY, iterations) {
        var r = this.getSelectionAutoSelect();

        prepareForLayerUndo();
        undoArea = r;

        for (var i = 0; i < iterations; i++) {
            curLayer.boxBlur(r, radiusX, radiusY);
        }

        addUndo(new CPUndoPaint());
        invalidateFusion();
    };

    this.rectangleSelection = function (r) {
        var newSelection = r.clone();

        newSelection.clip(this.getBounds());

        addUndo(new CPUndoRectangleSelection(this.getSelection(), newSelection));

        this.setSelection(newSelection);
    };

    /**
     * Get the most recently completed operation from the undo list, or null if the undo list is empty.
     *
     * @returns {*}
     */
    function getActiveOperation() {
        if (undoList.length > 0) {
            return undoList[undoList.length - 1];
        }

        return null;
    }

    /**
     * Move the currently selected layer data by the given offset.
     *
     * @param {int} offsetX
     * @param {int} offsetY
     * @param {boolean} copy - Make a copy of the selection instead of moving it.
     */
    this.move = function (offsetX, offsetY, copy) {
        /*
         * Add rounding to ensure we haven't been given float coordinates (that would cause horrible flow-on effects like
         * the boundary of the undo rectangle having float coordinates)
         */
        offsetX |= 0;
        offsetY |= 0;

        if (offsetX == 0 && offsetY == 0) {
            return;
        }

        opacityArea.makeEmpty(); // Prevents a drawing tool being called during layer fusion to draw itself to the layer

        var activeOp = getActiveOperation();

        // If we've changed layers since our last move, we want to move the new layer, not the old one, so can't amend
        if (!copy && activeOp instanceof CPActionMoveSelection && activeOp.layerIndex == this.getActiveLayerIndex()) {
            activeOp.amend(offsetX, offsetY);
            redoList = [];
            hasUnsavedChanges = true;
        } else {
            activeOp = new CPActionMoveSelection(this.getSelectionAutoSelect(), offsetX, offsetY, copy);

            addUndo(activeOp);
        }
    };

    /**
     * Change the interpolation mode used by Free Transform operations
     *
     * @param {string} interpolation - Either "sharp" or "smooth"
     */
    this.setTransformInterpolation = function (interpolation) {
        transformInterpolation = interpolation;
        if (previewOperation instanceof CPActionTransformSelection) {
            previewOperation.setInterpolation(interpolation);
        }
    };

    /**
        * If the current operation is an affine transform, roll it back and remove it from the undo history.
        */
    this.transformAffineAbort = function () {
        if (previewOperation instanceof CPActionTransformSelection) {
            previewOperation.undo();
            previewOperation = null;
        }
    };

    /**
        * Begins transforming the current selection/layer, and returns the initial source rectangle and initial transform.
        * You can update the transform by calling transformAffine().
        * 
        * You must call transformAffineFinish() or transformAffineAbort() to finish the transformation.
        * 
        * Returns null if the current selection/layer doesn't contain any non-transparent pixels, and doesn't start
        * transforming.
        */
    this.transformAffineBegin = function () {
        // Are we already transforming? Continue that instead
        if (previewOperation instanceof CPActionTransformSelection) {
            return { transform: previewOperation.getTransform(), rect: previewOperation.getInitialTransformRect(), selection: previewOperation.getInitialSelectionRect() };
        }

        // Only transform the non-transparent pixels
        var layer = this.getActiveLayer(),
            selection = this.getSelectionAutoSelect(),
            initialRect = layer.getNonTransparentBounds(selection),
            initialTransform = new _CPTransform2.default();

        if (initialRect.isEmpty()) {
            return null;
        }

        /* If we introduce other previewOperations, we might want to check we aren't overwriting them here...
         * Though probably ChickenPaint's global exclusive mode will enforce this for us.
         */
        previewOperation = new CPActionTransformSelection(initialRect, initialTransform, transformInterpolation);

        opacityArea.makeEmpty(); // Prevents a drawing tool being called during layer fusion to draw itself to the layer

        return { transform: initialTransform, rect: initialRect, selection: selection };
    };

    /**
        * Finish and save the transform that is currently in progress.
        */
    this.transformAffineFinish = function () {
        if (previewOperation instanceof CPActionTransformSelection) {
            addUndo(previewOperation);
            previewOperation = null;
        }
    };

    /**
     * Transform the currently selected layer data using the given AffineTransform.
     *
     * @param {CPTransform} affineTransform
     */
    this.transformAffineAmend = function (affineTransform) {
        if (previewOperation instanceof CPActionTransformSelection) {
            previewOperation.amend(affineTransform);
        }
    };

    // Copy/Paste functions

    this.cutSelection = function (createUndo) {
        var selection = this.getSelection();

        if (selection.isEmpty()) {
            return;
        }

        clipboard = new _CPClip2.default(curLayer.cloneRect(selection), selection.left, selection.top);

        if (createUndo) {
            addUndo(new CPUndoCut(clipboard.bmp, this.getActiveLayerIndex(), selection));
        }

        curLayer.clearRect(selection, EMPTY_LAYER_COLOR);
        invalidateFusionRect(selection);
    };

    this.copySelection = function () {
        var selection = that.getSelection();

        if (selection.isEmpty()) {
            return;
        }

        clipboard = new _CPClip2.default(curLayer.cloneRect(selection), selection.left, selection.top);
    };

    this.copySelectionMerged = function () {
        var selection = that.getSelection();

        if (selection.isEmpty()) {
            return;
        }

        // make sure the fusioned picture is up to date
        this.fusionLayers();
        clipboard = new _CPClip2.default(fusion.cloneRect(selection), selection.left, selection.top);
    };

    /**
     *
     * @param createUndo boolean
     * @param clip CPClip
     */
    function pasteClip(createUndo, clip) {
        var activeLayerIndex = that.getActiveLayerIndex();

        if (createUndo) {
            addUndo(new CPUndoPaste(clip, activeLayerIndex, that.getSelection()));
        }

        var newLayer = new _CPLayer2.default(that.width, that.height, that.getDefaultLayerName()),
            sourceRect = clip.bmp.getBounds(),
            x,
            y;

        layers.splice(activeLayerIndex + 1, 0, newLayer);
        that.setActiveLayerIndex(activeLayerIndex + 1);

        if (sourceRect.isInside(that.getBounds())) {
            x = clip.x;
            y = clip.y;
        } else {
            x = (that.width - clip.bmp.width) / 2 | 0;
            y = (that.height - clip.bmp.height) / 2 | 0;
        }

        curLayer.copyBitmapRect(clip.bmp, x, y, sourceRect);
        that.emptySelection();

        invalidateFusion();
        callListenersLayerChange();
    }

    this.pasteClipboard = function (createUndo) {
        if (clipboard != null) {
            pasteClip(createUndo, clipboard);
        }
    };

    this.setSampleAllLayers = function (b) {
        sampleAllLayers = b;
    };

    this.setLockAlpha = function (b) {
        lockAlpha = b;
    };

    this.setForegroundColor = function (color) {
        curColor = color;
    };

    this.setBrush = function (brush) {
        curBrush = brush;
    };

    this.setBrushTexture = function (texture) {
        brushManager.setTexture(texture);
    };

    // ///////////////////////////////////////////////////////////////////////////////////
    // Paint engine
    // ///////////////////////////////////////////////////////////////////////////////////

    this.beginStroke = function (x, y, pressure) {
        if (curBrush == null) {
            return;
        }

        paintingModes[curBrush.paintMode].beginStroke(x, y, pressure);
    };

    this.continueStroke = function (x, y, pressure) {
        if (curBrush == null) {
            return;
        }

        paintingModes[curBrush.paintMode].continueStroke(x, y, pressure);
    };

    this.endStroke = function () {
        if (curBrush == null) {
            return;
        }

        paintingModes[curBrush.paintMode].endStroke();
    };

    this.hasAlpha = function () {
        return fusion.hasAlpha();
    };

    /**
     * Get the artwork as a single flat PNG image.
     * 
     * Rotation is [0..3] and selects a multiple of 90 degrees of clockwise rotation to be applied to the drawing before
     * saving.
     * 
     * @return A binary string of the PNG file data.
     */
    this.getFlatPNG = function (rotation) {
        this.fusionLayers();

        return fusion.getAsPNG(rotation);
    };

    /**
     * Returns true if this artwork can be exactly represented as a simple transparent PNG (i.e. doesn't have multiple 
     * layers, and base layer's opacity is set to 100%).
     */
    this.isSimpleDrawing = function () {
        return this.getLayerCount() == 1 && this.getLayer(0).getAlpha() == 100;
    };

    // ////////////////////////////////////////////////////
    // Undo classes

    /**
     * Save the difference between the current layer and the undoBuffer (within the undoArea) for undo, and clear
     * the undoArea.
     *
     * @constructor
     */
    function CPUndoPaint() {
        var rect = undoArea.clone(),
            data = undoBuffer.copyRectXOR(curLayer, rect);

        this.layer = that.getActiveLayerIndex();

        undoArea.makeEmpty();

        this.undo = function () {
            that.getLayer(this.layer).setRectXOR(data, rect);
            invalidateFusionRect(rect);
        };

        this.redo = function () {
            that.getLayer(this.layer).setRectXOR(data, rect);
            invalidateFusionRect(rect);
        };

        this.getMemoryUsed = function (undone, param) {
            return data.length;
        };
    }

    CPUndoPaint.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoPaint.prototype.constructor = CPUndoPaint;

    function CPUndoLayerVisible(_layerIndex, _oldVis, _newVis) {
        this.layerIndex = _layerIndex;
        this.oldVis = _oldVis;
        this.newVis = _newVis;
    }

    CPUndoLayerVisible.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoLayerVisible.prototype.constructor = CPUndoLayerVisible;

    CPUndoLayerVisible.prototype.redo = function () {
        that.getLayer(this.layerIndex).visible = this.newVis;

        invalidateFusion();
        callListenersLayerChange(this.layerIndex);
    };

    CPUndoLayerVisible.prototype.undo = function () {
        that.getLayer(this.layerIndex).visible = this.oldVis;

        invalidateFusion();
        callListenersLayerChange(this.layerIndex);
    };

    CPUndoLayerVisible.prototype.merge = function (u) {
        if (u instanceof CPUndoLayerVisible && this.layerIndex == u.layerIndex) {
            this.newVis = u.newVis;
            return true;
        }
        return false;
    };

    CPUndoLayerVisible.prototype.noChange = function () {
        return this.oldVis == this.newVis;
    };

    function CPUndoAddLayer(layerIndex) {
        this.undo = function () {
            layers.splice(layerIndex + 1, 1);
            that.setActiveLayerIndex(layerIndex);
            invalidateFusion();
            callListenersLayerChange();
        };

        this.redo = function () {
            var newLayer = new _CPLayer2.default(that.width, that.height, that.getDefaultLayerName());
            newLayer.clearAll(EMPTY_LAYER_COLOR);
            layers.splice(layerIndex + 1, 0, newLayer);
            that.setActiveLayerIndex(layerIndex + 1);

            invalidateFusion();
            callListenersLayerChange();
        };
    }

    CPUndoAddLayer.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoAddLayer.prototype.constructor = CPUndoAddLayer;

    function CPUndoDuplicateLayer(layerIndex) {
        this.undo = function () {
            layers.splice(layerIndex + 1, 1);
            that.setActiveLayerIndex(layerIndex);

            invalidateFusion();
            callListenersLayerChange();
        };

        this.redo = function () {
            var copySuffix = " Copy",
                sourceLayer = layers[layerIndex],
                newLayer = new _CPLayer2.default(that.width, that.height),
                newLayerName = sourceLayer.name;

            if (!newLayerName.endsWith(copySuffix)) {
                newLayerName += copySuffix;
            }

            newLayer.copyFrom(sourceLayer);
            newLayer.name = newLayerName;

            layers.splice(layerIndex + 1, 0, newLayer);

            that.setActiveLayerIndex(layerIndex + 1);

            invalidateFusion();
            callListenersLayerChange();
        };
    }

    CPUndoDuplicateLayer.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoDuplicateLayer.prototype.constructor = CPUndoDuplicateLayer;

    /**
     * @param layerIndex int
     * @param layer CPLayer
     */
    function CPUndoRemoveLayer(layerIndex, layer) {
        this.undo = function () {
            layers.splice(layerIndex, 0, layer);
            that.setActiveLayerIndex(layerIndex);

            invalidateFusion();
            callListenersLayerChange();
        };

        this.redo = function () {
            layers.splice(layerIndex, 1);
            that.setActiveLayerIndex(layerIndex < layers.length ? layerIndex : layerIndex - 1);

            invalidateFusion();
            callListenersLayerChange();
        };

        this.getMemoryUsed = function (undone) {
            return undone ? 0 : layer.width * layer.height * _CPColorBmp2.default.BYTES_PER_PIXEL;
        };
    }

    CPUndoRemoveLayer.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoRemoveLayer.prototype.constructor = CPUndoRemoveLayer;

    function CPUndoMergeDownLayer(layerIndex) {
        var layerBottom = new _CPLayer2.default(that.width, that.height),
            layerTop;

        layerBottom.copyFrom(layers[layerIndex - 1]);
        layerTop = layers[layerIndex];

        this.undo = function () {
            layers[layerIndex - 1].copyFrom(layerBottom);
            layers.splice(layerIndex, 0, layerTop);
            that.setActiveLayerIndex(layerIndex);

            layerBottom = layerTop = null;

            invalidateFusion();
            callListenersLayerChange();
        };

        this.redo = function () {
            layerBottom = new _CPLayer2.default(that.width, that.height);
            layerBottom.copyFrom(layers[layerIndex - 1]);
            layerTop = layers[layerIndex];

            that.setActiveLayerIndex(layerIndex);
            that.mergeDown(false);
        };

        this.getMemoryUsed = function (undone, param) {
            return undone ? 0 : that.width * that.height * _CPColorBmp2.default.BYTES_PER_PIXEL * 2;
        };
    }

    CPUndoMergeDownLayer.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoMergeDownLayer.prototype.constructor = CPUndoMergeDownLayer;

    function CPUndoMergeAllLayers() {
        var oldActiveLayerIndex = that.getActiveLayerIndex(),
            oldLayers = layers.slice(0); // Clone old layers array

        this.undo = function () {
            layers = oldLayers.slice(0);
            that.setActiveLayerIndex(oldActiveLayerIndex);

            invalidateFusion();
            callListenersLayerChange();
        };

        this.redo = function () {
            that.mergeAllLayers(false);
        };

        this.getMemoryUsed = function (undone, param) {
            return undone ? 0 : oldLayers.length * width * height * _CPColorBmp2.default.BYTES_PER_PIXEL;
        };
    }

    CPUndoMergeAllLayers.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoMergeAllLayers.prototype.constructor = CPUndoMergeAllLayers;

    function CPUndoMoveLayer(from, to) {
        this.undo = function () {
            if (to <= from) {
                moveLayerReal(to, from + 1);
            } else {
                moveLayerReal(to - 1, from);
            }
        };

        this.redo = function () {
            moveLayerReal(from, to);
        };
    }

    CPUndoMoveLayer.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoMoveLayer.prototype.constructor = CPUndoMoveLayer;

    function CPUndoLayerAlpha(layerIndex, alpha) {
        this.from = that.getLayer(layerIndex).getAlpha();
        this.to = alpha;
        this.layerIndex = layerIndex;
    }

    CPUndoLayerAlpha.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoLayerAlpha.prototype.constructor = CPUndoLayerAlpha;

    CPUndoLayerAlpha.prototype.undo = function () {
        that.getLayer(this.layerIndex).setAlpha(this.from);

        invalidateFusion();
        callListenersLayerChange(this.layerIndex);
    };

    CPUndoLayerAlpha.prototype.redo = function () {
        that.getLayer(this.layerIndex).setAlpha(this.to);

        invalidateFusion();
        callListenersLayerChange(this.layerIndex);
    };

    CPUndoLayerAlpha.prototype.merge = function (u) {
        if (u instanceof CPUndoLayerAlpha && this.layerIndex == u.layerIndex) {
            this.to = u.to;
            return true;
        }
        return false;
    };

    CPUndoLayerAlpha.prototype.noChange = function () {
        return this.from == this.to;
    };

    function CPUndoLayerMode(layerIndex, to) {
        this.layerIndex = layerIndex;
        this.from = that.getLayer(layerIndex).getBlendMode();
        this.to = to;
    }

    CPUndoLayerMode.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoLayerMode.prototype.constructor = CPUndoLayerMode;

    CPUndoLayerMode.prototype.undo = function () {
        that.getLayer(this.layerIndex).setBlendMode(this.from);

        invalidateFusion();
        callListenersLayerChange();
    };

    CPUndoLayerMode.prototype.redo = function () {
        that.getLayer(this.layerIndex).setBlendMode(this.to);

        invalidateFusion();
        callListenersLayerChange();
    };

    CPUndoLayerMode.prototype.merge = function (u) {
        if (u instanceof CPUndoLayerMode && this.layerIndex == u.layerIndex) {
            this.to = u.to;
            return true;
        }
        return false;
    };

    CPUndoLayerMode.prototype.noChange = function () {
        return this.from == this.to;
    };

    function CPUndoLayerRename(layerIndex, to) {
        this.layerIndex = layerIndex;
        this.to = to;
        this.from = that.getLayer(layerIndex).name;
    }

    CPUndoLayerRename.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoLayerRename.prototype.constructor = CPUndoLayerRename;

    CPUndoLayerRename.prototype.undo = function () {
        that.getLayer(this.layerIndex).name = this.from;
        callListenersLayerChange(this.layerIndex);
    };

    CPUndoLayerRename.prototype.redo = function () {
        that.getLayer(this.layerIndex).name = this.to;
        callListenersLayerChange(this.layerIndex);
    };

    CPUndoLayerRename.prototype.merge = function (u) {
        if (u instanceof CPUndoLayerRename && this.layerIndex == u.layerIndex) {
            this.to = u.to;
            return true;
        }
        return false;
    };

    CPUndoLayerRename.prototype.noChange = function () {
        return this.from == this.to;
    };

    /**
     * @param from CPRect
     * @param to CPRect
     */
    function CPUndoRectangleSelection(from, to) {
        from = from.clone();
        to = to.clone();

        this.undo = function () {
            that.setSelection(from);
            callListenersUpdateRegion(that.getBounds());
        };

        this.redo = function () {
            that.setSelection(to);
            callListenersUpdateRegion(that.getBounds());
        };

        this.noChange = function () {
            return from.equals(to);
        };
    }

    CPUndoRectangleSelection.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoRectangleSelection.prototype.constructor = CPUndoRectangleSelection;

    /**
     * Upon creation, transforms the currently selected region of the current layer by the given affine transform.
     *
     * @param {CPRect} srcRect - Rectangle to transform
     * @param {CPTransform} affineTransform - Transform to apply
     * @param {string} interpolation - "smooth" or "sharp"
     */
    function CPActionTransformSelection(srcRect, affineTransform, interpolation) {
        var fromSelection = that.getSelection(),
            dstRect = null,
            tempCanvas = document.createElement("canvas"),
            tempCanvasContext = tempCanvas.getContext("2d"),
            undoData,
            // A copy of the original layer within the undoDataRect
        undoDataRect,


        // A canvas for composing the transform onto
        fullUndoCanvas = document.createElement("canvas"),
            fullUndoCanvasContext = fullUndoCanvas.getContext("2d");

        affineTransform = affineTransform.clone();
        interpolation = interpolation || "smooth";

        this.undo = function () {
            var layer = that.getLayer(this.layerIndex),
                invalidateRegion = dstRect.clone(),
                undoSrcRegion;

            invalidateRegion.union(srcRect);

            undoSrcRegion = invalidateRegion.clone();
            undoSrcRegion.translate(-undoDataRect.left, -undoDataRect.top);

            layer.copyBitmapRect(undoData, invalidateRegion.left, invalidateRegion.top, undoSrcRegion);

            that.setSelection(fromSelection);
            that.setActiveLayerIndex(this.layerIndex);

            invalidateFusionRect(invalidateRegion);

            /*
             * Required because in the case of a copy, we don't invalidate the source rect in the fusion, so the canvas
             * won't end up repainting the selection rectangle there.
             */
            callListenersSelectionChange();
        };

        this.redo = function () {
            var layer = that.getLayer(this.layerIndex);

            // Make a fresh copy of the layer into a Canvas to compose onto
            fullUndoCanvasContext.putImageData(layer.getImageData(), 0, 0);

            // Erase the region we moved from
            fullUndoCanvasContext.clearRect(srcRect.left, srcRect.top, srcRect.getWidth(), srcRect.getHeight());

            (0, _CPPolyfill.setCanvasInterpolation)(fullUndoCanvasContext, interpolation == "smooth");

            fullUndoCanvasContext.save();

            // Apply the transform when drawing the transformed fragment
            fullUndoCanvasContext.setTransform(affineTransform.m[0], affineTransform.m[1], affineTransform.m[2], affineTransform.m[3], affineTransform.m[4], affineTransform.m[5]);
            fullUndoCanvasContext.drawImage(tempCanvas, srcRect.left, srcRect.top);

            fullUndoCanvasContext.restore();

            // Copy back to the layer data
            layer.setImageData(fullUndoCanvasContext.getImageData(0, 0, layer.width, layer.height));

            // Invalidate the source and destination regions we touched
            var invalidateRegion = srcRect.clone(),
                dstCorners = srcRect.toPoints();

            affineTransform.transformPoints(dstCorners);

            dstRect = _CPRect2.default.createBoundingBox(dstCorners);
            dstRect.roundContain();
            layer.getBounds().clip(dstRect);

            invalidateRegion.union(dstRect);

            invalidateFusionRect(invalidateRegion);

            // Transform the selection rect to enclose the transformed selection
            if (!fromSelection.isEmpty()) {
                var toSelectionPoints = fromSelection.toPoints(),
                    toSelectionRect;

                affineTransform.transformPoints(toSelectionPoints);

                toSelectionRect = _CPRect2.default.createBoundingBox(toSelectionPoints);
                toSelectionRect.roundNearest();
                layer.getBounds().clip(toSelectionRect);

                that.setSelection(toSelectionRect);
                callListenersSelectionChange();
            }
        };

        /**
         * Replace the transform with the given one.
         *
         * @param {CPTransform} _affineTransform
         */
        this.amend = function (_affineTransform) {
            var layer = that.getLayer(this.layerIndex);

            this.undo();

            if (undoDataRect.getWidth() < layer.width || undoDataRect.getHeight() < layer.height) {
                /*
                 * We need a complete copy of the layer in undoData to support further redo(). (As we probably previously
                 * only made a backup copy of the areas we erased using the old transform).
                 */
                undoData = layer.clone();
                undoDataRect = layer.getBounds();
            }

            affineTransform = _affineTransform.clone();
            this.redo();
        };

        this.setInterpolation = function (newInterpolation) {
            if (newInterpolation != interpolation) {
                interpolation = newInterpolation;

                this.undo();
                this.redo();
            }
        };

        /**
         * Called when we're no longer the top operation in the undo stack, so that we can optimize for lower memory
         * usage instead of faster revision speed
         */
        this.compact = function () {
            var layer = that.getLayer(this.layerIndex);

            // If we have a full undo, and we don't need very much area for undo, trim it to just the area we need
            if (undoDataRect.getWidth() == layer.width && undoDataRect.getHeight() == layer.height) {
                var dirtyRect = srcRect.getUnion(dstRect);

                if (dirtyRect.getArea() * 2 < layer.width * layer.height) {
                    undoDataRect = dirtyRect;
                    undoData = undoData.cloneRect(undoDataRect);
                }
            }
        };

        this.getMemoryUsed = function (undone, param) {
            return undoData.getMemorySize();
        };

        /**
            * Get a copy of the affine transform.
            */
        this.getTransform = function () {
            return affineTransform.clone();
        };

        /**
         * Get a copy of the initial document rectangle (before the transform was applied)
         *
         * @returns {CPRect}
         */
        this.getInitialTransformRect = function () {
            return srcRect.clone();
        };

        /**
         * Get a copy of the initial user selection rectangle (before the transform was applied). Can be empty if
         * the user didn't have anything selected before the transform began.
         *
         * @returns {CPRect}
         */
        this.getInitialSelectionRect = function () {
            return fromSelection.clone();
        };

        this.layerIndex = that.getActiveLayerIndex();

        var layer = that.getLayer(this.layerIndex);

        undoData = layer.clone();
        undoDataRect = layer.getBounds();
        fullUndoCanvas.width = layer.width;
        fullUndoCanvas.height = layer.height;

        // Make a copy of just the source rectangle in its own canvas so we have it as an image to be drawn later
        tempCanvas.width = srcRect.getWidth();
        tempCanvas.height = srcRect.getHeight();
        tempCanvasContext.putImageData(undoData.getImageData(), -srcRect.left, -srcRect.top, srcRect.left, srcRect.top, srcRect.getWidth(), srcRect.getHeight());

        this.redo();
    }

    CPActionTransformSelection.prototype = Object.create(_CPUndo2.default.prototype);
    CPActionTransformSelection.prototype.constructor = CPActionTransformSelection;

    /**
     * Upon creation, moves the currently selected region of the current layer by the given offset (or copies it if
     * 'copy' is true).
     *
     * @param srcRect
     * @param offsetX
     * @param offsetY
     * @param copy
     * @constructor
     */
    function CPActionMoveSelection(srcRect, offsetX, offsetY, copy) {
        var fromSelection = that.getSelection(),
            dstRect = null,
            fullUndo,
            // A copy of the entire layer
        srcData = null,
            // A copy of the original pixels at the srcRect, or null if we use a fullUndo instead
        dstData = null // A copy of the original pixels at the dstRect, or null
        ;

        this.undo = function () {
            var layer = that.getLayer(this.layerIndex),
                invalidateRegion = dstRect.clone();

            if (!copy) {
                invalidateRegion.union(srcRect);
            }

            if (fullUndo) {
                layer.copyBitmapRect(fullUndo, invalidateRegion.left, invalidateRegion.top, invalidateRegion);
            } else {
                layer.copyBitmapRect(srcData, srcRect.left, srcRect.top, srcData.getBounds());

                if (dstData) {
                    layer.copyBitmapRect(dstData, dstRect.left, dstRect.top, dstData.getBounds());
                }
            }

            that.setSelection(fromSelection);
            that.setActiveLayerIndex(this.layerIndex);

            invalidateFusionRect(invalidateRegion);

            /*
             * Required because in the case of a copy, we don't invalidate the source rect in the fusion, so the canvas
             * won't end up repainting the selection rectangle there.
             */
            callListenersSelectionChange();
        };

        this.redo = function () {
            var layer = that.getLayer(this.layerIndex),
                invalidateRegion = new _CPRect2.default(0, 0, 0, 0);

            if (!copy) {
                layer.clearRect(srcRect, 0);
                invalidateRegion.set(srcRect);
            }

            dstRect = srcRect.clone();
            dstRect.translate(offsetX, offsetY);
            layer.getBounds().clip(dstRect);

            /* Note that while we could copy image data from the layer itself onto the layer (instead of sourcing that
             * data from the undo buffers), this would require that pasteAlphaRect do the right thing when source and
             * dest rects overlap, which it doesn't.
             */
            if (fullUndo) {
                layer.pasteAlphaRect(fullUndo, srcRect, dstRect.left, dstRect.top);
            } else {
                layer.pasteAlphaRect(srcData, srcData.getBounds(), dstRect.left, dstRect.top);
            }

            invalidateRegion.union(dstRect);

            invalidateFusionRect(invalidateRegion);

            if (!fromSelection.isEmpty()) {
                var toSelection = fromSelection.clone();
                toSelection.translate(offsetX, offsetY);
                that.setSelection(toSelection);
                callListenersSelectionChange();
            }
        };

        /**
         * Move further by the given offset on top of the current offset.
         *
         * @param _offsetX {int}
         * @param _offsetY {int}
         */
        this.amend = function (_offsetX, _offsetY) {
            var layer = that.getLayer(this.layerIndex);

            if (fullUndo) {
                if (copy) {
                    this.undo();
                } else {
                    /*
                     * We don't need to restore the image at the *source* location as a full undo would do, since
                     * we'll only erase that area again once we redo(). So just restore the data at the dest.
                     */
                    layer.copyBitmapRect(fullUndo, dstRect.left, dstRect.top, dstRect);
                    invalidateFusionRect(dstRect);
                }
            } else {
                /*
                 * We want to make a complete copy of the layer in fullUndo to support fast further amend() calls.
                 */
                this.undo();

                fullUndo = layer.clone();
                srcData = null;
                dstData = null;
            }

            offsetX += _offsetX;
            offsetY += _offsetY;
            this.redo();
        };

        /**
         * Called when we're no longer the top operation in the undo stack, so that we can optimize for lower memory
         * usage instead of faster revision speed
         */
        this.compact = function () {
            if (fullUndo && srcRect.getArea() * 2 < that.width * that.height) {
                // Replace our copy of the entire layer with just a copy of the areas we damaged

                srcData = fullUndo.cloneRect(srcRect);

                if (!copy && dstRect.isInside(srcRect)) {
                    dstData = null;
                } else {
                    dstData = fullUndo.cloneRect(dstRect);
                }

                fullUndo = null;
            }
        };

        this.getMemoryUsed = function () {
            var size = 0;

            if (fullUndo) {
                size += fullUndo.getMemorySize();
            }
            if (srcData) {
                size += srcData.getMemorySize();
            }
            if (dstData) {
                size += dstData.getMemorySize();
            }

            return size;
        };

        this.layerIndex = that.getActiveLayerIndex();
        fullUndo = that.getLayer(this.layerIndex).clone();

        this.redo();
    }

    CPActionMoveSelection.prototype = Object.create(_CPUndo2.default.prototype);
    CPActionMoveSelection.prototype.constructor = CPActionMoveSelection;

    /**
     * Used to encapsulate multiple undo operation as one
     * 
     * @param undoes CPUndo[] List of undo operations to encapsulate
     */
    function CPMultiUndo(undoes) {
        this.undoes = undoes;
    }

    CPMultiUndo.prototype = Object.create(_CPUndo2.default.prototype);
    CPMultiUndo.prototype.constructor = CPMultiUndo;

    CPMultiUndo.prototype.undo = function () {
        for (var i = this.undoes.length - 1; i >= 0; i--) {
            this.undoes[i].undo();
        }
    };

    CPMultiUndo.prototype.redo = function () {
        for (var i = 0; i < this.undoes.length; i++) {
            this.undoes[i].redo();
        }
    };

    CPMultiUndo.prototype.noChange = function () {
        for (var i = 0; i < undoes.length; i++) {
            if (!undoes[i].noChange()) {
                return false;
            }
        }

        return true;
    };

    CPMultiUndo.prototype.getMemoryUsed = function (undone, param) {
        var total = 0;

        for (var i = 0; i < undoes.length; i++) {
            total += undoes[i].getMemoryUsed(undone, param);
        }

        return total;
    };

    /**
     * Store data to undo a cut operation
     * 
     * @param bmp CPColorBmp The rectangle of image data that was cut
     * @param layerIndex int Index of the layer the cut came from
     * @param selection CPRect The cut rectangle co-ordinates
     */
    function CPUndoCut(bmp, layerIndex, selection) {
        selection = selection.clone();

        this.undo = function () {
            that.setActiveLayerIndex(layerIndex);
            curLayer.copyBitmapRect(bmp, selection.left, selection.top, bmp.getBounds());
            that.setSelection(selection);
            invalidateFusionRect(selection);
        };

        this.redo = function () {
            that.setActiveLayerIndex(layerIndex);
            curLayer.clearRect(selection, EMPTY_LAYER_COLOR);
            that.emptySelection();
            invalidateFusionRect(selection);
        };

        this.getMemoryUsed = function (undone, param) {
            return bmp == param ? 0 : bmp.width * bmp.height * _CPColorBmp2.default.BYTES_PER_PIXEL;
        };
    }

    CPUndoCut.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoCut.prototype.constructor = CPUndoCut;

    /**
     * Store data to undo a paste operation
     * 
     * @param clip CPClip
     * @param layerIndex int
     * @param selection CPRect
     */
    function CPUndoPaste(clip, layerIndex, selection) {
        selection = selection.clone();

        this.undo = function () {
            layers.splice(layerIndex + 1, 1);

            that.setActiveLayerIndex(layerIndex);
            that.setSelection(selection);

            invalidateFusionRect(selection);
            callListenersLayerChange();
        };

        this.redo = function () {
            that.setActiveLayerIndex(layerIndex);
            pasteClip(false, clip);
        };

        this.getMemoryUsed = function (undone, param) {
            return clip.bmp == param ? 0 : clip.bmp.width * clip.bmp.height * 4;
        };
    }

    CPUndoPaste.prototype = Object.create(_CPUndo2.default.prototype);
    CPUndoPaste.prototype.constructor = CPUndoPaste;
};

CPArtwork.prototype = Object.create(EventEmitter.prototype);
CPArtwork.prototype.constructor = CPArtwork;

CPArtwork.prototype.getBounds = function () {
    return new _CPRect2.default(0, 0, this.width, this.height);
};

CPArtwork.prototype.isPointWithin = function (x, y) {
    return x >= 0 && y >= 0 && x < this.width && y < this.height;
};
module.exports = exports["default"];

},{"../util/CPColorFloat":48,"../util/CPPolyfill":49,"../util/CPRandom":51,"../util/CPRect":52,"../util/CPTransform":53,"./CPBlend":4,"./CPBrushInfo":5,"./CPBrushManager":6,"./CPClip":8,"./CPColorBmp":9,"./CPGreyBmp":10,"./CPLayer":11,"./CPUndo":15}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPBitmap;

var _CPRect = require("../util/CPRect");

var _CPRect2 = _interopRequireDefault(_CPRect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CPBitmap(width, height) {
    // Width and height forced to integers
    this.width = width | 0;
    this.height = height | 0;
} /*
      ChickenPaint
      
      ChickenPaint is a translation of ChibiPaint from Java to JavaScript
      by Nicholas Sherlock / Chicken Smoothie.
      
      ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
      ChickenPaint is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      ChickenPaint is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

CPBitmap.prototype.getBounds = function () {
    return new _CPRect2.default(0, 0, this.width, this.height);
};

CPBitmap.prototype.isInside = function (x, y) {
    return x >= 0 && y >= 0 && x < this.width && y < this.height;
};
module.exports = exports["default"];

},{"../util/CPRect":52}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPBlend;
// This file is generated, please see codegenerator/BlendGenerator.js!

function CPBlend() {}

var BYTES_PER_PIXEL = 4,
    ALPHA_BYTE_OFFSET = 3,
    BLEND_MODE_NAMES = ["normal", "multiply", "add", "screen", "lighten", "darken", "subtract", "dodge", "burn", "overlay", "hardLight", "softLight", "vividLight", "linearLight", "pinLight"],
    softLightLUTSquare = new Array(256),
    softLightLUTSquareRoot = new Array(256);

/**
* Blend the given layer onto the fusion using the multiply blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.multiplyOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = color2 - (layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / (255 * 255) | 0;

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = color2 - (layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / (255 * 255) | 0;

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = color2 - (layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / (255 * 255) | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the multiply blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.multiplyOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = color2 - (layer.data[pixIndex] ^ 0xFF) * color2 * alpha1 / (255 * 255) | 0;

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = color2 - (layer.data[pixIndex + 1] ^ 0xFF) * color2 * alpha1 / (255 * 255) | 0;

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = color2 - (layer.data[pixIndex + 2] ^ 0xFF) * color2 * alpha1 / (255 * 255) | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the multiply blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.multiplyOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + color1 * color2 * alpha12 / 255) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + color1 * color2 * alpha12 / 255) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + color1 * color2 * alpha12 / 255) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the multiply blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.multiplyOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + color1 * color2 * alpha12 / 255) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + color1 * color2 * alpha12 / 255) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + color1 * color2 * alpha12 / 255) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the normal blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.normalOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                if (alpha1 == 255) {

                    fusion.data[pixIndex] = layer.data[pixIndex];

                    fusion.data[pixIndex + 1] = layer.data[pixIndex + 1];

                    fusion.data[pixIndex + 2] = layer.data[pixIndex + 2];
                } else {
                    var invAlpha1 = 255 - alpha1;

                    color1 = layer.data[pixIndex];

                    fusion.data[pixIndex] = (color1 * alpha1 + fusion.data[pixIndex] * invAlpha1) / 255 | 0;

                    color1 = layer.data[pixIndex + 1];

                    fusion.data[pixIndex + 1] = (color1 * alpha1 + fusion.data[pixIndex + 1] * invAlpha1) / 255 | 0;

                    color1 = layer.data[pixIndex + 2];

                    fusion.data[pixIndex + 2] = (color1 * alpha1 + fusion.data[pixIndex + 2] * invAlpha1) / 255 | 0;
                }
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the normal blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.normalOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                if (alpha1 == 255) {

                    fusion.data[pixIndex] = layer.data[pixIndex];

                    fusion.data[pixIndex + 1] = layer.data[pixIndex + 1];

                    fusion.data[pixIndex + 2] = layer.data[pixIndex + 2];
                } else {
                    var invAlpha1 = 255 - alpha1;

                    color1 = layer.data[pixIndex];

                    fusion.data[pixIndex] = (color1 * alpha1 + fusion.data[pixIndex] * invAlpha1) / 255 | 0;

                    color1 = layer.data[pixIndex + 1];

                    fusion.data[pixIndex + 1] = (color1 * alpha1 + fusion.data[pixIndex + 1] * invAlpha1) / 255 | 0;

                    color1 = layer.data[pixIndex + 2];

                    fusion.data[pixIndex + 2] = (color1 * alpha1 + fusion.data[pixIndex + 2] * invAlpha1) / 255 | 0;
                }
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the normal blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.normalOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    realAlpha = alpha1 * 255 / newAlpha | 0,
                    invAlpha = 255 - realAlpha;

                fusion.data[pixIndex] = (layer.data[pixIndex] * realAlpha + fusion.data[pixIndex] * invAlpha) / 255;

                fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * realAlpha + fusion.data[pixIndex + 1] * invAlpha) / 255;

                fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * realAlpha + fusion.data[pixIndex + 2] * invAlpha) / 255;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the normal blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.normalOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    realAlpha = alpha1 * 255 / newAlpha | 0,
                    invAlpha = 255 - realAlpha;

                fusion.data[pixIndex] = (layer.data[pixIndex] * realAlpha + fusion.data[pixIndex] * invAlpha) / 255;

                fusion.data[pixIndex + 1] = (layer.data[pixIndex + 1] * realAlpha + fusion.data[pixIndex + 1] * invAlpha) / 255;

                fusion.data[pixIndex + 2] = (layer.data[pixIndex + 2] * realAlpha + fusion.data[pixIndex + 2] * invAlpha) / 255;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the add blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.addOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 | 0;

                fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 | 0;

                fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the add blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.addOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 | 0;

                fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 | 0;

                fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the add blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.addOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0;

                // No need to clamp the color to 0...255 since we're writing to a clamped array anyway

                fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex]) / newAlpha | 0;

                fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1]) / newAlpha | 0;

                fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2]) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the add blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.addOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0;

                // No need to clamp the color to 0...255 since we're writing to a clamped array anyway

                fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex]) / newAlpha | 0;

                fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1]) / newAlpha | 0;

                fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2]) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the subtract blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.subtractOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 - alpha1 | 0;

                fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 - alpha1 | 0;

                fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 - alpha1 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the subtract blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.subtractOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                fusion.data[pixIndex] = fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] / 255 - alpha1 | 0;

                fusion.data[pixIndex + 1] = fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] / 255 - alpha1 | 0;

                fusion.data[pixIndex + 2] = fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] / 255 - alpha1 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the subtract blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.subtractOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2;

                // No need to clamp the color to 255 since we're writing to a clamped array anyway

                fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] - alpha12) / newAlpha | 0;

                fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] - alpha12) / newAlpha | 0;

                fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] - alpha12) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the subtract blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.subtractOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2;

                // No need to clamp the color to 255 since we're writing to a clamped array anyway

                fusion.data[pixIndex] = (alpha2 * fusion.data[pixIndex] + alpha1 * layer.data[pixIndex] - alpha12) / newAlpha | 0;

                fusion.data[pixIndex + 1] = (alpha2 * fusion.data[pixIndex + 1] + alpha1 * layer.data[pixIndex + 1] - alpha12) / newAlpha | 0;

                fusion.data[pixIndex + 2] = (alpha2 * fusion.data[pixIndex + 2] + alpha1 * layer.data[pixIndex + 2] - alpha12) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the screen blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.screenOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 1] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 2] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the screen blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.screenOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 1] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = 0xFF ^ ((color2 ^ 0xFF) * invAlpha1 + (layer.data[pixIndex + 2] ^ 0xFF) * (color2 ^ 0xFF) * alpha1 / 255) / 255;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the screen blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.screenOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the screen blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.screenOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = 0xFF ^ ((color1 ^ 0xFF) * alpha1n2 + (color2 ^ 0xFF) * alphan12 + (color1 ^ 0xFF) * (color2 ^ 0xFF) * alpha12 / 255) / newAlpha;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the lighten blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.lightenOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the lighten blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.lightenOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = color2 >= color1 ? color2 : (color2 * invAlpha1 + color1 * alpha1) / 255;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the lighten blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.lightenOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,


                // This alpha is used when color1 > color2
                alpha12 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0,
                    invAlpha12 = alpha12 ^ 0xFF | 0,


                // This alpha is used when color2 > color1
                alpha21 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0,
                    invAlpha21 = alpha21 ^ 0xFF | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the lighten blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.lightenOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,


                // This alpha is used when color1 > color2
                alpha12 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0,
                    invAlpha12 = alpha12 ^ 0xFF | 0,


                // This alpha is used when color2 > color1
                alpha21 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0,
                    invAlpha21 = alpha21 ^ 0xFF | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color2 >= color1 ? color1 * alpha21 + color2 * invAlpha21 : color2 * alpha12 + color1 * invAlpha12) / 255 | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the darken blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.darkenOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 : color2;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 : color2;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 : color2;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the darken blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.darkenOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 : color2;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 : color2;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = color2 >= color1 ? (color2 * invAlpha1 + color1 * alpha1) / 255 : color2;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the darken blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.darkenOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,


                // This alpha is used when color1 > color2
                alpha12 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0,
                    invAlpha12 = alpha12 ^ 0xFF | 0,


                // This alpha is used when color2 > color1
                alpha21 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0,
                    invAlpha21 = alpha21 ^ 0xFF | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the darken blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.darkenOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,


                // This alpha is used when color1 > color2
                alpha12 = alpha1 * (alpha2 ^ 0xFF) / newAlpha | 0,
                    invAlpha12 = alpha12 ^ 0xFF | 0,


                // This alpha is used when color2 > color1
                alpha21 = alpha2 * (alpha1 ^ 0xFF) / newAlpha | 0,
                    invAlpha21 = alpha21 ^ 0xFF | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color2 >= color1 ? color2 * alpha21 + color1 * invAlpha21 : color1 * alpha12 + color2 * invAlpha12) / 255 | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the dodge blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.dodgeOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the dodge blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.dodgeOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the dodge blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.dodgeOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the dodge blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.dodgeOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 255 ? 255 : Math.min(255, 255 * color2 / (color1 ^ 0xFF) | 0))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the burn blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.burnOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the burn blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.burnOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color2 * invAlpha1 + alpha1 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the burn blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.burnOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the burn blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.burnOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xFF) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xFF) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (color1 * alpha1n2 + color2 * alphan12 + alpha12 * (color1 == 0 ? 0 : Math.min(255, 255 * (color2 ^ 0xFF) / color1) ^ 0xFF)) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the overlay blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.overlayOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the overlay blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.overlayOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xFF;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color2 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the overlay blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.overlayOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the overlay blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.overlayOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color2 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the hardLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.hardLightOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the hardLight blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.hardLightOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * 2 * color1 * color2 / 255 : alpha1 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the hardLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.hardLightOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the hardLight blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.hardLightOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * 2 * color1 * color2 / 255 : alpha12 * (2 * (color1 ^ 0xff) * (color2 ^ 0xff) / 255 ^ 0xff))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the softLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.softLightOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? (2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2 : (2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2)) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? (2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2 : (2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2)) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? (2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2 : (2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2)) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the softLight blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.softLightOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? (2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2 : (2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2)) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? (2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2 : (2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2)) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color1 <= 127 ? (2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2 : (2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2)) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the softLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.softLightOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2) : alpha12 * ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2) : alpha12 * ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2) : alpha12 * ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the softLight blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.softLightOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2) : alpha12 * ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2) : alpha12 * ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * ((2 * color1 - 255) * softLightLUTSquare[color2] / 255 + color2) : alpha12 * ((2 * color1 - 255) * softLightLUTSquareRoot[color2] / 255 + color2))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the vividLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.vividLightOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the vividLight blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.vividLightOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + (color1 <= 127 ? alpha1 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha1 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the vividLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.vividLightOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the vividLight blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.vividLightOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + (color1 <= 127 ? alpha12 * (color1 == 0 ? 0 : 255 - Math.min(255, (255 - color2) * 255 / (2 * color1))) : alpha12 * (color1 == 255 ? 255 : Math.min(255, color2 * 255 / (2 * (255 - color1)))))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the linearLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.linearLightOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex] - 255))) / 255 | 0;

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 1] - 255))) / 255 | 0;

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 2] - 255))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the linearLight blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.linearLightOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex] - 255))) / 255 | 0;

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 1] - 255))) / 255 | 0;

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * Math.min(255, Math.max(0, color2 + 2 * layer.data[pixIndex + 2] - 255))) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the linearLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.linearLightOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the linearLight blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.linearLightOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * Math.min(255, Math.max(0, color2 + 2 * color1 - 255))) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the pinLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.pinLightOntoOpaqueFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the pinLight blending operator.
* 
* Fusion pixels must be opaque, and the fusion layer's opacity must be set to 100.
*/

CPBlend.pinLightOntoOpaqueFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {

                var invAlpha1 = alpha1 ^ 0xff;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (invAlpha1 * color2 + alpha1 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / 255 | 0;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the pinLight blending operator.
* 
* The layer must have its layer alpha set to 100
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.pinLightOntoTransparentFusionWithOpaqueLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET];

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

/**
* Blend the given layer onto the fusion using the pinLight blending operator.
* 
* Fusion can contain transparent pixels, but the fusion layer's opacity must be set to 100.
*/

CPBlend.pinLightOntoTransparentFusionWithTransparentLayer = function (layer, fusion, rect) {
    var h = rect.getHeight() | 0,
        w = rect.getWidth() | 0,
        yStride = (layer.width - w) * BYTES_PER_PIXEL | 0,
        pixIndex = layer.offsetOfPixel(rect.left, rect.top) | 0;

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += BYTES_PER_PIXEL) {
            var alpha1, alpha2, color1, color2;

            alpha1 = layer.data[pixIndex + ALPHA_BYTE_OFFSET] * layer.alpha / 100 | 0;

            if (alpha1) {
                alpha2 = fusion.data[pixIndex + ALPHA_BYTE_OFFSET];

                var newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0,
                    alpha12 = alpha1 * alpha2 / 255 | 0,
                    alpha1n2 = alpha1 * (alpha2 ^ 0xff) / 255 | 0,
                    alphan12 = (alpha1 ^ 0xff) * alpha2 / 255 | 0;

                color1 = layer.data[pixIndex];

                color2 = fusion.data[pixIndex];

                fusion.data[pixIndex] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;

                color1 = layer.data[pixIndex + 1];

                color2 = fusion.data[pixIndex + 1];

                fusion.data[pixIndex + 1] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;

                color1 = layer.data[pixIndex + 2];

                color2 = fusion.data[pixIndex + 2];

                fusion.data[pixIndex + 2] = (alpha1n2 * color1 + alphan12 * color2 + alpha12 * (color2 >= 2 * color1 ? 2 * color1 : color2 <= 2 * color1 - 255 ? 2 * color1 - 255 : color2)) / newAlpha | 0;

                fusion.data[pixIndex + ALPHA_BYTE_OFFSET] = newAlpha;
            }
        }
    }
};

CPBlend.LM_NORMAL = 0;
CPBlend.LM_MULTIPLY = 1;
CPBlend.LM_ADD = 2;
CPBlend.LM_SCREEN = 3;
CPBlend.LM_LIGHTEN = 4;
CPBlend.LM_DARKEN = 5;
CPBlend.LM_SUBTRACT = 6;
CPBlend.LM_DODGE = 7;
CPBlend.LM_BURN = 8;
CPBlend.LM_OVERLAY = 9;
CPBlend.LM_HARDLIGHT = 10;
CPBlend.LM_SOFTLIGHT = 11;
CPBlend.LM_VIVIDLIGHT = 12;
CPBlend.LM_LINEARLIGHT = 13;
CPBlend.LM_PINLIGHT = 14;

/**
 * Fuse the given layer on top of the given fusion layer, using the blending operation defined in the layer.
 *
 * @param {CPLayer} fusion - Layer to fuse on top of
 * @param {boolean} fusionHasTransparency - True if the fusion layer has alpha < 100, or any transparent pixels.
 * @param {CPLayer} layer - Layer that should be drawn on top of the fusion
 * @param {CPRect} rect - The rectangle of pixels that should be fused.
 */
CPBlend.fuseLayer = function (fusion, fusionHasTransparency, layer, rect) {
    if (layer.alpha <= 0) {
        return;
    }

    var funcName = BLEND_MODE_NAMES[layer.blendMode] + "Onto";

    if (fusion.alpha < 100) {
        throw "Fusion layer alpha < 100 not supported.";
    }

    if (fusionHasTransparency) {
        funcName += "TransparentFusion";
    } else {
        funcName += "OpaqueFusion";
    }

    if (layer.alpha == 100) {
        funcName += "WithOpaqueLayer";
    } else {
        funcName += "WithTransparentLayer";
    }

    fusion.getBounds().clip(rect);

    this[funcName](layer, fusion, rect);
};
function makeLookupTables() {
    // V - V^2 table
    for (var i = 0; i < 256; i++) {
        var v = i / 255;

        softLightLUTSquare[i] = (v - v * v) * 255 | 0;
    }

    // sqrt(V) - V table
    for (var i = 0; i < 256; i++) {
        var v = i / 255;

        softLightLUTSquareRoot[i] = (Math.sqrt(v) - v) * 255 | 0;
    }
}
makeLookupTables();
module.exports = exports["default"];

},{}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPBrushInfo;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPBrushInfo(properties) {
    // Set brush setting fields with default values, then apply the supplied 'properties' on top
    for (var propName in CPBrushInfo.DEFAULTS) {
        if (CPBrushInfo.DEFAULTS.hasOwnProperty(propName)) {
            this[propName] = CPBrushInfo.DEFAULTS[propName];
        }
    }

    for (var propName in properties) {
        if (properties.hasOwnProperty(propName)) {
            this[propName] = properties[propName];
        }
    }
}

// Stroke modes
CPBrushInfo.SM_FREEHAND = 0;
CPBrushInfo.SM_LINE = 1;
CPBrushInfo.SM_BEZIER = 2;

// Brush dab types
CPBrushInfo.B_ROUND_PIXEL = 0;
CPBrushInfo.B_ROUND_AA = 1;
CPBrushInfo.B_ROUND_AIRBRUSH = 2;
CPBrushInfo.B_SQUARE_PIXEL = 3;
CPBrushInfo.B_SQUARE_AA = 4;

// painting modes
CPBrushInfo.M_PAINT = 0;
CPBrushInfo.M_ERASE = 1;
CPBrushInfo.M_DODGE = 2;
CPBrushInfo.M_BURN = 3;
CPBrushInfo.M_WATER = 4;
CPBrushInfo.M_BLUR = 5;
CPBrushInfo.M_SMUDGE = 6;
CPBrushInfo.M_OIL = 7;

CPBrushInfo.DEFAULTS = {
    isAA: false, isAirbrush: false,
    minSpacing: 0, spacing: 0,

    pressureSize: true,
    pressureAlpha: false,
    pressureScattering: false,

    type: 0, paintMode: 0,
    strokeMode: CPBrushInfo.SM_FREEHAND,
    resat: 1.0, bleed: 0.0,

    texture: 1.0,

    // "cur" values are current brush settings (once tablet pressure and stuff is applied)
    size: 0, curSize: 0,
    alpha: 0, curAlpha: 0,
    scattering: 0.0, curScattering: 0,
    squeeze: 0.0, curSqueeze: 0,
    angle: Math.PI, curAngle: 0,

    smoothing: 0.0
};

CPBrushInfo.prototype.applyPressure = function (pressure) {
    // FIXME: no variable size for smudge and oil :(
    if (this.pressureSize && this.paintMode != CPBrushInfo.M_SMUDGE && this.paintMode != CPBrushInfo.M_OIL) {
        this.curSize = Math.max(0.1, this.size * pressure);
    } else {
        this.curSize = Math.max(0.1, this.size);
    }

    // FIXME: what is the point of doing that?
    if (this.curSize > 16) {
        this.curSize = Math.floor(this.curSize);
    }

    this.curAlpha = this.pressureAlpha ? Math.floor(this.alpha * Math.min(pressure, 1.0)) : this.alpha;
    this.curSqueeze = this.squeeze;
    this.curAngle = this.angle;
    this.curScattering = this.scattering * this.curSize * (this.pressureScattering ? pressure : 1.0);
};

CPBrushInfo.prototype.clone = function () {
    return new CPBrushInfo(this);
};
module.exports = exports["default"];

},{}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPBrushManager;

var _CPBrushInfo = require("./CPBrushInfo");

var _CPBrushInfo2 = _interopRequireDefault(_CPBrushInfo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CPBrushManager() {
    var MAX_SQUEEZE = 10,
        BRUSH_MAX_DIM = 201,
        BRUSH_AA_MAX_DIM = 202;

    /*CPBrushDab {
        // the brush
        Uint8Array brush;
        int width, height;
        
        // and where and how to apply it
        int x, y, alpha;
    }*/

    var brush = new Uint8Array(BRUSH_MAX_DIM * BRUSH_MAX_DIM),
        brushAA = new Uint8Array(BRUSH_AA_MAX_DIM * BRUSH_AA_MAX_DIM),
        cacheBrush = null,
        cacheSize,
        cacheSqueeze,
        cacheAngle,
        cacheType,
        that = this;

    /**
     * Shift a brush by a positive sub-pixel amount (dx, dy) [0..1), and return the new brush. 
     * 
     * The resulting brush array is 1 pixel larger than the original one in both dimensions.
     */
    function getBrushWithAA(brushInfo, dx, dy) {
        var nonAABrush = getBrush(brushInfo),
            intSize = Math.ceil(brushInfo.curSize),
            intSizeAA = Math.ceil(brushInfo.curSize) + 1;

        for (var x = 0; x < intSizeAA * intSizeAA; x++) {
            brushAA[x] = 0;
        }

        var invdx_invdy = (1 - dx) * (1 - dy),
            dx_invdy = dx * (1 - dy),
            dx_dy = dx * dy,
            invdx_dy = (1 - dx) * dy,
            srcIndex = 0,
            dstIndex = 0;

        for (var y = 0; y < intSize; y++) {
            for (var x = 0; x < intSize; x++) {
                var brushAlpha = nonAABrush[srcIndex];

                /* 
                 * Use a weighted sum to shift the source pixels's position by a sub-pixel amount dx, dy and accumulate
                 * it into the final brushAA array.
                 */
                brushAA[dstIndex] += ~~(brushAlpha * invdx_invdy);
                brushAA[dstIndex + 1] += ~~(brushAlpha * dx_invdy);
                brushAA[dstIndex + 1 + intSizeAA] += ~~(brushAlpha * dx_dy);
                brushAA[dstIndex + intSizeAA] += ~~(brushAlpha * invdx_dy);

                srcIndex++;
                dstIndex++;
            }
            dstIndex += intSizeAA - intSize;
        }

        return brushAA;
    }

    function buildBrush(brush, brushInfo) {
        var intSize = Math.ceil(brushInfo.curSize),
            center = intSize / 2.0,
            sqrRadius = brushInfo.curSize / 2 * (brushInfo.curSize / 2),
            xFactor = 1.0 + brushInfo.curSqueeze * MAX_SQUEEZE,
            cosA = Math.cos(brushInfo.curAngle),
            sinA = Math.sin(brushInfo.curAngle),
            offset = 0;

        for (var j = 0; j < intSize; j++) {
            for (var i = 0; i < intSize; i++) {
                var x = i + 0.5 - center,
                    y = j + 0.5 - center,
                    dx = (x * cosA - y * sinA) * xFactor,
                    dy = y * cosA + x * sinA,
                    sqrDist = dx * dx + dy * dy;

                if (sqrDist <= sqrRadius) {
                    brush[offset++] = 0xFF;
                } else {
                    brush[offset++] = 0;
                }
            }
        }

        return brush;
    }

    function buildBrushAA(brush, brushInfo) {
        var intSize = Math.ceil(brushInfo.curSize),
            center = intSize / 2.0,
            sqrRadius = brushInfo.curSize / 2 * (brushInfo.curSize / 2),
            sqrRadiusInner = (brushInfo.curSize - 2) / 2 * ((brushInfo.curSize - 2) / 2),
            sqrRadiusOuter = (brushInfo.curSize + 2) / 2 * ((brushInfo.curSize + 2) / 2),
            xFactor = 1.0 + brushInfo.curSqueeze * MAX_SQUEEZE,
            cosA = Math.cos(brushInfo.curAngle),
            sinA = Math.sin(brushInfo.curAngle),
            offset = 0;

        for (var j = 0; j < intSize; j++) {
            for (var i = 0; i < intSize; i++) {
                var x = i + 0.5 - center,
                    y = j + 0.5 - center,
                    dx = (x * cosA - y * sinA) * xFactor,
                    dy = y * cosA + x * sinA,
                    sqrDist = dx * dx + dy * dy;

                if (sqrDist <= sqrRadiusInner) {
                    brush[offset++] = 0xFF;
                } else if (sqrDist > sqrRadiusOuter) {
                    brush[offset++] = 0;
                } else {
                    var count = 0;

                    for (var oy = 0; oy < 4; oy++) {
                        for (var ox = 0; ox < 4; ox++) {
                            x = i + ox * (1.0 / 4.0) - center;
                            y = j + oy * (1.0 / 4.0) - center;
                            dx = (x * cosA - y * sinA) * xFactor;
                            dy = y * cosA + x * sinA;

                            sqrDist = dx * dx + dy * dy;
                            if (sqrDist <= sqrRadius) {
                                count += 1;
                            }
                        }
                    }
                    brush[offset++] = Math.min(count * 16, 255);
                }
            }
        }

        return brush;
    }

    function buildBrushSquare(brush, brushInfo) {
        var intSize = Math.ceil(brushInfo.curSize),
            center = intSize / 2.0,
            size = brushInfo.curSize * Math.sin(Math.PI / 4),
            sizeX = size / 2 / (1.0 + brushInfo.curSqueeze * MAX_SQUEEZE),
            sizeY = size / 2,
            cosA = Math.cos(brushInfo.curAngle),
            sinA = Math.sin(brushInfo.curAngle),
            offset = 0;

        for (var j = 0; j < intSize; j++) {
            for (var i = 0; i < intSize; i++) {
                var x = i + 0.5 - center,
                    y = j + 0.5 - center,
                    dx = Math.abs(x * cosA - y * sinA),
                    dy = Math.abs(y * cosA + x * sinA);

                if (dx <= sizeX && dy <= sizeY) {
                    brush[offset++] = 0xFF;
                } else {
                    brush[offset++] = 0;
                }
            }
        }

        return brush;
    }

    function buildBrushSquareAA(brush, brushInfo) {
        var intSize = Math.ceil(brushInfo.curSize),
            center = intSize / 2.0,
            size = brushInfo.curSize * Math.sin(Math.PI / 4),
            sizeX = size / 2 / (1.0 + brushInfo.curSqueeze * MAX_SQUEEZE),
            sizeY = size / 2,
            sizeXInner = sizeX - 1,
            sizeYInner = sizeY - 1,
            sizeXOuter = sizeX + 1,
            sizeYOuter = sizeY + 1,
            cosA = Math.cos(brushInfo.curAngle),
            sinA = Math.sin(brushInfo.curAngle),
            offset = 0;

        for (var j = 0; j < intSize; j++) {
            for (var i = 0; i < intSize; i++) {
                var x = i + 0.5 - center,
                    y = j + 0.5 - center,
                    dx = Math.abs(x * cosA - y * sinA),
                    dy = Math.abs(y * cosA + x * sinA);

                if (dx <= sizeXInner && dy <= sizeYInner) {
                    brush[offset++] = 0xFF;
                } else if (dx > sizeXOuter || dy > sizeYOuter) {
                    brush[offset++] = 0;
                } else {
                    var count = 0;

                    for (var oy = 0; oy < 4; oy++) {
                        for (var ox = 0; ox < 4; ox++) {
                            x = i + ox * (1.0 / 4.0) - center;
                            y = j + oy * (1.0 / 4.0) - center;
                            dx = Math.abs(x * cosA - y * sinA);
                            dy = Math.abs(y * cosA + x * sinA);

                            if (dx <= sizeX && dy <= sizeY) {
                                count++;
                            }
                        }
                    }
                    brush[offset++] = Math.min(count * 16, 255);
                }
            }
        }

        return brush;
    }

    function buildBrushSoft(brush, brushInfo) {
        var intSize = Math.ceil(brushInfo.curSize),
            center = intSize / 2.0,
            sqrRadius = brushInfo.curSize / 2 * (brushInfo.curSize / 2),
            xFactor = 1.0 + brushInfo.curSqueeze * MAX_SQUEEZE,
            cosA = Math.cos(brushInfo.curAngle),
            sinA = Math.sin(brushInfo.curAngle),
            offset = 0;

        for (var j = 0; j < intSize; j++) {
            for (var i = 0; i < intSize; i++) {
                var x = i + 0.5 - center,
                    y = j + 0.5 - center,
                    dx = (x * cosA - y * sinA) * xFactor,
                    dy = y * cosA + x * sinA,
                    sqrDist = dx * dx + dy * dy;

                if (sqrDist <= sqrRadius) {
                    brush[offset++] = ~~(255 * (1 - sqrDist / sqrRadius));
                } else {
                    brush[offset++] = 0;
                }
            }
        }

        return brush;
    }

    /**
     * Build and return a brush that conforms to the given brush settings.
     * 
     * @returns a Uint8Array
     */
    function getBrush(brushInfo) {
        if (cacheBrush != null && brushInfo.curSize == cacheSize && brushInfo.curSqueeze == cacheSqueeze && brushInfo.curAngle == cacheAngle && brushInfo.type == cacheType) {
            return cacheBrush;
        }

        switch (brushInfo.type) {
            case _CPBrushInfo2.default.B_ROUND_AIRBRUSH:
                brush = buildBrushSoft(brush, brushInfo);
                break;
            case _CPBrushInfo2.default.B_ROUND_AA:
                brush = buildBrushAA(brush, brushInfo);
                break;
            case _CPBrushInfo2.default.B_ROUND_PIXEL:
                brush = buildBrush(brush, brushInfo);
                break;
            case _CPBrushInfo2.default.B_SQUARE_AA:
                brush = buildBrushSquareAA(brush, brushInfo);
                break;
            case _CPBrushInfo2.default.B_SQUARE_PIXEL:
                brush = buildBrushSquare(brush, brushInfo);
                break;
        }

        cacheBrush = brush;
        cacheSize = brushInfo.curSize;
        cacheType = brushInfo.type;
        cacheSqueeze = brushInfo.curSqueeze;
        cacheAngle = brushInfo.curAngle;

        return brush;
    }

    function applyTexture(dab, textureAmount) {
        var amount = Math.floor(textureAmount * 255),
            texture = that.texture,
            textureX = dab.x % texture.width,
            textureY = dab.y % texture.height,
            brushPos = 0,
            texturePos,
            textureEOL;

        if (textureX < 0) {
            textureX += texture.width;
        }

        if (textureY < 0) {
            textureY += texture.height;
        }

        for (var y = 0; y < dab.height; y++) {
            texturePos = textureY * texture.width + textureX;
            textureEOL = textureY * texture.width + texture.width;

            for (var x = 0; x < dab.width; x++) {
                var brushValue = dab.brush[brushPos],
                    textureValue = texture.data[texturePos];

                dab.brush[brushPos] = ~~(brushValue * (textureValue * amount / 255 ^ 0xff) / 255);

                brushPos++;

                texturePos++;
                if (texturePos == textureEOL) {
                    // Wrap to left side of texture
                    texturePos -= texture.width;
                }
            }

            textureY++;
            if (textureY == texture.height) {
                textureY = 0;
            }
        }
    }

    /**
     * @param x float
     * @param y float
     * brushInfo - a CPBrushInfo object
     */
    this.getDab = function (x, y, brushInfo) {
        var dab = {
            alpha: brushInfo.curAlpha,
            width: Math.ceil(brushInfo.curSize),
            height: Math.ceil(brushInfo.curSize)
        };

        // FIXME: I don't like this special case for ROUND_PIXEL
        // it would be better to have brush presets for working with pixels
        var useAA = brushInfo.isAA && brushInfo.type != _CPBrushInfo2.default.B_ROUND_PIXEL;

        if (useAA) {
            dab.width++;
            dab.height++;
        }

        var nx = x - dab.width / 2.0 + 0.5,
            ny = y - dab.height / 2.0 + 0.5;

        // this is necessary as Java uses convert towards zero float to int conversion
        if (nx < 0) {
            nx -= 1;
        }
        if (ny < 0) {
            ny -= 1;
        }

        if (useAA) {
            var dx = Math.abs(nx - ~~nx),
                dy = Math.abs(ny - ~~ny);

            dab.brush = getBrushWithAA(brushInfo, dx, dy);
        } else {
            dab.brush = getBrush(brushInfo);
        }

        dab.x = ~~nx;
        dab.y = ~~ny;

        if (brushInfo.texture > 0.0 && this.texture != null) {
            // we need a brush bitmap that can be modified everytime
            // the one in "brush" can be kept in cache so if we are using it, make a copy
            if (dab.brush == brush) {
                brushAA.set(brush);
                dab.brush = brushAA;
            }
            applyTexture(dab, brushInfo.texture);
        }

        return dab;
    };

    this.setTexture = function (texture) {
        this.texture = texture;
    };
} /*
      ChickenPaint
      
      ChickenPaint is a translation of ChibiPaint from Java to JavaScript
      by Nicholas Sherlock / Chicken Smoothie.
      
      ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
      ChickenPaint is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      ChickenPaint is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

module.exports = exports["default"];

},{"./CPBrushInfo":5}],7:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPChibiFile;

var _CPArtwork = require("./CPArtwork");

var _CPArtwork2 = _interopRequireDefault(_CPArtwork);

var _CPLayer = require("./CPLayer");

var _CPLayer2 = _interopRequireDefault(_CPLayer);

var _CPColorBmp = require("./CPColorBmp");

var _CPColorBmp2 = _interopRequireDefault(_CPColorBmp);

var _ArrayDataStream = require("../util/ArrayDataStream");

var _ArrayDataStream2 = _interopRequireDefault(_ArrayDataStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPChibiFile() {

    function CPChibiHeader(stream, chunk) {
        this.version = stream.readU32BE();
        this.width = stream.readU32BE();
        this.height = stream.readU32BE();
        this.layersNb = stream.readU32BE();
    }

    CPChibiHeader.FIXED_HEADER_LENGTH = 4 * 4;

    function CPChibiChunkHeader(stream) {
        var chunkType = new Array(4);

        for (var i = 0; i < chunkType.length; i++) {
            chunkType[i] = String.fromCharCode(stream.readByte());
        }

        this.chunkType = chunkType.join("");
        this.chunkSize = stream.readU32BE();

        if (stream.eof) {
            throw "Truncated chunk";
        }
    }

    function CPChibiLayerChunkHeader() {
        var payloadOffset, titleLength;

        this.readFixedHeader = function (stream) {
            payloadOffset = stream.readU32BE();

            this.blendMode = stream.readU32BE();
            this.alpha = stream.readU32BE();
            this.visible = (stream.readU32BE() & 1) != 0;

            titleLength = stream.readU32BE();
        };

        /* 
         * After reading the fixed header, use this function to find out how many more bytes of header
         * need to be read.
         */
        this.getVariableHeaderLen = function () {
            return payloadOffset - CPChibiLayerChunkHeader.FIXED_HEADER_LENGTH;
        };

        this.getTotalHeaderLen = function () {
            return CPChibiLayerChunkHeader.FIXED_HEADER_LENGTH + this.getVariableHeaderLen();
        };

        this.readVariableHeader = function (stream) {
            this.name = stream.readString(titleLength);

            // Skip to the pixel data (allows additional header fields to be added that we don't yet support)
            stream.skip(payloadOffset - titleLength - CPChibiLayerChunkHeader.FIXED_HEADER_LENGTH);
        };
    }

    // The size of the initial, fixed-length portion of the header
    CPChibiLayerChunkHeader.FIXED_HEADER_LENGTH = 4 * 5;

    var CHI_MAGIC = "CHIBIOEK",
        CHUNK_TAG_HEAD = "HEAD",
        CHUNK_TAG_LAYER = "LAYR",
        CHUNK_TAG_END = "ZEND",
        BYTES_PER_PIXEL = _CPColorBmp2.default.BYTES_PER_PIXEL,
        ALPHA_BYTE_OFFSET = _CPColorBmp2.default.ALPHA_BYTE_OFFSET,
        RED_BYTE_OFFSET = _CPColorBmp2.default.RED_BYTE_OFFSET,
        GREEN_BYTE_OFFSET = _CPColorBmp2.default.GREEN_BYTE_OFFSET,
        BLUE_BYTE_OFFSET = _CPColorBmp2.default.BLUE_BYTE_OFFSET;

    function serializeEndChunk() {
        var buffer = new Uint8Array(CHUNK_TAG_END.length + 4),
            stream = new _ArrayDataStream2.default(buffer);

        stream.writeString(CHUNK_TAG_END);
        stream.writeU32BE(0);

        return stream.getAsDataArray();
    }

    function serializeHeaderChunk(artwork) {
        var buffer = new Uint8Array(CHUNK_TAG_HEAD.length + 4 * 5),
            stream = new _ArrayDataStream2.default(buffer);

        stream.writeString(CHUNK_TAG_HEAD);
        stream.writeU32BE(16); // ChunkSize

        stream.writeU32BE(0); // Current Version: Major: 0 Minor: 0
        stream.writeU32BE(artwork.width);
        stream.writeU32BE(artwork.height);
        stream.writeU32BE(artwork.getLayerCount());

        return stream.getAsDataArray();
    }

    function serializeLayerChunk(layer) {
        var chunkSize = 20 + layer.name.length + layer.data.length,
            buffer = new Uint8Array(CHUNK_TAG_LAYER.length + 4 + chunkSize),
            stream = new _ArrayDataStream2.default(buffer),
            pos;

        stream.writeString(CHUNK_TAG_LAYER); // Chunk ID
        stream.writeU32BE(chunkSize); // ChunkSize

        stream.writeU32BE(20 + layer.name.length); // Offset to layer data from start of header

        stream.writeU32BE(layer.blendMode);
        stream.writeU32BE(layer.alpha);
        stream.writeU32BE(layer.visible ? 1 : 0); // layer visibility and future flags

        stream.writeU32BE(layer.name.length);
        stream.writeString(layer.name);

        // Convert layer bytes from RGBA to ARGB order to match the Chibi specs
        pos = stream.pos;
        for (var i = 0; i < layer.data.length; i += BYTES_PER_PIXEL) {
            buffer[pos++] = layer.data[i + ALPHA_BYTE_OFFSET];
            buffer[pos++] = layer.data[i + RED_BYTE_OFFSET];
            buffer[pos++] = layer.data[i + GREEN_BYTE_OFFSET];
            buffer[pos++] = layer.data[i + BLUE_BYTE_OFFSET];
        }

        return buffer;
    }

    /**
     * Serialize the given artwork to Chibifile format. Returns a promise which resolves to the serialized Blob.
     */
    this.serialize = function (artwork) {
        return new Promise(function (resolve, reject) {
            var deflator = new window.pako.Deflate({
                level: 7
            }),
                blobParts = [],
                magic = new Uint8Array(CHI_MAGIC.length);

            // The magic file signature is not ZLIB compressed:
            for (var i = 0; i < CHI_MAGIC.length; i++) {
                magic[i] = CHI_MAGIC.charCodeAt(i);
            }
            blobParts.push(magic);

            // The rest gets compressed
            deflator.push(serializeHeaderChunk(artwork), false);

            var layers = artwork.getLayers(),
                i = 0;

            // Insert a settimeout between each serialized layer, so we can maintain browser responsiveness

            function serializeLayer() {
                if (i == layers.length) {
                    deflator.push(serializeEndChunk(artwork), true);

                    blobParts.push(deflator.result);

                    resolve(new Blob(blobParts, { type: "application/octet-stream" }));
                } else {
                    deflator.push(serializeLayerChunk(layers[i++]), false);

                    setTimeout(serializeLayer, 10);
                }
            }

            setTimeout(serializeLayer, 10);
        });
    };

    function hasChibiMagicMarker(array) {
        for (var i = 0; i < CHI_MAGIC.length; i++) {
            if (array[i] != CHI_MAGIC.charCodeAt(i)) {
                return false;
            }
        }

        return true;
    }

    /**
     * Concat two Uint8Arrays to make a new one and return it.
     * 
     * Either one may be set to null. If either one is null, the other is returned. If both are null, null is
     * returned.
     */
    function concatBuffers(one, two) {
        if (one == null || one.length == 0) {
            return two;
        }
        if (two == null || two.length == 0) {
            return one;
        }

        var result = new Uint8Array(one.length + two.length);

        result.set(one, 0);
        result.set(two, one.length);

        return result;
    }

    /**
     * Attempt to load a chibifile from the given arraybuffer.
     *
     * @returns A CPArtwork on success, or null on failure.
     */
    this.read = function (arrayBuffer) {
        var STATE_WAIT_FOR_CHUNK = 0,
            STATE_DECODE_IMAGE_HEADER = 1,
            STATE_DECODE_LAYER_HEADER_FIXED = 2,
            STATE_DECODE_LAYER_HEADER_VARIABLE = 3,
            STATE_DECODE_LAYER = 4,
            STATE_SKIP_TRAILING_CHUNK_BYTES = 5,
            STATE_SUCCESS = 6,
            STATE_FATAL = 10;

        var pako = new window.pako.Inflate({}),
            state = STATE_WAIT_FOR_CHUNK,
            artwork = null,
            layerHeader,
            layer,
            layerBytesRead,
            layerBytesTotal,
            skipCount,
            headerChunk = null,
            header = null,
            chunk = null,
            buffer = null;

        /**
         * Decode A,R,G,B pixels from the given buffer into the R,G,B,A pixel array given by layerPix.
         * 
         * The layerBytesRead and layerBytesTotal variables are used to keep track of the decode process and to 
         * limit the number of bytes read, respectively.
         * 
         * Returns the buffer with the read bytes removed from the front, or null if the buffer was read in its entirety.
         */
        function decodePixels(buffer, layerPix) {
            var subpixel = layerBytesRead % BYTES_PER_PIXEL,
                dstPixelStartOffset = layerBytesRead - subpixel,
                bufferPos = 0,


            // Map from source channel order to CPLayer's dest order
            channelMap = [ALPHA_BYTE_OFFSET, RED_BYTE_OFFSET, GREEN_BYTE_OFFSET, BLUE_BYTE_OFFSET];

            // The first pixel might be a partial one since we might be continuing a pixel split over buffers
            for (; subpixel < BYTES_PER_PIXEL && bufferPos < buffer.length; subpixel++) {
                layerPix[dstPixelStartOffset + channelMap[subpixel]] = buffer[bufferPos];
                layerBytesRead++;
                bufferPos++;
            }

            // How many more pixels are we to read in this buffer?
            var bytesRemain = Math.min(buffer.length - bufferPos, layerBytesTotal - layerBytesRead) | 0,
                fullPixelsRemain = bytesRemain / BYTES_PER_PIXEL | 0,
                subpixelsRemain = bytesRemain % BYTES_PER_PIXEL;

            for (var i = 0; i < fullPixelsRemain; i++) {
                layerPix[layerBytesRead + ALPHA_BYTE_OFFSET] = buffer[bufferPos];
                layerPix[layerBytesRead + RED_BYTE_OFFSET] = buffer[bufferPos + 1];
                layerPix[layerBytesRead + GREEN_BYTE_OFFSET] = buffer[bufferPos + 2];
                layerPix[layerBytesRead + BLUE_BYTE_OFFSET] = buffer[bufferPos + 3];
                layerBytesRead += BYTES_PER_PIXEL;
                bufferPos += BYTES_PER_PIXEL;
            }

            // Read a fractional pixel at the end of the buffer
            dstPixelStartOffset = layerBytesRead;
            for (subpixel = 0; subpixel < subpixelsRemain; subpixel++) {
                layerPix[dstPixelStartOffset + channelMap[subpixel]] = buffer[bufferPos];
                layerBytesRead++;
                bufferPos++;
            }

            if (bufferPos < buffer.length) {
                // Layer was completed before the end of the buffer, there is buffer left over for someone else to use
                return buffer.subarray(bufferPos);
            } else {
                // Buffer exhausted
                return null;
            }
        }

        function processBlock(block) {
            var stream;

            // Add a loop here so we can re-enter the switch with 'continue'
            while (true) {
                switch (state) {
                    case STATE_WAIT_FOR_CHUNK:
                        buffer = concatBuffers(buffer, block);
                        block = null;

                        // Wait for whole chunk header to become available
                        if (!buffer || buffer.length < 8) {
                            break;
                        }

                        // Decode chunk header
                        stream = new _ArrayDataStream2.default(buffer);
                        chunk = new CPChibiChunkHeader(stream);

                        // Remove the chunk header from the start of the buffer
                        buffer = buffer.subarray(stream.pos);

                        if (headerChunk) {
                            if (chunk.chunkType == CHUNK_TAG_END) {
                                state = STATE_SUCCESS;
                                break;
                            } else if (chunk.chunkType == CHUNK_TAG_LAYER) {
                                state = STATE_DECODE_LAYER_HEADER_FIXED;
                            } else {
                                console.log("Unknown chunk type '" + chunk.chunkType + "', attempting to skip...");

                                block = buffer;
                                buffer = null;

                                skipCount = chunk.chunkSize;
                                state = STATE_SKIP_TRAILING_CHUNK_BYTES;
                            }

                            continue;
                        } else if (chunk.chunkType == CHUNK_TAG_HEAD) {
                            headerChunk = chunk;

                            // Try to decode the header
                            state = STATE_DECODE_IMAGE_HEADER;
                            continue;
                        } else {
                            // File didn't start with image header chunk
                            state = STATE_FATAL;
                        }
                        break;
                    case STATE_DECODE_IMAGE_HEADER:
                        buffer = concatBuffers(buffer, block);
                        block = null;

                        // Wait for whole chunk to be available
                        if (!buffer || buffer.length < headerChunk.chunkSize) {
                            break;
                        }

                        stream = new _ArrayDataStream2.default(buffer);
                        header = new CPChibiHeader(stream, headerChunk);

                        if (header.version >>> 16 > 0) {
                            state = STATE_FATAL; // the file version is higher than what we can deal with, bail out
                            break;
                        }

                        artwork = new _CPArtwork2.default(header.width, header.height);

                        block = buffer;
                        buffer = null;

                        skipCount = headerChunk.chunkSize; // Skip the header chunk along with any trailing bytes
                        state = STATE_SKIP_TRAILING_CHUNK_BYTES;
                        continue;
                        break;
                    case STATE_DECODE_LAYER_HEADER_FIXED:
                        buffer = concatBuffers(buffer, block);
                        block = null;

                        // Wait for first part of header to arrive
                        if (!buffer || buffer.length < CPChibiLayerChunkHeader.FIXED_HEADER_LENGTH) {
                            break;
                        }

                        layerHeader = new CPChibiLayerChunkHeader();

                        stream = new _ArrayDataStream2.default(buffer);
                        layerHeader.readFixedHeader(stream);

                        buffer = buffer.subarray(stream.pos);

                        state = STATE_DECODE_LAYER_HEADER_VARIABLE;
                        continue;
                        break;
                    case STATE_DECODE_LAYER_HEADER_VARIABLE:
                        buffer = concatBuffers(buffer, block);
                        block = null;

                        // Wait for variable part of header to arrive
                        if (!buffer || buffer.length < layerHeader.getVariableHeaderLen()) {
                            break;
                        }

                        stream = new _ArrayDataStream2.default(buffer);
                        layerHeader.readVariableHeader(stream);

                        buffer = buffer.subarray(stream.pos);

                        layer = new _CPLayer2.default(header.width, header.height, layerHeader.name);
                        layer.blendMode = layerHeader.blendMode;
                        layer.alpha = layerHeader.alpha;
                        layer.visible = layerHeader.visible;

                        layerBytesRead = 0;
                        layerBytesTotal = header.width * header.height * BYTES_PER_PIXEL;

                        /* 
                         * While decoding layers, we won't keep a persistent buffer around, so if we have any
                         * bytes left over, provide them to the next state as if they were a newly inflated block.
                         */
                        block = buffer;
                        buffer = null;

                        state = STATE_DECODE_LAYER;
                        continue;
                        break;
                    case STATE_DECODE_LAYER:
                        /* 
                         * When decoding layer data, we never concat blocks together, we are capable of decoding
                         * partial pixels that get split over block boundaries. So we don't use 'buffer' to accumulate
                         * data, and only read from incoming 'block's.
                         */
                        if (block != null) {
                            block = decodePixels(block, layer.data);

                            if (layerBytesRead >= layerBytesTotal) {
                                artwork.addLayerObject(layer);

                                // Skip any trailing bytes in the layer chunk
                                skipCount = chunk.chunkSize - layerHeader.getTotalHeaderLen() - layerBytesTotal;
                                state = STATE_SKIP_TRAILING_CHUNK_BYTES;
                                continue;
                            }
                        }
                        break;
                    case STATE_SKIP_TRAILING_CHUNK_BYTES:
                        if (block) {
                            if (skipCount < block.length) {
                                block = block.subarray(skipCount);
                                skipCount = 0;
                            } else {
                                skipCount -= block.length;
                                block = null;
                            }
                        }

                        if (skipCount == 0) {
                            state = STATE_WAIT_FOR_CHUNK;
                            continue;
                        }
                        break;
                }

                break;
            }
        }

        arrayBuffer = new Uint8Array(arrayBuffer);

        if (!hasChibiMagicMarker(arrayBuffer)) {
            return null; // not a ChibiPaint file
        }

        // Remove the magic header
        arrayBuffer = arrayBuffer.subarray(CHI_MAGIC.length);

        pako.onData = processBlock;

        pako.onEnd = function (status) {
            if (status === 0 && state == STATE_SUCCESS) {
                artwork.setActiveLayerIndex(artwork.getTopmostVisibleLayer());

                this.result = artwork;
            } else {
                console.log("Fatal error decoding ChibiFile");

                this.result = null;
            }
        };

        // Begin decompression/decoding
        pako.push(arrayBuffer);

        return pako.result;
    };
}
module.exports = exports["default"];

},{"../util/ArrayDataStream":45,"./CPArtwork":2,"./CPColorBmp":9,"./CPLayer":11}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPClip;
/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPClip(bmp, x, y) {
    this.bmp = bmp;

    this.x = x;
    this.y = y;
};
module.exports = exports["default"];

},{}],9:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPColorBmp;

var _CPBitmap = require("./CPBitmap");

var _CPBitmap2 = _interopRequireDefault(_CPBitmap);

var _CPRect = require("../util/CPRect");

var _CPRect2 = _interopRequireDefault(_CPRect);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function createImageData(width, height) {
    // return new ImageData(this.width, this.height); // Doesn't work on old IE
    var canvas = document.createElement("canvas"),
        context = canvas.getContext("2d");

    return context.createImageData(width, height);
}

//
// A 32bpp bitmap class (one byte per channel in RGBA order)
//

function CPColorBmp(width, height) {
    _CPBitmap2.default.call(this, width, height);

    // The ImageData object that holds the image data
    this.imageData = createImageData(this.width, this.height);

    // The bitmap data array (one byte per channel in RGBA order)
    this.data = this.imageData.data;
}

CPColorBmp.prototype = Object.create(_CPBitmap2.default.prototype);
CPColorBmp.prototype.constructor = CPColorBmp;

CPColorBmp.BYTES_PER_PIXEL = 4;
CPColorBmp.RED_BYTE_OFFSET = 0;
CPColorBmp.GREEN_BYTE_OFFSET = 1;
CPColorBmp.BLUE_BYTE_OFFSET = 2;
CPColorBmp.ALPHA_BYTE_OFFSET = 3;

// Creates a CPBitmap from a portion of this bitmap
CPColorBmp.prototype.cloneRect = function (rect) {
    var result = new CPColorBmp(rect.getWidth(), rect.getHeight());

    result.copyBitmapRect(this, 0, 0, rect);

    return result;
};

//
// Pixel access with friendly clipping. Pixel will be 32-bit integer in ARGB format
//
CPColorBmp.prototype.getPixel = function (x, y) {
    x = Math.max(0, Math.min(this.width - 1, x));
    y = Math.max(0, Math.min(this.height - 1, y));

    var pixIndex = this.offsetOfPixel(x, y);

    return this.data[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET] << 24 | this.data[pixIndex + CPColorBmp.RED_BYTE_OFFSET] << 16 | this.data[pixIndex + CPColorBmp.GREEN_BYTE_OFFSET] << 8 | this.data[pixIndex + CPColorBmp.BLUE_BYTE_OFFSET];
};

/**
 * Get an r,g,b,a array of the xor of this bitmap and the given one, within the given rectangle
 *
 * @returns {Uint8Array}
 */
CPColorBmp.prototype.copyRectXOR = function (bmp, rect) {
    rect = this.getBounds().clip(rect);

    var w = rect.getWidth(),
        h = rect.getHeight(),
        buffer = new Uint8Array(w * h * CPColorBmp.BYTES_PER_PIXEL),
        outputIndex = 0,
        bmp1Index = this.offsetOfPixel(rect.left, rect.top),
        bmp2Index = bmp.offsetOfPixel(rect.left, rect.top),
        bmp1YSkip = (this.width - w) * CPColorBmp.BYTES_PER_PIXEL,
        bmp2YSkip = (bmp.width - w) * CPColorBmp.BYTES_PER_PIXEL,
        widthBytes = w * CPColorBmp.BYTES_PER_PIXEL;

    for (var y = rect.top; y < rect.bottom; y++, bmp1Index += bmp1YSkip, bmp2Index += bmp2YSkip) {
        for (var x = 0; x < widthBytes; x++, outputIndex++, bmp1Index++, bmp2Index++) {
            buffer[outputIndex] = this.data[bmp1Index] ^ bmp.data[bmp2Index];
        }
    }

    return buffer;
};

CPColorBmp.prototype.setRectXOR = function (buffer, rect) {
    rect = this.getBounds().clip(rect);

    var w = rect.getWidth(),
        h = rect.getHeight(),
        bmp1Index = this.offsetOfPixel(rect.left, rect.top),
        bufferIndex = 0,
        bmp1YSkip = (this.width - w) * CPColorBmp.BYTES_PER_PIXEL,
        widthBytes = w * CPColorBmp.BYTES_PER_PIXEL;

    for (var y = 0; y < h; y++) {
        for (var x = 0; x < widthBytes; x++) {
            this.data[bmp1Index++] ^= buffer[bufferIndex++];
        }
        bmp1Index += bmp1YSkip;
    }
};

//
// Copy another bitmap into this one using alpha blending
//
CPColorBmp.prototype.pasteAlphaRect = function (bmp, srcRect, x, y) {
    var srcRectCpy = srcRect.clone(),
        dstRect = new _CPRect2.default(x, y, 0, 0);

    this.getBounds().clipSourceDest(srcRectCpy, dstRect);

    var srcYStride = (bmp.width - dstRect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL,
        dstYStride = (this.width - dstRect.getWidth()) * CPColorBmp.BYTES_PER_PIXEL,
        srcOffset = bmp.offsetOfPixel(srcRectCpy.left, srcRectCpy.top),
        dstOffset = this.offsetOfPixel(dstRect.left, dstRect.top);

    for (var y = dstRect.top; y < dstRect.bottom; y++, srcOffset += srcYStride, dstOffset += dstYStride) {
        for (var x = dstRect.left; x < dstRect.right; x++) {
            var alpha1 = bmp.data[srcOffset + CPColorBmp.ALPHA_BYTE_OFFSET];

            if (alpha1 <= 0) {
                dstOffset += CPColorBmp.BYTES_PER_PIXEL;
                srcOffset += CPColorBmp.BYTES_PER_PIXEL;
                continue;
            }

            if (alpha1 == 255) {
                for (var i = 0; i < CPColorBmp.BYTES_PER_PIXEL; i++) {
                    this.data[dstOffset++] = bmp.data[srcOffset++];
                }
                continue;
            }

            var alpha2 = this.data[dstOffset + CPColorBmp.ALPHA_BYTE_OFFSET],
                newAlpha = alpha1 + alpha2 - alpha1 * alpha2 / 255 | 0;

            if (newAlpha > 0) {
                var realAlpha = alpha1 * 255 / newAlpha | 0,
                    invAlpha = 255 - realAlpha;

                for (var i = 0; i < 3; i++, dstOffset++, srcOffset++) {
                    this.data[dstOffset] = bmp.data[srcOffset] + (this.data[dstOffset] * invAlpha - bmp.data[srcOffset] * invAlpha) / 255 | 0;
                }
                this.data[dstOffset++] = newAlpha;
                srcOffset++;
            } else {
                dstOffset += CPColorBmp.BYTES_PER_PIXEL;
                srcOffset += CPColorBmp.BYTES_PER_PIXEL;
            }
        }
    }
};

/** 
 * Copy the rectangle at srcRect from bmp onto this image at (dstX, dstY).
 */
CPColorBmp.prototype.copyBitmapRect = function (bmp, dstX, dstY, srcRect) {
    var srcRect = srcRect.clone(),
        dstRect = new _CPRect2.default(dstX, dstY, 0, 0);

    this.getBounds().clipSourceDest(srcRect, dstRect);

    var w = dstRect.getWidth() | 0,
        h = dstRect.getHeight() | 0;

    // Are we just trying to duplicate the bitmap?
    if (dstRect.left == 0 && dstRect.top == 0 && w == this.width && h == this.height && w == bmp.width && h == bmp.height) {
        this.copyDataFrom(bmp);
    } else {
        var dstIndex = this.offsetOfPixel(dstRect.left, dstRect.top),
            srcIndex = bmp.offsetOfPixel(srcRect.left, srcRect.top),
            dstYSkip = (this.width - w) * CPColorBmp.BYTES_PER_PIXEL,
            srcYSkip = (bmp.width - w) * CPColorBmp.BYTES_PER_PIXEL;

        for (var y = 0; y < h; y++) {
            for (var x = 0; x < w; x++) {
                this.data[dstIndex] = bmp.data[srcIndex];
                this.data[dstIndex + 1] = bmp.data[srcIndex + 1];
                this.data[dstIndex + 2] = bmp.data[srcIndex + 2];
                this.data[dstIndex + 3] = bmp.data[srcIndex + 3];
                dstIndex += 4;
                srcIndex += 4;
            }
            srcIndex += srcYSkip;
            dstIndex += dstYSkip;
        }
    }
};

//
// Copies the Alpha channel from another bitmap. Assumes both bitmaps are the same width.
//
CPColorBmp.prototype.copyAlphaFrom = function (bmp, rect) {
    rect = this.getBounds().clip(rect);

    var w = rect.getWidth(),
        h = rect.getHeight(),
        pixIndex = this.offsetOfPixel(rect.left, rect.top) + CPColorBmp.ALPHA_BYTE_OFFSET /* Apply offset here so we don't have to do it per-pixel*/
    ,
        ySkip = (this.width - w) * CPColorBmp.BYTES_PER_PIXEL;

    for (var y = 0; y < h; y++) {
        for (var x = 0; x < w; x++) {
            this.data[pixIndex] = bmp.data[pixIndex];
            pixIndex += CPColorBmp.BYTES_PER_PIXEL;
        }
        pixIndex += ySkip;
    }
};

CPColorBmp.prototype.copyDataFrom = function (bmp) {
    if (bmp.width != this.width || bmp.height != this.height) {
        this.width = bmp.width;
        this.height = bmp.height;

        this.imageData = createImageData(this.width, this.height);
        this.data = this.imageData.data;
    }

    if ("set" in this.data) {
        this.data.set(bmp.data);
    } else {
        // IE doesn't use Uint8ClampedArray for ImageData, so set() isn't available
        for (var i = 0; i < this.data.length; i++) {
            this.data[i] = bmp.data[i];
        }
    }
};

/**
 * Flood fill the given color starting from the given point
 * @param x int
 * @param y int
 * @param color int
 */
CPColorBmp.prototype.floodFill = function (x, y, color) {
    if (!this.isInside(x, y)) {
        return;
    }

    var oldColor = this.getPixel(x, y),
        oldAlpha = oldColor >> 24 & 0xFF,
        oldRed = oldColor >> 16 & 0xFF,
        oldGreen = oldColor >> 8 & 0xFF,
        oldBlue = oldColor & 0xFF,
        colorAlpha = color >> 24 & 0xFF,
        colorRed = color >> 16 & 0xFF,
        colorGreen = color >> 8 & 0xFF,
        colorBlue = color & 0xFF,
        stack = [],
        clip = this.getBounds(),
        data = this.data;

    // Change the left and right bounds from pixel indexes into byte indexes for easy clipping
    clip.left *= CPColorBmp.BYTES_PER_PIXEL;
    clip.right *= CPColorBmp.BYTES_PER_PIXEL;

    stack.push({ x1: x * CPColorBmp.BYTES_PER_PIXEL, x2: x * CPColorBmp.BYTES_PER_PIXEL, y: y, dy: -1 });
    stack.push({ x1: x * CPColorBmp.BYTES_PER_PIXEL, x2: x * CPColorBmp.BYTES_PER_PIXEL, y: y + 1, dy: 1 });

    /* 
     * If we are filling 100% transparent areas then we need to ignore the residual color information
     * (it would also be possible to clear it when erasing, but then the performance impact would be on the eraser 
     * rather than on this low importance flood fill)
     */
    if (oldAlpha == 0) {
        if (colorAlpha == 0) {
            return;
        }

        while (stack.length > 0) {
            var line = stack.pop();

            if (line.y < clip.top || line.y >= clip.bottom) {
                continue;
            }

            var lineOffset = this.offsetOfPixel(0, line.y),
                left = line.x1,
                next;

            while (left >= clip.left && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == 0) {
                data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;

                left -= CPColorBmp.BYTES_PER_PIXEL;
            }

            if (left >= line.x1) {
                while (left <= line.x2 && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] != oldAlpha) {
                    left += CPColorBmp.BYTES_PER_PIXEL;
                }
                next = left + CPColorBmp.BYTES_PER_PIXEL;
                if (left > line.x2) {
                    continue;
                }
            } else {
                left += CPColorBmp.BYTES_PER_PIXEL;
                if (left < line.x1) {
                    stack.push({ x1: left, x2: line.x1 - CPColorBmp.BYTES_PER_PIXEL, y: line.y - line.dy, dy: -line.dy });
                }
                next = line.x1 + CPColorBmp.BYTES_PER_PIXEL;
            }

            do {
                data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;

                while (next < clip.right && data[next + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha) {
                    data[next + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                    data[next + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                    data[next + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                    data[next + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;

                    next += CPColorBmp.BYTES_PER_PIXEL;
                }
                stack.push({ x1: left, x2: next - CPColorBmp.BYTES_PER_PIXEL, y: line.y + line.dy, dy: line.dy });

                if (next - CPColorBmp.BYTES_PER_PIXEL > line.x2) {
                    stack.push({ x1: line.x2 + CPColorBmp.BYTES_PER_PIXEL, x2: next - CPColorBmp.BYTES_PER_PIXEL, y: line.y - line.dy, dy: -line.dy });
                }

                left = next + CPColorBmp.BYTES_PER_PIXEL;
                while (left <= line.x2 && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] != oldAlpha) {
                    left += CPColorBmp.BYTES_PER_PIXEL;
                }

                next = left + CPColorBmp.BYTES_PER_PIXEL;
            } while (left <= line.x2);
        }
    } else {
        if (color == oldColor) {
            return;
        }

        while (stack.length > 0) {
            var line = stack.pop();

            if (line.y < clip.top || line.y >= clip.bottom) {
                continue;
            }

            var lineOffset = this.offsetOfPixel(0, line.y),
                left = line.x1,
                next;

            while (left >= clip.left && data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] == oldRed && data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] == oldGreen && data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] == oldBlue && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha) {
                data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;

                left -= CPColorBmp.BYTES_PER_PIXEL;
            }

            if (left >= line.x1) {
                while (left <= line.x2 && !(data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] == oldRed && data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] == oldGreen && data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] == oldBlue && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha)) {
                    left += CPColorBmp.BYTES_PER_PIXEL;
                }
                next = left + CPColorBmp.BYTES_PER_PIXEL;
                if (left > line.x2) {
                    continue;
                }
            } else {
                left += CPColorBmp.BYTES_PER_PIXEL;
                if (left < line.x1) {
                    stack.push({ x1: left, x2: line.x1 - CPColorBmp.BYTES_PER_PIXEL, y: line.y - line.dy, dy: -line.dy });
                }
                next = line.x1 + CPColorBmp.BYTES_PER_PIXEL;
            }

            do {
                data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;

                while (next < clip.right && data[next + lineOffset + CPColorBmp.RED_BYTE_OFFSET] == oldRed && data[next + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] == oldGreen && data[next + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] == oldBlue && data[next + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha) {
                    data[next + lineOffset + CPColorBmp.RED_BYTE_OFFSET] = colorRed;
                    data[next + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] = colorGreen;
                    data[next + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] = colorBlue;
                    data[next + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] = colorAlpha;

                    next += CPColorBmp.BYTES_PER_PIXEL;
                }
                stack.push({ x1: left, x2: next - CPColorBmp.BYTES_PER_PIXEL, y: line.y + line.dy, dy: line.dy });

                if (next - CPColorBmp.BYTES_PER_PIXEL > line.x2) {
                    stack.push({ x1: line.x2 + CPColorBmp.BYTES_PER_PIXEL, x2: next - CPColorBmp.BYTES_PER_PIXEL, y: line.y - line.dy, dy: -line.dy });
                }

                left = next + CPColorBmp.BYTES_PER_PIXEL;
                while (left <= line.x2 && !(data[left + lineOffset + CPColorBmp.RED_BYTE_OFFSET] == oldRed && data[left + lineOffset + CPColorBmp.GREEN_BYTE_OFFSET] == oldGreen && data[left + lineOffset + CPColorBmp.BLUE_BYTE_OFFSET] == oldBlue && data[left + lineOffset + CPColorBmp.ALPHA_BYTE_OFFSET] == oldAlpha)) {
                    left += CPColorBmp.BYTES_PER_PIXEL;
                }

                next = left + CPColorBmp.BYTES_PER_PIXEL;
            } while (left <= line.x2);
        }
    }
};

/**
 * Premultiply the RGB channels in the given R,G,B,A channel buffer with the alpha channel.
 * 
 * @param buffer R,G,B,A channel array
 * @param len Number of pixels in buffer to modify
 */
function multiplyAlpha(buffer, len) {
    var pixIndex = 0;

    for (var i = 0; i < len; i++) {
        var alpha = buffer[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET];

        // Multiply the RGB channels by alpha
        for (var j = 0; j < 3; j++, pixIndex++) {
            buffer[pixIndex] = Math.round(buffer[pixIndex] * alpha / 255);
        }
        pixIndex++; // Don't modify alpha channel
    }
}

/**
 * Inverse of multiplyAlpha()
 */
function separateAlpha(buffer, len) {
    var pixIndex = 0;

    for (var i = 0; i < len; i++) {
        var alpha = buffer[pixIndex + CPColorBmp.ALPHA_BYTE_OFFSET];

        if (alpha != 0) {
            var invAlpha = 255 / alpha;

            for (var j = 0; j < 3; j++, pixIndex++) {
                buffer[pixIndex] = Math.min(Math.round(buffer[pixIndex] * invAlpha), 255);
            }
            // Don't modify alpha channel
            pixIndex++;
        } else {
            pixIndex += CPColorBmp.BYTES_PER_PIXEL;
        }
    }
}

function boxBlurLine(src, dst, len, radius) {
    var totalPixels = 0,
        totalChannels = [0, 0, 0, 0],
        pixIndex,
        dstIndex;

    pixIndex = 0;
    for (var i = 0; i < radius && i < len; i++) {
        for (var j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++) {
            totalChannels[j] += src[pixIndex++];
        }
        totalPixels++;
    }

    dstIndex = 0;
    for (var i = 0; i < len; i++) {
        // New pixel joins the window at the right
        if (i + radius < len) {
            pixIndex = (i + radius) * CPColorBmp.BYTES_PER_PIXEL;

            for (var j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++) {
                totalChannels[j] += src[pixIndex++];
            }
            totalPixels++;
        }

        for (var j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++) {
            dst[dstIndex++] = Math.round(totalChannels[j] / totalPixels);
        }

        // Old pixel leaves the window at the left
        if (i - radius >= 0) {
            pixIndex = (i - radius) * CPColorBmp.BYTES_PER_PIXEL;

            for (var j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++) {
                totalChannels[j] -= src[pixIndex++];
            }
            totalPixels--;
        }
    }
}

/**
 * Copy a column of pixels in the bitmap to the given R,G,B,A buffer.
 * 
 * @param x X-coordinate of column
 * @param y Y-coordinate of top of column to copy
 * @param len Number of pixels to copy
 * @param buffer R,G,B,A array
 */
CPColorBmp.prototype.copyPixelColumnToArray = function (x, y, len, buffer) {
    var yJump = (this.width - 1) * CPColorBmp.BYTES_PER_PIXEL,
        dstOffset = 0,
        srcOffset = this.offsetOfPixel(x, y);

    for (var i = 0; i < len; i++) {
        for (var j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++) {
            buffer[dstOffset++] = this.data[srcOffset++];
        }

        srcOffset += yJump;
    }
};

/**
 * Copy the pixels from the given R,G,B,A buffer to a column of pixels in the bitmap.
 * 
 * @param x X-coordinate of column
 * @param y Y-coordinate of top of column to copy
 * @param len Number of pixels to copy
 * @param buffer R,G,B,A array to copy from
 */
CPColorBmp.prototype.copyArrayToPixelColumn = function (x, y, len, buffer) {
    var yJump = (this.width - 1) * CPColorBmp.BYTES_PER_PIXEL,
        srcOffset = 0,
        dstOffset = this.offsetOfPixel(x, y);

    for (var i = 0; i < len; i++) {
        for (var j = 0; j < CPColorBmp.BYTES_PER_PIXEL; j++) {
            this.data[dstOffset++] = buffer[srcOffset++];
        }

        dstOffset += yJump;
    }
};

CPColorBmp.prototype.boxBlur = function (rect, radiusX, radiusY) {
    rect = this.getBounds().clip(rect);

    var rectWidth = rect.getWidth(),
        rectWidthBytes = rectWidth * CPColorBmp.BYTES_PER_PIXEL,
        rectHeight = rect.getHeight(),
        rectLength = Math.max(rectWidth, rectHeight),
        src = new Uint8Array(rectLength * CPColorBmp.BYTES_PER_PIXEL),
        dst = new Uint8Array(rectLength * CPColorBmp.BYTES_PER_PIXEL);

    for (var y = rect.top; y < rect.bottom; y++) {
        var pixOffset = this.offsetOfPixel(rect.left, y);

        for (var x = 0; x < rectWidthBytes; x++) {
            src[x] = this.data[pixOffset++];
        }

        multiplyAlpha(src, rectWidth);
        boxBlurLine(src, dst, rectWidth, radiusX);

        pixOffset = this.offsetOfPixel(rect.left, y);

        for (var x = 0; x < rectWidthBytes; x++) {
            this.data[pixOffset++] = dst[x];
        }
    }

    for (var x = rect.left; x < rect.right; x++) {
        this.copyPixelColumnToArray(x, rect.top, rectHeight, src);

        boxBlurLine(src, dst, rectHeight, radiusY);
        separateAlpha(dst, rectHeight);

        this.copyArrayToPixelColumn(x, rect.top, rectHeight, dst);
    }
};

CPColorBmp.prototype.offsetOfPixel = function (x, y) {
    return (y * this.width + x) * CPColorBmp.BYTES_PER_PIXEL | 0;
};

CPColorBmp.prototype.getMemorySize = function () {
    return this.data.length;
};

// Load from a loaded HTML Image object
CPColorBmp.prototype.loadFromImage = function (image) {
    var imageCanvas = document.createElement("canvas"),
        imageContext = imageCanvas.getContext("2d");

    imageCanvas.width = image.width;
    imageCanvas.height = image.height;

    imageContext.globalCompositeOperation = "copy";
    imageContext.drawImage(image, 0, 0);

    this.imageData = imageContext.getImageData(0, 0, this.width, this.height);
    this.data = this.imageData.data;
};

CPColorBmp.prototype.getImageData = function () {
    return this.imageData;
};

/**
 * Replace the image data with the provided ImageData object (i.e. use it by reference).
 *
 * @param imageData {ImageData}
 */
CPColorBmp.prototype.setImageData = function (imageData) {
    this.width = imageData.width;
    this.height = imageData.height;
    this.imageData = imageData;
    this.data = imageData.data;
};
module.exports = exports["default"];

},{"../util/CPRect":52,"./CPBitmap":3}],10:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPGreyBmp;

var _CPBitmap = require("./CPBitmap");

var _CPBitmap2 = _interopRequireDefault(_CPBitmap);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CPGreyBmp(width, height, bitDepth) {

    _CPBitmap2.default.call(this, width, height);

    this.bitDepth = bitDepth;

    switch (bitDepth) {
        case 32:
            this.data = new Uint32Array(width * height);
            break;
        case 16:
            this.data = new Uint16Array(width * height);
            break;
        case 8:
        default:
            this.data = new Uint8Array(width * height);
    }

    this.clone = function () {
        var result = new CPGreyBmp(this.width, this.height, this.bitDepth);

        result.data.set(this.data);

        return result;
    };

    this.clearAll = function (value) {
        for (var i = 0; i < this.data.length; i++) {
            this.data[i] = value;
        }
    };

    this.clearRect = function (rect, value) {
        var rect = this.getBounds().clip(rect),
            yStride = this.width - rect.getWidth(),
            pixIndex = this.offsetOfPixel(rect.left, rect.top);

        for (var y = rect.top; y < rect.bottom; y++, pixIndex += yStride) {
            for (var x = rect.left; x < rect.right; x++, pixIndex++) {
                this.data[pixIndex] = value;
            }
        }
    };

    this.mirrorHorizontally = function () {
        var newData = new Uint8Array(width * height);

        for (var y = 0; y < height; y++) {
            for (var x = 0; x < width; x++) {
                newData[y * width + x] = this.data[y * width + width - x - 1];
            }
        }

        this.data = newData;
    };

    this.applyLUT = function (lut) {
        for (var i = 0; i < this.data.length; i++) {
            this.data[i] = lut.table[this.data[i]];
        }
    };

    this.toCanvas = function () {
        var imageData = this.toImageData(),
            canvas = document.createElement("canvas"),
            context = canvas.getContext("2d");

        canvas.width = this.width;
        canvas.height = this.height;

        context.putImageData(imageData, 0, 0);

        return canvas;
    };

    this.toImageData = function () {
        var canvas = document.createElement("canvas"),
            context = canvas.getContext("2d"),
            imageData = context.createImageData(this.width, this.height),
            srcIndex = 0,
            dstIndex = 0;

        for (var y = 0; y < this.height; y++) {
            for (var x = 0; x < this.width; x++) {
                imageData.data[dstIndex++] = this.data[srcIndex];
                imageData.data[dstIndex++] = this.data[srcIndex];
                imageData.data[dstIndex++] = this.data[srcIndex];
                imageData.data[dstIndex++] = 0xFF;
                srcIndex++;
            }
        }

        return imageData;
    };
} /*
      ChickenPaint
      
      ChickenPaint is a translation of ChibiPaint from Java to JavaScript
      by Nicholas Sherlock / Chicken Smoothie.
      
      ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
      ChickenPaint is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      ChickenPaint is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

CPGreyBmp.prototype.offsetOfPixel = function (x, y) {
    return y * this.width + x;
};
module.exports = exports["default"];

},{"./CPBitmap":3}],11:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPLayer;

var _CPColorBmp = require('./CPColorBmp');

var _CPColorBmp2 = _interopRequireDefault(_CPColorBmp);

var _CPBlend = require('./CPBlend');

var _CPBlend2 = _interopRequireDefault(_CPBlend);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Note layer is not cleared to any specific values upon initial creation, use clearAll().
 */
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPLayer(width, height, name) {
    // Super-constructor
    _CPColorBmp2.default.call(this, width, height);

    this.name = name || "";

    this.alpha = 100;
    this.visible = true;
    this.blendMode = _CPBlend2.default.LM_NORMAL;
}

CPLayer.prototype = Object.create(_CPColorBmp2.default.prototype);
CPLayer.prototype.constructor = CPLayer;

var BYTES_PER_PIXEL = 4,
    ALPHA_BYTE_OFFSET = 3;

CPLayer.prototype.clearAll = function (color) {
    var a = color >> 24 & 0xFF,
        r = color >> 16 & 0xFF,
        g = color >> 8 & 0xFF,
        b = color & 0xFF;

    for (var i = 0; i < this.width * this.height * BYTES_PER_PIXEL;) {
        this.data[i++] = r;
        this.data[i++] = g;
        this.data[i++] = b;
        this.data[i++] = a;
    }
};

CPLayer.prototype.clearRect = function (rect, color) {
    var a = color >> 24 & 0xFF,
        r = color >> 16 & 0xFF,
        g = color >> 8 & 0xFF,
        b = color & 0xFF;

    var rect = this.getBounds().clip(rect),
        yStride = (this.width - rect.getWidth()) * BYTES_PER_PIXEL,
        pixIndex = this.offsetOfPixel(rect.left, rect.top);

    for (var y = rect.top; y < rect.bottom; y++, pixIndex += yStride) {
        for (var x = rect.left; x < rect.right; x++) {
            this.data[pixIndex++] = r;
            this.data[pixIndex++] = g;
            this.data[pixIndex++] = b;
            this.data[pixIndex++] = a;
        }
    }
};

/**
 * @param rect CPRect
 * @param source CPLayer
 */
CPLayer.prototype.copyRegionHFlip = function (rect, source) {
    rect = this.getBounds().clip(rect);

    for (var y = rect.top; y < rect.bottom; y++) {
        var dstOffset = this.offsetOfPixel(rect.left, y),
            srcOffset = source.offsetOfPixel(rect.right - 1, y);

        for (var x = rect.left; x < rect.right; x++, srcOffset -= _CPColorBmp2.default.BYTES_PER_PIXEL * 2) {
            for (var i = 0; i < _CPColorBmp2.default.BYTES_PER_PIXEL; i++) {
                this.data[dstOffset++] = source.data[srcOffset++];
            }
        }
    }
};

/**
 * @param rect CPRect
 * @param source CPLayer
 */
CPLayer.prototype.copyRegionVFlip = function (rect, source) {
    rect = this.getBounds().clip(rect);

    var widthBytes = rect.getWidth() * _CPColorBmp2.default.BYTES_PER_PIXEL;

    for (var y = rect.top; y < rect.bottom; y++) {
        var dstOffset = this.offsetOfPixel(rect.left, y),
            srcOffset = source.offsetOfPixel(rect.left, rect.bottom - 1 - (y - rect.top));

        for (var x = 0; x < widthBytes; x++) {
            this.data[dstOffset++] = source.data[srcOffset++];
        }
    }
};

/**
 * @param r CPRect
 */
CPLayer.prototype.fillWithNoise = function (rect) {
    rect = this.getBounds().clip(rect);

    var value,
        yStride = (this.width - rect.getWidth()) * _CPColorBmp2.default.BYTES_PER_PIXEL,
        pixIndex = this.offsetOfPixel(rect.left, rect.top);

    for (var y = rect.top; y < rect.bottom; y++, pixIndex += yStride) {
        for (var x = rect.left; x < rect.right; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            value = Math.random() * 0x100 | 0;

            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = value;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = value;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = value;
            this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = 0xFF;
        }
    }
};

/**
 * Replace the pixels in the given rect with the given horizontal gradient.
 *
 * @param rect CPRect
 * @param fromX int
 * @param toX int
 * @param gradientPoints int[]
 */
CPLayer.prototype.gradientHorzReplace = function (rect, fromX, toX, gradientPoints) {
    var fromColor = {
        r: gradientPoints[0] >> 16 & 0xFF,
        g: gradientPoints[0] >> 8 & 0xFF,
        b: gradientPoints[0] & 0xFF,
        a: gradientPoints[0] >> 24 & 0xFF
    },
        toColor = {
        r: gradientPoints[1] >> 16 & 0xFF,
        g: gradientPoints[1] >> 8 & 0xFF,
        b: gradientPoints[1] & 0xFF,
        a: gradientPoints[1] >> 24 & 0xFF
    },
        yStride = (this.width - rect.getWidth()) * _CPColorBmp2.default.BYTES_PER_PIXEL,
        pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0,
        h = rect.bottom - rect.top | 0;

    if (toX < fromX) {
        var temp = toX;
        toX = fromX;
        fromX = temp;

        temp = fromColor;
        fromColor = toColor;
        toColor = temp;
    }

    var gradientRange = toX - fromX | 0,
        rStep = (toColor.r - fromColor.r) / gradientRange,
        gStep = (toColor.g - fromColor.g) / gradientRange,
        bStep = (toColor.b - fromColor.b) / gradientRange,
        aStep = (toColor.a - fromColor.a) / gradientRange,
        jump = Math.max(rect.left - fromX, 0);

    for (var y = 0; y < h; y++, pixIndex += yStride) {
        // The solid color section before the gradient
        var x = rect.left;

        for (var xEnd = Math.min(fromX, rect.right) | 0; x < xEnd; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = fromColor.r;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = fromColor.g;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = fromColor.b;
            this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = fromColor.a;
        }

        // In the gradient
        var r = fromColor.r + rStep * jump,
            g = fromColor.g + gStep * jump,
            b = fromColor.b + bStep * jump,
            a = fromColor.a + aStep * jump;

        for (xEnd = Math.min(toX, rect.right) | 0; x < xEnd; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = r;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = g;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = b;
            this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = a;

            r += rStep;
            g += gStep;
            b += bStep;
            a += aStep;
        }

        // The section after the end of the gradient
        for (; x < rect.right; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = toColor.r;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = toColor.g;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = toColor.b;
            this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = toColor.a;
        }
    }
};

/**
 * Replace the pixels in the given rect with the given vertical gradient.
 *
 * @param {CPRect} rect
 * @param fromY int
 * @param toY int
 * @param gradientPoints int[]
 */
CPLayer.prototype.gradientVertReplace = function (rect, fromY, toY, gradientPoints) {
    var fromColor = {
        r: gradientPoints[0] >> 16 & 0xFF,
        g: gradientPoints[0] >> 8 & 0xFF,
        b: gradientPoints[0] & 0xFF,
        a: gradientPoints[0] >> 24 & 0xFF
    },
        toColor = {
        r: gradientPoints[1] >> 16 & 0xFF,
        g: gradientPoints[1] >> 8 & 0xFF,
        b: gradientPoints[1] & 0xFF,
        a: gradientPoints[1] >> 24 & 0xFF
    },
        yStride = (this.width - rect.getWidth()) * _CPColorBmp2.default.BYTES_PER_PIXEL,
        pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0,
        w = rect.right - rect.left | 0;

    if (toY < fromY) {
        var temp = toY;
        toY = fromY;
        fromY = temp;

        temp = fromColor;
        fromColor = toColor;
        toColor = temp;
    }

    var y = rect.top;

    // The solid color section before the start of the gradient
    for (var yEnd = Math.min(rect.bottom, fromY) | 0; y < yEnd; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = fromColor.r;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = fromColor.g;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = fromColor.b;
            this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = fromColor.a;
        }
    }

    // Inside the gradient
    var gradientRange = toY - fromY | 0,
        rStep = (toColor.r - fromColor.r) / gradientRange,
        gStep = (toColor.g - fromColor.g) / gradientRange,
        bStep = (toColor.b - fromColor.b) / gradientRange,
        aStep = (toColor.a - fromColor.a) / gradientRange,
        jump = Math.max(y - fromY, 0),
        r = fromColor.r + rStep * jump,
        g = fromColor.g + gStep * jump,
        b = fromColor.b + bStep * jump,
        a = fromColor.a + aStep * jump;

    for (var yEnd = Math.min(rect.bottom, toY) | 0; y < yEnd; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = r;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = g;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = b;
            this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = a;
        }

        r += rStep;
        g += gStep;
        b += bStep;
        a += aStep;
    }

    // The section after the end of the gradient
    for (; y < rect.bottom; y++, pixIndex += yStride) {
        for (var x = 0; x < w; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = toColor.r;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = toColor.g;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = toColor.b;
            this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = toColor.a;
        }
    }
};

/**
 * Replace the pixels in the given rect with the given gradient.
 *
 * @param rect CPRect
 * @param fromX int
 * @param fromY int
 * @param toX int
 * @param toY int
 * @param gradientPoints int[]
 */
CPLayer.prototype.gradientReplace = function (rect, fromX, fromY, toX, toY, gradientPoints) {
    var yStride = (this.width - rect.getWidth()) * _CPColorBmp2.default.BYTES_PER_PIXEL,
        pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0,
        w = rect.right - rect.left | 0,
        fromColor = {
        r: gradientPoints[0] >> 16 & 0xFF,
        g: gradientPoints[0] >> 8 & 0xFF,
        b: gradientPoints[0] & 0xFF,
        a: gradientPoints[0] >> 24 & 0xFF
    },
        toColor = {
        r: gradientPoints[1] >> 16 & 0xFF,
        g: gradientPoints[1] >> 8 & 0xFF,
        b: gradientPoints[1] & 0xFF,
        a: gradientPoints[1] >> 24 & 0xFF
    },


    // How many pixels vertically does the gradient sequence complete over (+infinity for horizontal gradients!)
    vertRange = toY - fromY + (toX - fromX) * (toX - fromX) / (toY - fromY),

    // Same for horizontal
    horzRange = toX - fromX + (toY - fromY) * (toY - fromY) / (toX - fromX),
        horzStep = 1 / horzRange;

    for (var y = rect.top; y < rect.bottom; y++, pixIndex += yStride) {
        var
        // The position the row starts at in the gradient [0.0 ... 1.0)
        prop = (rect.left - fromX) / horzRange + (y - fromY) / vertRange;

        for (var x = 0; x < w; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            var propClamped = Math.min(Math.max(prop, 0.0), 1.0),
                invPropClamped = 1 - propClamped;

            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = fromColor.r * invPropClamped + toColor.r * propClamped;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = fromColor.g * invPropClamped + toColor.g * propClamped;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = fromColor.b * invPropClamped + toColor.b * propClamped;
            this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = fromColor.a * invPropClamped + toColor.a * propClamped;

            prop += horzStep;
        }
    }
};

/**
 * Alpha blend the given gradient onto the pixels in the given rect.
 *
 * @param rect CPRect
 * @param fromX int
 * @param fromY int
 * @param toX int
 * @param toY int
 * @param gradientPoints int[]
 */
CPLayer.prototype.gradientAlpha = function (rect, fromX, fromY, toX, toY, gradientPoints) {
    var yStride = (this.width - rect.getWidth()) * _CPColorBmp2.default.BYTES_PER_PIXEL,
        pixIndex = this.offsetOfPixel(rect.left, rect.top) | 0,
        w = rect.right - rect.left | 0,
        fromColor = {
        r: gradientPoints[0] >> 16 & 0xFF,
        g: gradientPoints[0] >> 8 & 0xFF,
        b: gradientPoints[0] & 0xFF,
        a: gradientPoints[0] >> 24 & 0xFF
    },
        toColor = {
        r: gradientPoints[1] >> 16 & 0xFF,
        g: gradientPoints[1] >> 8 & 0xFF,
        b: gradientPoints[1] & 0xFF,
        a: gradientPoints[1] >> 24 & 0xFF
    },


    // How many pixels vertically does the gradient sequence complete over (+infinity for horizontal gradients!)
    vertRange = toY - fromY + (toX - fromX) * (toX - fromX) / (toY - fromY),

    // Same for horizontal
    horzRange = toX - fromX + (toY - fromY) * (toY - fromY) / (toX - fromX),
        horzStep = 1 / horzRange;

    for (var y = rect.top; y < rect.bottom; y++, pixIndex += yStride) {
        var
        // The position the row starts at in the gradient [0.0 ... 1.0)
        prop = (rect.left - fromX) / horzRange + (y - fromY) / vertRange;

        for (var x = 0; x < w; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            var propClamped = Math.min(Math.max(prop, 0.0), 1.0),
                invPropClamped = 1 - propClamped,


            // The gradient color to draw
            r = fromColor.r * invPropClamped + toColor.r * propClamped,
                g = fromColor.g * invPropClamped + toColor.g * propClamped,
                b = fromColor.b * invPropClamped + toColor.b * propClamped,
                a = fromColor.a * invPropClamped + toColor.a * propClamped,
                alpha2 = this.data[pixIndex + ALPHA_BYTE_OFFSET],
                newAlpha = a + alpha2 - a * alpha2 / 255 | 0;

            if (newAlpha > 0) {
                var realAlpha = a * 255 / newAlpha | 0,
                    invAlpha = 255 - realAlpha;

                this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = (r * realAlpha + this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] * invAlpha) / 255 | 0;
                this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = (g * realAlpha + this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] * invAlpha) / 255 | 0;
                this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = (b * realAlpha + this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] * invAlpha) / 255 | 0;
                this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = newAlpha;
            }

            prop += horzStep;
        }
    }
};

/**
 * Draw a gradient which begins at fromX, fromY and ends at toX, toY, clipped to the given rect, on top of the
 * pixels in the layer.
 *
 * @param gradientPoints Array with gradient colors (ARGB integers)
 * @param rect CPRect
 * @param replace Set to true to replace the pixels in the layer rather than blending the gradient on top of them.
 */
CPLayer.prototype.gradient = function (rect, fromX, fromY, toX, toY, gradientPoints, replace) {
    rect = this.getBounds().clip(rect);

    // Degenerate case
    if (fromX == toX && fromY == toY) {
        return;
    }

    // Opaque blend if possible
    if (replace || gradientPoints[0] >>> 24 == 255 && gradientPoints[1] >>> 24 == 255) {
        if (fromX == toX) {
            this.gradientVertReplace(rect, fromY, toY, gradientPoints);
        } else if (fromY == toY) {
            this.gradientHorzReplace(rect, fromX, toX, gradientPoints);
        } else {
            this.gradientReplace(rect, fromX, fromY, toX, toY, gradientPoints);
        }
    } else {
        this.gradientAlpha(rect, fromX, fromY, toX, toY, gradientPoints);
    }
};

/**
 * @param r CPRect
 */
CPLayer.prototype.fillWithColorNoise = function (rect) {
    rect = this.getBounds().clip(rect);

    var value,
        yStride = (this.width - rect.getWidth()) * _CPColorBmp2.default.BYTES_PER_PIXEL,
        pixIndex = this.offsetOfPixel(rect.left, rect.top);

    for (var y = rect.top; y < rect.bottom; y++, pixIndex += yStride) {
        for (var x = rect.left; x < rect.right; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            value = Math.random() * 0x1000000 | 0;

            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = value >> 16 & 0xFF;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = value >> 8 & 0xFF;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = value & 0xFF;
            this.data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = 0xFF;
        }
    }
};

/**
 * @param r CPRect
 */
CPLayer.prototype.invert = function (rect) {
    rect = this.getBounds().clip(rect);

    var yStride = (this.width - rect.getWidth()) * _CPColorBmp2.default.BYTES_PER_PIXEL,
        pixIndex = this.offsetOfPixel(rect.left, rect.top);

    for (var y = rect.top; y < rect.bottom; y++, pixIndex += yStride) {
        for (var x = rect.left; x < rect.right; x++, pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL) {
            this.data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] ^= 0xFF;
            this.data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] ^= 0xFF;
            this.data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] ^= 0xFF;
        }
    }
};

CPLayer.prototype.getAlpha = function () {
    return this.alpha;
};

CPLayer.prototype.getBlendMode = function () {
    return this.blendMode;
};

CPLayer.prototype.clone = function () {
    var result = new CPLayer(this.width, this.height, "");

    result.copyFrom(this);

    return result;
};

CPLayer.prototype.copyFrom = function (layer) {
    this.name = layer.name;
    this.blendMode = layer.blendMode;
    this.alpha = layer.alpha;
    this.visible = layer.visible;

    this.copyDataFrom(layer);
};

// Do we have any non-opaque pixels in the entire layer?
CPLayer.prototype.hasAlpha = function () {
    if (this.alpha != 100) {
        return true;
    }

    var pixIndex = ALPHA_BYTE_OFFSET;

    for (var y = 0; y < height; y++) {
        var alphaAnded = 0xFF;

        for (var x = 0; x < this.width; x++, pixIndex += BYTES_PER_PIXEL) {
            alphaAnded &= this.data[pixIndex];
        }

        // Only check once per row in order to reduce branching in the inner loop
        if (alphaAnded != 0xFF) {
            return true;
        }
    }

    return false;
};

// Do we have any semi-transparent pixels in the given rectangle?
CPLayer.prototype.hasAlphaInRect = function (rect) {
    if (this.alpha != 100) {
        return true;
    }

    rect = this.getBounds().clip(rect);

    var yStride = (this.width - rect.getWidth()) * BYTES_PER_PIXEL,
        pixIndex = this.offsetOfPixel(rect.left, rect.top) + ALPHA_BYTE_OFFSET;

    for (var y = rect.top; y < rect.bottom; y++, pixIndex += yStride) {
        var alphaAnded = 0xFF;

        for (var x = rect.left; x < rect.right; x++, pixIndex += BYTES_PER_PIXEL) {
            alphaAnded &= this.data[pixIndex];
        }

        // Only check once per row in order to reduce branching in the inner loop
        if (alphaAnded != 0xFF) {
            return true;
        }
    }

    return false;
};

/**
 * Get a rectangle that encloses any non-transparent pixels in the layer within the given initialBounds (or an empty
 * rect if the pixels inside the given bounds are 100% transparent).
 *
 * @param {CPRect} initialBounds - The rect to search within (pass getBounds() to search the whole layer)
 *
 * @returns {CPRect}
 */
CPLayer.prototype.getNonTransparentBounds = function (initialBounds) {
    var pixIndex,
        result = initialBounds.clone(),
        x,
        y,
        alphaOred,
        yStride;

    // Find the first non-transparent row
    yStride = (this.width - result.getWidth()) * BYTES_PER_PIXEL;
    pixIndex = this.offsetOfPixel(result.left, result.top) + ALPHA_BYTE_OFFSET;

    for (y = result.top; y < result.bottom; y++, pixIndex += yStride) {
        alphaOred = 0x00;

        for (var x = result.left; x < result.right; x++, pixIndex += BYTES_PER_PIXEL) {
            alphaOred |= this.data[pixIndex];
        }

        // Only check once per row in order to reduce branching in the inner loop
        if (alphaOred != 0x00) {
            break;
        }
    }

    result.top = y;

    if (result.top == result.bottom) {
        // Rect is empty, no opaque pixels in the initialBounds
        return result;
    }

    // Now the last non-transparent row
    pixIndex = this.offsetOfPixel(result.right - 1, result.bottom - 1) + ALPHA_BYTE_OFFSET;
    for (y = result.bottom - 1; y >= result.top; y--, pixIndex -= yStride) {
        alphaOred = 0x00;

        for (var x = result.right - 1; x >= result.left; x--, pixIndex -= BYTES_PER_PIXEL) {
            alphaOred |= this.data[pixIndex];
        }

        // Only check once per row in order to reduce branching in the inner loop
        if (alphaOred != 0x00) {
            break;
        }
    }

    result.bottom = y + 1; /* +1 since the bottom/right edges of the rect are exclusive */

    // Now columns from the left
    yStride = BYTES_PER_PIXEL * this.width;
    for (x = result.left; x < result.right; x++) {
        pixIndex = this.offsetOfPixel(x, result.top) + ALPHA_BYTE_OFFSET;
        alphaOred = 0x00;

        for (y = result.top; y < result.bottom; y++, pixIndex += yStride) {
            alphaOred |= this.data[pixIndex];
        }

        if (alphaOred != 0x00) {
            break;
        }
    }

    result.left = x;

    // And columns from the right
    for (x = result.right - 1; x >= result.left; x--) {
        pixIndex = this.offsetOfPixel(x, result.top) + ALPHA_BYTE_OFFSET;
        alphaOred = 0x00;

        for (y = result.top; y < result.bottom; y++, pixIndex += yStride) {
            alphaOred |= this.data[pixIndex];
        }

        if (alphaOred != 0x00) {
            break;
        }
    }

    result.right = x + 1;

    return result;
};

CPLayer.prototype.setAlpha = function (alpha) {
    this.alpha = alpha;
};

CPLayer.prototype.setBlendMode = function (blendMode) {
    this.blendMode = blendMode;
};

CPLayer.prototype.getAlpha = function () {
    return this.alpha;
};

CPLayer.prototype.getBlendMode = function () {
    return this.blendMode;
};

/**
 * Returns a new canvas with a rotated version of the given canvas.
 * 
 * Rotation is [0..3] and selects a multiple of 90 degrees of clockwise rotation to be applied.
 */
function getRotatedCanvas(canvas, rotation) {
    rotation = rotation % 4;

    if (rotation == 0) {
        return canvas;
    }

    var rotatedCanvas = document.createElement("canvas"),
        rotatedCanvasContext = rotatedCanvas.getContext("2d");

    if (rotation % 2 == 0) {
        rotatedCanvas.width = canvas.width;
        rotatedCanvas.height = canvas.height;
    } else {
        rotatedCanvas.width = canvas.height;
        rotatedCanvas.height = canvas.width;
    }

    switch (rotation) {
        case 1:
            // 90 degree clockwise:
            rotatedCanvasContext.rotate(Math.PI / 2);
            rotatedCanvasContext.drawImage(canvas, 0, -canvas.height);
            break;
        case 2:
            rotatedCanvasContext.rotate(Math.PI);
            rotatedCanvasContext.drawImage(canvas, -canvas.width, -canvas.height);
            break;
        case 3:
            // 90 degree counter-clockwise:
            rotatedCanvasContext.rotate(-Math.PI / 2);
            rotatedCanvasContext.drawImage(canvas, -canvas.width, 0);
            break;
        case 0:
        default:
            return canvas;
    }

    return rotatedCanvas;
}

function decodeBase64PNGDataURL(url) {
    if (typeof url !== "string" || !url.match(/^data:image\/png;base64,/i)) {
        return false;
    }

    return window.atob(url.substring("data:image\/png;base64,".length));
}

/**
 * Get the layer as a PNG image.
 * 
 * Rotation is [0..3] and selects a multiple of 90 degrees of clockwise rotation to be applied, or 0 to leave
 * unrotated.
 */
CPLayer.prototype.getAsPNG = function (rotation) {
    var canvas = document.createElement("canvas"),
        canvasContext = canvas.getContext("2d");

    // First draw our image data onto a canvas...
    canvas.width = this.imageData.width;
    canvas.height = this.imageData.height;

    canvasContext.putImageData(this.imageData, 0, 0);

    // Rotate it if needed
    canvas = getRotatedCanvas(canvas, rotation || 0);

    return decodeBase64PNGDataURL(canvas.toDataURL('image/png'));
};
module.exports = exports['default'];

},{"./CPBlend":4,"./CPColorBmp":9}],12:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPLookUpTable;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPLookUpTable() {
    this.table = new Uint8Array(256);

    this.loadIdentity = function () {
        for (var i = 0; i < 256; i++) {
            this.table[i] = i;
        }
    };

    this.loadBrightnessContrast = function (brightness, contrast) {
        var slope = contrast > 0.0 ? 1.0 / (1.0001 - contrast) : 1.0 + contrast,
            offset = 0.5 - slope * 0.5 + brightness;

        for (var i = 0; i < 256; i++) {
            var x = i / 255.0,
                y = x * slope + offset;

            this.table[i] = Math.min(255, Math.max(~~(y * 255.0), 0));
        }
    };

    this.invert = function () {
        for (var i = 0; i < 256; i++) {
            this.table[i] = 255 - this.table[i];
        }
    };
}
module.exports = exports["default"];

},{}],13:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPResourceLoader;

var _CPChibiFile = require("./CPChibiFile");

var _CPChibiFile2 = _interopRequireDefault(_CPChibiFile);

var _CPArtwork = require("./CPArtwork");

var _CPArtwork2 = _interopRequireDefault(_CPArtwork);

var _CPLayer = require("./CPLayer");

var _CPLayer2 = _interopRequireDefault(_CPLayer);

var _AdobeColorTable = require("../util/AdobeColorTable");

var _AdobeColorTable2 = _interopRequireDefault(_AdobeColorTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Loads ChickenPaint resources from a remote server and emits progress events.
 *
 * loadImageURL - URL of PNG/JPEG image to load for editing (optional)
 * loadChibiFileURL - URL of .chi file to load for editing (optional). Used in preference to loadImage.
 * loadSwatchesURL - URL of an .aco palette to load (optional)
 */
function CPResourceLoader(options) {
    var resources = [],
        completed = {},
        that = this;

    if (options.loadChibiFileUrl && ("" + options.loadChibiFileUrl).length > 0) {
        resources.push({
            url: options.loadChibiFileUrl,
            friendly: "drawing layers",
            name: "layers",
            required: true
        });
    } else {
        if (options.loadImageUrl && ("" + options.loadImageUrl).length > 0) {
            resources.push({
                url: options.loadImageUrl,
                friendly: "drawing",
                name: "flat",
                required: true
            });
        }
    }

    if (options.loadSwatchesUrl) {
        resources.push({
            url: options.loadSwatchesUrl,
            friendly: "color swatches",
            name: "swatches",
            required: false,
            noProgress: true // So short that we may as well keep the smoothie drained
        });
    }

    function decodeResource(resource, resourceData) {
        return new Promise(function (resolve, reject) {
            switch (resource.name) {
                case "flat":
                    var blob = new Blob([resourceData], { type: "image/png" }),
                        imageUrl = window.URL.createObjectURL(blob);

                    if (imageUrl) {
                        var image = new Image();

                        image.onload = function () {
                            var artwork = new _CPArtwork2.default(this.width, this.height),
                                layer = new _CPLayer2.default(this.width, this.height, "Layer 1");

                            layer.loadFromImage(image);
                            artwork.addLayerObject(layer);

                            image = null;
                            window.URL.revokeObjectURL(imageUrl);

                            resolve(artwork);
                        };

                        image.src = imageUrl;
                    } else {
                        resolve(null);
                    }
                    break;
                case "swatches":
                    var reader = new _AdobeColorTable2.default(),
                        colors = reader.read(resourceData);

                    resolve(colors);
                    break;
                case "layers":
                    var reader = new _CPChibiFile2.default(),
                        artwork = reader.read(resourceData);

                    resolve(artwork);
                    break;
                default:
                    resolve(null);
                    break;
            }
        });
    }

    function reportProgress(resource, progress) {
        if (progress === null) {
            that.emitEvent("loadingProgress", [1.0, "Loading your " + resource.friendly + "..."]);
        } else {
            that.emitEvent("loadingProgress", [progress, "Loading your " + resource.friendly + " (" + Math.round(progress * 100) + "%)..."]);
        }
    }

    this.load = function () {
        if (resources.length == 0) {
            that.emitEvent("loadingComplete", [completed]);
            return;
        }

        var resource = resources.shift(),
            xhr = new XMLHttpRequest();

        xhr.addEventListener("progress", function (evt) {
            var progress;

            if (evt.lengthComputable && !resource.noProgress) {
                progress = evt.loaded / evt.total;
            } else {
                progress = null;
            }

            reportProgress(resource, progress);
        }, false);

        function handleFatal() {
            if (resource.required) {
                that.emitEvent("loadingFailure", ["Failed to load your " + resource.friendly + ", please try again later."]);
            } else {
                // Skip unimportant resources
                that.load();
            }
        }

        xhr.addEventListener("load", function (evt) {
            if (this.status == 200) {
                var response = this.response;

                that.emitEvent("loadingProgress", [1.0, "Starting ChickenPaint..."]);

                // Yield to the DOM to give it a chance to paint the loaded message before we begin decoding
                setTimeout(function () {
                    decodeResource(resource, response).then(function (decoded) {
                        if (decoded) {
                            completed[resource.name] = decoded;

                            // Move on to the next file
                            that.load();
                        } else {
                            that.emitEvent("loadingFailure", ["Failed to read your " + resource.friendly]);
                        }
                    });
                }, 0);
            } else {
                handleFatal();
            }
        }, false);

        xhr.addEventListener("error", handleFatal);

        reportProgress(resource, resource.noProgress ? null : 0.0);

        xhr.open("GET", resource.url, true);

        xhr.responseType = 'arraybuffer';

        xhr.send();
    };
}

CPResourceLoader.prototype = Object.create(EventEmitter.prototype);
CPResourceLoader.prototype.constructor = CPResourceLoader;
module.exports = exports["default"];

},{"../util/AdobeColorTable":44,"./CPArtwork":2,"./CPChibiFile":7,"./CPLayer":11}],14:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.binaryStringToByteArray = binaryStringToByteArray;
exports.default = CPResourceSaver;

var _CPChibiFile = require("./CPChibiFile");

var _CPChibiFile2 = _interopRequireDefault(_CPChibiFile);

var _CPArtwork = require("./CPArtwork");

var _CPArtwork2 = _interopRequireDefault(_CPArtwork);

var _AdobeColorTable = require("../util/AdobeColorTable");

var _AdobeColorTable2 = _interopRequireDefault(_AdobeColorTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * We generally can't do much with binary strings because various methods will try to UTF-8 mangle them.
 * This function converts such a string to a Uint8Array instead.
 */
function binaryStringToByteArray(s) {
    var result = new Uint8Array(s.length);

    for (var i = 0; i < s.length; i++) {
        result[i] = s.charCodeAt(i);
    }

    return result;
}

/**
 * Saves ChickenPaint resources to a remote server or to the disk and emits progress events.
 *
 * Options:
 *     url - URL to send to. If omitted, will save to the disk instead.
 *     artwork - Artwork to send
 *     rotation - Integer [0..3] of the number of 90 degree rotation steps that should be applied to canvas upon opening.
 *     swatches - Array of ARGB integer colors to save as the image swatches (optional)
 */
function CPResourceSaver(options) {
    var that = this,
        cancelled = false;

    options.rotation = options.rotation || 0;

    function reportProgress(progress) {
        if (progress === null) {
            that.emitEvent("savingProgress", [1.0, "Saving your drawing to the server..."]);
        } else {
            that.emitEvent("savingProgress", [progress, "Saving your drawing to the server...  (" + Math.round(progress * 100) + "%)"]);
        }
    }

    function reportFatal(serverMessage) {
        that.emitEvent("savingFailure", [serverMessage]);
    }

    function postDrawing(formData) {
        var xhr = new XMLHttpRequest();

        xhr.upload.addEventListener("progress", function (evt) {
            var progress;

            if (evt.lengthComputable) {
                progress = evt.loaded / evt.total;
            } else {
                progress = null;
            }

            reportProgress(progress);
        }, false);

        xhr.addEventListener("load", function (evt) {
            reportProgress(1.0);

            if (this.status == 200 && /^CHIBIOK/.test(this.response)) {
                that.emitEvent("savingComplete");
            } else {
                reportFatal(this.response);
            }
        }, false);

        xhr.addEventListener("error", function () {
            reportFatal(this.response);
        }, false);

        reportProgress(0);

        xhr.open("POST", options.url, true);

        xhr.responseType = "text";

        xhr.send(formData);
    }

    /**
     * Begin saving the data provided in the constructor. Returns immediately, and fires these events to report the
     * saving progress:
     * 
     * savingProgress(progress) - Progress is [0.0 ... 1.0] and reports how much has uploaded so far, or null if the 
     *                            total progress could not be determined.
     * savingFailure(error)     - When saving fails, along with a string error message to display to the user. 
     * savingComplete()         - When saving completes succesfully
     */
    this.save = function () {
        var flat, flatBlob, swatchesBlob;

        flat = binaryStringToByteArray(options.artwork.getFlatPNG(options.rotation));
        flatBlob = new Blob([flat], { type: "image/png" });
        flat = null; // Don't need this any more

        var serializeLayers;

        if (options.artwork.isSimpleDrawing()) {
            serializeLayers = Promise.resolve(null);
        } else {
            serializeLayers = new _CPChibiFile2.default().serialize(options.artwork);
        }

        serializeLayers.then(function (chibiBlob) {
            if (cancelled) {
                that.emitEvent("savingFailure");
                return;
            }

            if (options.swatches) {
                var aco = new _AdobeColorTable2.default();

                swatchesBlob = new Blob([aco.write(options.swatches)], { type: "application/octet-stream" });
            } else {
                swatchesBlob = null;
            }

            if (options.url) {
                var marker = "This marker ensures the upload wasn't truncated",
                    formData = new FormData();

                formData.append("beginMarker", marker);

                formData.append("painter", "ChickenPaint v1.0");

                formData.append("picture", flatBlob);
                flatBlob = null;

                if (chibiBlob) {
                    formData.append("chibifileFormat", "ChickenPaint v0.0");
                    formData.append("chibifile", chibiBlob);
                    chibiBlob = null;

                    // Layers will need to be rotated upon opening
                    formData.append("rotation", "" + options.rotation);
                } else {
                    /*
                     * Because the image is a flat PNG, we rotate it before we saved it and it doesn't need further
                     * rotation upon opening.
                     */
                    formData.append("rotation", "0");
                }

                if (swatchesBlob) {
                    formData.append("swatches", swatchesBlob);
                    swatchesBlob = null;
                }

                formData.append("endMarker", marker);

                postDrawing(formData);
            } else {
                window.saveAs(flatBlob, "oekaki.png");

                if (chibiBlob) {
                    window.saveAs(chibiBlob, "oekaki.chi");
                }
                if (swatchesBlob) {
                    window.saveAs(swatchesBlob, "oekaki.aco");
                }
            }
        });
    };

    this.cancel = function () {
        cancelled = true;
    };
}

CPResourceSaver.prototype = Object.create(EventEmitter.prototype);
CPResourceSaver.prototype.constructor = CPResourceSaver;

},{"../util/AdobeColorTable":44,"./CPArtwork":2,"./CPChibiFile":7}],15:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPUndo;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPUndo() {}

/**
 * Attempt to merge the given undo into this one, and return true if successful.
 *
 * @param undo
 * @returns {boolean}
 */
CPUndo.prototype.merge = function (undo) {
    return false;
};

/**
 * Return true if this undo didn't modify the document.
 *
 * @returns {boolean}
 */
CPUndo.prototype.noChange = function () {
    return false;
};

/**
 * Return the number of bytes of memory used by this undo, or 0 if it cannot be estimated.
 *
 * @param undone
 * @param param
 * @returns {number}
 */
CPUndo.prototype.getMemoryUsed = function (undone, param) {
    return 0;
};

/**
 * Call when this undo is no longer on the top of the stack, so it can optimize its memory usage.
 */
CPUndo.prototype.compact = function () {};
module.exports = exports["default"];

},{}],16:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPAboutDialog;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPAboutDialog(parent) {
    var dialog = $("<div class=\"modal fade chickenpaint-about-dialog\" tabindex=\"-1\" role=\"dialog\">\n                <div class=\"modal-dialog\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                                <span aria-hidden=\"true\">&times;</span>\n                            </button>\n                            <h4 class=\"modal-title\">About ChickenPaint</h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <a class=\"chickenpaint-on-github\" target=\"_blank\" href=\"https://github.com/thenickdude/chickenpaint\"><span class=\"fa fa-github\"></span> ChickenPaint on GitHub</a>\n                            \n                            <p>\n                                ChickenPaint is a translation of <a href=\"http://www.chibipaint.com/\" target=\"_blank\">ChibiPaint</a>\n                                from Java to JavaScript by Nicholas Sherlock / Chicken Smoothie\n                            </p>\n                            <p>\n                                ChibiPaint is Copyright (c) 2006-2008 Marc Schefer. All Rights Reserved\n                            </p>\n                            <p>\n                                ChickenPaint is free software: you can redistribute it and/or modify\n                                it under the terms of the GNU General Public License as published by\n                                the Free Software Foundation, either version 3 of the License, or\n                                (at your option) any later version.\n                            </p>\n        \n                            <p>\n                                ChickenPaint is distributed in the hope that it will be useful,\n                                but WITHOUT ANY WARRANTY; without even the implied warranty of\n                                MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n                                <a target=\"_blank\" href=\"http://www.gnu.org/licenses/\">GNU General Public License</a> for more details.\n                            </p>\n        \n                            <pre class=\"pre-scrollable chickenpaint-third-party-licenses\">Includes icons from the <a href=\"http://tango.freedesktop.org/\" target=\"_blank\">Tango Desktop Project</a>\n\nIncludes these MIT-licensed libraries:\n\n    Includes the <a target=\"_blank\" href=\"https://github.com/eligrey/FileSaver.js\">FileSaver.js library</a>\n    FileSaver.js Copyright \xA9 2015 <a target=\"_blank\" href=\"http://eligrey.com/\">Eli Grey</a>\n\n    Includes the <a target=\"_blank\" href=\"https://github.com/nodeca/pako\">Pako zlib compression library</a>\n    Copyright (C) 2014-2015 by Vitaly Puzrin\n    \n    Includes the <a target=\"_blank\" href=\"https://github.com/madrobby/keymaster\">keymaster.js</a> keyboard library\n    Copyright (c) 2011-2013 Thomas Fuchs\n\n    Includes the <a target=\"_blank\" href=\"https://github.com/stefanpenner/es6-promise\">es6-promise</a> library\n    Copyright (c) 2014 Yehuda Katz, Tom Dale, Stefan Penner and contributors\n\n    Includes the <a target=\"_blank\" href=\"http://benalman.com/projects/jquery-throttle-debounce-plugin/\">jQuery throttle-debounce</a> library\n    Copyright (c) 2010 \"Cowboy\" Ben Alman\n\n    Permission is hereby granted, free of charge, to any person\n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use,\n    copy, modify, merge, publish, distribute, sublicense, and/or\n    sell copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n\n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT \n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n\nIncludes the <a href=\"http://www.jquery.com/\" target=\"_blank\">JQuery library</a>\nCopyright <a href=\"https://jquery.org/\" target=\"_blank\">jQuery Foundation and other contributors</a>\n    \n    This software consists of voluntary contributions made by many\n    individuals. For exact contribution history, see the revision \n    history available at https://github.com/jquery/jquery\n    \n    The following license applies to all parts of this software \n    except as documented below:\n    \n    Permission is hereby granted, free of charge, to any person \n    obtaining a copy of this software and associated documentation\n    files (the \"Software\"), to deal in the Software without\n    restriction, including without limitation the rights to use, \n    copy, modify, merge, publish, distribute, sublicense, and/or\n    sell copies of the Software, and to permit persons to whom the\n    Software is furnished to do so, subject to the following\n    conditions:\n    \n    The above copyright notice and this permission notice shall be\n    included in all copies or substantial portions of the Software.\n    \n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n    OTHER DEALINGS IN THE SOFTWARE.\n                    </pre>\n                </div>\n            </div>\n        </div>\n    ");

    // Destroy the modal upon close
    dialog.on("hidden.bs.modal", function (e) {
        dialog.remove();
    });

    dialog.modal({
        show: false
    });

    // Fix the backdrop location in the DOM by reparenting it to the chickenpaint container
    dialog.data("bs.modal").$body = $(parent);

    parent.appendChild(dialog[0]);

    this.show = function () {
        dialog.modal("show");
    };
}
module.exports = exports["default"];

},{}],17:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPBoxBlurDialog;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPBoxBlurDialog(parent, controller) {
    var dialog = $("<div class=\"modal fade\" tabindex=\"-1\" role=\"dialog\">\n                <div class=\"modal-dialog\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                                <span aria-hidden=\"true\">&times;</span>\n                            </button>\n                            <h4 class=\"modal-title\">Box blur</h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <form>\n                                <div class=\"form-group\">\n                                    <label>Blur amount (pixels)</label>\n                                    <input type=\"text\" class=\"form-control chickenpaint-blur-amount\" value=\"3\">\n                                </div>\n                                <div class=\"form-group\">\n                                    <label>Iterations (1-8, larger gives smoother blur)</label>\n                                    <input type=\"text\" class=\"form-control chickenpaint-blur-iterations\" value=\"1\">\n                                </div>\n                            </form>\n                        </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">Cancel</button>\n                            <button type=\"button\" class=\"btn btn-primary chickenpaint-apply-box-blur\" data-dismiss=\"modal\">Ok</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        "),
        blurAmountElem = $(".chickenpaint-blur-amount", dialog),
        blurIterationsElem = $(".chickenpaint-blur-iterations", dialog),
        applyButton = $(".chickenpaint-apply-box-blur", dialog);

    this.show = function () {
        dialog.modal("show");
    };

    applyButton.click(function (e) {
        var blur = Math.max(parseInt(blurAmountElem.val(), 10), 1),
            iterations = Math.min(Math.max(parseInt(blurIterationsElem.val(), 10), 1), 8);

        controller.getArtwork().boxBlur(blur, blur, iterations);
    });

    dialog.modal({
        show: false
    }).on('shown.bs.modal', function () {
        blurAmountElem.focus();
    }).on('keypress', function (e) {
        if (e.keyCode == 13) {
            applyButton.click();
        }
    });

    // Fix the backdrop location in the DOM by reparenting it to the chickenpaint container
    dialog.data("bs.modal").$body = $(parent);

    parent.appendChild(dialog[0]);

    /* TODO
    panel.add(new JLabel("Blur amount:"));
    SpinnerModel blurXSM = new SpinnerNumberModel(3, 1, 100, 1);
    
    panel.add(new JLabel("Iterations:"));
    SpinnerModel iterSM = new SpinnerNumberModel(1, 1, 8, 1);
    */
}
module.exports = exports["default"];

},{}],18:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPBrushPalette;

var _ChickenPaint = require("../ChickenPaint");

var _ChickenPaint2 = _interopRequireDefault(_ChickenPaint);

var _CPPalette = require("./CPPalette");

var _CPPalette2 = _interopRequireDefault(_CPPalette);

var _CPCheckbox = require("./CPCheckbox");

var _CPCheckbox2 = _interopRequireDefault(_CPCheckbox);

var _CPColorSwatch = require("./CPColorSwatch");

var _CPColorSwatch2 = _interopRequireDefault(_CPColorSwatch);

var _CPSlider = require("./CPSlider");

var _CPSlider2 = _interopRequireDefault(_CPSlider);

var _CPGUIUtils = require("./CPGUIUtils");

var _CPLayer = require("../engine/CPLayer");

var _CPLayer2 = _interopRequireDefault(_CPLayer);

var _CPColor = require("../util/CPColor");

var _CPColor2 = _interopRequireDefault(_CPColor);

var _CPPolyfill = require("../util/CPPolyfill");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sliderCheckboxGroup(checkbox, slider) {
    var group = document.createElement("div");

    group.className = "chickenpaint-checkbox-slider-group";

    group.appendChild(checkbox.getElement());
    group.appendChild(slider.getElement());

    return group;
} /*
      ChickenPaint
      
      ChickenPaint is a translation of ChibiPaint from Java to JavaScript
      by Nicholas Sherlock / Chicken Smoothie.
      
      ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
      ChickenPaint is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      ChickenPaint is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

function fillCombobox(combo, optionNames) {
    for (var key in optionNames) {
        var option = document.createElement("option");

        option.appendChild(document.createTextNode(optionNames[key]));
        option.value = key;

        combo.appendChild(option);
    }
}

function CPGradientPreview(controller) {
    var that = this,
        w = 150,
        h = 32,
        canvas = document.createElement("canvas"),
        canvasContext = canvas.getContext("2d"),
        checkerboard = (0, _CPGUIUtils.createCheckerboardPattern)(canvasContext),
        image = new _CPLayer2.default(w, h, ""),
        imageCanvas = document.createElement("canvas"),
        imageCanvasContext = imageCanvas.getContext("2d"),
        gradient = controller.getCurGradient();

    function paint() {
        image.gradient(image.getBounds(), 0, 0, image.width, 0, gradient, true);
        imageCanvasContext.putImageData(image.imageData, 0, 0, 0, 0, w, h);

        canvasContext.fillRect(0, 0, canvas.width, canvas.height);
        canvasContext.drawImage(imageCanvas, 0, 0);
    }

    this.getElement = function () {
        return canvas;
    };

    controller.on("gradientChange", function (_gradient) {
        gradient = _gradient;

        paint();
    });

    canvas.width = imageCanvas.width = w;
    canvas.height = imageCanvas.height = h;

    canvas.className = 'chickenpaint-gradient-preview';

    canvasContext.fillStyle = checkerboard;

    paint();
}

function CPBrushPalette(controller) {
    _CPPalette2.default.call(this, controller, "brush", "Tool options");

    var brushPanel = new CPBrushPanel(controller),
        gradientPanel = new CPGradientPanel(controller),
        transformPanel = new CPTransformPanel(controller),
        body = this.getBodyElement();

    body.appendChild(brushPanel.getElement());
    body.appendChild(gradientPanel.getElement());
    body.appendChild(transformPanel.getElement());

    controller.on('modeChange', function (mode) {
        brushPanel.getElement().style.display = "none";
        gradientPanel.getElement().style.display = "none";
        transformPanel.getElement().style.display = "none";

        switch (mode) {
            case _ChickenPaint2.default.M_GRADIENTFILL:
                gradientPanel.getElement().style.display = "block";
                break;
            case _ChickenPaint2.default.M_TRANSFORM:
                transformPanel.getElement().style.display = "block";
                break;
            default:
                brushPanel.getElement().style.display = "block";
                break;
        }
    });
}

CPBrushPalette.prototype = Object.create(_CPPalette2.default.prototype);
CPBrushPalette.prototype.constructor = CPBrushPalette;

function CPBrushPanel(controller) {
    var TIP_NAMES = ["Round Pixelated", "Round Hard Edge", "Round Soft", "Square Pixelated", "Square Hard Edge"],
        BRUSH_SIZES = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 15, 20, 25, 30, 35, 40, 45, 50, 60, 70, 80, 90, 100, 125, 150, 175, 200];

    var panel = document.createElement("div"),
        tipCombo = document.createElement("select"),
        alphaCB = new _CPCheckbox2.default(false, "Control brush opacity with pen pressure"),
        alphaSlider = new _CPSlider2.default(1, 255),
        sizeCB = new _CPCheckbox2.default(true, "Control brush size with pen pressure"),
        sizeSlider = new _CPSlider2.default(1, 200, false, true),
        scatteringCB = new _CPCheckbox2.default(false, "Control brush scattering with pen pressure"),
        scatteringSlider = new _CPSlider2.default(0, 1000, false, true),
        resatSlider = new _CPSlider2.default(0, 100, false, true),
        bleedSlider = new _CPSlider2.default(0, 100, false, true),
        spacingSlider = new _CPSlider2.default(0, 100, false, true),
        smoothingSlider = new _CPSlider2.default(0, 100, false, true),
        brushPreview = new CPBrushPalette.CPBrushPreview(controller);

    function fillWithInitialValues() {
        alphaCB.setValue(controller.getBrushInfo().pressureAlpha);
        alphaSlider.setValue(controller.getAlpha());

        sizeCB.setValue(controller.getBrushInfo().pressureSize);
        sizeSlider.setValue(controller.getBrushSize());

        scatteringCB.setValue(controller.getBrushInfo().pressureScattering);
        scatteringSlider.setValue(~~(controller.getBrushInfo().scattering * 100));

        tipCombo.value = controller.getBrushInfo().type;

        resatSlider.setValue(~~(controller.getBrushInfo().resat * 100));
        bleedSlider.setValue(~~(controller.getBrushInfo().bleed * 100));
        spacingSlider.setValue(~~(controller.getBrushInfo().spacing * 100));
        smoothingSlider.setValue(~~(controller.getBrushInfo().smoothing * 100));
    }

    this.getElement = function () {
        return panel;
    };

    alphaSlider.title = function (value) {
        return "Opacity: " + value;
    };

    alphaSlider.on('valueChange', function (value) {
        controller.setAlpha(value);
    });

    sizeSlider.title = function (value) {
        return "Brush size: " + value;
    };

    sizeSlider.on('valueChange', function (value) {
        controller.setBrushSize(value);
    });

    resatSlider.title = function (value) {
        return "Color: " + value + "%";
    };

    resatSlider.on('valueChange', function (value) {
        controller.getBrushInfo().resat = value / 100.0;
        controller.callToolListeners();
    });

    bleedSlider.title = function (value) {
        return "Blend: " + value + "%";
    };

    bleedSlider.on('valueChange', function (value) {
        controller.getBrushInfo().bleed = value / 100.0;
        controller.callToolListeners();
    });

    spacingSlider.title = function (value) {
        return "Spacing: " + value + "%";
    };

    spacingSlider.on('valueChange', function (value) {
        controller.getBrushInfo().spacing = value / 100.0;
        controller.callToolListeners();
    });

    scatteringSlider.title = function (value) {
        return "Scattering: " + value + "%";
    };

    scatteringSlider.on('valueChange', function (value) {
        controller.getBrushInfo().scattering = value / 100.0;
        controller.callToolListeners();
    });

    smoothingSlider.title = function (value) {
        return "Smoothing: " + value + "%";
    };

    smoothingSlider.on('valueChange', function (value) {
        controller.getBrushInfo().smoothing = value / 100.0;
        controller.callToolListeners();
    });

    scatteringCB.on('valueChange', function (state) {
        controller.getBrushInfo().pressureScattering = state;
        controller.callToolListeners();
    });

    alphaCB.on('valueChange', function (state) {
        controller.getBrushInfo().pressureAlpha = state;
        controller.callToolListeners();
    });

    sizeCB.on('valueChange', function (state) {
        controller.getBrushInfo().pressureSize = state;
        controller.callToolListeners();
    });

    tipCombo.addEventListener("change", function (e) {
        controller.getBrushInfo().type = parseInt(tipCombo.value, 10);
    });

    tipCombo.className = 'form-control';
    fillCombobox(tipCombo, TIP_NAMES);

    panel.appendChild(tipCombo);

    panel.appendChild(brushPreview.getElement());

    panel.appendChild(sliderCheckboxGroup(sizeCB, sizeSlider));
    panel.appendChild(sliderCheckboxGroup(alphaCB, alphaSlider));
    panel.appendChild(resatSlider.getElement());
    panel.appendChild(bleedSlider.getElement());
    panel.appendChild(spacingSlider.getElement());
    panel.appendChild(sliderCheckboxGroup(scatteringCB, scatteringSlider));
    panel.appendChild(smoothingSlider.getElement());

    fillWithInitialValues();

    controller.on('toolChange', function (tool, toolInfo) {
        alphaSlider.setValue(toolInfo.alpha);
        sizeSlider.setValue(toolInfo.size);
        sizeCB.setValue(toolInfo.pressureSize);
        alphaCB.setValue(toolInfo.pressureAlpha);
        tipCombo.value = toolInfo.type;
        scatteringCB.setValue(toolInfo.pressureScattering);

        if (~~(toolInfo.resat * 100.0) != resatSlider.value) {
            resatSlider.setValue(~~(toolInfo.resat * 100.0));
        }

        if (~~(toolInfo.bleed * 100.0) != bleedSlider.value) {
            bleedSlider.setValue(~~(toolInfo.bleed * 100.0));
        }

        if (~~(toolInfo.spacing * 100.0) != spacingSlider.value) {
            spacingSlider.setValue(~~(toolInfo.spacing * 100.0));
        }

        if (~~(toolInfo.scattering * 100.0) != scatteringSlider.value) {
            scatteringSlider.setValue(~~(toolInfo.scattering * 100.0));
        }

        if (~~(toolInfo.smoothing * 100.0) != smoothingSlider.value) {
            smoothingSlider.setValue(~~(toolInfo.smoothing * 100.0));
        }
    });

    key("1,2,3,4,5,6,7,8,9,0", function (event, handler) {
        var shortcut = parseInt(handler.shortcut, 10);

        if (shortcut == 0) {
            shortcut = 10;
        }

        controller.setAlpha(Math.round(shortcut / 10 * 255));
    });

    key("{,[", function () {
        var size = controller.getBrushSize();

        for (var i = BRUSH_SIZES.length - 1; i >= 0; i--) {
            if (size > BRUSH_SIZES[i]) {
                controller.setBrushSize(BRUSH_SIZES[i]);
                break;
            }
        }
    });

    key("},]", function () {
        var size = controller.getBrushSize();

        for (var i = 0; i < BRUSH_SIZES.length; i++) {
            if (size < BRUSH_SIZES[i]) {
                controller.setBrushSize(BRUSH_SIZES[i]);
                break;
            }
        }
    });
}

CPBrushPalette.CPBrushPreview = function (controller) {
    var size = 16,
        canvas = document.createElement("canvas"),
        canvasContext = canvas.getContext("2d"),
        mouseCaptured = false;

    function paint() {
        canvasContext.clearRect(0, 0, canvas.width, canvas.height);

        canvasContext.beginPath();
        canvasContext.arc(canvas.width / 2, canvas.height / 2, size / 2 * window.devicePixelRatio, 0, Math.PI * 2);
        canvasContext.stroke();
    }

    function handleMouseDrag(e) {
        var offset = $(canvas).offset(),
            pt = { x: e.pageX - offset.left, y: e.pageY - offset.top },
            x = pt.x - $(canvas).width() / 2,
            y = pt.y - $(canvas).height() / 2,
            newSize = Math.round(Math.sqrt(x * x + y * y) * 2);

        size = Math.max(1, Math.min(200, newSize));

        paint();
        controller.setBrushSize(size);
    }

    function handleMouseUp(e) {
        if (mouseCaptured) {
            mouseCaptured = false;
            window.removeEventListener('mouseup', handleMouseUp);
            window.removeEventListener('mousemove', handleMouseDrag);
        }
    }

    this.getElement = function () {
        return canvas;
    };

    canvas.addEventListener('mousedown', function (e) {
        if (!mouseCaptured) {
            mouseCaptured = true;

            window.addEventListener('mouseup', handleMouseUp);
            window.addEventListener('mousemove', handleMouseDrag);

            handleMouseDrag(e);
        }
    });

    controller.on("toolChange", function (tool, toolInfo) {
        if (toolInfo.size != size) {
            size = toolInfo.size;
            paint();
        }
    });

    canvas.width = 64;
    canvas.height = 64;

    if (window.devicePixelRatio > 1) {
        canvas.style.width = canvas.width + 'px';
        canvas.style.height = canvas.height + 'px';

        canvas.width = canvas.width * window.devicePixelRatio;
        canvas.height = canvas.height * window.devicePixelRatio;
    }

    canvas.className = 'chickenpaint-brush-preview';

    canvasContext.strokeStyle = 'black';
    canvasContext.lineWidth = 1.0 * window.devicePixelRatio;

    paint();
};

function CPGradientPanel(controller) {
    var gradientPanel = document.createElement("div"),
        gradientPreview = new CPGradientPreview(controller),
        gradientStartSwatch = new _CPColorSwatch2.default(new _CPColor2.default(controller.getCurGradient()[0] & 0xFFFFFF)),
        gradientEndSwatch = new _CPColorSwatch2.default(new _CPColor2.default(controller.getCurGradient()[1] & 0xFFFFFF));

    function updateGradient() {
        var gradient = new Array(2);

        gradient[0] = gradientStartSwatch.getAlpha() << 24 | gradientStartSwatch.getColorRgb();
        gradient[1] = gradientEndSwatch.getAlpha() << 24 | gradientEndSwatch.getColorRgb();

        controller.setCurGradient(gradient);
    }

    this.getElement = function () {
        return gradientPanel;
    };

    gradientPanel.className = "chickenpaint-gradient-panel";
    gradientPanel.style.display = "none";

    gradientStartSwatch.on("colorChange", updateGradient);
    gradientStartSwatch.on("alphaChange", updateGradient);
    gradientEndSwatch.on("colorChange", updateGradient);
    gradientEndSwatch.on("alphaChange", updateGradient);

    var title, colorsGroup, colorGroup;

    title = document.createElement("p");
    title.innerHTML = "Gradient";

    gradientPanel.appendChild(title);
    gradientPanel.appendChild(gradientPreview.getElement());

    colorsGroup = document.createElement("div");
    colorsGroup.className = "chickenpaint-gradient-colors";

    colorGroup = document.createElement("div");
    colorGroup.className = "chickenpaint-gradient-start-color";

    colorGroup.appendChild(gradientStartSwatch.getElement());

    colorsGroup.appendChild(colorGroup);

    colorGroup = document.createElement("div");
    colorGroup.className = "chickenpaint-gradient-end-color";

    colorGroup.appendChild(gradientEndSwatch.getElement());

    colorsGroup.appendChild(colorGroup);

    gradientPanel.appendChild(colorsGroup);
}

function CPTransformPanel(controller) {
    var TRANSFORM_INTERPOLATION = { smooth: "Smooth", sharp: "Sharp" };

    var panel = document.createElement("div"),
        acceptButton = document.createElement("button"),
        rejectButton = document.createElement("button"),
        interpCombo = document.createElement("select");

    this.getElement = function () {
        return panel;
    };

    panel.className = "chickenpaint-transform-panel";
    panel.style.display = "none";

    acceptButton.type = "button";
    rejectButton.type = "button";

    acceptButton.className = "btn btn-primary btn-block";
    rejectButton.className = "btn btn-default btn-block";

    acceptButton.innerHTML = "Apply transform";
    rejectButton.innerHTML = "Cancel";

    interpCombo.addEventListener("change", function (e) {
        controller.setTransformInterpolation(this.value);
    });

    interpCombo.className = 'form-control chickenpaint-transform-interpolation';
    fillCombobox(interpCombo, TRANSFORM_INTERPOLATION);

    if ((0, _CPPolyfill.isCanvasInterpolationSupported)()) {
        var interpGroup = document.createElement("div"),
            interpLabel = document.createElement("label");

        interpLabel.innerHTML = "Transform style";

        interpGroup.className = "form-group";
        interpGroup.appendChild(interpLabel);
        interpGroup.appendChild(interpCombo);

        panel.appendChild(interpGroup);
    }

    var buttonGroup = document.createElement("div");

    buttonGroup.appendChild(acceptButton);
    buttonGroup.appendChild(rejectButton);

    buttonGroup.className = "form-group";

    panel.appendChild(buttonGroup);

    acceptButton.addEventListener("click", function (e) {
        controller.actionPerformed({ action: "CPTransformAccept" });
        e.preventDefault();
    });

    rejectButton.addEventListener("click", function (e) {
        controller.actionPerformed({ action: "CPTransformReject" });
        e.preventDefault();
    });
}
module.exports = exports["default"];

},{"../ChickenPaint":1,"../engine/CPLayer":11,"../util/CPColor":47,"../util/CPPolyfill":49,"./CPCheckbox":20,"./CPColorSwatch":24,"./CPGUIUtils":26,"./CPPalette":32,"./CPSlider":37}],19:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPCanvas;

var _CPRect = require("../util/CPRect");

var _CPRect2 = _interopRequireDefault(_CPRect);

var _CPTransform = require("../util/CPTransform");

var _CPTransform2 = _interopRequireDefault(_CPTransform);

var _CPWacomTablet = require("../util/CPWacomTablet");

var _CPWacomTablet2 = _interopRequireDefault(_CPWacomTablet);

var _CPBezier = require("../util/CPBezier");

var _CPBezier2 = _interopRequireDefault(_CPBezier);

var _throttleDebounce = require("../util/throttle-debounce");

var _CPPolygon = require("../util/CPPolygon");

var _CPPolygon2 = _interopRequireDefault(_CPPolygon);

var _CPPolyfill = require("../util/CPPolyfill");

var _ChickenPaint = require("../ChickenPaint");

var _ChickenPaint2 = _interopRequireDefault(_ChickenPaint);

var _CPBrushInfo = require("../engine/CPBrushInfo");

var _CPBrushInfo2 = _interopRequireDefault(_CPBrushInfo);

var _CPGUIUtils = require("./CPGUIUtils");

var _CPScrollbar = require("./CPScrollbar");

var _CPScrollbar2 = _interopRequireDefault(_CPScrollbar);

var _CPVector = require("../util/CPVector");

var _CPVector2 = _interopRequireDefault(_CPVector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPModeStack() {
    this.modes = [];
}

/* We have two distinguished mode indexes which correspond to the CPDefaultMode and the mode that the user has selected
 * in the tool palette (the global drawing mode). On top of that are other transient modes.
 */
CPModeStack.MODE_INDEX_DEFAULT = 0;
CPModeStack.MODE_INDEX_USER = 1;

CPModeStack.prototype.setMode = function (index, newMode) {
    var oldMode = this.modes[index];

    if (oldMode == newMode) {
        return;
    }

    if (oldMode) {
        oldMode.leave();
    }

    this.modes[index] = newMode;
    newMode.enter();
};

CPModeStack.prototype.setDefaultMode = function (newMode) {
    newMode.transient = false;
    newMode.capture = false;

    this.setMode(CPModeStack.MODE_INDEX_DEFAULT, newMode);
};

CPModeStack.prototype.setUserMode = function (newMode) {
    // Leave any transient modes that were on top of the user mode
    for (var i = this.modes.length - 1; i > CPModeStack.MODE_INDEX_USER; i--) {
        this.modes[i].leave();
        this.modes.splice(i, 1);
    }

    newMode.transient = false;
    newMode.capture = false;

    this.setMode(CPModeStack.MODE_INDEX_USER, newMode);
};

/**
 * Deliver the event with the given name and array of parameters to the mode stack.
 *
 * @param event
 * @param params
 * @returns {boolean} True if any mode captured the event
 */
CPModeStack.prototype.deliverEvent = function (event, params) {
    for (var i = this.modes.length - 1; i >= 0; i--) {
        var mode = this.modes[i];

        if (mode[event].apply(mode, params) || mode.capture && event != "paint") {
            /* If the event was handled, don't try to deliver it to anything further up the stack */
            return true;
        }
    }

    return false;
};

// We can call these routines to deliver events that bubble up the mode stack
var _arr = ["mouseDown", "mouseUp"];

var _loop = function _loop() {
    var eventName = _arr[_i];
    CPModeStack.prototype[eventName] = function (e, button, pressure) {
        this.deliverEvent(eventName, [e, button, pressure]);
    };
};

for (var _i = 0; _i < _arr.length; _i++) {
    _loop();
}

var _arr2 = ["mouseDrag", "mouseMove"];

var _loop2 = function _loop2() {
    var eventName = _arr2[_i2];
    CPModeStack.prototype[eventName] = function (e, pressure) {
        this.deliverEvent(eventName, [e, pressure]);
    };
};

for (var _i2 = 0; _i2 < _arr2.length; _i2++) {
    _loop2();
}

var _arr3 = ["keyDown", "keyUp"];

var _loop3 = function _loop3() {
    var eventName = _arr3[_i3];
    CPModeStack.prototype[eventName] = function (e) {
        if (this.deliverEvent(eventName, [e])) {
            // Swallow handled keypresses
            e.preventDefault();
        }
    };
};

for (var _i3 = 0; _i3 < _arr3.length; _i3++) {
    _loop3();
}

CPModeStack.prototype.paint = function (context) {
    this.deliverEvent("paint", [context]);
};

/**
 * Add a mode to the top of the mode stack.
 *
 * @param mode {CPMode}
 * @param transient {boolean} Set to true if the mode is expected to remove itself from stack upon completion.
 */
CPModeStack.prototype.push = function (mode, transient) {
    var previousTop = this.peek();

    if (previousTop) {
        previousTop.suspend();
    }

    mode.transient = transient;
    mode.capture = false;

    mode.enter();

    this.modes.push(mode);
};

CPModeStack.prototype.peek = function () {
    if (this.modes.length > 0) {
        return this.modes[this.modes.length - 1];
    } else {
        return null;
    }
};

/**
 * Remove the node at the top of the stack and return the new top of the stack.
 *
 * @returns {*}
 */
CPModeStack.prototype.pop = function () {
    var outgoingMode = this.modes.pop(),
        newTop = this.peek();

    if (outgoingMode) {
        outgoingMode.leave();
    }

    if (newTop) {
        newTop.resume();
    }

    return newTop;
};

function CPCanvas(controller) {
    var BUTTON_PRIMARY = 0,
        BUTTON_WHEEL = 1,
        BUTTON_SECONDARY = 2,
        MIN_ZOOM = 0.10,
        MAX_ZOOM = 16.0,
        CURSOR_DEFAULT = "default",
        CURSOR_PANNABLE = "grab",
        CURSOR_PANNING = "grabbing",
        CURSOR_CROSSHAIR = "crosshair",
        CURSOR_MOVE = "move",
        CURSOR_NESW_RESIZE = "nesw-resize",
        CURSOR_NWSE_RESIZE = "nwse-resize",
        CURSOR_NS_RESIZE = "ns-resize",
        CURSOR_EW_RESIZE = "ew-resize";

    var that = this,
        canvasContainer = document.createElement("div"),
        canvasContainerTop = document.createElement("div"),
        canvasContainerBottom = document.createElement("div"),


    // Our canvas that fills the entire screen
    canvas = document.createElement("canvas"),
        canvasContext = canvas.getContext("2d"),


    // Our cache of the artwork's fusion to be drawn onto our main canvas using our current transform
    artworkCanvas = document.createElement("canvas"),
        artworkCanvasContext = artworkCanvas.getContext("2d"),
        checkerboardPattern = (0, _CPGUIUtils.createCheckerboardPattern)(canvasContext),
        artwork = controller.getArtwork(),


    // Canvas transformations
    zoom = 1,
        offsetX = 0,
        offsetY = 0,
        canvasRotation = 0.0,
        transform = new _CPTransform2.default(),
        interpolation = false,


    // Grid options
    showGrid = false,
        gridSize = 32,
        mouseX = 0,
        mouseY = 0,
        mouseIn = false,
        mouseDown = [false, false, false] /* Track each button independently */,
        wacomPenDown = false,


    /* The area of the document that should have its layers fused and repainted to the screen
     * (i.e. an area modified by drawing tools). 
     * 
     * Initially set to the size of the artwork so we can repaint the whole thing.
     */
    artworkUpdateRegion = new _CPRect2.default(0, 0, artwork.width, artwork.height),


    /**
     * The area of the canvas that should be repainted to the screen during the next repaint internal (in canvas
     * coordinates).
     */
    repaintRegion = new _CPRect2.default(0, 0, 0, 0),
        scheduledRepaint = false,


    //
    // Modes system: modes control the way the GUI is reacting to the user input
    // All the tools are implemented through modes
    //

    defaultMode,
        colorPickerMode,
        panMode,
        rotateCanvasMode,
        floodFillMode,
        gradientFillMode,
        rectSelectionMode,
        moveToolMode,
        transformMode,


    // this must correspond to the stroke modes defined in CPToolInfo
    drawingModes = [],
        modeStack = new CPModeStack(),
        curDrawMode,
        curSelectedMode,
        horzScroll = new _CPScrollbar2.default(false),
        vertScroll = new _CPScrollbar2.default(true),
        tablet = _CPWacomTablet2.default.getRef();

    Math.sign = Math.sign || function (x) {
        x = +x; // convert to a number
        if (x === 0 || isNaN(x)) {
            return x;
        }
        return x > 0 ? 1 : -1;
    };

    // Parent class with empty event handlers for those drawing modes that don't need every event
    function CPMode() {}

    /**
        * True if this mode will be exiting the mode stack as soon as the current interation is complete.
        *
        * @type {boolean}
        */
    CPMode.prototype.transient = false;

    /**
        * If true, no input events will be sent to any modes underneath this one (event stream is captured).
        *
        * Painting events will continue to bubble.
        *
        * @type {boolean}
        */
    CPMode.prototype.capture = false;

    CPMode.prototype.enter = function () {
        setCursor(CURSOR_DEFAULT);
    };

    CPMode.prototype.leave = function () {
        this.capture = false;
    };

    CPMode.prototype.mouseMove = CPMode.prototype.paint = CPMode.prototype.mouseDown = CPMode.prototype.mouseDrag = CPMode.prototype.mouseUp = CPMode.prototype.keyDown = CPMode.prototype.suspend = CPMode.prototype.resume = CPMode.prototype.keyUp = function () {};

    //
    // Default UI Mode when not doing anything: used to start the other modes
    //

    function CPDefaultMode() {}

    CPDefaultMode.prototype = Object.create(CPMode.prototype);
    CPDefaultMode.prototype.constructor = CPDefaultMode;

    CPDefaultMode.prototype.mouseDown = function (e, button, pressure) {
        var spacePressed = key.isPressed("space");

        if (!spacePressed && (button == BUTTON_SECONDARY || button == BUTTON_PRIMARY && e.altKey)) {
            modeStack.push(colorPickerMode, true);
            // Avoid infinite recursion by only delivering the event to the new mode (don't let it bubble back to us!)
            modeStack.peek().mouseDown(e, button, pressure);
        } else if (button == BUTTON_WHEEL || spacePressed && button == BUTTON_PRIMARY) {
            if (e.altKey) {
                modeStack.push(rotateCanvasMode, true);
                modeStack.peek().mouseDown(e, button, pressure);
            } else {
                modeStack.push(panMode, true);
                modeStack.peek().mouseDown(e, button, pressure);
            }
        }
    };

    CPDefaultMode.prototype.keyDown = function (e) {
        if (e.keyCode == 32 /* Space */) {
                if (e.altKey) {
                    modeStack.push(rotateCanvasMode, true);
                    modeStack.peek().keyDown(e);
                } else {
                    // We can start the pan mode before the mouse button is even pressed, so that the "grabbable" cursor appears
                    modeStack.push(panMode, true);
                    modeStack.peek().keyDown(e);
                }
                return true;
            }
    };

    /**
        * A base for the three drawing modes, so they can all share the same brush-preview-circle drawing behaviour.
        *
        * @constructor
        */
    function CPDrawingMode() {
        this.shouldPaintBrushPreview = false;

        /* The last rectangle we dirtied with a brush preview circle, or null if one hasn't been drawn yet */
        this.oldPreviewRect = null;
    }

    CPDrawingMode.prototype = Object.create(CPMode.prototype);
    CPDrawingMode.prototype.constructor = CPDrawingMode;

    /**
     * Get a rectangle that encloses the preview brush, in screen coordinates.
     */
    CPDrawingMode.prototype.getBrushPreviewOval = function () {
        var brushSize = controller.getBrushSize() * zoom;

        return new _CPRect2.default(mouseX - brushSize / 2, mouseY - brushSize / 2, mouseX + brushSize / 2, mouseY + brushSize / 2);
    };

    /**
     * Queues up the brush preview oval to be drawn.
     */
    CPDrawingMode.prototype.queueBrushPreview = function () {
        /* If we're not the top-most mode, it's unlikely that left clicking will drawing for us, so don't consider
         * painting the brush preview
         */
        if (modeStack.peek() != this) {
            return;
        }

        this.shouldPaintBrushPreview = true;

        var rect = this.getBrushPreviewOval();

        rect.grow(2, 2);

        // If a brush preview was drawn previously, stretch the repaint region to remove that old copy
        if (this.oldPreviewRect != null) {
            rect.union(this.oldPreviewRect);
            this.oldPreviewRect = null;
        }

        repaintRect(rect);
    };

    /**
        * Erase the brush preview if one had been drawn
        */
    CPDrawingMode.prototype.eraseBrushPreview = function () {
        this.shouldPaintBrushPreview = false;

        if (this.oldPreviewRect != null) {
            repaintRect(this.oldPreviewRect);
            this.oldPreviewRect = null;
        }
    };

    CPDrawingMode.prototype.mouseMove = function (e, pressure) {
        this.queueBrushPreview();
    };

    CPDrawingMode.prototype.enter = function () {
        CPMode.prototype.enter.call(this);

        if (mouseIn) {
            this.queueBrushPreview();
        }
    };

    CPDrawingMode.prototype.leave = function () {
        CPMode.prototype.leave.call(this);
        this.eraseBrushPreview();
    };

    CPDrawingMode.prototype.suspend = CPDrawingMode.prototype.leave;
    CPDrawingMode.prototype.resume = CPDrawingMode.prototype.enter;

    CPDrawingMode.prototype.paint = function () {
        if (this.shouldPaintBrushPreview) {
            this.shouldPaintBrushPreview = false;

            var r = this.getBrushPreviewOval();

            canvasContext.beginPath();

            canvasContext.arc((r.left + r.right) / 2, (r.top + r.bottom) / 2, r.getWidth() / 2, 0, Math.PI * 2);

            canvasContext.stroke();

            r.grow(2, 2);

            if (this.oldPreviewRect == null) {
                this.oldPreviewRect = r;
            } else {
                this.oldPreviewRect.union(r);
            }
        }
    };

    function CPFreehandMode() {
        CPDrawingMode.call(this);

        this.smoothMouse = { x: 0.0, y: 0.0 };
    }

    CPFreehandMode.prototype = Object.create(CPDrawingMode.prototype);
    CPFreehandMode.prototype.constructor = CPFreehandMode;

    CPFreehandMode.prototype.mouseDown = function (e, button, pressure) {
        if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !key.isPressed("space") && shouldDrawToThisLayer()) {
            var pf = coordToDocument({ x: mouseX, y: mouseY });

            this.eraseBrushPreview();

            this.capture = true;
            artwork.beginStroke(pf.x, pf.y, pressure);

            this.smoothMouse = pf;

            return true;
        }
    };

    CPFreehandMode.prototype.mouseDrag = function (e, pressure) {
        if (this.capture) {
            var pf = coordToDocument({ x: mouseX, y: mouseY }),
                smoothing = Math.min(0.999, Math.pow(controller.getBrushInfo().smoothing, 0.3));

            this.smoothMouse.x = (1.0 - smoothing) * pf.x + smoothing * this.smoothMouse.x;
            this.smoothMouse.y = (1.0 - smoothing) * pf.y + smoothing * this.smoothMouse.y;

            artwork.continueStroke(this.smoothMouse.x, this.smoothMouse.y, pressure);

            return true;
        } else {
            this.mouseMove(e);
        }
    };

    CPFreehandMode.prototype.mouseUp = function (e, button, pressure) {
        if (this.capture) {
            if (button == BUTTON_PRIMARY) {
                this.capture = false;
                artwork.endStroke();
            }
            return true;
        }
    };

    function CPLineMode() {
        var dragLineFrom,
            dragLineTo,
            LINE_PREVIEW_WIDTH = 1;

        this.mouseDown = function (e, button, pressure) {
            if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !key.isPressed("space") && shouldDrawToThisLayer()) {
                this.capture = true;
                dragLineFrom = dragLineTo = { x: mouseX + 0.5, y: mouseY + 0.5 };

                this.eraseBrushPreview();

                return true;
            }
        };

        this.mouseDrag = function (e) {
            if (this.capture) {
                var
                // The old line position that we'll invalidate for redraw
                invalidateRect = new _CPRect2.default(Math.min(dragLineFrom.x, dragLineTo.x) - LINE_PREVIEW_WIDTH - 1, Math.min(dragLineFrom.y, dragLineTo.y) - LINE_PREVIEW_WIDTH - 1, Math.max(dragLineFrom.x, dragLineTo.x) + LINE_PREVIEW_WIDTH + 1 + 1, Math.max(dragLineFrom.y, dragLineTo.y) + LINE_PREVIEW_WIDTH + 1 + 1);

                dragLineTo = { x: mouseX + 0.5, y: mouseY + 0.5 }; // Target centre of pixel

                if (e.shiftKey) {
                    // Snap to nearest 45 degrees
                    var snap = Math.PI / 4,
                        angle = Math.round(Math.atan2(dragLineTo.y - dragLineFrom.y, dragLineTo.x - dragLineFrom.x) / snap);

                    switch (angle) {
                        case 0:
                        case 4:
                            dragLineTo.y = dragLineFrom.y;
                            break;

                        case 2:
                        case 6:
                            dragLineTo.x = dragLineFrom.x;
                            break;

                        default:
                            angle *= snap;

                            var length = Math.sqrt((dragLineTo.y - dragLineFrom.y) * (dragLineTo.y - dragLineFrom.y) + (dragLineTo.x - dragLineFrom.x) * (dragLineTo.x - dragLineFrom.x));

                            dragLineTo.x = dragLineFrom.x + length * Math.cos(angle);
                            dragLineTo.y = dragLineFrom.y + length * Math.sin(angle);
                    }
                }

                // The new line position
                invalidateRect.union(new _CPRect2.default(Math.min(dragLineFrom.x, dragLineTo.x) - LINE_PREVIEW_WIDTH - 1, Math.min(dragLineFrom.y, dragLineTo.y) - LINE_PREVIEW_WIDTH - 1, Math.max(dragLineFrom.x, dragLineTo.x) + LINE_PREVIEW_WIDTH + 1 + 1, Math.max(dragLineFrom.y, dragLineTo.y) + LINE_PREVIEW_WIDTH + 1 + 1));

                repaintRect(invalidateRect);

                return true;
            } else {
                this.mouseMove.call(this, e);
            }
        };

        this.mouseUp = function (e, button, pressure) {
            if (this.capture && button == BUTTON_PRIMARY) {
                var from = coordToDocument(dragLineFrom),
                    to = coordToDocument(dragLineTo);

                this.capture = false;

                this.drawLine(from, to);

                var invalidateRect = new _CPRect2.default(Math.min(dragLineFrom.x, dragLineTo.x) - LINE_PREVIEW_WIDTH - 1, Math.min(dragLineFrom.y, dragLineTo.y) - LINE_PREVIEW_WIDTH - 1, Math.max(dragLineFrom.x, dragLineTo.x) + LINE_PREVIEW_WIDTH + 1 + 1, Math.max(dragLineFrom.y, dragLineTo.y) + LINE_PREVIEW_WIDTH + 1 + 1);

                repaintRect(invalidateRect);

                return true;
            }
        };

        this.paint = function () {
            if (this.capture) {
                canvasContext.lineWidth = LINE_PREVIEW_WIDTH;
                canvasContext.beginPath();
                canvasContext.moveTo(dragLineFrom.x, dragLineFrom.y);
                canvasContext.lineTo(dragLineTo.x, dragLineTo.y);
                canvasContext.stroke();
            } else {
                // Draw the regular brush preview circle
                CPDrawingMode.prototype.paint.call(this);
            }
        };

        CPDrawingMode.call(this);
    }

    CPLineMode.prototype = Object.create(CPDrawingMode.prototype);
    CPLineMode.prototype.constructor = CPLineMode;

    CPLineMode.prototype.drawLine = function (from, to) {
        artwork.beginStroke(from.x, from.y, 1);
        artwork.continueStroke(to.x, to.y, 1);
        artwork.endStroke();
    };

    function CPBezierMode() {
        var BEZIER_POINTS = 500,
            BEZIER_POINTS_PREVIEW = 100;

        var dragBezierMode = 0,
            // 0 Initial drag, 1 first control point, 2 second point
        dragBezierP0,
            dragBezierP1,
            dragBezierP2,
            dragBezierP3;

        this.mouseDown = function (e, button, pressure) {
            if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !key.isPressed("space") && shouldDrawToThisLayer()) {
                var p = coordToDocument({ x: mouseX, y: mouseY });

                dragBezierMode = 0;
                dragBezierP0 = dragBezierP1 = dragBezierP2 = dragBezierP3 = p;
                this.capture = true;

                this.eraseBrushPreview();

                return true;
            }
        };

        // Handles the first part of the Bezier where the user drags out a straight line
        this.mouseDrag = function (e) {
            if (this.capture && dragBezierMode == 0) {
                var p = coordToDocument({ x: mouseX, y: mouseY });

                dragBezierP2 = dragBezierP3 = p;

                that.repaintAll();

                return true;
            } else {
                this.mouseMove.call(this, e);
            }
        };

        this.mouseUp = function (e, button, pressure) {
            if (this.capture && button == BUTTON_PRIMARY) {
                if (dragBezierMode == 0) {
                    dragBezierMode = 1;
                } else if (dragBezierMode == 1) {
                    dragBezierMode = 2;
                } else if (dragBezierMode == 2) {
                    this.capture = false;

                    var p0 = dragBezierP0,
                        p1 = dragBezierP1,
                        p2 = dragBezierP2,
                        p3 = dragBezierP3,
                        bezier = new _CPBezier2.default();

                    bezier.x0 = p0.x;
                    bezier.y0 = p0.y;
                    bezier.x1 = p1.x;
                    bezier.y1 = p1.y;
                    bezier.x2 = p2.x;
                    bezier.y2 = p2.y;
                    bezier.x3 = p3.x;
                    bezier.y3 = p3.y;

                    var x = new Array(BEZIER_POINTS),
                        y = new Array(BEZIER_POINTS);

                    bezier.compute(x, y, BEZIER_POINTS);

                    artwork.beginStroke(x[0], y[0], 1);
                    for (var i = 1; i < BEZIER_POINTS; i++) {
                        artwork.continueStroke(x[i], y[i], 1);
                    }
                    artwork.endStroke();
                    that.repaintAll();
                }

                return true;
            }
        };

        this.mouseMove = function (e, pressure) {
            if (this.capture) {
                var p = coordToDocument({ x: mouseX, y: mouseY });

                if (dragBezierMode == 1) {
                    dragBezierP1 = p;
                } else if (dragBezierMode == 2) {
                    dragBezierP2 = p;
                }
                that.repaintAll(); // FIXME: repaint only the bezier region

                return true;
            } else {
                // Draw the normal brush preview while not in the middle of a bezier operation
                CPDrawingMode.prototype.mouseMove.call(this, e, pressure);
            }
        };

        this.paint = function () {
            if (this.capture) {
                var bezier = new _CPBezier2.default(),
                    p0 = coordToDisplay(dragBezierP0),
                    p1 = coordToDisplay(dragBezierP1),
                    p2 = coordToDisplay(dragBezierP2),
                    p3 = coordToDisplay(dragBezierP3);

                bezier.x0 = p0.x;
                bezier.y0 = p0.y;
                bezier.x1 = p1.x;
                bezier.y1 = p1.y;
                bezier.x2 = p2.x;
                bezier.y2 = p2.y;
                bezier.x3 = p3.x;
                bezier.y3 = p3.y;

                var x = new Array(BEZIER_POINTS_PREVIEW),
                    y = new Array(BEZIER_POINTS_PREVIEW);

                bezier.compute(x, y, BEZIER_POINTS_PREVIEW);

                canvasContext.beginPath();

                canvasContext.moveTo(x[0], y[0]);
                for (var i = 1; i < BEZIER_POINTS_PREVIEW; i++) {
                    canvasContext.lineTo(x[i], y[i]);
                }

                canvasContext.moveTo(~~p0.x, ~~p0.y);
                canvasContext.lineTo(~~p1.x, ~~p1.y);

                canvasContext.moveTo(~~p2.x, ~~p2.y);
                canvasContext.lineTo(~~p3.x, ~~p3.y);

                canvasContext.stroke();
            } else {
                // Paint the regular brush preview
                CPDrawingMode.prototype.paint.call(this);
            }
        };

        CPDrawingMode.call(this);
    }

    CPBezierMode.prototype = Object.create(CPDrawingMode.prototype);
    CPBezierMode.prototype.constructor = CPBezierMode;

    function CPColorPickerMode() {
        var mouseButton;

        this.mouseDown = function (e, button, pressure) {
            if (this.capture) {
                return true;
            } else if (!key.isPressed("space") && (button == BUTTON_PRIMARY && (!this.transient || e.altKey) || button == BUTTON_SECONDARY)) {
                mouseButton = button;
                this.capture = true;

                setCursor(CURSOR_CROSSHAIR);

                this.mouseDrag(e);

                return true;
            } else if (this.transient) {
                // If we're not sampling and we get a button not intended for us, we probably shouldn't be on the stack
                modeStack.pop();
            }
        };

        this.mouseDrag = function (e) {
            if (this.capture) {
                var pf = coordToDocument({ x: mouseX, y: mouseY });

                if (artwork.isPointWithin(pf.x, pf.y)) {
                    controller.setCurColorRgb(artwork.colorPicker(pf.x, pf.y));
                }

                return true;
            }
        };

        this.mouseUp = function (e, button, pressure) {
            if (this.capture && button == mouseButton) {
                mouseButton = -1;
                this.capture = false;
                setCursor(CURSOR_DEFAULT);

                if (this.transient) {
                    modeStack.pop();
                }

                return true;
            }
        };

        this.enter = function () {
            CPMode.prototype.enter.call(this);
            mouseButton = -1;
        };
    }

    CPColorPickerMode.prototype = Object.create(CPMode.prototype);
    CPColorPickerMode.prototype.constructor = CPColorPickerMode;

    function CPPanMode() {
        var panningX, panningY, panningOffset, panningButton;

        this.keyDown = function (e) {
            if (e.keyCode == 32 /* Space */) {
                    // If we're not already panning, then advertise that a left-click would pan
                    if (!this.capture) {
                        setCursor(CURSOR_PANNABLE);
                    }

                    return true;
                }
        };

        this.keyUp = function (e) {
            if (this.transient && panningButton != BUTTON_WHEEL && e.keyCode == 32 /* Space */) {
                    setCursor(CURSOR_DEFAULT);

                    modeStack.pop(); // yield control to the default mode

                    return true;
                }
        };

        this.mouseDown = function (e, button, pressure) {
            if (this.capture) {
                return true;
            } else if (button == BUTTON_WHEEL || key.isPressed("space") && button == BUTTON_PRIMARY) {
                this.capture = true;
                panningButton = button;
                panningX = e.pageX;
                panningY = e.pageY;
                panningOffset = that.getOffset();
                setCursor(CURSOR_PANNING);

                return true;
            } else if (this.transient) {
                // If we're not panning and we get a button not intended for us, we probably shouldn't be on the stack
                modeStack.pop();
            }
        };

        this.mouseDrag = function (e) {
            if (this.capture) {
                that.setOffset(panningOffset.x + e.pageX - panningX, panningOffset.y + e.pageY - panningY);

                return true;
            }
        };

        this.mouseUp = function (e, button, pressure) {
            if (this.capture && button == panningButton) {
                panningButton = -1;
                this.capture = false;

                if (this.transient && !key.isPressed("space")) {
                    setCursor(CURSOR_DEFAULT);

                    modeStack.pop();
                }

                return true;
            }
        };

        this.enter = function () {
            setCursor(CURSOR_PANNABLE);
        };
    }

    CPPanMode.prototype = Object.create(CPMode.prototype);
    CPPanMode.prototype.constructor = CPFloodFillMode;

    function CPFloodFillMode() {}

    CPFloodFillMode.prototype = Object.create(CPMode.prototype);
    CPFloodFillMode.prototype.constructor = CPFloodFillMode;

    CPFloodFillMode.prototype.mouseDown = function (e, button, pressure) {
        if (button == BUTTON_PRIMARY && !e.altKey && !key.isPressed("space") && shouldDrawToThisLayer()) {
            var pf = coordToDocument({ x: mouseX, y: mouseY });

            if (artwork.isPointWithin(pf.x, pf.y)) {
                artwork.floodFill(pf.x, pf.y);
                that.repaintAll();
            }

            return true;
        }
    };

    function CPRectSelectionMode() {
        var firstClick,
            curRect = new _CPRect2.default(0, 0, 0, 0),
            selectingButton = -1;

        this.mouseDown = function (e, button, pressure) {
            if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !key.isPressed("space")) {
                var p = coordToDocumentInt({ x: mouseX, y: mouseY });

                selectingButton = button;

                curRect.makeEmpty();
                firstClick = p;

                that.repaintAll();

                this.capture = true;

                return true;
            }
        };

        this.mouseDrag = function (e) {
            if (!this.capture) return false;

            var p = coordToDocumentInt({ x: mouseX, y: mouseY }),
                square = e.shiftKey,
                squareDist = ~~Math.max(Math.abs(p.x - firstClick.x), Math.abs(p.y - firstClick.y));

            if (p.x >= firstClick.x) {
                curRect.left = firstClick.x;
                curRect.right = (square ? firstClick.x + squareDist : p.x) + 1;
            } else {
                curRect.left = square ? firstClick.x - squareDist : p.x;
                curRect.right = firstClick.x + 1;
            }

            if (p.y >= firstClick.y) {
                curRect.top = firstClick.y;
                curRect.bottom = (square ? firstClick.y + squareDist : p.y) + 1;
            } else {
                curRect.top = square ? firstClick.y - squareDist : p.y;
                curRect.bottom = firstClick.y + 1;
            }

            that.repaintAll();

            return true;
        };

        this.mouseUp = function (e, button, pressure) {
            if (this.capture && button == selectingButton) {
                artwork.rectangleSelection(curRect);
                curRect.makeEmpty();

                that.repaintAll();

                this.capture = false;
                selectingButton = -1;

                return true;
            }
        };

        this.paint = function () {
            if (!curRect.isEmpty()) {
                canvasContext.lineWidth = 1;
                plotSelectionRect(canvasContext, curRect);
            }
        };
    }

    CPRectSelectionMode.prototype = Object.create(CPMode.prototype);
    CPRectSelectionMode.prototype.constructor = CPRectSelectionMode;

    function CPMoveToolMode() {
        var lastPoint,
            copyMode,
            firstMove = false;

        this.mouseDown = function (e, button, pressure) {
            if (!this.capture && button == BUTTON_PRIMARY && !key.isPressed("space") && shouldDrawToThisLayer()) {
                lastPoint = coordToDocument({ x: mouseX, y: mouseY });

                copyMode = e.altKey;
                firstMove = true;
                this.capture = true;

                return true;
            }
        };

        this.mouseDrag = (0, _throttleDebounce.throttle)(25, function (e) {
            if (this.capture) {
                var p = coordToDocument({ x: mouseX, y: mouseY }),
                    moveFloat = { x: p.x - lastPoint.x, y: p.y - lastPoint.y },
                    moveInt = { x: ~~moveFloat.x, y: ~~moveFloat.y }; // Round towards zero

                artwork.move(moveInt.x, moveInt.y, copyMode && firstMove);

                firstMove = false;

                /*
                 * Nudge the last point by the remainder we weren't able to move this iteration (due to move() only
                 * accepting integer offsets). This'll carry that fractional part of the move over for next iteration.
                 */
                lastPoint.x = p.x - (moveFloat.x - moveInt.x);
                lastPoint.y = p.y - (moveFloat.y - moveInt.y);

                return true;
            }
        });

        this.mouseUp = function (e, button, pressure) {
            if (this.capture && button == BUTTON_PRIMARY) {
                this.capture = false;
                if (this.transient) {
                    modeStack.pop();
                }
                return true;
            }
        };
    }

    CPMoveToolMode.prototype = Object.create(CPMode.prototype);
    CPMoveToolMode.prototype.constructor = CPMoveToolMode;

    CPMoveToolMode.prototype.mouseMove = function (e) {
        if (!key.isPressed("space") && !e.altKey) {
            setCursor(CURSOR_MOVE);
            return true;
        }
    };

    CPMoveToolMode.prototype.enter = function () {
        setCursor(CURSOR_MOVE);
    };

    function CPTransformMode() {
        var HANDLE_RADIUS = 3,
            DRAG_NONE = -1,
            DRAG_ROTATE = -2,
            DRAG_MOVE = -3,
            DRAG_NW_CORNER = 0,
            DRAG_N_EDGE = 1,
            DRAG_NE_CORNER = 2,
            DRAG_E_EDGE = 3,
            DRAG_SE_CORNER = 4,
            DRAG_S_EDGE = 5,
            DRAG_SW_CORNER = 6,
            DRAG_W_EDGE = 7;

        var
        /** @type {CPTransform} The current transformation */
        affine,

        /** @type {CPRect} The initial document rectangle to transform */
        srcRect,

        /** @type {CPPolygon} The initial transform rect */
        origCornerPoints,

        /** @type {CPPolygon} The current corners of the transform rect in document space */
        cornerPoints,
            draggingMode = DRAG_NONE,
            lastDragPointDisplay,
            lastDragPointDoc,


        // Keep track of how many degrees we've rotated so far during this transformation
        rotationAccumulator;

        /**
               * Get the polygon that represents the current transform result area in display coordinates.
               *
               * @returns {CPPolygon}
               */
        function cornersToDisplayPolygon() {
            return cornerPoints.getTransformed(transform);
        }

        function averagePoints(p1, p2) {
            return { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
        }

        function roundPoint(p) {
            return { x: Math.round(p.x), y: Math.round(p.y) };
        }

        /**
               * Decide which drag action should be taken if our mouse was pressed in the given position.
               *
               * @param {CPPolygon} corners - The corners of the current transform area
               * @param mouse - The mouse point
               * @returns {number} A DRAG_* constant
               */
        function classifyDragAction(corners, mouse) {
            var HANDLE_CAPTURE_RADIUS = 7,
                HANDLE_CAPTURE_RADIUS_SQR = HANDLE_CAPTURE_RADIUS * HANDLE_CAPTURE_RADIUS,
                EDGE_CAPTURE_RADIUS = HANDLE_CAPTURE_RADIUS,
                EDGE_CAPTURE_RADIUS_SQR = EDGE_CAPTURE_RADIUS * EDGE_CAPTURE_RADIUS;

            // Are we dragging a corner?
            for (var i = 0; i < corners.points.length; i++) {
                if ((mouse.x - corners.points[i].x) * (mouse.x - corners.points[i].x) + (mouse.y - corners.points[i].y) * (mouse.y - corners.points[i].y) <= HANDLE_CAPTURE_RADIUS_SQR) {
                    return i * 2;
                }
            }

            // Are we dragging an edge?
            for (var i = 0; i < corners.points.length; i++) {
                var edgeP1 = corners.points[i],
                    edgeP2 = corners.points[(i + 1) % corners.points.length],
                    vEdge = new _CPVector2.default(edgeP2.x - edgeP1.x, edgeP2.y - edgeP1.y),
                    vMouse = new _CPVector2.default(mouse.x - edgeP1.x, mouse.y - edgeP1.y),
                    vEdgeLen = vEdge.getLength(),
                    vEdgeScaled = vEdge.getScaled(1 / vEdgeLen),
                    vMouseScaled = vMouse.getScaled(1 / vEdgeLen),
                    mousePropOnLine = vEdgeScaled.getDotProduct(vMouseScaled);

                // If we're within the ends of the line (perpendicularly speaking)
                if (mousePropOnLine >= 0.0 && mousePropOnLine <= 1.0) {
                    // This gives us the point on the line closest to the mouse
                    vEdge.scale(mousePropOnLine);

                    if ((vEdge.x - vMouse.x) * (vEdge.x - vMouse.x) + (vEdge.y - vMouse.y) * (vEdge.y - vMouse.y) <= EDGE_CAPTURE_RADIUS_SQR) {
                        return i * 2 + 1;
                    }
                }
            }

            if (corners.containsPoint(mouse)) {
                return DRAG_MOVE;
            }

            return DRAG_ROTATE;
        }

        function setCursorForHandles() {
            var corners = cornersToDisplayPolygon(),
                mouse = { x: mouseX, y: mouseY },
                dragAction = classifyDragAction(corners, mouse);

            switch (dragAction) {
                case DRAG_NW_CORNER:
                case DRAG_NE_CORNER:
                case DRAG_SE_CORNER:
                case DRAG_SW_CORNER:
                    // Choose a cursor for a 45-degree resize from this corner
                    var cornerIndex = ~~(dragAction / 2),
                        cornerBefore = corners.points[(cornerIndex + 3) % 4],
                        corner = corners.points[cornerIndex],
                        cornerAfter = corners.points[(cornerIndex + 1) % 4],


                    // Get a vector which points 45 degrees toward the center of the box, this'll do for cursor direction
                    v45 = _CPVector2.default.subtractPoints(cornerBefore, corner).normalize().add(_CPVector2.default.subtractPoints(cornerAfter, corner).normalize());

                    setResizeCursorForVector(v45);
                    break;
                case DRAG_N_EDGE:
                case DRAG_E_EDGE:
                case DRAG_S_EDGE:
                case DRAG_W_EDGE:
                    // Resizing from here will move edge perpendicularly
                    var corner1 = corners.points[~~(dragAction / 2)],
                        corner2 = corners.points[(~~(dragAction / 2) + 1) % 4],
                        vPerp = _CPVector2.default.subtractPoints(corner2, corner1).getPerpendicular();

                    setResizeCursorForVector(vPerp);
                    break;
                case DRAG_MOVE:
                    setCursor(CURSOR_MOVE);
                    break;
                case DRAG_ROTATE:
                    setCursor(CURSOR_DEFAULT); // TODO add a custom rotation cursor
                    break;
                default:
                    setCursor(CURSOR_DEFAULT);
            }
        }

        this.mouseDown = function (e, button, pressure) {
            if (!this.capture && button == BUTTON_PRIMARY && !e.altKey && !key.isPressed("space")) {
                var corners = cornersToDisplayPolygon();

                draggingMode = classifyDragAction(corners, { x: mouseX, y: mouseY });

                lastDragPointDisplay = { x: mouseX, y: mouseY };
                lastDragPointDoc = coordToDocument(lastDragPointDisplay);

                this.capture = true;

                setCursorForHandles();

                return true;
            }
        };

        this.mouseDrag = (0, _throttleDebounce.throttle)(40, function (e) {
            var MIN_SCALE = 0.001;

            if (this.capture) {
                var dragPointDisplay = { x: mouseX, y: mouseY };

                switch (draggingMode) {
                    case DRAG_MOVE:
                        var dragPointDoc = roundPoint(coordToDocument(dragPointDisplay)),
                            translation = _CPVector2.default.subtractPoints(dragPointDoc, lastDragPointDoc),


                        // Only translate in whole-pixel increments (in document space not canvas space)
                        translationRounded = translation.getTruncated(),
                            translationRemainder = translation.subtract(translationRounded),
                            translateInstance = new _CPTransform2.default();

                        /*
                         * Apply the translate *after* the current affine is applied.
                         */
                        translateInstance.translate(translationRounded.x, translationRounded.y);

                        affine.preMultiply(translateInstance);

                        // Accumulate the fractional move that we didn't apply for next time
                        lastDragPointDoc = _CPVector2.default.subtractPoints(dragPointDoc, translationRemainder);
                        break;
                    case DRAG_ROTATE:
                        var DRAG_ROTATE_SNAP_ANGLE = Math.PI / 4;

                        var centerDoc = cornerPoints.getCenter(),
                            centerDisplay = coordToDisplay(centerDoc),
                            oldMouseAngle = Math.atan2(lastDragPointDisplay.y - centerDisplay.y, lastDragPointDisplay.x - centerDisplay.x),
                            newMouseAngle = Math.atan2(dragPointDisplay.y - centerDisplay.y, dragPointDisplay.x - centerDisplay.x),
                            deltaMouseAngle = newMouseAngle - oldMouseAngle,
                            rotateAngle = void 0,
                            rotateInstance = new _CPTransform2.default();

                        rotationAccumulator += deltaMouseAngle;

                        if (e.shiftKey) {
                            /*
                             * The rotation in the decomposition was made about the origin. We want to rotate about the
                             * center of the selection, so first rotate the selection to square it up with the axes,
                             * then we'll pivot the selection about its center to the new angle.
                             */
                            rotateAngle = -affine.decompose().rotate + Math.round(rotationAccumulator / DRAG_ROTATE_SNAP_ANGLE) * DRAG_ROTATE_SNAP_ANGLE;
                        } else {
                            rotateAngle = deltaMouseAngle;
                        }

                        /* Apply the rotation *after* the current affine instead of before it, so that we don't
                         * end up scaling on top of the rotated selection later (which would cause an unwanted shear)
                         */
                        rotateInstance.rotateAroundPoint(rotateAngle, centerDoc.x, centerDoc.y);

                        affine.preMultiply(rotateInstance);

                        lastDragPointDisplay = dragPointDisplay;
                        break;
                    case DRAG_NW_CORNER:
                    case DRAG_NE_CORNER:
                    case DRAG_SE_CORNER:
                    case DRAG_SW_CORNER:
                        {
                            var draggingCorner = ~~(draggingMode / 2),
                                oldCorner = origCornerPoints.points[draggingCorner],

                            // The corner we dragged will move into its new position
                            newCorner = affine.getInverted().getTransformedPoint(roundPoint(coordToDocument(dragPointDisplay))),


                            // The opposite corner to the one we dragged must not move
                            fixCorner = origCornerPoints.points[(draggingCorner + 2) % 4],


                            /* Now we can see how much we'd need to scale the original rectangle about the fixed corner
                             * for the other corner to reach the new position.
                             */
                            scaleX = (newCorner.x - fixCorner.x) / (oldCorner.x - fixCorner.x),
                                scaleY = (newCorner.y - fixCorner.y) / (oldCorner.y - fixCorner.y);

                            /*
                             * If the user resized it until it was zero-sized, just ignore that position and assume they'll move
                             * past it in a msec.
                             */
                            if (Math.abs(scaleX) < MIN_SCALE || Math.abs(scaleY) < MIN_SCALE || isNaN(scaleX) || isNaN(scaleY)) {
                                return true;
                            }

                            // Does user want proportional resize?
                            if (e.shiftKey) {
                                var largestScale = Math.max(scaleX, scaleY);

                                scaleX = largestScale;
                                scaleY = largestScale;
                            }

                            // The transform we do here will be performed first before any of the other transforms (scale, rotate, etc)
                            affine.scaleAroundPoint(scaleX, scaleY, fixCorner.x, fixCorner.y);
                        }
                        break;
                    case DRAG_N_EDGE:
                    case DRAG_S_EDGE:
                    case DRAG_E_EDGE:
                    case DRAG_W_EDGE:
                        {
                            var cornerIndex = ~~(draggingMode / 2),
                                oldHandle = averagePoints(origCornerPoints.points[cornerIndex], origCornerPoints.points[(cornerIndex + 1) % 4]),


                            // The handle we dragged will move into its new position
                            newHandle = affine.getInverted().getTransformedPoint(roundPoint(coordToDocument(dragPointDisplay))),


                            // The opposite handle to the one we dragged must not move
                            fixHandle = averagePoints(origCornerPoints.points[(cornerIndex + 2) % 4], origCornerPoints.points[(cornerIndex + 3) % 4]),
                                _scaleX = void 0,
                                _scaleY = void 0,
                                oldVector = _CPVector2.default.subtractPoints(oldHandle, fixHandle),
                                newVector = _CPVector2.default.subtractPoints(newHandle, fixHandle),
                                oldLength = oldVector.getLength(),

                            // We only take the length in the perpendicular direction to the transform edge:
                            newLength = oldVector.getDotProduct(newVector) / oldLength,
                                newScale = newLength / oldLength;

                            /*
                             * If the user resized it until it was zero-sized, just ignore that position and assume they'll move
                             * past it in a msec.
                             */
                            if (Math.abs(newScale) < MIN_SCALE || isNaN(newScale)) {
                                return true;
                            }

                            if (draggingMode == DRAG_N_EDGE || draggingMode == DRAG_S_EDGE) {
                                _scaleX = 1.0;
                                _scaleY = newScale;
                            } else {
                                _scaleX = newScale;
                                _scaleY = 1.0;
                            }

                            affine.scaleAroundPoint(_scaleX, _scaleY, fixHandle.x, fixHandle.y);
                        }
                        break;
                }

                cornerPoints = origCornerPoints.getTransformed(affine);

                artwork.transformAffineAmend(affine);

                // TODO make me more specific
                that.repaintAll();

                return true;
            }
        });

        this.mouseUp = function (e, button, pressure) {
            if (this.capture && button == BUTTON_PRIMARY) {
                this.capture = false;
                draggingMode = DRAG_NONE;
                return true;
            }
        };

        /*
         * Set an appropriate resize cursor for the specified vector from the center to the handle.
         */
        function setResizeCursorForVector(v) {
            var angle = Math.atan2(-v.y, v.x),

            /*
                 * Slice up into 45 degrees slices so that there are +-22.5 degrees centered around each corner,
                 * and a 45 degree segment for each edge
                 */
            slice = Math.floor(angle / (Math.PI / 4) + 0.5),
                cursor = void 0;

            // Wrap angles below the x-axis wrap to positive ones...
            if (slice < 0) {
                slice += 4;
            }

            switch (slice) {
                case 0:
                default:
                    cursor = CURSOR_EW_RESIZE;
                    break;
                case 1:
                    cursor = CURSOR_NESW_RESIZE;
                    break;
                case 2:
                    cursor = CURSOR_NS_RESIZE;
                    break;
                case 3:
                    cursor = CURSOR_NWSE_RESIZE;
                    break;
            }

            setCursor(cursor);
        }

        this.mouseMove = function () {
            // We want to stick with our choice of cursor throughout the drag operation
            if (!this.capture) {
                setCursorForHandles();
            }
        };

        this.paint = function () {
            var corners = cornersToDisplayPolygon().points,
                handles = new Array(corners.length * 2);

            // Collect the positions of the edge and corner handles...
            for (var i = 0; i < corners.length; i++) {
                handles[i] = corners[i];
            }

            for (var i = 0; i < corners.length; i++) {
                var edgeP1 = corners[i],
                    edgeP2 = corners[(i + 1) % corners.length],
                    midWay = { x: (edgeP1.x + edgeP2.x) / 2, y: (edgeP1.y + edgeP2.y) / 2 };

                handles[i + corners.length] = midWay;
            }

            setContrastingDrawStyle(canvasContext, "fill");
            for (var i = 0; i < handles.length; i++) {
                canvasContext.fillRect(handles[i].x - HANDLE_RADIUS, handles[i].y - HANDLE_RADIUS, HANDLE_RADIUS * 2 + 1, HANDLE_RADIUS * 2 + 1);
            }

            strokePolygon(canvasContext, corners);
        };

        this.keyDown = function (e) {
            if (e.keyCode == 13 /* Enter */) {
                    controller.actionPerformed({ action: "CPTransformAccept" });

                    return true;
                } else if (e.keyCode == 27 /* Escape */) {
                    controller.actionPerformed({ action: "CPTransformReject" });

                    return true;
                }
        };

        this.enter = function () {
            CPMode.prototype.enter.call(this);

            // Start off with the identity transform
            var initial = artwork.transformAffineBegin(),
                initialSelection;

            affine = initial.transform;
            srcRect = initial.rect;

            // Decide on the rectangle we'll show as the boundary of the transform area
            initialSelection = initial.selection;

            /* If the user didn't have anything selected, we'll use the actual shrink-wrapped transform area instead. */
            if (initialSelection.isEmpty()) {
                initialSelection = initial.rect.clone();
            }

            origCornerPoints = new _CPPolygon2.default(initialSelection.toPoints());
            cornerPoints = origCornerPoints.getTransformed(affine);

            draggingMode = -1;
            rotationAccumulator = 0;

            that.repaintAll();
        };

        this.leave = function () {
            CPMode.prototype.leave.call(this);
            that.repaintAll();
        };
    }

    CPTransformMode.prototype = Object.create(CPMode.prototype);
    CPTransformMode.prototype.constructor = CPTransformMode;

    function CPRotateCanvasMode() {
        var firstClick,
            initAngle = 0.0,
            initTransform,
            dragged = false,
            rotateButton = -1;

        this.mouseDown = function (e, button, pressure) {
            if (this.capture) {
                return true;
            } else if (!this.transient && button == BUTTON_PRIMARY && !e.altKey && !key.isPressed("space") || e.altKey && (button == BUTTON_WHEEL || button == BUTTON_PRIMARY && key.isPressed("space"))) {
                firstClick = { x: mouseX, y: mouseY };

                initAngle = that.getRotation();
                initTransform = transform.clone();

                dragged = false;

                this.capture = true;
                rotateButton = button;

                return true;
            } else if (this.transient) {
                modeStack.pop();
            }
        };

        this.mouseDrag = function (e) {
            if (this.capture) {
                var p = { x: mouseX, y: mouseY },
                    displayCenter = { x: $(canvas).width() / 2, y: $(canvas).height() / 2 },
                    canvasCenter = { x: canvas.width / 2, y: canvas.height / 2 },
                    deltaAngle = Math.atan2(p.y - displayCenter.y, p.x - displayCenter.x) - Math.atan2(firstClick.y - displayCenter.y, firstClick.x - displayCenter.x),
                    rotTrans = new _CPTransform2.default();

                rotTrans.rotateAroundPoint(deltaAngle, canvasCenter.x, canvasCenter.y);

                rotTrans.multiply(initTransform);

                that.setRotation(initAngle + deltaAngle);
                that.setOffset(~~rotTrans.getTranslateX(), ~~rotTrans.getTranslateY());

                dragged = true;

                return true;
            }
        };

        /**
         * When the mouse is released after rotation, we might want to snap our angle to the nearest 90 degree mark.
         */
        function finishRotation() {
            var ROTATE_SNAP_DEGREES = 5;

            var nearest90 = Math.round(canvasRotation / (Math.PI / 2)) * Math.PI / 2;

            if (Math.abs(canvasRotation - nearest90) < ROTATE_SNAP_DEGREES / 180 * Math.PI) {
                var deltaAngle = nearest90 - initAngle,
                    center = { x: canvas.width / 2, y: canvas.height / 2 },
                    rotTrans = new _CPTransform2.default();

                rotTrans.rotateAroundPoint(deltaAngle, center.x, center.y);

                rotTrans.multiply(initTransform);

                that.setRotation(initAngle + deltaAngle);
                that.setOffset(~~rotTrans.getTranslateX(), ~~rotTrans.getTranslateY());

                that.repaintAll();
            }
        }

        this.mouseUp = function (e, button, pressure) {
            if (this.capture && button == rotateButton) {
                if (dragged) {
                    finishRotation();
                } else {
                    that.resetRotation();
                }

                this.capture = false;

                if (this.transient && !(key.isPressed("space") && key.alt)) {
                    modeStack.pop();
                }

                return true;
            }
        };

        this.keyUp = function (e) {
            if (this.transient && rotateButton != BUTTON_WHEEL && e.keyCode == 32 /* Space */) {
                    setCursor(CURSOR_DEFAULT);

                    modeStack.pop(); // yield control to the default mode

                    return true;
                }
        };

        this.keyDown = function (e) {
            if (e.keyCode == 32 /* Space */ && e.altKey) {
                // That's our hotkey, so stay in this mode (don't forward to CPDefaultMode)
                return true;
            }
        };
    }

    CPRotateCanvasMode.prototype = Object.create(CPMode.prototype);
    CPRotateCanvasMode.prototype.constructor = CPRotateCanvasMode;

    function CPGradientFillMode() {
        // Super constructor
        CPLineMode.call(this);
    }

    CPGradientFillMode.prototype = Object.create(CPLineMode.prototype);
    CPGradientFillMode.prototype.constructor = CPGradientFillMode;

    CPGradientFillMode.prototype.drawLine = function (from, to) {
        artwork.gradientFill(Math.round(from.x), Math.round(from.y), Math.round(to.x), Math.round(to.y), controller.getCurGradient());
    };

    CPGradientFillMode.prototype.queueBrushPreview = function () {
        //Suppress the drawing of the brush preview (inherited from CPDrawingMode)
    };

    function setCursor(cursor) {
        if (canvas.getAttribute("data-cursor") != cursor) {
            canvas.setAttribute("data-cursor", cursor);
        }
    }

    /**
        * Check that we should be drawing to the current layer, and let the user know if they are being blocked by the
        * layer settings.
        *
        * @returns {boolean} True if we should draw to the current layer
        */
    function shouldDrawToThisLayer() {
        var activeLayer = artwork.getActiveLayer();

        if (!activeLayer.visible) {
            controller.showLayerNotification(artwork.getActiveLayerIndex(), "Whoops! This layer is currently hidden", "layer");

            return false;
        } else if (activeLayer.alpha == 0) {
            controller.showLayerNotification(artwork.getActiveLayerIndex(), "Whoops! This layer's opacity is currently 0%", "opacity");

            return false;
        }

        return true;
    }

    /**
     * Update the scrollbar's range/position to match the current view settings for the document.
     *
     * @param scrollbar {CPScrollbar}
     * @param visMin The smallest coordinate in this axis in which the drawing appears
     * @param visWidth The extent of the drawing in this axis
     * @param viewSize The extent of the screen canvas in this axis
     * @param offset The present pixel offset of the drawing in this axis
     */
    function updateScrollBar(scrollbar, visMin, visWidth, viewSize, offset) {
        var xMin = visMin - viewSize - offset + visWidth / 4,
            xMax = visMin + visWidth - offset - visWidth / 4;

        scrollbar.setValues(-offset, viewSize, xMin, xMax);

        scrollbar.setBlockIncrement(Math.max(1, ~~(viewSize * .66)));
        scrollbar.setUnitIncrement(Math.max(1, ~~(viewSize * .05)));
    }

    function updateScrollBars() {
        if (horzScroll == null || vertScroll == null || horzScroll.getValueIsAdjusting() || vertScroll.getValueIsAdjusting()) {
            return;
        }

        var visibleRect = getRefreshArea(new _CPRect2.default(0, 0, artworkCanvas.width, artworkCanvas.height));

        updateScrollBar(horzScroll, visibleRect.left, visibleRect.getWidth(), $(canvas).width(), that.getOffset().x);
        updateScrollBar(vertScroll, visibleRect.top, visibleRect.getHeight(), $(canvas).height(), that.getOffset().y);
    }

    function updateTransform() {
        transform.setToIdentity();
        transform.translate(offsetX, offsetY);
        transform.scale(zoom, zoom);
        transform.rotate(canvasRotation);

        updateScrollBars();
        that.repaintAll();
    }

    /**
     * Convert a canvas-relative coordinate into document coordinates and return the new coordinate.
     */
    function coordToDocument(coord) {
        // TODO cache inverted transform
        return transform.getInverted().getTransformedPoint(coord);
    }

    /**
     * Convert a canvas-relative coordinate into document coordinates.
     */
    function coordToDocumentInt(coord) {
        var result = coordToDocument(coord);

        result.x = Math.floor(result.x);
        result.y = Math.floor(result.y);

        return result;
    }

    /**
     * Convert a {x: pageX, y: pageY} co-ordinate pair from a mouse event to canvas-relative coordinates.
     */
    function mouseCoordToCanvas(coord) {
        var rect = canvas.getBoundingClientRect();

        return { x: coord.x - rect.left - window.pageXOffset, y: coord.y - rect.top - window.pageYOffset };
    }

    function coordToDisplay(p) {
        return transform.getTransformedPoint(p);
    }

    function coordToDisplayInt(p) {
        var result = coordToDisplay(p);

        result.x = Math.round(result.x);
        result.y = Math.round(result.y);

        return result;
    }

    /**
        * Convert a rectangle that encloses the given document pixels into a rectangle in display coordinates.
        *
        * @param rect {CPRect}
        * @returns {*[]}
        */
    function rectToDisplay(rect) {
        var center = coordToDisplay({ x: (rect.left + rect.right) / 2, y: (rect.top + rect.bottom) / 2 }),
            coords = rect.toPoints();

        for (var i = 0; i < coords.length; i++) {
            coords[i] = coordToDisplayInt(coords[i]);

            // Need to inset the co-ordinates by 0.5 display pixels for the line to pass through the middle of the display pixel
            coords[i].x += Math.sign(center.x - coords[i].x) * 0.5;
            coords[i].y += Math.sign(center.y - coords[i].y) * 0.5;
        }

        return coords;
    }

    function strokePolygon(context, coords) {
        context.beginPath();

        context.moveTo(coords[0].x, coords[0].y);
        for (var i = 1; i < coords.length; i++) {
            context.lineTo(coords[i].x, coords[i].y);
        }
        context.lineTo(coords[0].x, coords[0].y);

        context.stroke();
    }

    /**
     * Stroke a selection rectangle that encloses the pixels in the given rectangle (in document co-ordinates).
     */
    function plotSelectionRect(context, rect) {
        strokePolygon(context, rectToDisplay(rect));
    }

    /**
     * Take a CPRect of document coordinates and return a CPRect of canvas coordinates to repaint for that region.
     */
    function getRefreshArea(r) {
        var p1 = coordToDisplayInt({ x: r.left - 1, y: r.top - 1 }),
            p2 = coordToDisplayInt({ x: r.left - 1, y: r.bottom }),
            p3 = coordToDisplayInt({ x: r.right, y: r.top - 1 }),
            p4 = coordToDisplayInt({ x: r.right, y: r.bottom }),
            r2 = new _CPRect2.default(Math.min(Math.min(p1.x, p2.x), Math.min(p3.x, p4.x)), Math.min(Math.min(p1.y, p2.y), Math.min(p3.y, p4.y)), Math.max(Math.max(p1.x, p2.x), Math.max(p3.x, p4.x)) + 1, Math.max(Math.max(p1.y, p2.y), Math.max(p3.y, p4.y)) + 1);

        r2.grow(2, 2); // to be sure to include everything

        return r2;
    }

    /**
     * Adjust the current offset to bring the center of the artwork to the center of the canvas
     */
    function centerCanvas() {
        var width = canvas.width,
            height = canvas.height,
            artworkCenter = coordToDisplay({ x: artwork.width / 2, y: artwork.height / 2 });

        that.setOffset(Math.round(offsetX + width / 2.0 - artworkCenter.x), Math.round(offsetY + height / 2.0 - artworkCenter.y));
    }

    this.setZoom = function (_zoom) {
        zoom = _zoom;
        updateTransform();
    };

    this.getZoom = function () {
        return zoom;
    };

    this.setGridSize = function (_gridSize) {
        gridSize = Math.max(Math.round(_gridSize), 1);
        this.repaintAll();
    };

    this.getGridSize = function () {
        return gridSize;
    };

    this.setOffset = function (x, y) {
        if (isNaN(x) || isNaN(y)) {
            console.log("Bad offset");
        } else {
            offsetX = x;
            offsetY = y;
            updateTransform();
        }
    };

    this.getOffset = function () {
        return { x: offsetX, y: offsetY };
    };

    this.setInterpolation = function (enabled) {
        interpolation = enabled;

        (0, _CPPolyfill.setCanvasInterpolation)(canvasContext, enabled);

        this.repaintAll();
    };

    this.setRotation = function (angle) {
        canvasRotation = angle % (2 * Math.PI);
        updateTransform();
    };

    /**
     * Get canvas rotation in radians.
     * 
     * @return {number}
     */
    this.getRotation = function () {
        return canvasRotation;
    };

    /**
     * Get the rotation as the nearest number of whole 90 degree clockwise rotations ([0..3])
     */
    this.getRotation90 = function () {
        var rotation = Math.round(this.getRotation() / Math.PI * 2);

        // Just in case:
        rotation %= 4;

        // We want [0..3] as output
        if (rotation < 0) {
            rotation += 4;
        }

        return rotation;
    };

    /**
     *
     * @param zoom float
     * @param centerX float X co-ordinate in the canvas space
     * @param centerY float Y co-ordinate in the canvas space
     */
    function zoomOnPoint(zoom, centerX, centerY) {
        zoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, zoom));

        if (that.getZoom() != zoom) {
            var offset = that.getOffset();

            that.setOffset(offset.x + ~~((centerX - offset.x) * (1 - zoom / that.getZoom())), offset.y + ~~((centerY - offset.y) * (1 - zoom / that.getZoom())));

            that.setZoom(zoom);

            /*CPController.CPViewInfo viewInfo = new CPController.CPViewInfo();
            viewInfo.zoom = zoom;
            viewInfo.offsetX = offsetX;
            viewInfo.offsetY = offsetY;
            controller.callViewListeners(viewInfo); TODO */

            that.repaintAll();
        }
    }

    // More advanced zoom methods
    function zoomOnCenter(zoom) {
        var width = $(canvas).width(),
            height = $(canvas).height();

        zoomOnPoint(zoom, width / 2, height / 2);
    }

    this.zoomIn = function () {
        zoomOnCenter(this.getZoom() * 2);
    };

    this.zoomOut = function () {
        zoomOnCenter(this.getZoom() * 0.5);
    };

    this.zoom100 = function () {
        zoomOnCenter(1);
        centerCanvas();
    };

    this.resetRotation = function () {
        var center = { x: canvas.width / 2, y: canvas.height / 2 },
            rotTrans = new _CPTransform2.default();

        rotTrans.rotateAroundPoint(-this.getRotation(), center.x, center.y);
        rotTrans.multiply(transform);

        this.setOffset(~~rotTrans.getTranslateX(), ~~rotTrans.getTranslateY());
        this.setRotation(0);
    };

    /**
     * Add the pointer pressure field to the given pointer event.
     */
    function getPointerPressure(e) {
        // Use Wacom pressure in preference to pointer event pressure (if present)
        if (wacomPenDown) {
            return tablet.getPressure();
        } else {
            /* In the Pointer Events API, mice have a default pressure of 0.5, but we want 1.0. Since we can't 
             * distinguish between mice and pens at this point, we don't have any better options:
             */
            return e.pressure * 2;
        }
    }

    var mouseWheelDebounce = false;

    function handleMouseWheel(e) {
        if (e.deltaY != 0) {
            if (!mouseWheelDebounce || Math.abs(e.deltaY) > 20) {
                var factor;

                if (e.deltaY > 0) {
                    factor = 1 / 1.15;
                } else {
                    factor = 1.15;
                }

                var canvasPoint = mouseCoordToCanvas({ x: e.pageX, y: e.pageY }),
                    docPoint = coordToDocument(canvasPoint);

                if (artwork.isPointWithin(docPoint.x, docPoint.y)) {
                    zoomOnPoint(that.getZoom() * factor, canvasPoint.x, canvasPoint.y);
                } else {
                    zoomOnPoint(that.getZoom() * factor, offsetX + ~~(artwork.width * zoom / 2), offsetY + ~~(artwork.height * zoom / 2));
                }

                mouseWheelDebounce = mouseWheelDebounce || setTimeout(function () {
                    mouseWheelDebounce = false;
                }, 50);
            }

            e.preventDefault();
        }
    }

    var canvasClientRect;

    function handlePointerMove(e) {
        // Use the cached position of the canvas on the page if possible
        if (!canvasClientRect) {
            canvasClientRect = canvas.getBoundingClientRect();
        }

        /* Store these globally for the event handlers to refer to (we'd write to the event itself but some browsers
         * don't enjoy that)
         */
        mouseX = e.clientX - canvasClientRect.left;
        mouseY = e.clientY - canvasClientRect.top;

        // Flags used by e.buttons
        var FLAG_PRIMARY = 1,
            FLAG_SECONDARY = 2,
            FLAG_WHEEL = 4;

        var isDragging = e.buttons != 0,
            pressure = getPointerPressure(e);

        // Did any of our buttons change state?
        if ((e.buttons & FLAG_PRIMARY) != 0 != mouseDown[BUTTON_PRIMARY]) {
            if (e.mozPressure === 0.5) {
                /* We received a Mozilla "click" level of pressure (0.5) as a pointer-move
                 * before we received the actual mouseDown event (which carries the correct pressure).
                 *
                 * Observed on Firefox 56 on macOS High Sierra
                 */
                return; // Ignore!
            }

            mouseDown[BUTTON_PRIMARY] = !mouseDown[BUTTON_PRIMARY];

            if (mouseDown[BUTTON_PRIMARY]) {
                modeStack.mouseDown(e, BUTTON_PRIMARY, pressure);
            } else {
                modeStack.mouseUp(e, BUTTON_PRIMARY, pressure);
            }
        }

        if ((e.buttons & FLAG_SECONDARY) != 0 != mouseDown[BUTTON_SECONDARY]) {
            mouseDown[BUTTON_SECONDARY] = !mouseDown[BUTTON_SECONDARY];

            if (mouseDown[BUTTON_SECONDARY]) {
                modeStack.mouseDown(e, BUTTON_SECONDARY, pressure);
            } else {
                modeStack.mouseUp(e, BUTTON_SECONDARY, pressure);
            }
        }

        if ((e.buttons & FLAG_WHEEL) != 0 != mouseDown[BUTTON_WHEEL]) {
            mouseDown[BUTTON_WHEEL] = !mouseDown[BUTTON_WHEEL];

            if (mouseDown[BUTTON_WHEEL]) {
                modeStack.mouseDown(e, BUTTON_WHEEL, pressure);
            } else {
                modeStack.mouseUp(e, BUTTON_WHEEL, pressure);
            }
        }

        if (isDragging) {
            modeStack.mouseDrag(e, pressure);
        } else {
            modeStack.mouseMove(e, pressure);
        }
    }

    // Called when all mouse/pointer buttons are released
    function handlePointerUp(e) {
        mouseDown[BUTTON_PRIMARY] = false;
        mouseDown[BUTTON_SECONDARY] = false;
        mouseDown[BUTTON_WHEEL] = false;

        wacomPenDown = false;
        modeStack.mouseUp(e, e.button, 0.0);
        canvas.releasePointerCapture(e.pointerId);
    }

    // Called when the first button on the pointer is depressed / pen touches the surface
    function handlePointerDown(e) {
        canvas.setPointerCapture(e.pointerId);

        canvasClientRect = canvas.getBoundingClientRect();

        // Store these globally for the event handlers to refer to
        mouseX = e.clientX - canvasClientRect.left;
        mouseY = e.clientY - canvasClientRect.top;

        wacomPenDown = tablet.isPen();

        mouseDown[BUTTON_PRIMARY] = false;
        mouseDown[BUTTON_SECONDARY] = false;
        mouseDown[BUTTON_WHEEL] = false;

        mouseDown[e.button] = true;

        modeStack.mouseDown(e, e.button, getPointerPressure(e));
    }

    function handleKeyDown(e) {
        modeStack.keyDown(e);
    }

    function handleKeyUp(e) {
        modeStack.keyUp(e);
    }

    // Get the DOM element for the canvas area
    this.getElement = function () {
        return canvasContainer;
    };

    /**
     * Schedule a repaint for the current repaint region.
     */
    function repaint() {
        if (!scheduledRepaint) {
            scheduledRepaint = true;
            window.requestAnimationFrame(function () {
                that.paint();
            });
        }
    }

    /**
     * Schedule a repaint for the entire screen.
     */
    this.repaintAll = function () {
        repaintRegion.left = 0;
        repaintRegion.top = 0;
        repaintRegion.right = canvas.width;
        repaintRegion.bottom = canvas.height;

        repaint();
    };

    /**
     * Schedule a repaint for an area of the screen for later.
     * 
     * @param rect CPRect Region that should be repainted using display coordinates
     */
    function repaintRect(rect) {
        repaintRegion.union(rect);

        repaint();
    }

    /**
        * Set the globalCompositeOperation and fill/stroke color up to maximize contrast for the drawn items
        * against arbitrary backgrounds.
        *
        * @param canvasContext
        * @param {string} kind - "stroke" or "fill" depending on which colour you'd like to set
        */
    function setContrastingDrawStyle(canvasContext, kind) {
        kind = kind + "Style";
        canvasContext.globalCompositeOperation = 'exclusion';

        if (canvasContext.globalCompositeOperation == "exclusion") {
            // White + exclusion inverts the colors underneath, giving us good contrast
            canvasContext[kind] = 'white';
        } else {
            // IE Edge doesn't support Exclusion, so how about Difference with mid-grey instead
            // This is visible on black and white, but disappears on a grey background
            canvasContext.globalCompositeOperation = 'difference';
            canvasContext[kind] = '#888';

            // For super dumb browsers (only support source-over), at least don't make the cursor invisible on a white BG!
            if (canvasContext.globalCompositeOperation != "difference") {
                canvasContext[kind] = 'black';
            }
        }
    }

    this.paint = function () {
        var drawingWasClipped = false;

        scheduledRepaint = false;

        /* Clip drawing to the area of the screen we want to repaint */
        if (!repaintRegion.isEmpty()) {
            canvasContext.save();

            if (canvasContext.clip) {
                canvasContext.beginPath();

                repaintRegion.left = repaintRegion.left | 0;
                repaintRegion.top = repaintRegion.top | 0;

                canvasContext.rect(repaintRegion.left, repaintRegion.top, Math.ceil(repaintRegion.getWidth()), Math.ceil(repaintRegion.getHeight()));

                canvasContext.clip();
            }

            drawingWasClipped = true;
        }

        /* Copy pixels that changed in the document into our local fused image cache */
        if (!artworkUpdateRegion.isEmpty()) {
            var imageData = artwork.fusionLayers();

            artworkCanvasContext.putImageData(imageData, 0, 0, artworkUpdateRegion.left, artworkUpdateRegion.top, artworkUpdateRegion.getWidth(), artworkUpdateRegion.getHeight());

            artworkUpdateRegion.makeEmpty();
        }

        canvasContext.fillStyle = '#606060';
        canvasContext.fillRect(0, 0, canvas.width, canvas.height);

        // Transform the coordinate system to bring the document into the right position on the screen (translate/zoom/etc)
        canvasContext.save();
        {
            canvasContext.setTransform(transform.m[0], transform.m[1], transform.m[2], transform.m[3], transform.m[4], transform.m[5]);

            canvasContext.fillStyle = checkerboardPattern;
            canvasContext.fillRect(0, 0, artwork.width, artwork.height);

            canvasContext.drawImage(artworkCanvas, 0, 0, artworkCanvas.width, artworkCanvas.height);
        }
        canvasContext.restore();

        // The rest of the drawing happens using the original screen coordinate system
        setContrastingDrawStyle(canvasContext, "stroke");

        canvasContext.lineWidth = 1.0;

        // Draw the artwork selection so long as we're not in the middle of selecting a new rectangle
        if (!artwork.getSelection().isEmpty() && !(modeStack.peek() instanceof CPRectSelectionMode && modeStack.peek().capture)) {
            canvasContext.setLineDash([3, 2]);

            plotSelectionRect(canvasContext, artwork.getSelection());

            canvasContext.setLineDash([]);
        }

        // Draw grid
        if (showGrid) {
            var bounds = artwork.getBounds(),
                gridVisualPitch = zoom * gridSize;

            /* If the grid is going to be miniscule on the screen (basically just covering/inverting the entire artwork,
             * do not paint it.
             */
            if (gridVisualPitch > 2) {
                canvasContext.beginPath();

                // Vertical lines
                for (var i = gridSize - 1; i < bounds.right; i += gridSize) {
                    var p1 = coordToDisplay({ x: i, y: bounds.top }),
                        p2 = coordToDisplay({ x: i, y: bounds.bottom });

                    canvasContext.moveTo(p1.x + 0.5, p1.y + 0.5);
                    canvasContext.lineTo(p2.x + 0.5, p2.y + 0.5);
                }

                // Horizontal lines
                for (var i = gridSize - 1; i < bounds.bottom; i += gridSize) {
                    var p1 = coordToDisplay({ x: 0, y: i }),
                        p2 = coordToDisplay({ x: bounds.right, y: i });

                    canvasContext.moveTo(p1.x + 0.5, p1.y + 0.5);
                    canvasContext.lineTo(p2.x + 0.5, p2.y + 0.5);
                }

                canvasContext.stroke();
            }
        }

        // Additional drawing by the current mode
        modeStack.paint(canvasContext);

        canvasContext.globalCompositeOperation = 'source-over';

        if (drawingWasClipped) {
            repaintRegion.makeEmpty();

            canvasContext.restore();
        }
    };

    this.showGrid = function (show) {
        showGrid = show;
        this.repaintAll();
    };

    /**
     * Resize the canvas area to the given height (in pixels)
     *
     * @param {int} height New canvas area height in CSS pixels
     * @param {boolean} skipCenter True if the canvas should not be re-centered
     */
    this.resize = function (height, skipCenter) {
        // Leave room for the bottom scrollbar
        height -= $(canvasContainerBottom).outerHeight();

        $(canvas).css('height', height + "px");

        canvas.width = $(canvas).width();
        canvas.height = height;

        canvasClientRect = null;

        if (!skipCenter) {
            centerCanvas();
        }

        // Interpolation property gets reset when canvas resizes
        this.setInterpolation(interpolation);

        this.repaintAll();
    };

    controller.on("toolChange", function (tool, toolInfo) {
        var newMode = drawingModes[toolInfo.strokeMode];

        // If we currently have any drawing modes active, switch them to the drawing mode of the new tool
        for (var i = 0; i < modeStack.modes.length; i++) {
            if (modeStack.modes[i] instanceof CPDrawingMode) {
                modeStack.modes[i].leave();
                modeStack.modes[i] = newMode;
                modeStack.modes[i].enter();

                break;
            }
        }

        curDrawMode = newMode;
    });

    controller.on("modeChange", function (mode) {
        var newMode;

        switch (mode) {
            case _ChickenPaint2.default.M_DRAW:
                newMode = curDrawMode;
                break;

            case _ChickenPaint2.default.M_FLOODFILL:
                newMode = floodFillMode;
                break;

            case _ChickenPaint2.default.M_GRADIENTFILL:
                newMode = gradientFillMode;
                break;

            case _ChickenPaint2.default.M_RECT_SELECTION:
                newMode = rectSelectionMode;
                break;

            case _ChickenPaint2.default.M_MOVE_TOOL:
                newMode = moveToolMode;
                break;

            case _ChickenPaint2.default.M_ROTATE_CANVAS:
                newMode = rotateCanvasMode;
                break;

            case _ChickenPaint2.default.M_COLOR_PICKER:
                newMode = colorPickerMode;
                break;

            case _ChickenPaint2.default.M_TRANSFORM:
                newMode = transformMode;
                break;
        }

        modeStack.setUserMode(newMode);
    });

    //
    // Modes system: modes control the way the GUI is reacting to the user input
    // All the tools are implemented through modes
    //

    defaultMode = new CPDefaultMode();
    colorPickerMode = new CPColorPickerMode();
    panMode = new CPPanMode();
    rotateCanvasMode = new CPRotateCanvasMode();
    floodFillMode = new CPFloodFillMode();
    gradientFillMode = new CPGradientFillMode();
    rectSelectionMode = new CPRectSelectionMode();
    moveToolMode = new CPMoveToolMode();
    transformMode = new CPTransformMode();

    // this must correspond to the stroke modes defined in CPToolInfo
    drawingModes = [new CPFreehandMode(), new CPLineMode(), new CPBezierMode()];

    curDrawMode = drawingModes[_CPBrushInfo2.default.SM_FREEHAND];

    // The default mode will handle the events that no other modes are interested in
    modeStack.setDefaultMode(defaultMode);
    modeStack.setUserMode(curDrawMode);

    artworkCanvas.width = artwork.width;
    artworkCanvas.height = artwork.height;

    canvas.width = 800;
    canvas.height = 900;
    canvas.className = "chickenpaint-canvas";
    canvas.setAttribute("touch-action", "none");

    if (!canvasContext.setLineDash) {
        canvasContext.setLineDash = function () {}; // For IE 10 and older
    }

    canvas.addEventListener("contextmenu", function (e) {
        e.preventDefault();
    });

    canvas.addEventListener("mouseenter", function () {
        mouseIn = true;
    });

    canvas.addEventListener("mouseleave", function () {
        mouseIn = false;

        if (!mouseDown[BUTTON_PRIMARY] && !mouseDown[BUTTON_SECONDARY] && !mouseDown[BUTTON_WHEEL]) {
            that.repaintAll();
        }
    });

    canvas.addEventListener("pointerdown", handlePointerDown);
    canvas.addEventListener("pointermove", handlePointerMove);
    canvas.addEventListener("pointerup", handlePointerUp);
    canvas.addEventListener("wheel", handleMouseWheel);

    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    /* Workaround for Chrome Mac bug that causes canvas to be disposed and never recreated when tab is switched into the 
     * background https://bugs.chromium.org/p/chromium/issues/detail?id=588434
     */
    document.addEventListener("visibilitychange", function () {
        var oldHeight = canvas.height + $(canvasContainerBottom).outerHeight();

        canvas.width = 1;
        canvas.height = 1;

        that.resize(oldHeight, true);
    }, false);

    window.addEventListener("scroll", function () {
        canvasClientRect = null;
    });

    canvas.addEventListener("mousedown", function (e) {
        if (e.button == BUTTON_WHEEL) {
            // Prevent middle-mouse scrolling in Firefox
            e.preventDefault();
        }
    });

    artwork.on("changeSelection", function () {
        // We could keep track of our last-painted selection rect and only invalidate that here
        that.repaintAll();
    });

    artwork.on("updateRegion", function (region) {
        artworkUpdateRegion.union(region);

        repaintRect(getRefreshArea(artworkUpdateRegion));
    });

    horzScroll.on("valueChanged", function (value) {
        var p = that.getOffset();

        that.setOffset(-value, p.y);
    });

    vertScroll.on("valueChanged", function (value) {
        var p = that.getOffset();

        that.setOffset(p.x, -value);
    });

    this.setInterpolation(false);

    var canvasSpacingWrapper = document.createElement("div");

    canvasSpacingWrapper.className = 'chickenpaint-canvas-container-wrapper';
    canvasSpacingWrapper.appendChild(canvas);

    canvasContainerTop.className = 'chickenpaint-canvas-container-top';
    canvasContainerTop.appendChild(canvasSpacingWrapper);
    canvasContainerTop.appendChild(vertScroll.getElement());

    canvasContainerBottom.className = 'chickenpaint-canvas-container-bottom';
    canvasContainerBottom.appendChild(horzScroll.getElement());

    canvasContainer.appendChild(canvasContainerTop);
    canvasContainer.appendChild(canvasContainerBottom);

    controller.setCanvas(this);
}
module.exports = exports["default"];

},{"../ChickenPaint":1,"../engine/CPBrushInfo":5,"../util/CPBezier":46,"../util/CPPolyfill":49,"../util/CPPolygon":50,"../util/CPRect":52,"../util/CPTransform":53,"../util/CPVector":54,"../util/CPWacomTablet":55,"../util/throttle-debounce":56,"./CPGUIUtils":26,"./CPScrollbar":34}],20:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPCheckbox;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPCheckbox(state, title) {
    var canvas = document.createElement('canvas'),
        canvasContext = canvas.getContext('2d'),
        that = this;

    this.state = state || false;

    function paint() {
        var width = canvas.width,
            height = canvas.height;

        canvasContext.clearRect(0, 0, width, height);

        canvasContext.beginPath();
        canvasContext.arc(width / 2 + 1, width / 2 + 1, Math.max(width / 2, 1) - 2, 0, Math.PI * 2);

        if (that.state) {
            canvasContext.fill();
        } else {
            canvasContext.stroke();
        }
    }

    this.setValue = function (b) {
        if (this.state != b) {
            this.state = b;

            this.emitEvent('valueChange', [b]);

            paint();
        }
    };

    this.getElement = function () {
        return canvas;
    };

    canvas.addEventListener("mousedown", function (e) {
        that.setValue(!that.state);
    });

    canvas.title = title || "";
    canvas.className = 'chickenpaint-checkbox';

    canvas.width = 20;
    canvas.height = 20;

    canvas.fillStyle = 'black';
    canvas.strokeStyle = 'black';

    paint();
};

CPCheckbox.prototype = Object.create(EventEmitter.prototype);
CPCheckbox.prototype.constructor = CPCheckbox;
module.exports = exports['default'];

},{}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPColorPalette;

var _CPPalette = require('./CPPalette');

var _CPPalette2 = _interopRequireDefault(_CPPalette);

var _CPColorSelect = require('./CPColorSelect');

var _CPColorSelect2 = _interopRequireDefault(_CPColorSelect);

var _CPColorSlider = require('./CPColorSlider');

var _CPColorSlider2 = _interopRequireDefault(_CPColorSlider);

var _CPColor = require('../util/CPColor');

var _CPColor2 = _interopRequireDefault(_CPColor);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPColorPalette(cpController) {
    _CPPalette2.default.call(this, cpController, "color", "Color");

    var colorSelect = new _CPColorSelect2.default(cpController),
        colorSlider = new _CPColorSlider2.default(cpController, colorSelect),
        colorShow = new CPColorShow(cpController),
        body = this.getBodyElement(),
        topSection = document.createElement("div");

    topSection.className = 'chickenpaint-colorpicker-top';

    topSection.appendChild(colorSelect.getElement());
    topSection.appendChild(colorSlider.getElement());

    body.appendChild(topSection);
    body.appendChild(colorShow.getElement());
}

function CPColorShow(cpController) {
    var color = 0,
        element = document.createElement("div");

    function padLeft(string, padding, len) {
        while (string.length < len) {
            string = padding + string;
        }
        return string;
    }

    function paint() {
        element.style.backgroundColor = '#' + padLeft(Number(color).toString(16), "0", 6);
    }

    function mouseClick(e) {
        e.preventDefault();

        var colHex = "#" + padLeft(Number(color).toString(16), "0", 6);

        colHex = window.prompt("Please enter a color in hex format", colHex);

        if (colHex != null) {
            try {
                if (colHex.match(/^#/) || colHex.match(/^$/)) {
                    colHex = colHex.substring(1);
                }

                var newColor = parseInt(colHex, 16);

                cpController.setCurColor(new _CPColor2.default(newColor));
            } catch (e) {}
        }
    }

    this.getElement = function () {
        return element;
    };

    cpController.on("colorChange", function (_color) {
        color = _color.getRgb();
        paint();
    });

    element.className = 'chickenpaint-colorpicker-show';

    element.addEventListener("click", mouseClick);

    paint();
}

CPColorPalette.prototype = Object.create(_CPPalette2.default.prototype);
CPColorPalette.prototype.constructor = CPColorPalette;
module.exports = exports['default'];

},{"../util/CPColor":47,"./CPColorSelect":22,"./CPColorSlider":23,"./CPPalette":32}],22:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPColorSelect;

var _CPColor = require("../util/CPColor");

var _CPColor2 = _interopRequireDefault(_CPColor);

var _CPColorBmp = require("../engine/CPColorBmp");

var _CPColorBmp2 = _interopRequireDefault(_CPColorBmp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPColorSelect(cpController, initialColor) {
    var w = 128,
        h = 128,
        canvas = document.createElement("canvas"),
        canvasContext = canvas.getContext("2d"),
        imageData = canvasContext.createImageData(w, h),
        data = imageData.data,
        color = new _CPColor2.default(),
        needRefresh = true,
        capturedMouse = false;

    function makeBitmap() {
        var col = color.clone(),
            pixIndex = 0;

        for (var y = 0; y < h; y++) {
            col.setValue(255 - y * 255 / h);

            for (var x = 0; x < w; x++) {
                col.setSaturation(x * 255 / w);

                data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = col.rgb >> 16 & 0xFF;
                data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = col.rgb >> 8 & 0xFF;
                data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = col.rgb & 0xFF;
                data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = 0xFF;

                pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL;
            }
        }

        needRefresh = false;
    }

    function paint() {
        if (needRefresh) {
            makeBitmap();
        }

        canvasContext.putImageData(imageData, 0, 0, 0, 0, w, h);

        var x = color.getSaturation() * w / 255,
            y = (255 - color.getValue()) * h / 255;

        canvasContext.globalCompositeOperation = 'exclusion';
        canvasContext.strokeStyle = 'white';
        canvasContext.lineWidth = 1.5;

        canvasContext.beginPath();
        canvasContext.arc(x, y, 5, 0, Math.PI * 2);
        canvasContext.stroke();

        canvasContext.globalCompositeOperation = 'source-over';
    }

    function mousePickColor(e) {
        var x = e.pageX - $(canvas).offset().left,
            y = e.pageY - $(canvas).offset().top,
            sat = x * 255 / w,
            value = 255 - y * 255 / h;

        color.setSaturation(Math.max(0, Math.min(255, sat)));
        color.setValue(Math.max(0, Math.min(255, value)));

        paint();
        cpController.setCurColor(color);
    }

    function continueDrag(e) {
        mousePickColor(e);
    }

    function endDrag(e) {
        canvas.releasePointerCapture(e.pointerId);
        capturedMouse = false;
        canvas.removeEventListener("pointerup", endDrag);
        canvas.removeEventListener("pointermove", continueDrag);
    }

    function startDrag(e) {
        if (!capturedMouse) {
            capturedMouse = true;
            canvas.setPointerCapture(e.pointerId);
            canvas.addEventListener("pointerup", endDrag);
            canvas.addEventListener("pointermove", continueDrag);
        }

        mousePickColor(e);
    }

    this.setHue = function (hue) {
        if (color.getHue() != hue) {
            color.setHue(hue);
            cpController.setCurColor(color);
        }
    };

    this.getElement = function () {
        return canvas;
    };

    cpController.on("colorChange", function (c) {
        color.copyFrom(c);

        needRefresh = true;
        paint();
    });

    canvas.addEventListener("pointerdown", startDrag);

    canvas.className = 'chickenpaint-colorpicker-select';
    canvas.setAttribute("touch-action", "none");

    canvas.width = w;
    canvas.height = h;

    if (initialColor) {
        color.copyFrom(initialColor);
    }

    paint();
}
module.exports = exports["default"];

},{"../engine/CPColorBmp":9,"../util/CPColor":47}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPColorSlider;

var _CPColor = require("../util/CPColor");

var _CPColor2 = _interopRequireDefault(_CPColor);

var _CPColorBmp = require("../engine/CPColorBmp");

var _CPColorBmp2 = _interopRequireDefault(_CPColorBmp);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPColorSlider(cpController, selecter, initialHue) {
    var that = this,
        w = 24,
        h = 128,
        canvas = document.createElement("canvas"),
        canvasContext = canvas.getContext("2d"),
        imageData = canvasContext.createImageData(w, h),
        data = imageData.data,
        capturedMouse = false,
        hue = initialHue || 0;

    function makeBitmap() {
        var color = new _CPColor2.default(),
            pixIndex = 0;

        color.setRgbComponents(0, 255, 255);

        for (var y = 0; y < h; y++) {
            color.setHue(y * 359 / h);

            for (var x = 0; x < w; x++) {
                data[pixIndex + _CPColorBmp2.default.RED_BYTE_OFFSET] = color.rgb >> 16 & 0xFF;
                data[pixIndex + _CPColorBmp2.default.GREEN_BYTE_OFFSET] = color.rgb >> 8 & 0xFF;
                data[pixIndex + _CPColorBmp2.default.BLUE_BYTE_OFFSET] = color.rgb & 0xFF;
                data[pixIndex + _CPColorBmp2.default.ALPHA_BYTE_OFFSET] = 0xFF;

                pixIndex += _CPColorBmp2.default.BYTES_PER_PIXEL;
            }
        }
    }

    function paint() {
        canvasContext.putImageData(imageData, 0, 0, 0, 0, w, h);

        var y = hue * h / 360;

        canvasContext.globalCompositeOperation = 'exclusion';
        canvasContext.strokeStyle = 'white';
        canvasContext.lineWidth = 1.5;

        canvasContext.beginPath();
        canvasContext.moveTo(0, y);
        canvasContext.lineTo(w, y);
        canvasContext.stroke();

        canvasContext.globalCompositeOperation = 'source-over';
    }

    function mousePickColor(e) {
        var y = e.pageY - $(canvas).offset().top,
            _hue = ~~(y * 360 / h);

        hue = Math.max(0, Math.min(359, _hue));
        paint();

        if (selecter != null) {
            selecter.setHue(hue);
        }
    }

    function continueDrag(e) {
        mousePickColor(e);
    }

    function endDrag(e) {
        canvas.releasePointerCapture(e.pointerId);
        capturedMouse = false;
        canvas.removeEventListener("pointerup", endDrag);
        canvas.removeEventListener("pointermove", continueDrag);
    }

    function startDrag(e) {
        if (!capturedMouse) {
            capturedMouse = true;
            canvas.setPointerCapture(e.pointerId);
            canvas.addEventListener("pointerup", endDrag);
            canvas.addEventListener("pointermove", continueDrag);
        }

        mousePickColor(e);
    }

    this.getElement = function () {
        return canvas;
    };

    this.setHue = function (h) {
        hue = h;
        paint();
    };

    cpController.on("colorChange", function (color) {
        that.setHue(color.getHue());
    });

    canvas.setAttribute("touch-action", "none");

    canvas.addEventListener("pointerdown", startDrag);

    canvas.width = w;
    canvas.height = h;

    canvas.className = 'chickenpaint-colorpicker-slider';

    makeBitmap();
    paint();
}
module.exports = exports["default"];

},{"../engine/CPColorBmp":9,"../util/CPColor":47}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPColorSwatch;

var _CPColor = require('../util/CPColor');

var _CPColor2 = _interopRequireDefault(_CPColor);

var _CPSlider = require('./CPSlider');

var _CPSlider2 = _interopRequireDefault(_CPSlider);

var _CPColorSelect = require('./CPColorSelect');

var _CPColorSelect2 = _interopRequireDefault(_CPColorSelect);

var _CPColorSlider = require('./CPColorSlider');

var _CPColorSlider2 = _interopRequireDefault(_CPColorSlider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint

    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.

    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPColorSwatch(initialColor, initialAlpha) {
    var that = this,
        color = new _CPColor2.default(0),
        alpha = 255,
        element = document.createElement("div");

    function padLeft(string, padding, len) {
        while (string.length < len) {
            string = padding + string;
        }
        return string;
    }

    function paint() {
        element.style.backgroundColor = '#' + padLeft(Number(color.getRgb()).toString(16), "0", 6);
    }

    function mouseClick(e) {
        e.preventDefault();
    }

    this.getElement = function () {
        return element;
    };

    this.setColor = function (_color) {
        if (!color.isEqual(_color)) {
            color.copyFrom(_color);

            paint();

            this.emitEvent("colorChange", [color]);
        }
    };

    this.setAlpha = function (_alpha) {
        if (_alpha != alpha) {
            alpha = _alpha;

            paint();

            this.emitEvent("alphaChange", [alpha]);
        }
    };

    this.getColorRgb = function () {
        return color.getRgb();
    };

    this.getAlpha = function () {
        return alpha;
    };

    this.setCurColor = this.setColor;

    function buildColorEditPanel() {
        var panel = document.createElement("div"),
            group = document.createElement("div"),
            select = new _CPColorSelect2.default(that, color),
            slider = new _CPColorSlider2.default(that, select, color.getHue()),
            alphaSlider = new _CPSlider2.default(0, 255);

        panel.className = "chickenpaint-color-pick-panel";

        group.className = "chickenpaint-colorpicker-top";

        group.appendChild(select.getElement());
        group.appendChild(slider.getElement());

        panel.appendChild(group);

        alphaSlider.value = alpha;
        alphaSlider.title = function (alpha) {
            return "Opacity: " + alpha;
        };
        alphaSlider.on("valueChange", function (alpha) {
            that.setAlpha(alpha);
        });

        panel.appendChild(alphaSlider.getElement());

        setTimeout(function () {
            alphaSlider.resize();
        }, 0);

        return panel;
    }

    element.className = 'chickenpaint-color-pick-swatch';

    element.addEventListener("click", mouseClick);

    if (initialColor) {
        color.copyFrom(initialColor);
    }

    if (initialAlpha) {
        alpha = initialAlpha;
    }

    // Clicking outside the popover will dismiss it
    function closeClickHandler(e) {
        if ($(e.target).closest(".popover").length == 0 && $(e.target).closest(".chickenpaint-color-pick-swatch")[0] != element) {
            $(element).popover("hide");
        }
    }

    $(element).popover({
        html: true,
        content: function content() {
            window.addEventListener("mousedown", closeClickHandler);

            return buildColorEditPanel();
        },
        trigger: "manual",
        placement: "bottom"

    }).on("click", function () {
        $(this).popover("toggle");
    }).on("hidden.bs.popover", function () {
        window.removeEventListener("mousedown", closeClickHandler);
    });

    paint();
}

CPColorSwatch.prototype = Object.create(EventEmitter.prototype);
CPColorSwatch.prototype.constructor = CPColorSwatch;
module.exports = exports['default'];

},{"../util/CPColor":47,"./CPColorSelect":22,"./CPColorSlider":23,"./CPSlider":37}],25:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = CPConfirmTransformDialog;
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/
function CPConfirmTransformDialog(parent, controller) {
	var dialog = $("<div class=\"modal fade\" tabindex=\"-1\" role=\"dialog\">\n\t            <div class=\"modal-dialog\">\n\t                <div class=\"modal-content\">\n\t                    <div class=\"modal-header\">\n\t                        <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n\t                            <span aria-hidden=\"true\">&times;</span>\n\t                        </button>\n\t                        <h4 class=\"modal-title\">Complete transform</h4>\n\t                    </div>\n\t                    <div class=\"modal-body\">\n\t                        <p>\n\t                            You need to finish transforming this layer before you can do that. What would you like to do with the transform?\n\t\t\t\t\t\t\t</p>\n\t                    </div>\n\t                    <div class=\"modal-footer\">\n\t                        <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">Cancel</button>\n\t                        <button type=\"button\" class=\"btn btn-default chickenpaint-reject-transform\" data-dismiss=\"modal\">Undo transform</button>\n\t                        <button type=\"button\" class=\"btn btn-primary chickenpaint-accept-transform\" data-dismiss=\"modal\">Apply transform</button>\n\t                    </div>\n\t                </div>\n\t            </div>\n\t        </div>\n\t    "),
	    that = this,
	    applyButton = $(".chickenpaint-accept-transform", dialog),
	    rejectButton = $(".chickenpaint-reject-transform", dialog);

	applyButton.click(function (e) {
		controller.actionPerformed({ action: "CPTransformAccept" });
		that.emitEvent("accept");
	});

	rejectButton.click(function (e) {
		controller.actionPerformed({ action: "CPTransformReject" });
		that.emitEvent("reject");
	});

	dialog.modal({
		show: false
	}).on('shown.bs.modal', function () {
		applyButton.focus();
	}).on("hidden.bs.modal", function (e) {
		// Destroy the modal upon close
		dialog.remove();
	}).on('keypress', function (e) {
		if (e.keyCode == 13) {
			applyButton.click();
		}
	});

	// Fix the backdrop location in the DOM by reparenting it to the chickenpaint container
	dialog.data("bs.modal").$body = $(parent);

	parent.appendChild(dialog[0]);

	this.show = function () {
		dialog.modal("show");
	};
}

CPConfirmTransformDialog.prototype = Object.create(EventEmitter.prototype);
CPConfirmTransformDialog.prototype.constructor = CPConfirmTransformDialog;
module.exports = exports["default"];

},{}],26:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createCheckerboardPattern = createCheckerboardPattern;
/**
 * Create a checkerboard HTML5 CanvasPattern (which can be used for fillStyle) using the given canvas context.
 * 
 * @param canvasContext
 * @returns {CanvasPattern}
 */
function createCheckerboardPattern(canvasContext) {
    var checkerboardCanvas = document.createElement("canvas"),
        checkerboardContext = checkerboardCanvas.getContext("2d"),
        imageData = checkerboardContext.createImageData(64, 64),
        data = imageData.data,
        pixelOffset = 0;

    for (var j = 0; j < 64; j++) {
        for (var i = 0; i < 64; i++) {
            if ((i & 0x8) != 0 ^ (j & 0x8) != 0) {
                // White
                data[pixelOffset++] = 0xff;
                data[pixelOffset++] = 0xff;
                data[pixelOffset++] = 0xff;
                data[pixelOffset++] = 0xff;
            } else {
                // Grey
                data[pixelOffset++] = 0xcc;
                data[pixelOffset++] = 0xcc;
                data[pixelOffset++] = 0xcc;
                data[pixelOffset++] = 0xff;
            }
        }
    }

    checkerboardCanvas.width = 64;
    checkerboardCanvas.height = 64;
    checkerboardContext.putImageData(imageData, 0, 0);

    return canvasContext.createPattern(checkerboardCanvas, 'repeat');
}

},{}],27:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPGridDialog;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPGridDialog(parent, canvas) {
    var dialog = $("<div class=\"modal fade\" tabindex=\"-1\" role=\"dialog\">\n                <div class=\"modal-dialog\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                                <span aria-hidden=\"true\">&times;</span>\n                            </button>\n                            <h4 class=\"modal-title\">Grid options</h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <form>\n                                <div class=\"form-group\">\n                                    <label>Grid size</label>\n                                    <input type=\"text\" class=\"form-control chickenpaint-grid-size\" value=\"\" autofocus>\n                                </div>\n                            </form>\n                        </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-default\" data-dismiss=\"modal\">Cancel</button>\n                            <button type=\"button\" class=\"btn btn-primary chickenpaint-apply-grid-settings\" data-dismiss=\"modal\">Ok</button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        "),
        gridSizeElem = $(".chickenpaint-grid-size", dialog),
        applyButton = $(".chickenpaint-apply-grid-settings", dialog);

    gridSizeElem.val(canvas.getGridSize());

    $(".chickenpaint-apply-grid-settings", dialog).click(function (e) {
        var gridSize = parseInt(gridSizeElem.val(), 10);

        canvas.setGridSize(gridSize);
    });

    dialog.modal({
        show: false
    }).on('shown.bs.modal', function () {
        gridSizeElem.focus();
    }).on('keypress', function (e) {
        if (e.keyCode == 13) {
            applyButton.click();
        }
    });

    // Fix the backdrop location in the DOM by reparenting it to the chickenpaint container
    dialog.data("bs.modal").$body = $(parent);

    parent.appendChild(dialog[0]);

    this.show = function () {
        dialog.modal("show");
    };
}
module.exports = exports["default"];

},{}],28:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPLayersPalette;

var _CPPalette = require("./CPPalette");

var _CPPalette2 = _interopRequireDefault(_CPPalette);

var _CPSlider = require("./CPSlider");

var _CPSlider2 = _interopRequireDefault(_CPSlider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPLayersPalette(controller) {
    _CPPalette2.default.call(this, controller, "layers", "Layers", true);

    var MODE_NAMES = ["Normal", "Multiply", "Add", "Screen", "Lighten", "Darken", "Subtract", "Dodge", "Burn", "Overlay", "Hard Light", "Soft Light", "Vivid Light", "Linear Light", "Pin Light"];

    var palette = this,
        layerH = 32,
        eyeW = 24,
        body = this.getBodyElement(),
        layerWidget = new CPLayerWidget(),
        alphaSlider = new _CPSlider2.default(0, 100),
        blendCombo = document.createElement("select"),
        renameField = new CPRenameField(),
        cbSampleAllLayers = document.createElement("input"),
        cbLockAlpha = document.createElement("input"),
        addButton = document.createElement("li"),
        removeButton = document.createElement("li");

    function fillCombobox(combo, optionNames) {
        for (var i = 0; i < optionNames.length; i++) {
            var option = document.createElement("option");

            option.appendChild(document.createTextNode(optionNames[i]));
            option.value = i;

            combo.appendChild(option);
        }
    }

    function wrapCheckboxWithLabel(checkbox, title) {
        var div = document.createElement("div"),
            label = document.createElement("label");

        div.className = "checkbox";

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(title));

        div.appendChild(label);

        return div;
    }

    function showRenameControl(layerIndex) {
        var d = layerWidget.getCSSSize(),
            artwork = controller.getArtwork(),
            layer = artwork.getLayer(layerIndex);

        renameField.show(eyeW / window.devicePixelRatio, d.height - (layerIndex + 1) * layerH / window.devicePixelRatio, layerIndex, layer.name);
    }

    var parentSetSize = this.setSize,
        parentSetHeight = this.setHeight;

    this.setSize = function (w, h) {
        parentSetSize.call(this, w, h);

        layerWidget.resize();
        alphaSlider.resize();
    };

    this.setHeight = function (h) {
        parentSetHeight.call(this, h);

        layerWidget.resize();
    };

    function CPLayerWidget() {
        var NOTIFICATION_HIDE_DELAY_MS_PER_CHAR = 70,
            NOTIFICATION_HIDE_DELAY_MIN = 3000;

        var layerDrag,
            layerDragReally,
            layerDragIndex,
            layerDragY,
            container = document.createElement("div"),
            canvas = document.createElement("canvas"),
            canvasContext = canvas.getContext("2d"),
            oldApplyPlacement,
            notificationMessage = "",
            notificationLayerIndex = -1,
            notificationLocation = "",
            dismissTimer = false,
            that = this;

        /**
         * Get the size of the component on screen in CSS pixels.
         */
        this.getCSSSize = function () {
            return { width: $(canvas).width(), height: $(canvas).height() };
        };

        function getLayerIndex(point) {
            return Math.floor((canvas.height - point.y / $(canvas).height() * canvas.height) / layerH);
        }

        /**
         * @param layer CPLayer
         * @param selected boolean
         */
        function drawLayer(layer, selected) {
            var d = { width: canvas.width, height: canvas.height };

            if (selected) {
                canvasContext.fillStyle = '#B0B0C0';
            } else {
                canvasContext.fillStyle = 'white';
            }
            canvasContext.fillRect(0, 0, d.width, layerH);

            canvasContext.beginPath();

            canvasContext.moveTo(0, 0);
            canvasContext.lineTo(d.width, 0);

            canvasContext.moveTo(eyeW, 0);
            canvasContext.lineTo(eyeW, layerH);

            canvasContext.moveTo(eyeW + 6 * window.devicePixelRatio, layerH / 2);
            canvasContext.lineTo(d.width - 6 * window.devicePixelRatio, layerH / 2);

            canvasContext.stroke();

            canvasContext.fillStyle = 'black';

            canvasContext.fillText(layer.name, eyeW + 6 * window.devicePixelRatio, 12 * window.devicePixelRatio);
            canvasContext.fillText(MODE_NAMES[layer.blendMode] + ": " + layer.alpha + "%", eyeW + 6 * window.devicePixelRatio, layerH - 5 * window.devicePixelRatio);

            canvasContext.beginPath();
            if (layer.visible) {
                canvasContext.arc(eyeW / 2, layerH / 2, 9 * window.devicePixelRatio, 0, Math.PI * 2);
                canvasContext.fill();
            } else {
                canvasContext.arc(eyeW / 2, layerH / 2, 9 * window.devicePixelRatio, 0, Math.PI * 2);
                canvasContext.stroke();
            }
        }

        function mouseUp(e) {
            if (e.button == 0) {
                var offset = $(canvas).offset(),
                    artwork = controller.getArtwork(),
                    layers = artwork.getLayers(),
                    mouseLoc = { x: e.pageX - offset.left, y: e.pageY - offset.top },
                    layerOver = getLayerIndex(mouseLoc);

                //layerDragY = e.pageY - offset.top;

                if (layerOver >= 0 && layerOver <= layers.length && layerOver != layerDragIndex && layerOver != layerDragIndex + 1) {
                    controller.actionPerformed({ action: "CPMoveLayer", fromIndex: layerDragIndex, toIndex: layerOver });
                }

                // Do we need to repaint to erase draglines?
                if (layerDragReally) {
                    layerDragReally = false;
                    that.paint();
                }

                layerDrag = false;

                window.removeEventListener("mousemove", mouseDragged);
                window.removeEventListener("mouseup", mouseUp);
            }
        }

        function mouseDragged(e) {
            if (layerDrag) {
                layerDragReally = true;
                layerDragY = e.pageY - $(canvas).offset().top;
                that.paint();
            }
        }

        /**
         * Repaint just the layer with the specified index
         */
        this.paintLayer = function (layerIndex) {
            var layer = artwork.getLayer(layerIndex),
                layerTop = canvas.height - layerH * (layerIndex + 1);

            canvasContext.save();

            canvasContext.fillStyle = '#606060';
            canvasContext.fillRect(0, layerTop, canvas.width, layerH);

            canvasContext.strokeStyle = 'black';

            canvasContext.translate(0, layerTop);
            drawLayer(layer, layerIndex == artwork.getActiveLayerIndex());

            canvasContext.restore();
        };

        /**
         * Repaint the entire control
         */
        this.paint = function () {
            var artwork = controller.getArtwork(),
                layers = artwork.getLayers(),
                d = { width: canvas.width, height: canvas.height },
                canvasScaleFactor = canvas.height / $(canvas).height();

            canvasContext.save();

            canvasContext.fillStyle = '#606060';
            canvasContext.fillRect(0, 0, d.width, d.height - layers.length * layerH);

            canvasContext.strokeStyle = 'black';

            // Draw the list of layers, with the first layer at the bottom of the control
            canvasContext.translate(0, d.height - layerH);

            for (var i = 0; i < layers.length; i++) {
                drawLayer(layers[i], i == artwork.getActiveLayerIndex());
                canvasContext.translate(0, -layerH);
            }

            if (layerDragReally) {
                canvasContext.translate(0, layers.length * layerH - (d.height - layerH));
                canvasContext.strokeRect(0, layerDragY * canvasScaleFactor - layerH / 2, d.width, layerH);

                var layerOver = getLayerIndex({ x: 0, y: layerDragY });

                if (layerOver <= layers.length && layerOver != layerDragIndex && layerOver != layerDragIndex + 1) {
                    canvasContext.fillRect(0, d.height - layerOver * layerH - 2, d.width, 4 * window.devicePixelRatio);
                }
            }

            canvasContext.restore();
        };

        this.resize = function () {
            var artwork = controller.getArtwork(),


            // Our parent container will act as our scrollbar clip area
            parent = $(canvas).parent(),
                parentHeight = parent.height(),
                parentWidth = parent.width(),
                newWidth,
                newHeight;

            layerH = 34 * window.devicePixelRatio;
            eyeW = 24 * window.devicePixelRatio;

            newWidth = parentWidth * window.devicePixelRatio;
            newHeight = Math.max(layerH * artwork.getLayerCount(), parentHeight * window.devicePixelRatio);

            // Should we trigger a scrollbar to appear?
            if (newHeight > parentHeight * window.devicePixelRatio) {
                // Take the scrollbar width into account in our width
                newWidth -= 15 * window.devicePixelRatio;
                parent[0].style.overflowY = 'scroll';
            } else {
                parent[0].style.overflowY = 'hidden';
            }

            canvas.width = newWidth;
            canvas.height = newHeight;

            canvas.style.width = newWidth / window.devicePixelRatio + "px";
            canvas.style.height = newHeight / window.devicePixelRatio + "px";

            canvasContext.font = layerH * 0.25 + "pt sans-serif";

            this.paint();
            this.dismissNotification();
        };

        this.getElement = function () {
            return container;
        };

        canvas.addEventListener("click", function (e) {
            if (renameField.isVisible()) {
                renameField.renameAndHide();
            }
        });

        canvas.addEventListener("dblclick", function (e) {
            var offset = $(canvas).offset(),
                mouseLoc = { x: e.pageX - offset.left, y: e.pageY - offset.top },
                layerIndex = getLayerIndex(mouseLoc);

            if (mouseLoc.x * window.devicePixelRatio > eyeW && layerIndex >= 0 && layerIndex < artwork.getLayerCount()) {
                showRenameControl(layerIndex);
            }
        });

        canvas.addEventListener("mousedown", function (e) {
            var offset = $(canvas).offset(),
                mouseLoc = { x: e.pageX - offset.left, y: e.pageY - offset.top };

            /* Click, moved from mouseClicked due to problems with focus and stuff */
            if (e.button == 0) {
                /* Left button */
                var artwork = controller.getArtwork(),
                    layers = artwork.getLayers(),
                    layerIndex = getLayerIndex(mouseLoc);

                if (layerIndex >= 0 && layerIndex < artwork.getLayerCount()) {
                    var layer = artwork.getLayer(layerIndex);

                    if (mouseLoc.x / $(canvas).width() * canvas.width < eyeW) {
                        controller.actionPerformed({ action: "CPSetLayerVisibility", layerIndex: layerIndex, visible: !layer.visible });
                    } else if (artwork.getActiveLayerIndex() != layerIndex) {
                        controller.actionPerformed({ action: "CPSetActiveLayerIndex", layerIndex: layerIndex });
                    }
                }

                if (layerIndex < layers.length) {
                    layerDrag = true;
                    layerDragY = mouseLoc.y;
                    layerDragIndex = layerIndex;

                    window.addEventListener("mousemove", mouseDragged);
                    window.addEventListener("mouseup", mouseUp);
                }
            }
        });

        /**
         * Scroll the layer widget until the layer with the given index is fully visible.
         *
         * @param layerIndex
         */
        function revealLayer(layerIndex) {
            var layerWidgetPos = canvas.getBoundingClientRect(),
                scrollBoxPos = container.getBoundingClientRect(),
                scrollBoxHeight = scrollBoxPos.bottom - scrollBoxPos.top,
                layerHeight = layerH / window.devicePixelRatio,
                layerTop = layerWidgetPos.bottom - layerHeight * (layerIndex + 1),
                layerBottom = layerTop + layerHeight;

            container.scrollTop = Math.max(Math.min(Math.max(container.scrollTop, layerBottom - layerWidgetPos.top - scrollBoxHeight), layerTop - layerWidgetPos.top), 0);
        }

        this.dismissNotification = function () {
            $(canvas).popover('hide');
        };

        this.showNotification = function (layerIndex, message, where) {
            notificationMessage = message;
            notificationLayerIndex = layerIndex;

            if (artwork.getActiveLayerIndex() == layerIndex && where == "opacity") {
                notificationLocation = "opacity";
            } else {
                notificationLocation = "layer";
                revealLayer(layerIndex);
            }

            $(canvas).popover("show");

            if (dismissTimer) {
                clearTimeout(dismissTimer);
            }
            dismissTimer = setTimeout(function () {
                dismissTimer = false;
                that.dismissNotification();
            }, Math.max(Math.round(notificationMessage.length * NOTIFICATION_HIDE_DELAY_MS_PER_CHAR), NOTIFICATION_HIDE_DELAY_MIN));
        };

        /* Reposition the popover to the layer/location that the notification applies to */
        function applyNotificationPlacement(offset, placement) {
            oldApplyPlacement.call(this, offset, placement);

            var $tip = this.tip(),
                $arrow = this.arrow(),
                layerWidgetPos = canvas.getBoundingClientRect(),
                scrollBoxPos = container.getBoundingClientRect();

            switch (notificationLocation) {
                case "layer":
                    var layerMiddle = layerWidgetPos.bottom - layerH / window.devicePixelRatio * (notificationLayerIndex + 0.5);

                    layerMiddle = Math.min(Math.max(layerMiddle, scrollBoxPos.top), scrollBoxPos.bottom);

                    $tip.offset({
                        top: layerMiddle + document.body.scrollTop - $tip.height() / 2,
                        left: layerWidgetPos.left - $tip.outerWidth() - $arrow.outerWidth()
                    });
                    break;
                case "opacity":
                    var alphaSliderPos = alphaSlider.getElement().getBoundingClientRect();

                    $tip.offset({
                        top: (alphaSliderPos.top + alphaSliderPos.bottom - $tip.height()) / 2 + document.body.scrollTop,
                        left: alphaSliderPos.left - $tip.outerWidth() - $arrow.outerWidth()
                    });
                    break;
            }

            $arrow.css("top", "50%");
        }

        controller.on("layerNotification", this.showNotification.bind(this));

        $(canvas).popover({
            html: false,
            content: function content() {
                return notificationMessage;
            },
            placement: "left",
            trigger: "manual",
            container: palette.getElement()
        });

        var popover = $(canvas).data('bs.popover');

        // Save the old positioning routine so we can call it later
        oldApplyPlacement = popover.applyPlacement;

        popover.applyPlacement = applyNotificationPlacement;

        if (!window.devicePixelRatio) {
            window.devicePixelRatio = 1.0;
        }

        canvasContext.strokeStyle = 'black';

        container.className = "chickenpaint-layers-widget";
        container.appendChild(canvas);
    }

    function CPRenameField() {
        var layerIndex = -1,
            textBox = document.createElement("input"),
            that = this;

        this.hide = function () {
            layerIndex = -1;
            textBox.style.display = 'none';
        };

        this.renameAndHide = function () {
            if (artwork.getLayer(layerIndex).name != textBox.value) {
                controller.actionPerformed({ action: "CPSetLayerName", layerIndex: layerIndex, name: textBox.value });
            }

            this.hide();
        };

        this.isVisible = function () {
            return textBox.style.display != 'none';
        };

        this.setLocation = function (positionX, positionY) {
            textBox.style.left = positionX + "px";
            textBox.style.top = positionY + "px";
        };

        this.show = function (x, y, _layerIndex, layerName) {
            layerIndex = _layerIndex;
            textBox.value = layerName;
            this.setLocation(x, y);

            textBox.style.display = 'block';
            textBox.select();
        };

        this.getElement = function () {
            return textBox;
        };

        textBox.type = "text";
        textBox.className = "chickenpaint-layer-new-name form-control input-sm";
        textBox.style.display = 'none';

        textBox.addEventListener("keydown", function (e) {
            // Prevent other keyhandlers (CPCanvas) from getting their grubby hands on the input
            e.stopPropagation();
        });

        textBox.addEventListener("keypress", function (e) {
            if (e.keyCode == 13) {
                // Enter
                that.renameAndHide();
            }
            e.stopPropagation();
        });

        textBox.addEventListener("keyup", function (e) {
            if (e.keyCode == 27) {
                // Escape
                that.hide();
            }
            e.stopPropagation();
        });

        textBox.addEventListener("blur", function (e) {
            if (layerIndex != -1) {
                that.renameAndHide();
            }
        });
    }

    blendCombo.className = "form-control";
    blendCombo.title = "Layer blending mode";
    blendCombo.addEventListener("change", function (e) {
        controller.actionPerformed({ action: "CPSetLayerBlendMode", layerIndex: artwork.getActiveLayerIndex(), blendMode: parseInt(blendCombo.value, 10) });
    });

    fillCombobox(blendCombo, MODE_NAMES);

    body.appendChild(blendCombo);

    alphaSlider.title = function (value) {
        return "Opacity: " + value + "%";
    };

    alphaSlider.on("valueChange", function (value) {
        controller.actionPerformed({ action: "CPSetLayerAlpha", layerIndex: artwork.getActiveLayerIndex(), alpha: value });
    });

    body.appendChild(alphaSlider.getElement());

    cbSampleAllLayers.type = "checkbox";
    cbSampleAllLayers.addEventListener("click", function (e) {
        var artwork = controller.getArtwork();

        artwork.setSampleAllLayers(cbSampleAllLayers.checked);
    });

    body.appendChild(wrapCheckboxWithLabel(cbSampleAllLayers, "Sample all layers"));

    cbLockAlpha.type = "checkbox";
    cbLockAlpha.addEventListener("click", function (e) {
        var artwork = controller.getArtwork();

        artwork.setLockAlpha(cbLockAlpha.checked);
    });

    body.appendChild(wrapCheckboxWithLabel(cbLockAlpha, "Lock alpha"));

    layerWidget.getElement().appendChild(renameField.getElement());

    body.appendChild(layerWidget.getElement());

    // Add/Remove layer buttons
    var addRemoveContainer = document.createElement("ul");

    addRemoveContainer.className = 'chickenpaint-layer-add-remove list-unstyled';

    addButton.className = 'chickenpaint-small-toolbar-button chickenpaint-add-layer';
    addButton.title = 'Add layer';
    addButton.addEventListener("click", function () {
        controller.actionPerformed({ action: "CPAddLayer" });
    });

    removeButton.className = 'chickenpaint-small-toolbar-button chickenpaint-remove-layer';
    removeButton.title = "Delete layer";
    removeButton.addEventListener("click", function () {
        controller.actionPerformed({ action: "CPRemoveLayer" });
    });

    addRemoveContainer.appendChild(addButton);
    addRemoveContainer.appendChild(removeButton);

    body.appendChild(addRemoveContainer);

    var artwork = controller.getArtwork();

    // Set initial values
    alphaSlider.setValue(artwork.getActiveLayer().getAlpha());
    blendCombo.value = artwork.getActiveLayer().getBlendMode();

    artwork.on("changeLayer", function (layerIndex) {
        var artwork = this;

        if (artwork.getActiveLayer().getAlpha() != alphaSlider.value) {
            alphaSlider.setValue(artwork.getActiveLayer().getAlpha());
        }

        if (artwork.getActiveLayer().getBlendMode() != parseInt(blendCombo.value, 10)) {
            blendCombo.value = artwork.getActiveLayer().getBlendMode();
        }

        if (layerIndex !== undefined) {
            layerWidget.paintLayer(layerIndex);
        } else {
            // We may have added or removed layers, resize as appropriate
            layerWidget.resize();
        }

        layerWidget.dismissNotification();
    });
}

CPLayersPalette.prototype = Object.create(_CPPalette2.default.prototype);
CPLayersPalette.prototype.constructor = CPLayersPalette;
module.exports = exports["default"];

},{"./CPPalette":32,"./CPSlider":37}],29:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPMainGUI;

var _CPCanvas = require("./CPCanvas");

var _CPCanvas2 = _interopRequireDefault(_CPCanvas);

var _CPPaletteManager = require("./CPPaletteManager");

var _CPPaletteManager2 = _interopRequireDefault(_CPPaletteManager);

var _CPMainMenu = require("./CPMainMenu");

var _CPMainMenu2 = _interopRequireDefault(_CPMainMenu);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CPMainGUI(controller, uiElem) {
    var lowerArea = document.createElement("div"),
        canvas = new _CPCanvas2.default(controller),
        paletteManager = new _CPPaletteManager2.default(controller),
        menuBar,
        fullScreenMode = false,
        that = this;

    this.togglePalettes = function () {
        paletteManager.togglePalettes();
    };

    this.arrangePalettes = function () {
        // Give the browser a chance to do the sizing of the palettes before we try to rearrange them
        setTimeout(paletteManager.arrangePalettes.bind(paletteManager), 0);
    };

    this.constrainPalettes = function () {
        paletteManager.constrainPalettes();
    };

    this.showPalette = function (paletteName, show) {
        paletteManager.showPaletteByName(paletteName, show);
    };

    this.getSwatches = function () {
        return paletteManager.palettes.swatches.getSwatches();
    };

    this.setSwatches = function (swatches) {
        paletteManager.palettes.swatches.setSwatches(swatches);
    };

    this.getPaletteManager = function () {
        return paletteManager;
    };

    this.setRotation = function (rotation) {
        canvas.setRotation(rotation);
    };

    this.setFullScreenMode = function (value) {
        fullScreenMode = value;

        that.resize();
        that.arrangePalettes();
    };

    this.resize = function () {
        var newHeight;

        if (fullScreenMode) {
            newHeight = $(window).height() - $(menuBar.getElement()).height();
        } else {
            newHeight = Math.min(Math.max($(window).height() - $(menuBar.getElement()).height() - 65, 500), 750);
        }

        canvas.resize(newHeight);
        that.constrainPalettes();
    };

    menuBar = new _CPMainMenu2.default(controller, this);

    uiElem.appendChild(menuBar.getElement());

    lowerArea.className = 'chickenpaint-main-section';

    lowerArea.appendChild(canvas.getElement());
    lowerArea.appendChild(paletteManager.getElement());

    uiElem.appendChild(lowerArea);

    window.addEventListener("resize", this.resize.bind(this));

    setTimeout(this.resize.bind(this), 0);
} /*
      ChickenPaint
      
      ChickenPaint is a translation of ChibiPaint from Java to JavaScript
      by Nicholas Sherlock / Chicken Smoothie.
      
      ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
      ChickenPaint is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      ChickenPaint is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

CPMainGUI.prototype = Object.create(EventEmitter.prototype);
CPMainGUI.prototype.constructor = CPMainGUI;
module.exports = exports["default"];

},{"./CPCanvas":19,"./CPMainMenu":30,"./CPPaletteManager":33}],30:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPMainMenu;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

var MENU_ENTRIES = [{
    name: "File",
    mnemonic: "F",
    children: [{
        name: "Save to my computer",
        action: "CPSave",
        mnemonic: "S",
        shortcut: "ctrl+s"
    }, {
        name: "Save Oekaki",
        action: "CPSend",
        mnemonic: "S",
        shortcut: "ctrl+s"
    }]
}, {
    name: "Edit",
    mnemonic: "E",
    children: [{
        name: "Undo",
        action: "CPUndo",
        mnemonic: "U",
        shortcut: "ctrl+z",
        title: "Undoes the most recent action"
    }, {
        name: "Redo",
        action: "CPRedo",
        mnemonic: "R",
        shortcut: "shift+ctrl+z",
        title: "Redoes a previously undone action"
    }, {
        name: "Clear history",
        action: "CPClearHistory",
        mnemonic: "H",
        title: "Removes all undo/redo information to regain memory"
    }, {
        name: "-"
    }, {
        name: "Cut",
        action: "CPCut",
        mnemonic: "T",
        shortcut: "ctrl+x"
    }, {
        name: "Copy",
        action: "CPCopy",
        mnemonic: "C",
        shortcut: "ctrl+c"
    }, {
        name: "Copy merged",
        action: "CPCopyMerged",
        mnemonic: "Y",
        shortcut: "shift+ctrl+c"
    }, {
        name: "Paste",
        action: "CPPaste",
        mnemonic: "P",
        shortcut: "ctrl+v"
    }, {
        name: "-"
    }, {
        name: "Select all",
        action: "CPSelectAll",
        mnemonic: "A",
        shortcut: "ctrl+a"
    }, {
        name: "Deselect",
        action: "CPDeselectAll",
        mnemonic: "D",
        shortcut: "ctrl+d"
    }, {
        name: "-"
    }, {
        name: "Transform",
        action: "CPTransform",
        mnemonic: "T",
        shortcut: "ctrl+y"
    }]
}, {
    name: "Layers",
    mnemonic: "L",
    children: [{
        name: "Duplicate",
        action: "CPLayerDuplicate",
        mnemonic: "D",
        shortcut: "shift+ctrl+d",
        title: "Creates a copy of the currently selected layer"
    }, {
        name: "-"
    }, {
        name: "Merge down",
        action: "CPLayerMergeDown",
        mnemonic: "E",
        shortcut: "ctrl+e",
        title: "Merges the currently selected layer with the one directly below it"
    }, {
        name: "Merge all layers",
        action: "CPLayerMergeAll",
        mnemonic: "A",
        title: "Merges all the layers"
    }]
}, {
    name: "Effects",
    mnemonic: "E",
    children: [{
        name: "Clear",
        action: "CPClear",
        mnemonic: "D",
        shortcut: "del,backspace",
        title: "Clears the selected area"
    }, {
        name: "Fill",
        action: "CPFill",
        mnemonic: "F",
        shortcut: "ctrl+f",
        title: "Fills the selected area with the current color"
    }, {
        name: "Flip horizontal",
        action: "CPHFlip",
        mnemonic: "H",
        title: "Flips the current selected area horizontally"
    }, {
        name: "Flip vertical",
        action: "CPVFlip",
        mnemonic: "V",
        title: "Flips the current selected area vertically"
    }, {
        name: "Invert",
        action: "CPFXInvert",
        mnemonic: "I",
        title: "Invert the image colors"
    }, {
        name: "-"
    }, {
        name: "Box blur...",
        action: "CPFXBoxBlur",
        mnemonic: "B",
        title: "Blur effect"
    }, {
        name: "-"
    }, {
        name: "Monochromatic noise",
        action: "CPMNoise",
        mnemonic: "M",
        title: "Fills the selection with noise"
    }, {
        name: "Color noise",
        action: "CPCNoise",
        mnemonic: "C",
        title: "Fills the selection with colored noise"
    }]
}, {
    name: "View",
    mnemonic: "V",
    children: [{
        name: "Full-screen mode",
        action: "CPFullScreen",
        mnemonic: "F",
        checkbox: true,
        checked: false
    }, {
        name: "-"
    }, {
        name: "Zoom in",
        action: "CPZoomIn",
        mnemonic: "I",
        shortcut: "ctrl+=",
        title: "Zooms in"
    }, {
        name: "Zoom out",
        action: "CPZoomOut",
        mnemonic: "O",
        shortcut: "ctrl+-",
        title: "Zooms out"
    }, {
        name: "Zoom 100%",
        action: "CPZoom100",
        mnemonic: "1",
        shortcut: "ctrl+0",
        title: "Resets the zoom factor to 100%"
    }, {
        action: "CPLinearInterpolation",
        name: "-"
    }, {
        name: "Smooth-out zoomed canvas",
        action: "CPLinearInterpolation",
        mnemonic: "L",
        title: "Linear interpolation is used to give a smoothed looked to the picture when zoomed in",
        checkbox: true
    }, {
        name: "-"
    }, {
        name: "Show grid",
        action: "CPToggleGrid",
        mnemonic: "G",
        shortcut: "ctrl+g",
        title: "Displays a grid over the image",
        checkbox: true,
        checked: false
    }, {
        name: "Grid options...",
        action: "CPGridOptions",
        mnemonic: "D",
        title: "Shows the grid options dialog box"
    }]
}, {
    name: "Palettes",
    mnemonic: "P",
    children: [{
        name: "Rearrange",
        action: "CPArrangePalettes",
        title: "Rearrange the palette windows"
    }, {
        name: "Toggle palettes",
        action: "CPTogglePalettes",
        mnemonic: "P",
        shortcut: "tab",
        title: "Hides or shows all palettes"
    }, {
        name: "-"
    }, {
        name: "Show tool options",
        action: "CPPalBrush",
        mnemonic: "B",
        checkbox: true,
        checked: true
    }, {
        name: "Show color",
        action: "CPPalColor",
        mnemonic: "C",
        checkbox: true,
        checked: true
    }, {
        name: "Show layers",
        action: "CPPalLayers",
        mnemonic: "Y",
        checkbox: true,
        checked: true
    }, {
        name: "Show misc",
        action: "CPPalMisc",
        mnemonic: "M",
        checkbox: true,
        checked: true
    }, {
        name: "Show stroke",
        action: "CPPalStroke",
        mnemonic: "S",
        checkbox: true,
        checked: true
    }, {
        name: "Show swatches",
        action: "CPPalSwatches",
        mnemonic: "W",
        checkbox: true,
        checked: true
    }, {
        name: "Show textures",
        action: "CPPalTextures",
        mnemonic: "X",
        checkbox: true,
        checked: true
    }, {
        name: "Show tools",
        action: "CPPalTool",
        mnemonic: "T",
        checkbox: true,
        checked: true
    }]
}, {
    name: "Help",
    mnemonic: "H",
    children: [{
        name: "Tablet support",
        mnemonic: "T",
        action: "CPTabletSupport",
        title: "Help with getting a drawing tablet working"
    }, {
        name: "Shortcuts",
        mnemonic: "S",
        action: "CPShortcuts",
        title: "List of keyboard and mouse shortcuts"
    }, {
        name: "-"
    }, {
        name: "About",
        mnemonic: "A",
        action: "CPAbout",
        title: "Displays some information about ChickenPaint"
    }]
}];

function CPMainMenu(controller, mainGUI) {
    var bar = $('<nav class="navbar navbar-default">' + '<div class="container-fluid">' + '<div class="navbar-header">' + '<a class="navbar-brand" href="#">ChickenPaint</a>' + '</div>' + '<ul class="nav navbar-nav">' + '</ul>' + '</div>' + '</nav>'),
        macPlatform = /^Mac/i.test(navigator.platform);

    function menuItemClicked(target) {
        var action = target.data('action'),
            checkbox = target.data('checkbox'),
            selected;

        if (checkbox) {
            target.toggleClass("selected");
            selected = target.hasClass("selected");
        } else {
            selected = false;
        }

        controller.actionPerformed({
            action: action,
            checkbox: checkbox,
            selected: selected
        });
    }

    function presentShortcutText(shortcut) {
        shortcut = shortcut.toUpperCase();

        // Only show the first potential shortcut out of the comma-separated list
        shortcut = shortcut.replace(/(,.+)$/, "");

        // Although the keycode for zoom in is "=", we'll present it to the user as "+"
        shortcut = shortcut.replace("ctrl+=", "ctrl++");
        shortcut = shortcut.replace("+=", "++");

        if (macPlatform) {
            shortcut = shortcut.replace(/([^+])\+/g, "$1");
        } else {
            shortcut = shortcut.replace(/([^+])\+/g, "$1 ");
        }

        return shortcut;
    }

    function recurseFillMenu(menuElem, entries) {
        menuElem.append(entries.map(function (entry) {
            var entryElem;

            if (entry.action && !controller.isActionSupported(entry.action)) {
                return;
            }

            if (entry.action == "CPSend" && !controller.isActionSupported("CPContinue")) {
                // User won't be able to come back after saving, so make it sound more final
                entry.name = "Post Oekaki";
                entry.shortcut = "ctrl+p";
            }

            if (entry.children) {
                entryElem = $('<li class="dropdown">' + '<a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-haspopup="true" aria-expanded="false">' + entry.name + ' <span class="caret"></span></a>' + '<ul class="dropdown-menu">' + '</ul>' + '</li>');

                $(".dropdown-toggle", entryElem).dropdown();

                entryElem.on("show.bs.dropdown", function () {
                    /* Instead of Bootstrap's extremely expensive data API, we'll only listen for dismiss clicks on the
                     * document *while the menu is open!*
                     */
                    $(document).one("click", function () {
                        if (entryElem.hasClass("open")) {
                            $(".dropdown-toggle", entryElem).dropdown("toggle");
                        }
                    });
                });

                recurseFillMenu($(".dropdown-menu", entryElem), entry.children);
            } else if (entry.name == '-') {
                entryElem = $('<li role="separator" class="divider"></li>');
            } else {
                entryElem = $('<li><a href="#" data-action="' + entry.action + '"><span>' + entry.name + '</span></a></li>');

                if (entry.checkbox) {
                    $("a", entryElem).data("checkbox", true).toggleClass("selected", !!entry.checked);
                }
            }

            if (entry.title) {
                entryElem.attr('title', entry.title);
            }

            if (entry.shortcut) {
                var menuLink = $("> a", entryElem),
                    shortcutDesc = document.createElement("small");

                // Rewrite the shortcuts to Mac-style
                if (macPlatform) {
                    entry.shortcut = entry.shortcut.replace(/SHIFT/im, "");
                    entry.shortcut = entry.shortcut.replace(/ALT/im, "");
                    entry.shortcut = entry.shortcut.replace(/CTRL/im, "");
                }

                shortcutDesc.className = "chickenpaint-shortcut";
                shortcutDesc.innerHTML = presentShortcutText(entry.shortcut);

                menuLink.append(shortcutDesc);

                key(entry.shortcut, function (e) {
                    menuItemClicked(menuLink);

                    e.preventDefault();
                    e.stopPropagation();

                    return false;
                });
            }

            return entryElem;
        }));
    }

    this.getElement = function () {
        return bar[0];
    };

    recurseFillMenu($(".navbar-nav", bar), MENU_ENTRIES);

    $(bar).on('click', 'a:not(.dropdown-toggle)', function (e) {
        menuItemClicked($(this));
        e.preventDefault();
    });

    function onPaletteVisChange(paletteName, show) {
        // Toggle the tickbox of the corresponding menu entry to match the new palette visibility
        var palMenuEntry = $('[data-action=\"CPPal' + paletteName.substring(0, 1).toUpperCase() + paletteName.substring(1) + '\"]', bar);

        palMenuEntry.toggleClass("selected", show);
    }

    mainGUI.getPaletteManager().on("paletteVisChange", onPaletteVisChange);
}
module.exports = exports["default"];

},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPMiscPalette;

var _CPPalette = require("./CPPalette");

var _CPPalette2 = _interopRequireDefault(_CPPalette);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CPMiscPalette(cpController) {
    _CPPalette2.default.call(this, cpController, "misc", "Misc");

    var that = this,
        buttons = [{
        className: "chickenpaint-tool-zoom-in",
        command: "CPZoomIn",
        toolTip: "Zoom in"
    }, {
        className: "chickenpaint-tool-zoom-out",
        command: "CPZoomOut",
        toolTip: "Zoom out"
    }, {
        className: "chickenpaint-tool-zoom-100",
        command: "CPZoom100",
        toolTip: "Zoom 100%"
    }, {
        className: "chickenpaint-tool-undo",
        command: "CPUndo",
        toolTip: "Undo"
    }, {
        className: "chickenpaint-tool-redo",
        command: "CPRedo",
        toolTip: "Redo"
    }, {
        className: "chickenpaint-tool-send",
        command: "CPSend",
        toolTip: "Save pic"
    }];

    function buildButtons() {
        var body = that.getBodyElement(),
            listElem = document.createElement("ul");

        listElem.className = "chickenpaint-misc-tools list-unstyled";

        for (var i in buttons) {
            var button = buttons[i],
                buttonElem = document.createElement("li");

            if (button.command == 'CPSend' && !cpController.isActionSupported("CPContinue")) {
                button.toolTip = "Send picture to server";
                button.className = "chickenpaint-tool-send-and-end";
            }

            buttonElem.className = "chickenpaint-toolbar-button " + button.className;
            buttonElem.setAttribute("data-buttonIndex", i);

            listElem.appendChild(buttonElem);
        }

        listElem.addEventListener("mousedown", function (e) {
            if (e.target && e.target.nodeName == "LI") {
                $(e.target).addClass("selected");
            }
        });

        listElem.addEventListener("mouseup", function (e) {
            if (e.target && e.target.nodeName == "LI") {
                $(e.target).removeClass("selected");
            }
        });

        listElem.addEventListener("click", function (e) {
            if (e.target && e.target.nodeName == "LI") {
                var button = buttons[parseInt(e.target.getAttribute("data-buttonIndex"), 10)];

                cpController.actionPerformed({ action: button.command });
            }
        });

        body.appendChild(listElem);
    }

    buildButtons();
} /*
      ChickenPaint
      
      ChickenPaint is a translation of ChibiPaint from Java to JavaScript
      by Nicholas Sherlock / Chicken Smoothie.
      
      ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
      ChickenPaint is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      ChickenPaint is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

CPMiscPalette.prototype = Object.create(_CPPalette2.default.prototype);
CPMiscPalette.prototype.constructor = CPMiscPalette;
module.exports = exports["default"];

},{"./CPPalette":32}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPPalette;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPPalette(cpController, className, title, resizeVert) {
    this.title = title;
    this.name = className;
    this.resizeVert = resizeVert || false;

    var containerElement = document.createElement("div"),
        headElement = document.createElement("div"),
        closeButton = document.createElement("button"),
        bodyElement = document.createElement("div"),
        vertHandle = null,
        dragOffset,
        that = this;

    this.getElement = function () {
        return containerElement;
    };

    this.getBodyElement = function () {
        return bodyElement;
    };

    this.getWidth = function () {
        return $(containerElement).outerWidth();
    };

    this.getHeight = function () {
        return $(containerElement).outerHeight();
    };

    this.getX = function () {
        return parseInt(containerElement.style.left, 10) || 0;
    };

    this.getY = function () {
        return parseInt(containerElement.style.top, 10) || 0;
    };

    this.setLocation = function (x, y) {
        containerElement.style.left = x + "px";
        containerElement.style.top = y + "px";
    };

    this.setWidth = function (width) {
        containerElement.style.width = width + "px";
    };

    this.setHeight = function (height) {
        containerElement.style.height = height + "px";
    };

    this.setSize = function (width, height) {
        this.setWidth(width);
        this.setHeight(height);
    };

    function mouseDrag(e) {
        that.setLocation(e.pageX - dragOffset.x, e.pageY - dragOffset.y);
    }

    function mouseDragRelease(e) {
        window.removeEventListener("mousemove", mouseDrag);
        window.removeEventListener("mouseup", mouseDragRelease);
    }

    function vertHandleDrag(e) {
        that.setHeight(e.pageY - $(containerElement).offset().top);
    }

    function vertHandleRelease(e) {
        window.removeEventListener("mousemove", vertHandleDrag);
        window.removeEventListener("mouseup", vertHandleRelease);
    }

    function vertHandleMouseDown(e) {
        window.addEventListener("mousemove", vertHandleDrag);
        window.addEventListener("mouseup", vertHandleRelease);
    }

    function addVertResizeHandle() {
        vertHandle = document.createElement("div");

        vertHandle.className = "chickenpaint-resize-handle-vert";

        vertHandle.addEventListener("mousedown", vertHandleMouseDown);

        containerElement.appendChild(vertHandle);
    }

    closeButton.type = "button";
    closeButton.className = "close";
    closeButton.innerHTML = "&times;";

    containerElement.className = "chickenpaint-palette chickenpaint-palette-" + className;

    headElement.className = "chickenpaint-palette-head";

    var headTitle = document.createElement("h4");

    headTitle.className = 'modal-title';
    headTitle.appendChild(document.createTextNode(this.title));

    headElement.appendChild(closeButton);
    headElement.appendChild(headTitle);

    bodyElement.className = "chickenpaint-palette-body";

    containerElement.appendChild(headElement);
    containerElement.appendChild(bodyElement);

    if (this.resizeVert) {
        addVertResizeHandle();
    }

    headElement.addEventListener("mousedown", function (e) {
        if (e.button == 0) {
            /* Left */
            if (e.target.nodeName == "BUTTON") {
                that.emitEvent("paletteVisChange", [that, false]);
            } else {
                window.addEventListener("mousemove", mouseDrag);
                window.addEventListener("mouseup", mouseDragRelease);

                dragOffset = { x: e.pageX - $(containerElement).position().left, y: e.pageY - $(containerElement).position().top };
            }
        }
    });
}

CPPalette.prototype = Object.create(EventEmitter.prototype);
CPPalette.prototype.constructor = EventEmitter;
module.exports = exports["default"];

},{}],33:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPPaletteManager;

var _CPToolPalette = require("./CPToolPalette");

var _CPToolPalette2 = _interopRequireDefault(_CPToolPalette);

var _CPMiscPalette = require("./CPMiscPalette");

var _CPMiscPalette2 = _interopRequireDefault(_CPMiscPalette);

var _CPStrokePalette = require("./CPStrokePalette");

var _CPStrokePalette2 = _interopRequireDefault(_CPStrokePalette);

var _CPColorPalette = require("./CPColorPalette");

var _CPColorPalette2 = _interopRequireDefault(_CPColorPalette);

var _CPBrushPalette = require("./CPBrushPalette");

var _CPBrushPalette2 = _interopRequireDefault(_CPBrushPalette);

var _CPLayersPalette = require("./CPLayersPalette");

var _CPLayersPalette2 = _interopRequireDefault(_CPLayersPalette);

var _CPTexturePalette = require("./CPTexturePalette");

var _CPTexturePalette2 = _interopRequireDefault(_CPTexturePalette);

var _CPSwatchesPalette = require("./CPSwatchesPalette");

var _CPSwatchesPalette2 = _interopRequireDefault(_CPSwatchesPalette);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPPaletteManager(cpController) {
    var palettes = {
        tool: new _CPToolPalette2.default(cpController),
        misc: new _CPMiscPalette2.default(cpController),
        stroke: new _CPStrokePalette2.default(cpController),
        color: new _CPColorPalette2.default(cpController),
        brush: new _CPBrushPalette2.default(cpController),
        layers: new _CPLayersPalette2.default(cpController),
        textures: new _CPTexturePalette2.default(cpController),
        swatches: new _CPSwatchesPalette2.default(cpController)
    },
        paletteFrames = [],
        hiddenFrames = [],
        parentElem = document.createElement("div"),
        that = this;

    this.palettes = palettes;

    function showPalette(palette, show) {
        var palElement = palette.getElement();

        if (show) {
            parentElem.appendChild(palElement);
        } else {
            parentElem.removeChild(palElement);
        }
        that.emitEvent("paletteVisChange", [palette.name, show]);

        // FIXME: focus hack
        // controller.canvas.grabFocus(); TODO
    }

    this.showPaletteByName = function (paletteName, show) {
        var palette = palettes[paletteName];

        if (palette) {
            showPalette(palette, show);
        }
    };

    this.togglePalettes = function () {
        if (hiddenFrames.length == 0) {
            $("> .chickenpaint-palette", parentElem).each(function () {
                that.showPaletteByName(this.getAttribute("data-paletteName"), false);
                hiddenFrames.push(this);
            });
        } else {
            for (var i = 0; i < hiddenFrames.length; i++) {
                var frame = hiddenFrames[i];

                that.showPaletteByName(frame.getAttribute("data-paletteName"), true);
            }
            hiddenFrames = [];
        }
    };

    /**
     * Pop palettes that are currently outside the visible area back into view.
     */
    this.constrainPalettes = function () {
        var windowWidth = $(parentElem).parents(".chickenpaint-main-section").width(),
            windowHeight = $(parentElem).parents(".chickenpaint-main-section").height();

        for (var i in palettes) {
            var palette = palettes[i];

            /* Move palettes that are more than half out of the frame back into it */
            if (palette.getX() + palette.getWidth() / 2 > windowWidth) {
                palette.setLocation(windowWidth - palette.getWidth(), palette.getY());
            }

            if (palette.getY() + palette.getHeight() / 2 > windowHeight) {
                palette.setLocation(palette.getX(), windowHeight - palette.getHeight());
            }
        }

        //Move small palettes to the front so that they aren't completely hidden
        //palettes.swatches.moveToFront();

        //Special handling for the swatches palette being under the brush palette:
        var widthToSpare = windowWidth - palettes.tool.getWidth() - palettes.misc.getWidth() - palettes.stroke.getWidth() - palettes.color.getWidth() - palettes.brush.getWidth() - 15 > 0;

        if (palettes.swatches.getX() + palettes.swatches.getWidth() == palettes.brush.getX() + palettes.brush.getWidth() && Math.abs(palettes.swatches.getY() - palettes.brush.getY()) < 20) {
            palettes.swatches.setLocation(palettes.brush.getX() - palettes.swatches.getWidth() - (widthToSpare ? 5 : 1), 0);
        }

        //Special handling for layers palette being too damn tall:
        if (palettes.layers.getY() + palettes.layers.getHeight() > windowHeight) {
            palettes.layers.setHeight(Math.max(windowHeight - palettes.layers.getY(), 200));
        }
    };

    /**
     * Rearrange the palettes from scratch into a useful arrangement.
     */
    this.arrangePalettes = function () {
        var windowWidth = $(parentElem).parents(".chickenpaint-main-section").width(),
            windowHeight = $(parentElem).parents(".chickenpaint-main-section").height(),
            haveWidthToSpare = windowWidth - palettes.tool.getWidth() - palettes.misc.getWidth() - palettes.stroke.getWidth() - palettes.color.getWidth() - palettes.brush.getWidth() - 15 > 0;

        palettes.brush.setLocation(windowWidth - palettes.brush.getWidth() - 15, 0);

        var bottomOfBrush = palettes.brush.getY() + palettes.brush.getHeight();

        palettes.layers.setLocation(palettes.brush.getX(), windowHeight - bottomOfBrush > 300 ? bottomOfBrush + 2 : bottomOfBrush);
        palettes.layers.setSize(palettes.brush.getWidth(), windowHeight - palettes.layers.getY());

        palettes.tool.setLocation(0, 0);

        palettes.misc.setLocation(palettes.tool.getX() + palettes.tool.getWidth() + (haveWidthToSpare ? 5 : 1), 0);

        if (haveWidthToSpare) {
            palettes.stroke.setLocation(palettes.misc.getX() + palettes.misc.getWidth() + (haveWidthToSpare ? 5 : 1), 0);
        } else {
            palettes.stroke.setLocation(palettes.misc.getX(), palettes.misc.getY() + palettes.misc.getHeight() + 1);
        }

        palettes.swatches.setLocation(palettes.brush.getX() - palettes.swatches.getWidth() - (haveWidthToSpare ? 5 : 1), 0);

        palettes.textures.setWidth(Math.min(palettes.layers.getX() - palettes.textures.getX(), 490));
        palettes.textures.setLocation(palettes.color.getX() + palettes.color.getWidth() + 4, windowHeight - palettes.textures.getHeight());

        palettes.color.setLocation(0, Math.max(palettes.tool.getY() + palettes.tool.getHeight(), windowHeight - palettes.color.getHeight()));
    };

    this.getElement = function () {
        return parentElem;
    };

    parentElem.className = "chickenpaint-palettes";

    for (var paletteName in palettes) {
        var palette = palettes[paletteName],
            palElement = palette.getElement();

        palette.on("paletteVisChange", function () {
            showPalette(this, false);
        });

        palElement.setAttribute("data-paletteName", paletteName);
        paletteFrames.push(palElement);
    }

    for (var paletteName in palettes) {
        var palElement = palettes[paletteName].getElement();

        parentElem.appendChild(palElement);
    }
}

CPPaletteManager.prototype = Object.create(EventEmitter.prototype);
CPPaletteManager.prototype.constructor = CPPaletteManager;
module.exports = exports["default"];

},{"./CPBrushPalette":18,"./CPColorPalette":21,"./CPLayersPalette":28,"./CPMiscPalette":31,"./CPStrokePalette":39,"./CPSwatchesPalette":40,"./CPTexturePalette":42,"./CPToolPalette":43}],34:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPScrollbar;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * @param vertical boolean
 */
function CPScrollbar(vertical) {
    var bar = document.createElement("div"),
        handle = document.createElement("div"),
        handleInner = document.createElement("div"),
        min = 0,
        max = 1,
        offset = 0,
        visibleRange = 1,
        blockIncrement = 10,
        unitIncrement = 1,
        valueIsAdjusting = false,
        handleSize = 1,
        dragLastOffset,
        that = this;

    function updateBar() {
        var longDimension = vertical ? $(bar).height() : $(bar).width();

        /* As the size of the document approaches the size of the container, handle size grows to fill the 
         * whole track:
         */
        handleSize = visibleRange / (max - min) * longDimension;

        var handleOffset = (offset - min) / (max - min) * (longDimension - handleSize);

        handleInner.style[vertical ? "height" : "width"] = handleSize + "px";
        handle.style[vertical ? "height" : "width"] = handleSize + "px";

        handle.style[vertical ? "top" : "left"] = handleOffset + "px";
    }

    this.setValues = function (_offset, _visibleRange, _min, _max) {
        offset = _offset;
        visibleRange = _visibleRange;
        min = _min;
        max = _max;

        updateBar();
    };

    this.setBlockIncrement = function (increment) {
        blockIncrement = increment;
    };

    this.setUnitIncrement = function (increment) {
        unitIncrement = increment;
    };

    this.getElement = function () {
        return bar;
    };

    this.getValueIsAdjusting = function () {
        return valueIsAdjusting;
    };

    function onBarClick(e) {
        if (this == bar) {
            var clickPos = vertical ? e.pageY - $(bar).offset().top : e.pageX - $(bar).offset().left,
                barPos = parseInt(handle.style[vertical ? "top" : "left"], 10);

            if (clickPos < barPos) {
                offset -= blockIncrement;
            } else {
                offset += blockIncrement;
            }

            that.emitEvent("valueChanged", [offset]);
            updateBar();
        }
    }

    function onHandlePress(e) {
        e.stopPropagation();
        dragLastOffset = vertical ? e.pageY - $(bar).offset().top : e.pageX - $(bar).offset().left;

        $(handle).addClass("dragging");
        window.addEventListener("mouseup", onHandleRelease);
        window.addEventListener("mousemove", onHandleDrag);
    }

    function onHandleClick(e) {
        e.stopPropagation();
    }

    function onHandleDrag(e) {
        valueIsAdjusting = true;

        var longDimension = vertical ? $(bar).height() : $(bar).width(),
            mouseOffset = vertical ? e.pageY - $(bar).offset().top : e.pageX - $(bar).offset().left;

        offset = offset + (mouseOffset - dragLastOffset) * (max - min) / (longDimension - handleSize);

        offset = Math.min(Math.max(offset, min), max);

        dragLastOffset = mouseOffset;

        that.emitEvent("valueChanged", [offset]);
        updateBar();

        valueIsAdjusting = false;
    }

    function onHandleRelease(e) {
        e.stopPropagation();
        $(handle).removeClass("dragging");
        window.removeEventListener("mouseup", onHandleRelease);
        window.removeEventListener("mousemove", onHandleDrag);
    }

    bar.className = "chickenpaint-scrollbar " + (vertical ? "chickenpaint-scrollbar-vertical" : "chickenpaint-scrollbar-horizontal");
    handle.className = "chickenpaint-scrollbar-handle";
    handleInner.className = "chickenpaint-scrollbar-handle-inner";

    handle.appendChild(handleInner);
    bar.appendChild(handle);

    handle.addEventListener("mousedown", onHandlePress);
    handle.addEventListener("click", onHandleClick);

    bar.addEventListener("click", onBarClick);
}

CPScrollbar.prototype = Object.create(EventEmitter.prototype);
CPScrollbar.prototype.constructor = CPScrollbar;
module.exports = exports["default"];

},{}],35:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPSendDialog;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPSendDialog(controller, parent, resourceSaver) {
    var dialog = $("<div class=\"modal fade\" tabindex=\"-1\" role=\"dialog\">\n                <div class=\"modal-dialog\">\n                \n                    <div class=\"modal-content\" data-stage=\"saving\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                                <span aria-hidden=\"true\">&times;</span>\n                            </button>\n                            <h4 class=\"modal-title\">Saving drawing...</h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <p class=\"chickenpaint-saving-progress-message\">Preparing your drawing to be saved, please wait...</p>\n                            <pre class=\"chickenpaint-saving-error-message pre-scrollable\"></pre>\n                            <div class=\"progress\">\n                                <div class=\"progress-bar\" role=\"progressbar\" aria-valuenow=\"0\" aria-valuemin=\"0\" aria-valuemax=\"100\" style=\"width: 0%;\"></div>\n                            </div>\n                        </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-default chickenpaint-send-cancel\" data-dismiss=\"modal\">Cancel</button>\n                        </div>\n                    </div>\n                    <div class=\"modal-content\" data-stage=\"success-not-previously-posted\" style=\"display:none\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                                <span aria-hidden=\"true\">&times;</span>\n                            </button>\n                            <h4 class=\"modal-title\">Drawing saved!</h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <p>Your drawing has been saved, would you like to post it to the forum now?</p>\n                        </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-primary chickenpaint-post-drawing\" data-dismiss=\"modal\">Yes, post it now</button>\n                            <button type=\"button\" class=\"btn btn-default chickenpaint-continue-drawing\" data-dismiss=\"modal\">No, keep drawing</button>\n                            <button type=\"button\" class=\"btn btn-default chickenpaint-exit\" data-dismiss=\"modal\">No, quit and I'll finish it later</button>\n                        </div>\n                    </div>\n                    <div class=\"modal-content\" data-stage=\"success-already-posted\" style=\"display:none\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                                <span aria-hidden=\"true\">&times;</span>\n                            </button>\n                            <h4 class=\"modal-title\">Drawing saved!</h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <p>Your drawing has been saved, would you like to view it on the forum now?</p>\n                        </div>\n                        <div class=\"modal-footer\">\n                            <button type=\"button\" class=\"btn btn-primary chickenpaint-post-drawing\" data-dismiss=\"modal\">Yes, view the post</button>\n                            <button type=\"button\" class=\"btn btn-default chickenpaint-continue-drawing\" data-dismiss=\"modal\">No, keep drawing</button>\n                        </div>\n                    </div>\n                    <div class=\"modal-content\" data-stage=\"success-redirect\" style=\"display:none\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                                <span aria-hidden=\"true\">&times;</span>\n                            </button>\n                            <h4 class=\"modal-title\">Drawing saved!</h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <p>Your drawing has been saved, redirecting you to view your new post now...</p>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        "),
        progressMessageElem = $(".chickenpaint-saving-progress-message", dialog),
        progressError = $(".chickenpaint-saving-error-message", dialog),
        progressElem = $(".progress-bar", dialog),
        that = this;

    resourceSaver.on("savingProgress", function (progress, message) {
        progress *= 100;

        progressMessageElem.text(message);

        $(progressElem).attr("aria-valuenow", progress).css("width", progress + "%");
    });

    resourceSaver.on("savingComplete", function () {
        $(".modal-content[data-stage='saving']", dialog).hide();

        if (controller.isActionSupported("CPContinue")) {
            if (controller.isActionSupported("CPExit")) {
                $(".modal-content[data-stage='success-not-previously-posted']", dialog).show();
            } else {
                $(".modal-content[data-stage='success-already-posted']", dialog).show();
            }
        } else {
            $(".modal-content[data-stage='success-redirect']", dialog).show();
        }
    });

    resourceSaver.on("savingFailure", function (serverMessage) {
        progressElem.addClass("progress-bar-danger");

        var errorMessage = "Sorry, your drawing could not be saved, please try again later.";

        if (serverMessage) {
            serverMessage = serverMessage.replace(/^CHIBIERROR\s*/, "");

            if (serverMessage.length > 0) {
                errorMessage += "<br><br>The error returned from the server was:";

                progressError.text(serverMessage).show();
            }

            progressMessageElem.html(errorMessage);
        }
    });

    $(".chickenpaint-post-drawing", dialog).click(function () {
        controller.actionPerformed({ action: "CPPost" });
    });

    $(".chickenpaint-exit", dialog).toggle(controller.isActionSupported("CPExit")).click(function () {
        alert("When you want to come back and finish your drawing, just click the 'new drawing' button again and " + "you can choose to continue this drawing.");
        controller.actionPerformed({ action: "CPExit" });
    });

    $(".chickenpaint-send-cancel", dialog).click(function () {
        resourceSaver.cancel();
    });

    // Destroy the modal upon close
    dialog.on("hidden.bs.modal", function (e) {
        dialog.remove();
    });

    dialog.modal({
        show: false
    });

    dialog.on('shown.bs.modal', function () {
        that.emitEvent("shown");
    });

    // Fix the backdrop location in the DOM by reparenting it to the chickenpaint container
    dialog.data("bs.modal").$body = $(parent);

    parent.appendChild(dialog[0]);

    this.show = function () {
        dialog.modal("show");
    };
}

CPSendDialog.prototype = Object.create(EventEmitter.prototype);
CPSendDialog.prototype.contructor = CPSendDialog;
module.exports = exports["default"];

},{}],36:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPShortcutsDialog;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPShortcutsDialog(parent) {
    var dialog = $("<div class=\"modal fade chickenpaint-shortcuts-dialog\" tabindex=\"-1\" role=\"dialog\">\n                <div class=\"modal-dialog modal-lg\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                                <span aria-hidden=\"true\">&times;</span>\n                            </button>\n                            <h4 class=\"modal-title\">Shortcuts</h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <p>\n                                Many of the menu options and painting tools have keyboard shortcuts which are\n                                written next to them or appear when you hover.\n                            </p>\n                            <p>\n                                Here are some other shortcuts which are not as obvious!\n                            </p>\n                            <div class=\"chickenpaint-shortcuts-sections\">\n                                <div class=\"chickenpaint-shortcuts-section\">\n                                    <h5>Color swatches palette</h5>\n                                    <ul class=\"chickenpaint-shortcuts-list list-unstyled\">\n                                        <li>\n                                            <dl>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"fa fa-mouse-pointer\"></span> Left</span>\n                                                </dt>\n                                                <dd>\n                                                    Use as the drawing color\n                                                </dd>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"fa fa-mouse-pointer\"></span> Right</span>\n                                                </dt>\n                                                <dd>\n                                                    Remove or replace a color swatch\n                                                </dd>\n                                             </dl>\n                                        </li>\n                                    </ul>\n                                </div>\n                                <div class=\"chickenpaint-shortcuts-section\">\n                                    <h5>Line drawing mode</h5>\n                                    <ul class=\"chickenpaint-shortcuts-list list-unstyled\">\n                                        <li>\n                                            <dl>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"chickenpaint-shortcut-key\">Shift</span> + <span class=\"fa fa-mouse-pointer\"></span> Left</span>\n                                                </dt>\n                                                <dd>\n                                                    Snap line to nearest 45 degrees\n                                                </dd>\n                                             </dl>\n                                        </li>\n                                    </ul>\n                                </div>\n                                <div class=\"chickenpaint-shortcuts-section\">\n                                    <h5>Painting tools</h5>\n                                    <ul class=\"chickenpaint-shortcuts-list list-unstyled\">\n                                        <li>\n                                            <dl>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"chickenpaint-shortcut-key\">1</span> - <span class=\"chickenpaint-shortcut-key\">9</span> , <span class=\"chickenpaint-shortcut-key\">0</span></span>\n                                                </dt>\n                                                <dd>\n                                                    Change brush opacity\n                                                </dd>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"chickenpaint-shortcut-key\">[</span> , <span class=\"chickenpaint-shortcut-key\">]</span></span>\n                                                </dt>\n                                                <dd>\n                                                    Change brush size\n                                                </dd>\n                                            </dl>\n                                        </li>\n                                    </ul>\n                                </div>\n                                <div class=\"chickenpaint-shortcuts-section\">\n                                    <h5>Brush palette</h5>\n                                    <ul class=\"chickenpaint-shortcuts-list list-unstyled\">\n                                        <li>\n                                            <dl>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"fa fa-mouse-pointer\"></span> Right drag</span>\n                                                </dt>\n                                                <dd>\n                                                    Adjust brush sliders more precisely\n                                                </dd>\n                                            </dl>\n                                        </li>\n                                    </ul>\n                                </div>\n                                <div class=\"chickenpaint-shortcuts-section\">\n                                    <h5>Drawing canvas</h5>\n                                    <ul class=\"chickenpaint-shortcuts-list list-unstyled\">\n                                        <li>\n                                            <dl>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"fa fa-mouse-pointer\"></span> Middle</span> <span class=\"chickenpaint-shortcut-alternate\">or</span> <span class=\"chickenpaint-shortcut\"><span class=\"chickenpaint-shortcut-key\">Space</span> + <span class=\"fa fa-mouse-pointer\"></span> Left</span>\n                                                </dt>\n                                                <dd>\n                                                    Move the canvas around\n                                                </dd>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"chickenpaint-shortcut-key\">Alt</span> + <span class=\"fa fa-mouse-pointer\"></span> Middle</span> <span class=\"chickenpaint-shortcut-alternate\">or</span> <span class=\"chickenpaint-shortcut\"><span class=\"chickenpaint-shortcut-key\">Alt</span> + <span class=\"chickenpaint-shortcut-key\">Space</span> + <span class=\"fa fa-mouse-pointer\"></span> Left</span>\n                                                </dt>\n                                                <dd>\n                                                    Rotate the canvas\n                                                </dd>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"fa fa-mouse-pointer\"></span> Right</span> <span class=\"chickenpaint-shortcut-alternate\">or</span> <span class=\"chickenpaint-shortcut\"><span class=\"chickenpaint-shortcut-key\">Alt</span> + <span class=\"fa fa-mouse-pointer\"></span> Left</span>\n                                                </dt>\n                                                <dd>\n                                                    Sample the color under the cursor\n                                                </dd>\n                                             </dl>\n                                        </li>\n                                    </ul>\n                                </div>\n                                <div class=\"chickenpaint-shortcuts-section\">\n                                    <h5>Layers palette</h5>\n                                    <ul class=\"chickenpaint-shortcuts-list list-unstyled\">\n                                        <li>\n                                            <dl>\n                                                <dt>\n                                                    <span class=\"chickenpaint-shortcut\"><span class=\"fa fa-mouse-pointer\"></span> Double click</span>\n                                                </dt>\n                                                <dd>\n                                                    Rename layer\n                                                </dd>\n                                             </dl>\n                                        </li>\n                                    </ul>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            ");

    // Destroy the modal upon close
    dialog.on("hidden.bs.modal", function (e) {
        dialog.remove();
    });

    dialog.modal({
        show: false
    });

    // Fix the backdrop location in the DOM by reparenting it to the chickenpaint container
    dialog.data("bs.modal").$body = $(parent);

    parent.appendChild(dialog[0]);

    this.show = function () {
        dialog.modal("show");
    };
}
module.exports = exports["default"];

},{}],37:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPSlider;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * A simple slider control.
 */
function CPSlider(minValue, maxValue, centerMode, expMode) {
    var PRECISE_DRAG_SCALE = 4,
        EXP_MODE_FACTOR = 1.5;

    var canvas = document.createElement("canvas"),
        canvasContext = canvas.getContext("2d"),
        valueRange = maxValue - minValue,
        dragNormal = false,
        dragPrecise = false,
        dragPreciseX,
        doneInitialPaint = false,
        that = this;

    this.value = undefined;

    /**
     * Either a string to draw on the slider, or a function(value) which receives the current value of the slider and
     * should return the string to be painted to the slider.
     *
     * @name CPSlider#title
     * @default ""
     */
    this.title = "";

    centerMode = centerMode || false;

    function paint() {
        var width = canvas.width,
            height = canvas.height,
            title = typeof that.title === "string" ? that.title : that.title(that.value),
            textX = 2 * window.devicePixelRatio,
            textY = canvas.height * 0.75;

        if (centerMode) {
            canvasContext.save();

            canvasContext.fillStyle = 'white';

            canvasContext.fillRect(0, 0, width, height);

            canvasContext.fillStyle = 'black';

            canvasContext.fillText(title, textX, textY);
            canvasContext.beginPath();

            if (that.value >= valueRange / 2) {
                canvasContext.rect(width / 2, 0, (that.value - valueRange / 2) * width / valueRange, height);
            } else {
                canvasContext.rect(that.value * width / valueRange, 0, (valueRange / 2 - that.value) * width / valueRange, height);
            }

            canvasContext.fill();
            canvasContext.clip();

            canvasContext.fillStyle = 'white';
            canvasContext.fillText(title, textX, textY);

            canvasContext.restore();
        } else {
            var barProp = (that.value - minValue) / valueRange,
                barWidth;

            if (expMode) {
                barProp = Math.pow(barProp, 1 / EXP_MODE_FACTOR);
            }

            barWidth = barProp * width;

            canvasContext.save();
            canvasContext.save();

            canvasContext.fillStyle = 'black';

            canvasContext.beginPath();
            canvasContext.rect(0, 0, barWidth, height);
            canvasContext.fill();

            canvasContext.clip();

            canvasContext.fillStyle = 'white';
            canvasContext.fillText(title, textX, textY);

            // Remove the clip region
            canvasContext.restore();

            canvasContext.fillStyle = 'white';

            canvasContext.beginPath();
            canvasContext.rect(barWidth, 0, width, height);
            canvasContext.fill();

            canvasContext.clip();

            canvasContext.fillStyle = 'black';
            canvasContext.fillText(title, textX, textY);

            canvasContext.restore();
        }
    }

    function mouseSelect(e) {
        var width = $(canvas).width(),
            left = $(canvas).offset().left,
            proportion = (e.pageX - left) / width;

        if (expMode) {
            // Give the user finer control over the low values
            proportion = Math.pow(Math.max(proportion, 0.0), EXP_MODE_FACTOR);
        }

        that.setValue(proportion * valueRange + minValue);
    }

    function mouseDragged(e) {
        if (dragNormal) {
            mouseSelect(e);
        } else if (dragPrecise) {
            var diff = (e.pageX - dragPreciseX) / PRECISE_DRAG_SCALE;

            if (diff != 0) {
                var unrounded = that.value + diff,
                    rounded = unrounded | 0;

                that.setValue(rounded);

                /* Tweak the "old mouseX" position such that the fractional part of the value we were unable to set
                 * will be accumulated
                 */
                dragPreciseX = e.pageX - (unrounded - rounded) * PRECISE_DRAG_SCALE;
            }
        }
    }

    function mouseUp(e) {
        if (dragNormal && e.button == 0) {
            dragNormal = false;
        } else if (dragPrecise && e.button == 2) {
            dragPrecise = false;
        } else {
            return;
        }

        canvas.releasePointerCapture(e.pointerId);
        canvas.removeEventListener("pointerup", mouseUp);
        canvas.removeEventListener("pointermove", mouseDragged);
    }

    this.setValue = function (_value) {
        _value = ~~Math.max(minValue, Math.min(maxValue, _value));

        if (this.value != _value) {
            this.value = _value;

            // The event listeners might like to update our title property at this point to reflect the new value
            this.emitEvent('valueChange', [this.value]);

            if (doneInitialPaint) {
                paint();
            } else {
                // We don't bother to do our canvas dimensioning until we're supplied with an initial value
                doneInitialPaint = true;
                this.resize();
            }
        }
    };

    /**
     * Get the DOM element for the slider component.
     */
    this.getElement = function () {
        return canvas;
    };

    this.resize = function () {
        canvas.width = $(canvas).width() || 150;
        canvas.height = $(canvas).height() || 20;

        if (window.devicePixelRatio > 1) {
            // Assume our width is set to 100% or similar, so we only need to the fix the height
            canvas.style.height = canvas.height + 'px';

            canvas.width = canvas.width * window.devicePixelRatio;
            canvas.height = canvas.height * window.devicePixelRatio;
        }

        canvasContext.font = canvas.height * 0.47 + 'pt sans-serif';

        paint();
    };

    canvas.addEventListener("pointerdown", function (e) {
        var dragging = dragNormal || dragPrecise;

        if (!dragging) {
            canvas.setPointerCapture(e.pointerId);

            switch (e.button) {
                case 0:
                    // Left
                    dragNormal = true;
                    mouseSelect(e);
                    break;
                case 2:
                    // Right
                    dragPrecise = true;
                    dragPreciseX = e.pageX;
                    break;
                default:
                    return;
            }

            canvas.addEventListener("pointerup", mouseUp);
            canvas.addEventListener("pointermove", mouseDragged);
        }
    });

    canvas.addEventListener("contextmenu", function (e) {
        e.preventDefault();
    });

    canvas.setAttribute("touch-action", "none");

    canvas.className = 'chickenpaint-slider';

    if (!window.devicePixelRatio) {
        // Old browsers
        window.devicePixelRatio = 1.0;
    }
}

CPSlider.prototype = Object.create(EventEmitter.prototype);
CPSlider.prototype.constructor = CPSlider;
module.exports = exports["default"];

},{}],38:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPSplashScreen;
function CPSplashScreen(uiParent, loader, resourcesRoot) {
    var MAX_SMOOTHIE_OFFSET = 170;

    var canvas = document.createElement("canvas"),
        canvasContext = canvas.getContext("2d"),
        cup = new Image(),
        lid = new Image(),
        outlines = new Image(),
        text = new Image(),
        shading = new Image(),
        highlights = new Image(),
        smoothie = new Image(),
        images = [cup, lid, outlines, text, shading, highlights, smoothie],
        loadedCount = 0,
        cupComposite,
        smoothieComposite,
        cupCompositeContext,
        smoothieCompositeContext,
        progress = 0.0,
        message = "",
        fontHeight = 14;

    var imageRoot = resourcesRoot + "splash/";

    for (var i = 0; i < images.length; i++) {
        images[i].onload = function () {
            loadedCount++;

            if (loadedCount == images.length) {
                repaint();
            }
        };
    }

    cup.src = imageRoot + "cup.png";
    highlights.src = imageRoot + "highlights.png";
    lid.src = imageRoot + "lid.png";
    outlines.src = imageRoot + "lines.png";
    shading.src = imageRoot + "shading.png";
    smoothie.src = imageRoot + "smoothie.png";
    text.src = imageRoot + "text.png";

    function buildSmoothieComposite(imgWidth, imgHeight, progress) {
        if (!smoothieComposite) {
            smoothieComposite = document.createElement("canvas");

            smoothieComposite.width = imgWidth;
            smoothieComposite.height = imgHeight;

            smoothieCompositeContext = smoothieComposite.getContext("2d");
        }

        // First draw the smoothie in its mask position:
        smoothieCompositeContext.globalCompositeOperation = "copy";
        smoothieCompositeContext.drawImage(smoothie, 0, 0);

        // Now shift the smoothie downwards and use the original position as a mask
        smoothieCompositeContext.globalCompositeOperation = "source-in";
        smoothieCompositeContext.drawImage(smoothie, 0, Math.round(progress * MAX_SMOOTHIE_OFFSET));
    }

    function buildCupComposite(imgWidth, imgHeight, progress) {
        if (!cupComposite) {
            cupComposite = document.createElement("canvas");

            cupComposite.width = imgWidth;
            cupComposite.height = imgHeight;

            cupCompositeContext = cupComposite.getContext("2d");
        }

        cupCompositeContext.globalCompositeOperation = "copy";
        cupCompositeContext.drawImage(cup, 0, 0);

        buildSmoothieComposite(imgWidth, imgHeight, progress);

        cupCompositeContext.globalCompositeOperation = "source-over";
        cupCompositeContext.drawImage(smoothieComposite, 0, 0);

        cupCompositeContext.drawImage(lid, 0, 0);

        cupCompositeContext.globalCompositeOperation = "screen";
        cupCompositeContext.drawImage(highlights, 0, 0);

        cupCompositeContext.globalCompositeOperation = "multiply";
        cupCompositeContext.drawImage(shading, 0, 0);

        return cupComposite;
    }

    function repaint() {
        var centerX = canvas.width / 2,
            centerY = canvas.height / 2;

        canvasContext.fillStyle = 'white';
        canvasContext.fillRect(0, 0, canvas.width, canvas.height);

        if (loadedCount == images.length) {
            var imgWidth = text.width,
                imgHeight = text.height,
                left = Math.round(centerX - imgWidth / 2),
                top = Math.round(centerY - imgHeight / 2);

            canvasContext.drawImage(text, left, top);

            buildCupComposite(imgWidth, imgHeight, progress);

            //The whole cup composite is slightly transparent
            canvasContext.globalAlpha = 0.88;
            canvasContext.drawImage(cupComposite, left, top);

            canvasContext.globalAlpha = 1.0;

            canvasContext.drawImage(outlines, left, top);

            centerY = Math.round(centerY + imgHeight / 2 + 2);
        }

        if (message != "") {
            canvasContext.fillStyle = "black";

            var lines = message.split("\n");

            for (var i = 0; i < lines.length; i++) {
                var line = lines[i],
                    lineWidth = canvasContext.measureText(line).width;

                centerY += fontHeight * 2;

                canvasContext.fillText(line, centerX - lineWidth / 2, centerY);
            }
        }
    }

    function resize() {
        // Use the canvas dimensions set by the CSS styles
        canvas.width = canvas.clientWidth;
        canvas.height = canvas.clientHeight;

        canvasContext.font = fontHeight + "pt sans-serif";

        repaint();
    }

    loader.on("loadingProgress", function (_progress, _message) {
        progress = _progress;
        message = _message;

        repaint();
    });

    loader.on("loadingFailure", function (_message) {
        progress = 0;
        message = _message;

        repaint();
    });

    loader.on("loadingComplete", function () {
        window.removeEventListener("resize", resize);
        uiParent.removeChild(canvas);
    });

    window.addEventListener("resize", resize);

    canvas.className = "chickenpaint-splash-screen";

    uiParent.appendChild(canvas);

    resize();
}
module.exports = exports["default"];

},{}],39:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPStrokePalette;

var _CPPalette = require('./CPPalette');

var _CPPalette2 = _interopRequireDefault(_CPPalette);

var _CPBrushInfo = require('../engine/CPBrushInfo');

var _CPBrushInfo2 = _interopRequireDefault(_CPBrushInfo);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPStrokePalette(cpController) {
    _CPPalette2.default.call(this, cpController, "stroke", "Stroke");

    var that = this,
        buttons = [{
        className: "chickenpaint-tool-freehand",
        command: "CPFreeHand",
        toolTip: "Free-hand",
        selected: true
    }, {
        className: "chickenpaint-tool-line",
        command: "CPLine",
        toolTip: "Straight line"
    }, {
        className: "chickenpaint-tool-bezier",
        command: "CPBezier",
        toolTip: "Bezier curve"
    }],
        body = that.getBodyElement();

    function buildButtons() {
        var listElem = document.createElement("ul");

        listElem.className = "chickenpaint-stroke-tools list-unstyled";

        for (var i in buttons) {
            var button = buttons[i],
                buttonElem = document.createElement("li");

            buttonElem.className = "chickenpaint-toolbar-button " + button.className;
            buttonElem.setAttribute("data-buttonIndex", i);

            if (button.selected) {
                buttonElem.className = buttonElem.className + " selected";
            }

            listElem.appendChild(buttonElem);
        }

        listElem.addEventListener("click", function (e) {
            if (e.target && e.target.nodeName == "LI") {
                var button = buttons[parseInt(e.target.getAttribute("data-buttonIndex"), 10)];

                $("li", listElem).removeClass("selected");
                $(e.target).addClass("selected");

                cpController.actionPerformed({ action: button.command });
            }
        });

        body.appendChild(listElem);
    }

    buildButtons();

    cpController.on("toolChange", function (tool, toolInfo) {
        $(".chickenpaint-tool-freehand", body).toggleClass("selected", toolInfo.strokeMode == _CPBrushInfo2.default.SM_FREEHAND);
        $(".chickenpaint-tool-line", body).toggleClass("selected", toolInfo.strokeMode == _CPBrushInfo2.default.SM_LINE);
        $(".chickenpaint-tool-bezier", body).toggleClass("selected", toolInfo.strokeMode == _CPBrushInfo2.default.SM_BEZIER);
    });
}

CPStrokePalette.prototype = Object.create(_CPPalette2.default.prototype);
CPStrokePalette.prototype.constructor = CPStrokePalette;
module.exports = exports['default'];

},{"../engine/CPBrushInfo":5,"./CPPalette":32}],40:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPSwatchesPalette;

var _CPPalette = require('./CPPalette');

var _CPPalette2 = _interopRequireDefault(_CPPalette);

var _CPColor = require('../util/CPColor');

var _CPColor2 = _interopRequireDefault(_CPColor);

var _AdobeColorTable = require('../util/AdobeColorTable');

var _AdobeColorTable2 = _interopRequireDefault(_AdobeColorTable);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function padLeft(string, padding, len) {
    while (string.length < len) {
        string = padding + string;
    }
    return string;
} /*
      ChickenPaint
      
      ChickenPaint is a translation of ChibiPaint from Java to JavaScript
      by Nicholas Sherlock / Chicken Smoothie.
      
      ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
      ChickenPaint is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      ChickenPaint is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

function wrapWithElem(e, wrapWithName) {
    var parent = document.createElement(wrapWithName);

    parent.appendChild(e);

    return parent;
}

function fileAPIsSupported() {
    return window.File && window.FileReader && window.FileList && window.Blob;
}

function CPSwatchesPalette(controller) {
    _CPPalette2.default.call(this, controller, "swatches", "Color swatches");

    var INIT_COLORS = [0xffffff, 0x000000, 0xff0000, 0x00ff00, 0x0000ff, 0xffff00],
        modified = false,
        swatchPanel = document.createElement("ul"),
        buttonPanel = document.createElement("div"),
        fileInput,
        that = this;

    function CPColorSwatch(color) {
        var wrapper = document.createElement("div"),
            swatchElem = document.createElement("a"),
            swatchMenu = document.createElement("ul"),
            mnuRemove = document.createElement("a"),
            mnuSetToCurrent = document.createElement("a"),
            that = this;

        this.getElement = function () {
            return wrapper;
        };

        this.setColor = function (color) {
            swatchElem.setAttribute("data-color", color);
            swatchElem.style.backgroundColor = '#' + padLeft("" + Number(color).toString(16), "0", 6);
        };

        this.setColor(color);

        swatchElem.href = "#";
        swatchElem.className = "chickenpaint-color-swatch dropdown-toggle";
        swatchElem.setAttribute("data-toggle", "dropdown");

        mnuRemove.href = "#";
        mnuRemove.innerHTML = "Remove";

        mnuRemove.addEventListener("click", function (e) {
            e.preventDefault();
            $(wrapper).remove();

            modified = true;
        });

        mnuSetToCurrent.href = "#";
        mnuSetToCurrent.innerHTML = "Replace with current color";

        mnuSetToCurrent.addEventListener("click", function (e) {
            e.preventDefault();

            that.setColor(controller.getCurColor().getRgb());

            modified = true;
        });

        swatchMenu.className = "dropdown-menu";

        swatchMenu.appendChild(wrapWithElem(mnuRemove, "li"));
        swatchMenu.appendChild(wrapWithElem(mnuSetToCurrent, "li"));

        wrapper.className = "chickenpaint-color-swatch-wrapper";
        wrapper.appendChild(swatchElem);
        wrapper.appendChild(swatchMenu);

        $(wrapper).on("show.bs.dropdown", function () {
            var $btnDropDown = $(this).find(".dropdown-toggle"),
                $listHolder = $(this).find(".dropdown-menu");

            $listHolder.css({
                "top": $btnDropDown.position().top + $btnDropDown.outerHeight(true) + "px",
                "left": $btnDropDown.position().left + "px"
            });
        });
    }

    function clearSwatches() {
        while (swatchPanel.lastChild) {
            swatchPanel.removeChild(swatchPanel.lastChild);
        }
    }

    function addSwatch(color) {
        var swatch = new CPColorSwatch(color);

        swatchPanel.appendChild(swatch.getElement());
    }

    /**
     * Returns an array of colors in RGB 32-bit integer format
     */
    this.getSwatches = function () {
        var swatches = $(".chickenpaint-color-swatch", swatchPanel),
            colors = new Array(swatches.length);

        for (var i = 0; i < swatches.length; i++) {
            colors[i] = parseInt(swatches.get(i).getAttribute("data-color"), 10);
        }

        return colors;
    };

    this.setSwatches = function (swatches) {
        clearSwatches();

        for (var i = 0; i < swatches.length; i++) {
            addSwatch(swatches[i]);
        }

        modified = true;
    };

    this.isModified = function () {
        return modified;
    };

    function loadSwatches() {
        fileInput.onchange = function () {
            var fileList = this.files;

            if (fileList.length < 1) return;

            var file = fileList[0],
                reader = new FileReader();

            reader.onload = function () {
                var swatches = new _AdobeColorTable2.default().read(this.result);

                if (swatches != null && swatches.length > 0) {
                    that.setSwatches(swatches);
                } else {
                    alert("The swatches could not be read, did you select an .aco file?");
                }
            };

            reader.readAsArrayBuffer(file);
        };

        fileInput.click();
    }

    function saveSwatches() {
        var aco = new _AdobeColorTable2.default().write(that.getSwatches()),
            blob = new Blob([aco], { type: "application/octet-stream" });

        window.saveAs(blob, "oekakiswatches.aco");
    }

    function initSwatchPanel() {
        swatchPanel.className = "chickenpaint-color-swatches list-unstyled";

        for (var i = 0; i < INIT_COLORS.length; i++) {
            swatchPanel.appendChild(new CPColorSwatch(INIT_COLORS[i]).getElement());
        }

        swatchPanel.addEventListener("click", function (e) {
            var swatch = e.target;

            if (!/chickenpaint-color-swatch/.test(swatch.className)) {
                return;
            }

            if (e.button == 0 /* Left */ && swatch.getAttribute("data-color") !== undefined) {
                controller.setCurColor(new _CPColor2.default(parseInt(swatch.getAttribute("data-color"), 10)));
                e.stopPropagation();
                e.preventDefault();
            }
        });

        swatchPanel.addEventListener("contextmenu", function (e) {
            var swatch = e.target;

            if (!/chickenpaint-color-swatch/.test(swatch.className)) {
                return;
            }

            e.preventDefault();

            $(swatch).dropdown("toggle").off("click.bs.dropdown"); // Remove Bootstrap's left-click handler installed by toggle
        });
    }

    function initButtonsPanel() {
        var btnSettings = document.createElement("div"),
            btnAdd = document.createElement("div"),
            settingsMenu = document.createElement("ul"),
            mnuSave = document.createElement("a"),
            mnuLoad = document.createElement("a");

        btnAdd.title = "Add the current brush color as a new swatch";
        btnAdd.className = "chickenpaint-small-toolbar-button chickenpaint-color-swatch-add";

        btnSettings.className = "chickenpaint-small-toolbar-button chickenpaint-color-swatch-settings";
        btnSettings.setAttribute("data-toggle", "dropdown");
        $(btnSettings).dropdown();

        mnuSave.href = "#";
        mnuSave.innerHTML = "Save swatches to your computer...";
        mnuSave.addEventListener("click", function (e) {
            e.preventDefault();

            saveSwatches();
        });

        mnuLoad.href = "#";
        mnuLoad.innerHTML = "Load swatches from your computer...";
        mnuLoad.addEventListener("click", function (e) {
            e.preventDefault();

            loadSwatches();
        });

        settingsMenu.className = "dropdown-menu dropdown-menu-right";

        settingsMenu.appendChild(wrapWithElem(mnuSave, "li"));
        settingsMenu.appendChild(wrapWithElem(mnuLoad, "li"));

        var btnSettingsContainer = document.createElement("div");

        btnSettingsContainer.className = 'dropdown';
        btnSettingsContainer.appendChild(btnSettings);
        btnSettingsContainer.appendChild(settingsMenu);

        $(btnSettingsContainer).on("show.bs.dropdown", function () {
            /* Instead of Bootstrap's extremely expensive data API, we'll only listen for dismiss clicks on the
             * document *while the menu is open!*
             */
            $(document).one("click", function () {
                if ($(btnSettingsContainer).hasClass("open")) {
                    $(btnSettings).dropdown("toggle");
                }
            });
        });

        btnAdd.addEventListener("click", function (e) {
            addSwatch(controller.getCurColor().getRgb());
            modified = true;
        });

        buttonPanel.className = 'chickenpaint-color-swatches-buttons';

        // Don't offer to load/save swatches if we don't have the file API needed for reading them
        if (fileAPIsSupported()) {
            fileInput = document.createElement("input");

            fileInput.type = "file";
            fileInput.multiple = false;
            fileInput.style.display = "none";

            buttonPanel.appendChild(btnSettingsContainer);
            buttonPanel.appendChild(fileInput);
        }

        buttonPanel.appendChild(btnAdd);
    }

    initSwatchPanel();
    this.getBodyElement().appendChild(swatchPanel);

    initButtonsPanel();
    this.getBodyElement().appendChild(buttonPanel);
}

CPSwatchesPalette.prototype = Object.create(_CPPalette2.default.prototype);
CPSwatchesPalette.prototype.constructor = CPSwatchesPalette;
module.exports = exports['default'];

},{"../util/AdobeColorTable":44,"../util/CPColor":47,"./CPPalette":32}],41:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPTabletDialog;

var _CPWacomTablet = require("../util/CPWacomTablet");

var _CPWacomTablet2 = _interopRequireDefault(_CPWacomTablet);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CPTabletDialog(parent) {
    var dialog = $("<div class=\"modal fade\" tabindex=\"-1\" role=\"dialog\">\n                <div class=\"modal-dialog\">\n                    <div class=\"modal-content\">\n                        <div class=\"modal-header\">\n                            <button type=\"button\" class=\"close\" data-dismiss=\"modal\" aria-label=\"Close\">\n                                <span aria-hidden=\"true\">&times;</span>\n                            </button>\n                            <h4 class=\"modal-title\">Drawing tablet support</h4>\n                        </div>\n                        <div class=\"modal-body\">\n                            <p class=\"chickenpaint-tablet-there-are-two-options\">\n                                There are two ways you could use your tablet's pen pressure support with ChickenPaint.\n                            </p>\n                            <div class=\"chickenpaint-tablet-support chickenpaint-wacom-support\">\n                                <h4>\n                                    Plugin for Wacom tablets\n                                </h4>\n                                <div class=\"chickenpaint-supported-browsers\">\n                                    <div class=\"chickenpaint-supported-browser\">\n                                        <span class=\"fa fa-internet-explorer\"></span>\n                                        IE 10, 11\n                                    </div>\n                                    <div class=\"chickenpaint-supported-browser\">\n                                        <span class=\"fa fa-firefox\"></span>\n                                        Firefox (32-bit only)\n                                    </div>\n                                    <div class=\"chickenpaint-supported-browser\">\n                                        <span class=\"fa fa-safari\"></span>\n                                        Safari\n                                    </div>\n                                        <div class=\"chickenpaint-supported-browser\">\n                                        <span class=\"fa fa-opera\"></span>\n                                        Opera\n                                    </div>\n                                </div>\n                                <p class=\"chickenpaint-not-installed\">\n                                    The plugin for Wacom tablets doesn't seem to be installed in your browser yet.\n                                </p>\n                                <p class=\"chickenpaint-not-installed\">\n                                    Please make sure that you've installed the latest drivers for your tablet from the \n                                    <a href=\"http://www.wacom.com/en-us/support/product-support/drivers\" target=\"_blank\">Wacom drivers page</a>,\n                                    then restart your browser.\n                                </p>\n                                <p class=\"chickenpaint-not-supported\">\n                                    Your browser doesn't support the Wacom tablet plugin, please \n                                    try one of the browsers listed above instead.\n                                </p>\n                                <p class=\"chickenpaint-supported alert alert-success\">\n                                    The Wacom tablet plugin is installed and working.\n                                </p>\n                            </div>\n                            <div class=\"chickenpaint-tablet-support chickenpaint-pointerevents-support\">\n                                <h4>\n                                    Built-in support for most tablets <small>including Wacom tablets</small>\n                                </h4>\n                                <div class=\"chickenpaint-supported-browsers\">\n                                    <div class=\"chickenpaint-supported-browser\">\n                                        <span class=\"fa fa-internet-explorer\"></span>\n                                        IE (Windows 8)\n                                    </div>\n                                        <div class=\"chickenpaint-supported-browser\">\n                                        <span class=\"fa fa-edge\"></span>\n                                        Edge (Windows 10)\n                                    </div>\n                                    <div class=\"chickenpaint-supported-browser\">\n                                        <span class=\"fa fa-firefox\"></span>\n                                        Firefox (<a href=\"https://github.com/thenickdude/chickenpaint/blob/master/help/Firefox pressure support.md\" target=\"_blank\">experimental <i class=\"glyphicon glyphicon-new-window\"></i></a>)\n                                    </div>\n                                    <div class=\"chickenpaint-supported-browser\">\n                                        <span class=\"fa fa-chrome\"></span>\n                                        Chrome\n                                    </div>\n                                </div>\n                                <p class=\"chickenpaint-not-supported\">\n                                    Your browser doesn't have built-in support for drawing tablets, please try\n                                    one of the other browsers listed above.\n                                </p>\n                                <p class=\"chickenpaint-supported alert alert-success\">\n                                    Your browser has built-in support for drawing tablets!\n                                </p>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n       ");

    var wacomSupportElem = $(".chickenpaint-wacom-support", dialog),
        peSupportElem = $(".chickenpaint-pointerevents-support", dialog),
        bothOptionsElem = $(".chickenpaint-tablet-there-are-two-options", dialog),
        wacomPresent = _CPWacomTablet2.default.getRef().isTabletPresent(),
        peSupported = !!window.hasNativePointerEvents;

    wacomSupportElem.toggleClass("supported", wacomPresent);

    if (wacomPresent) {
        // Don't bother displaying info about Pointer Events if we have the Wacom plugin installed
        peSupportElem.hide();
        bothOptionsElem.hide();
    } else {
        // Chrome has dropped NPAPI support, so the Wacom plugin cannot be installed
        if (/Chrome/i.test(navigator.userAgent) && !/OPR/.test(navigator.userAgent) || /iPad/.test(navigator.userAgent) || /iPhone/.test(navigator.userAgent)) {
            wacomSupportElem.addClass("not-supported");
        }

        // Don't bother showing the Wacom plugin details if this browser supports pointer events
        if (peSupported) {
            wacomSupportElem.hide();
            bothOptionsElem.hide();
        }
    }

    peSupportElem.toggleClass("supported", peSupported);
    peSupportElem.toggleClass("not-supported", !peSupported);

    dialog.modal({
        show: false
    });

    // Fix the backdrop location in the DOM by reparenting it to the chickenpaint container
    dialog.data("bs.modal").$body = $(parent);

    parent.appendChild(dialog[0]);

    this.show = function () {
        dialog.modal("show");
    };
} /*
      ChickenPaint
      
      ChickenPaint is a translation of ChibiPaint from Java to JavaScript
      by Nicholas Sherlock / Chicken Smoothie.
      
      ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
      ChickenPaint is free software: you can redistribute it and/or modify
      it under the terms of the GNU General Public License as published by
      the Free Software Foundation, either version 3 of the License, or
      (at your option) any later version.
  
      ChickenPaint is distributed in the hope that it will be useful,
      but WITHOUT ANY WARRANTY; without even the implied warranty of
      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
      GNU General Public License for more details.
  
      You should have received a copy of the GNU General Public License
      along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

module.exports = exports["default"];

},{"../util/CPWacomTablet":55}],42:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPTexturePalette;

var _CPGreyBmp = require('../engine/CPGreyBmp');

var _CPGreyBmp2 = _interopRequireDefault(_CPGreyBmp);

var _CPLookUpTable = require('../engine/CPLookUpTable');

var _CPLookUpTable2 = _interopRequireDefault(_CPLookUpTable);

var _CPPalette = require('./CPPalette');

var _CPPalette2 = _interopRequireDefault(_CPPalette);

var _CPSlider = require('./CPSlider');

var _CPSlider2 = _interopRequireDefault(_CPSlider);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function wrapCheckboxWithLabel(checkbox, title) {
    var div = document.createElement("div"),
        label = document.createElement("label");

    div.className = "checkbox";

    label.appendChild(checkbox);
    label.appendChild(document.createTextNode(title));

    div.appendChild(label);

    return div;
}

function loadTextures(textureFilename, width, height, textureCount, then) {
    var img = new Image(),
        textures = [];

    img.onload = function () {
        var canvas = document.createElement("canvas"),
            canvasContext = canvas.getContext("2d");

        canvas.width = img.width;
        canvas.height = img.height;

        for (var i = 0; i < textureCount; i++) {
            canvasContext.drawImage(img, 0, i * height, width, height, 0, 0, width, height);

            try {
                var imageData = canvasContext.getImageData(0, 0, width, height),
                    texture = new _CPGreyBmp2.default(width, height);

                // Take just the red channel from the image to form the new grayscale texture
                for (var j = 0; j < width * height; j++) {
                    texture.data[j] = imageData.data[j * 4];
                }

                textures.push(texture);
            } catch (e) {
                // Quietly ignore errors that occur while loading the image (e.g. cross-origin security failures)
                console.log(e);
            }
        }

        then(textures);
    };

    img.src = textureFilename;
}

function CPTexturePalette(controller) {
    _CPPalette2.default.call(this, controller, "textures", "Textures");

    var TEXTURE_PREVIEW_SIZE = 64,
        TEXTURE_SWATCH_BUTTON_SIZE = 32,
        textures = [],
        // Array of CPGreyBmp
    selectedTexture,
        processedTexture,
        //Both CPGreyBmp

    mirror = false,
        inverse = false,
        brightness = 0.0,
        contrast = 0.0,
        optionsPanel,
        texturesPanel = document.createElement("div"),
        body = this.getBodyElement();

    /**
     * Add an array of textures to the global texture list, and add swatches for them to the UI.
     */
    function addTextures(newTextures) {
        for (var i = 0; i < newTextures.length; i++) {
            var texture = newTextures[i];

            textures.push(texture);

            var button = new CPTextureSwatch(texture, TEXTURE_SWATCH_BUTTON_SIZE, TEXTURE_SWATCH_BUTTON_SIZE);

            button.on("click", function () {
                selectedTexture = this.texture;
                updateSelectedTexture();
            });

            texturesPanel.appendChild(button.getElement());
        }
    }

    /**
     * Generate and return an array of procedurally-generated textures
     * 
     * @returns CPGreyBmp[]
     */
    function makeProceduralTextures() {
        var result = [null];

        var texture = new _CPGreyBmp2.default(2, 2);
        texture.data[0] = 0xFF;
        texture.data[3] = 0xFF;
        result.push(texture);

        result.push(makeDotTexture(2));
        result.push(makeDotTexture(3));
        result.push(makeDotTexture(4));
        result.push(makeDotTexture(6));
        result.push(makeDotTexture(8));

        result.push(makeVertLinesTexture(1, 2));
        result.push(makeVertLinesTexture(2, 4));

        result.push(makeHorizLinesTexture(1, 2));
        result.push(makeHorizLinesTexture(2, 4));

        result.push(makeCheckerBoardTexture(2));
        result.push(makeCheckerBoardTexture(4));
        result.push(makeCheckerBoardTexture(8));
        result.push(makeCheckerBoardTexture(16));

        return result;
    }

    /**
     * @param size int
     * 
     * @returns CPGreyBmp
     */
    function makeDotTexture(size) {
        var texture = new _CPGreyBmp2.default(size, size);

        for (var i = 1; i < size * size; i++) {
            texture.data[i] = 0xFF;
        }
        return texture;
    }

    /**
     * Make a checkerboard texture of the given dimensions.
     * 
     * @param size int
     * 
     * @returns CPGreyBmp
     */
    function makeCheckerBoardTexture(size) {
        var textureSize = 2 * size,
            texture = new _CPGreyBmp2.default(textureSize, textureSize);

        for (var i = 0; i < textureSize; i++) {
            for (var j = 0; j < textureSize; j++) {
                texture.data[i + j * textureSize] = (~~(i / size) + ~~(j / size)) % 2 == 0 ? 0 : 0xFF;
            }
        }

        return texture;
    }

    /**
     * Make a texture consisting of a series of evenly-spaced vertical lines
     * 
     * @param lineSize int
     * @param size int
     * 
     * @returns CPGreyBmp
     */
    function makeVertLinesTexture(lineSize, size) {
        var texture = new _CPGreyBmp2.default(size, size);

        for (var i = 0; i < size * size; i++) {
            if (~~(i % size) >= lineSize) {
                texture.data[i] = 0xFF;
            }
        }

        return texture;
    }

    /**
     * Make a texture consisting of a series of evenly-spaced horizontal lines
     *
     * @param lineSize int
     * @param size int
     * 
     * @returns CPGreyBmp
     */
    function makeHorizLinesTexture(lineSize, size) {
        var texture = new _CPGreyBmp2.default(size, size);

        for (var i = 0; i < size * size; i++) {
            if (i / size >= lineSize) {
                texture.data[i] = 0xFF;
            }
        }

        return texture;
    }

    function updateSelectedTexture() {
        if (selectedTexture != null) {
            processedTexture = selectedTexture.clone();

            if (mirror) {
                processedTexture.mirrorHorizontally();
            }

            var lut = new _CPLookUpTable2.default();

            lut.loadBrightnessContrast(brightness, contrast);

            if (inverse) {
                lut.invert();
            }

            processedTexture.applyLUT(lut);
        } else {
            processedTexture = null;
        }

        controller.getArtwork().setBrushTexture(processedTexture);

        if (optionsPanel != null) {
            optionsPanel.updateTexture();
        }
    }

    function CPTextureOptionsPanel() {
        var panel = document.createElement("div"),
            cbInverse = document.createElement("input"),
            cbMirror = document.createElement("input"),
            slBrightness = new _CPSlider2.default(0, 200, true),
            slContrast = new _CPSlider2.default(0, 200, true),
            sampleSwatch = new CPTextureSwatch(null, TEXTURE_PREVIEW_SIZE, TEXTURE_PREVIEW_SIZE),
            btnCustomize = document.createElement("button"),
            textureControlsPanel;

        function updatePopoverControls() {
            cbInverse.checked = inverse;
            cbMirror.checked = mirror;

            slBrightness.setValue(brightness * 100 + 100);
            slContrast.setValue(contrast * 100 + 100);
        }

        function buildTextureControlsPanel() {
            var panel = document.createElement("div");

            cbInverse.type = "checkbox";
            cbInverse.addEventListener("click", function (e) {
                inverse = this.checked;
                updateSelectedTexture();
            });

            panel.appendChild(wrapCheckboxWithLabel(cbInverse, "Inverse"));

            cbMirror.type = "checkbox";
            cbMirror.addEventListener("click", function (e) {
                mirror = this.checked;
                updateSelectedTexture();
            });

            panel.appendChild(wrapCheckboxWithLabel(cbMirror, "Mirror"));

            slBrightness.title = function (value) {
                return "Brightness: " + (value - 100) + "%";
            };

            slBrightness.on("valueChange", function (value) {
                brightness = (value - 100) / 100.0;

                updateSelectedTexture();
            });

            panel.appendChild(slBrightness.getElement());

            slContrast.title = function (value) {
                return "Contrast: " + (value - 100) + "%";
            };

            slContrast.on("valueChange", function (value) {
                contrast = (value - 100) / 100;

                updateSelectedTexture();
            });

            panel.appendChild(slContrast.getElement());

            var okayButton = document.createElement("button"),
                resetButton = document.createElement("button");

            okayButton.innerHTML = "Ok";
            okayButton.className = "btn btn-primary btn-sm";
            okayButton.type = "button";

            okayButton.addEventListener("click", function (e) {
                $(btnCustomize).popover('hide');
            });

            panel.appendChild(okayButton);
            panel.appendChild(document.createTextNode(" "));

            resetButton.innerHTML = "Reset";
            resetButton.className = "btn btn-default btn-sm";
            resetButton.type = "button";

            resetButton.addEventListener("click", function (e) {
                brightness = 0;
                contrast = 0;
                mirror = false;
                inverse = false;

                updatePopoverControls();
                updateSelectedTexture();
            });

            panel.appendChild(resetButton);

            updatePopoverControls();

            return panel;
        }

        // TODO use events instead
        this.updateTexture = function () {
            btnCustomize.disabled = processedTexture == null;
            sampleSwatch.setTexture(processedTexture);
        };

        this.getElement = function () {
            return panel;
        };

        panel.className = "chickenpaint-texture-options";
        panel.appendChild(sampleSwatch.getElement());

        btnCustomize.type = "button";
        btnCustomize.className = "btn btn-default btn-sm";
        btnCustomize.innerHTML = "Customize";

        textureControlsPanel = buildTextureControlsPanel();

        $(btnCustomize).popover({
            html: true,
            content: function content() {
                return textureControlsPanel;
            },
            trigger: "manual"
        }).on("click", function () {
            $(this).popover("toggle");
        });

        panel.appendChild(btnCustomize);

        this.updateTexture();
    }

    function CPTextureSwatch(texture, width, height) {
        var canvas = document.createElement("canvas"),
            canvasContext = canvas.getContext("2d"),
            that = this;

        this.setTexture = function (texture) {
            this.texture = texture;

            this.paint();
        };

        this.getElement = function () {
            return canvas;
        };

        this.paint = function () {
            if (this.texture != null) {
                canvasContext.fillStyle = canvasContext.createPattern(this.texture.toCanvas(), "repeat");
            } else {
                canvasContext.fillStyle = 'white';
            }
            canvasContext.fillRect(0, 0, canvas.width, canvas.height);
        };

        canvas.addEventListener("click", function () {
            that.emit("click");
        });

        canvas.width = width;
        canvas.height = height;

        this.setTexture(texture);
    }

    CPTextureSwatch.prototype = Object.create(EventEmitter.prototype);
    CPTextureSwatch.prototype.constructor = CPTextureSwatch;

    optionsPanel = new CPTextureOptionsPanel();

    body.appendChild(optionsPanel.getElement());

    texturesPanel.className = 'chickenpaint-texture-swatches';

    body.appendChild(texturesPanel);

    addTextures(makeProceduralTextures());

    loadTextures(controller.getResourcesRoot() + "gfx/textures32.png", 32, 32, 2, function (loadedTextures) {
        addTextures(loadedTextures);
    });
}

CPTexturePalette.prototype = Object.create(_CPPalette2.default.prototype);
CPTexturePalette.prototype.constructor = CPTexturePalette;
module.exports = exports['default'];

},{"../engine/CPGreyBmp":10,"../engine/CPLookUpTable":12,"./CPPalette":32,"./CPSlider":37}],43:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPToolPalette;

var _CPPalette = require('./CPPalette');

var _CPPalette2 = _interopRequireDefault(_CPPalette);

var _ChickenPaint = require('../ChickenPaint');

var _ChickenPaint2 = _interopRequireDefault(_ChickenPaint);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPToolPalette(cpController) {
    _CPPalette2.default.call(this, cpController, "tool", "Tools");

    var that = this,
        buttons = [{
        className: "chickenpaint-tool-rect-selection",
        command: "CPRectSelection",
        toolTip: "Marquee",
        shortcut: "m",
        mode: _ChickenPaint2.default.M_RECT_SELECTION
    }, {
        className: "chickenpaint-tool-move",
        command: "CPMoveTool",
        toolTip: "Move tool",
        shortcut: "v",
        mode: _ChickenPaint2.default.M_MOVE_TOOL
    }, {
        className: "chickenpaint-tool-flood-fill",
        command: "CPFloodFill",
        toolTip: "Flood fill",
        shortcut: "f",
        mode: _ChickenPaint2.default.M_FLOODFILL
    }, {
        className: "chickenpaint-tool-gradient-fill",
        command: "CPGradientFill",
        toolTip: "Gradient fill",
        shortcut: "g",
        mode: _ChickenPaint2.default.M_GRADIENTFILL
    }, {
        className: "chickenpaint-tool-color-picker",
        command: "CPColorPicker",
        toolTip: "Color picker",
        shortcut: "i",
        mode: _ChickenPaint2.default.M_COLOR_PICKER
    }, {
        className: "chickenpaint-tool-rotate-canvas",
        command: "CPRotateCanvas",
        commandDoubleClick: "CPResetCanvasRotation",
        toolTip: "Rotate canvas",
        mode: _ChickenPaint2.default.M_ROTATE_CANVAS
    }, {
        className: "chickenpaint-tool-pencil",
        command: "CPPencil",
        toolTip: "Pencil",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_PENCIL
    }, {
        className: "chickenpaint-tool-pen",
        command: "CPPen",
        toolTip: "Pen",
        selected: true, // TODO a better mechanism for the controller to let us know the initial tool
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_PEN
    }, {
        className: "chickenpaint-tool-airbrush",
        command: "CPAirbrush",
        toolTip: "Airbrush",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_AIRBRUSH
    }, {
        className: "chickenpaint-tool-water",
        command: "CPWater",
        toolTip: "Waterpaint",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_WATER
    }, {
        className: "chickenpaint-tool-eraser",
        command: "CPEraser",
        toolTip: "Eraser",
        shortcut: "e",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_ERASER
    }, {
        className: "chickenpaint-tool-soft-eraser",
        command: "CPSoftEraser",
        toolTip: "Soft eraser",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_SOFTERASER
    }, {
        className: "chickenpaint-tool-smudge",
        command: "CPSmudge",
        toolTip: "Smudge",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_SMUDGE
    }, {
        className: "chickenpaint-tool-blender",
        command: "CPBlender",
        toolTip: "Blender",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_BLENDER
    }, {
        className: "chickenpaint-tool-dodge",
        command: "CPDodge",
        toolTip: "Dodge",
        shortcut: "o",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_DODGE
    }, {
        className: "chickenpaint-tool-burn",
        command: "CPBurn",
        toolTip: "Burn",
        shortcut: "p",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_BURN
    }, {
        className: "chickenpaint-tool-blur",
        command: "CPBlur",
        toolTip: "Blur",
        mode: _ChickenPaint2.default.M_DRAW,
        tool: _ChickenPaint2.default.T_BLUR
    }],
        listElem = document.createElement("ul");

    function buttonClicked(e) {
        if (this.nodeName == "LI") {
            var button = buttons[parseInt(this.getAttribute("data-buttonIndex"), 10)];

            cpController.actionPerformed({ action: button.command });
        }
    }

    function buildButtons() {
        var body = that.getBodyElement();

        listElem.className = "chickenpaint-tools list-unstyled";

        for (var i in buttons) {
            (function (i) {
                var button = buttons[i],
                    buttonElem = document.createElement("li");

                buttonElem.className = "chickenpaint-toolbar-button " + button.className;
                buttonElem.setAttribute("data-buttonIndex", i);

                buttonElem.setAttribute('data-mode', button.mode);
                if (button.tool !== undefined) {
                    buttonElem.setAttribute('data-tool', button.tool);
                }

                buttonElem.title = button.toolTip;

                if (button.shortcut) {
                    buttonElem.title += " (" + button.shortcut.toUpperCase() + ")";

                    key(button.shortcut, function () {
                        buttonClicked.call(buttonElem);

                        return false;
                    });
                }

                if (button.selected) {
                    buttonElem.className = buttonElem.className + " selected";
                }

                listElem.appendChild(buttonElem);
            })(i);
        }

        $(listElem).on("click", "li", buttonClicked);

        listElem.addEventListener("dblclick", function (e) {
            if (this.nodeName == "LI") {
                var button = buttons[parseInt(this.getAttribute("data-buttonIndex"), 10)];

                if (button.commandDoubleClick) {
                    cpController.actionPerformed({ action: button.commandDoubleClick });
                }
            }
        });

        body.appendChild(listElem);
    }

    cpController.on("modeChange", function (newMode) {
        var body = that.getBodyElement();

        $("li", body).removeClass("selected");

        if (newMode == _ChickenPaint2.default.M_DRAW) {
            $("li[data-tool=" + cpController.getCurTool() + "]", body).addClass("selected");
        } else {
            $("li[data-mode=" + newMode + "]", body).addClass("selected");
        }
    });

    cpController.on("toolChange", function (newTool) {
        var body = that.getBodyElement();

        if (cpController.getCurMode() == _ChickenPaint2.default.M_DRAW) {
            $("li", body).removeClass("selected");

            $("li[data-tool=" + newTool + "]", body).addClass("selected");
        }
    });

    buildButtons();
}

CPToolPalette.prototype = Object.create(_CPPalette2.default.prototype);
CPToolPalette.prototype.constructor = CPToolPalette;
module.exports = exports['default'];

},{"../ChickenPaint":1,"./CPPalette":32}],44:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = AdobeColorTable;

var _ArrayDataStream = require("./ArrayDataStream");

var _ArrayDataStream2 = _interopRequireDefault(_ArrayDataStream);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ACO_COLORSPACE_RGB = 0,
    ACO_COLORSPACE_HSB = 1,
    ACO_COLORSPACE_CMYK = 2,
    ACO_COLORSPACE_LAB = 7,
    ACO_COLORSPACE_GRAYSCALE = 8; /* 
                                   * By Nicholas Sherlock <n.sherlock@gmail.com>
                                   * 
                                   * Released under the WTFPLv2 https://en.wikipedia.org/wiki/WTFPL
                                   */

function AdobeColorTable() {}

/**
 * Read an .aco (Adobe COlor) swatches file and return an array of RGB colors.
 * 
 * Supports version 1 palettes, only RGB format.
 * 
 * @param input A Uint8Array of the .aco file contents
 * @return An array of colours, or null if the file was not supported.
 */
AdobeColorTable.prototype.read = function (input) {
    if (input == null) {
        return null;
    }

    var stream = new _ArrayDataStream2.default(new Uint8Array(input)),
        version,
        count,
        result = [];

    version = stream.readU16BE();
    if (version != 1) {
        return null;
    }
    count = stream.readU16BE();

    for (var i = 0; i < count; i++) {
        var colourspace = stream.readU16BE();

        if (colourspace != ACO_COLORSPACE_RGB) {
            continue; // Drop unsupported colours silently
        }

        // Scale back down from 16-bit to 8-bit
        var r = stream.readU16BE() * 255 / 65535,
            g = stream.readU16BE() * 255 / 65535,
            b = stream.readU16BE() * 255 / 65535;

        stream.readU16BE(); // third value unused

        result.push(r << 16 | g << 8 | b);
    }

    return result;
};

/**
 * Write an .aco (Adobe COlor) swatches file of the given array of RGB colours (colors are integers with the
 * blue channel in the least-significant position).
 */
AdobeColorTable.prototype.write = function (colours) {
    var buffer = new Uint8Array(2 * 2 + colours.length * 10),
        stream = new _ArrayDataStream2.default(buffer);

    stream.writeU16BE(1); // Version 1
    stream.writeU16BE(colours.length); // Number of colours

    for (var i = 0; i < colours.length; i++) {
        var colour = colours[i];

        stream.writeU16BE(ACO_COLORSPACE_RGB);

        // Scale up colours to 16-bits (65535/255 = 257)
        stream.writeU16BE((colour >> 16 & 0xFF) * 257);
        stream.writeU16BE((colour >> 8 & 0xFF) * 257);
        stream.writeU16BE((colour & 0xFF) * 257);
        stream.writeU16BE(0);
    }

    return stream.getAsDataArray();
};
module.exports = exports["default"];

},{"./ArrayDataStream":45}],45:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = ArrayDataStream;
/**
 * A tool for presenting a Uint8Array as a stream for reading and writing some simple data types.
 * 
 * By Nicholas Sherlock <n.sherlock@gmail.com> 2016, released under the WTFPL license.
 */

var EOF = -1;

function signExtend16Bit(word) {
    //If sign bit is set, fill the top bits with 1s to sign-extend
    return word & 0x8000 ? word | 0xFFFF0000 : word;
}

function signExtend8Bit(byte) {
    //If sign bit is set, fill the top bits with 1s to sign-extend
    return byte & 0x80 ? byte | 0xFFFFFF00 : byte;
}

/**
 * Create a stream on existing array of unsigned byte data (i.e. hopefully Uint8Array).
 * 
 * @param data Uint8Array to stream data from
 * @param start The index of the byte in the array that will be read first, or leave undefined to begin at the
 *              beginning of the array
 * @param end The index of the end of the stream, or leave undefined to use the end of the array as the end of
 *            the stream.
 */
function ArrayDataStream(data, start, end) {
    this.data = data;
    this.eof = false;
    this.start = start === undefined ? 0 : start;
    this.end = end === undefined ? data.length : end;
    this.pos = this.start;
};

/**
 * Read a single byte from the stream and turn it into a JavaScript string (assuming ASCII).
 * 
 * @returns String containing one character, or EOF if the end of file was reached (eof flag
 * is set).
 */
ArrayDataStream.prototype.readChar = function () {
    if (this.pos < this.end) {
        return String.fromCharCode(this.data[this.pos++]);
    }

    this.eof = true;
    return EOF;
};

/**
 * Read one unsigned byte from the stream
 * 
 * @returns Unsigned byte, or EOF if the end of file was reached (eof flag is set).
 */
ArrayDataStream.prototype.readByte = function () {
    if (this.pos < this.end) {
        return this.data[this.pos++];
    }

    this.eof = true;
    return EOF;
};

//Synonym:
ArrayDataStream.prototype.readU8 = ArrayDataStream.prototype.readByte;

ArrayDataStream.prototype.readS8 = function () {
    return signExtend8Bit(this.readByte());
};

ArrayDataStream.prototype.unreadChar = function (c) {
    this.pos--;
};

ArrayDataStream.prototype.peekChar = function () {
    if (this.pos < this.end) {
        return String.fromCharCode(this.data[this.pos]);
    }

    this.eof = true;
    return EOF;
};

ArrayDataStream.prototype.readString = function (length) {
    var chars = new Array(length),
        i;

    for (i = 0; i < length; i++) {
        chars[i] = this.readChar();
    }

    return chars.join("");
};

ArrayDataStream.prototype.readS16 = function () {
    var b1 = this.readByte(),
        b2 = this.readByte();

    return signExtend16Bit(b1 << 8 | b2);
};

ArrayDataStream.prototype.readU16BE = function () {
    var b1 = this.readByte(),
        b2 = this.readByte();

    return b1 << 8 | b2;
};

ArrayDataStream.prototype.readU16LE = function () {
    var b1 = this.readByte(),
        b2 = this.readByte();

    return b2 << 8 | b1;
};

ArrayDataStream.prototype.readU32BE = function () {
    var b1 = this.readByte(),
        b2 = this.readByte(),
        b3 = this.readByte(),
        b4 = this.readByte();
    return (b1 << 24 | b2 << 16 | b3 << 8 | b4) >>> 0;
};

ArrayDataStream.prototype.readU32LE = function () {
    var b1 = this.readByte(),
        b2 = this.readByte(),
        b3 = this.readByte(),
        b4 = this.readByte();
    return (b4 << 24 | b3 << 16 | b2 << 8 | b1) >>> 0;
};

ArrayDataStream.prototype.readBytes = function (count) {
    var result = this.data.subarray(this.pos, this.pos + count);

    this.pos += count;

    if (this.pos > this.end) {
        this.eof = true;
    }

    return result;
};

ArrayDataStream.prototype.skip = function (numBytes) {
    this.pos += numBytes;

    if (this.pos > this.end) {
        this.eof = true;
    }
};

ArrayDataStream.prototype.seek = function (offset) {
    this.pos = offset;
};

ArrayDataStream.prototype.writeBytes = function (arr) {
    for (var i = 0; i < arr.length; i++) {
        this.data[this.pos++] = arr[i];
    }
};

ArrayDataStream.prototype.writeByte = function (b) {
    this.data[this.pos++] = b;
};

//Synonym:
ArrayDataStream.prototype.writeU8 = ArrayDataStream.prototype.writeByte;

ArrayDataStream.prototype.writeU16LE = function (u) {
    this.data[this.pos++] = u;
    this.data[this.pos++] = u >> 8;
};

ArrayDataStream.prototype.writeU16BE = function (u) {
    this.data[this.pos++] = u >> 8;
    this.data[this.pos++] = u;
};

ArrayDataStream.prototype.writeU32BE = function (u) {
    this.data[this.pos++] = u >> 24;
    this.data[this.pos++] = u >> 16;
    this.data[this.pos++] = u >> 8;
    this.data[this.pos++] = u;
};

ArrayDataStream.prototype.writeU32LE = function (u) {
    this.data[this.pos++] = u;
    this.data[this.pos++] = u >> 8;
    this.data[this.pos++] = u >> 16;
    this.data[this.pos++] = u >> 24;
};

ArrayDataStream.prototype.writeDoubleBE = function (d) {
    var bytes = new Uint8Array(new Float64Array([d]).buffer);

    for (var i = bytes.length - 1; i >= 0; i--) {
        this.writeByte(bytes[i]);
    }
};

ArrayDataStream.prototype.writeFloatBE = function (d) {
    var bytes = new Uint8Array(new Float32Array([d]).buffer);

    for (var i = bytes.length - 1; i >= 0; i--) {
        this.writeByte(bytes[i]);
    }
};

/**
 * Write an ASCII string to the stream
 */
ArrayDataStream.prototype.writeString = function (s) {
    for (var i = 0; i < s.length; i++) {
        this.data[this.pos++] = s.charCodeAt(i);
    }
};

/**
 * Write the given unsigned 32-bit integer to the stream in big-endian order using the given byte width.
 * No error checking is performed to ensure that the supplied width is correct for the integer.
 * 
 * Omit the width parameter to have it determined automatically for you.
 * 
 * @param u Unsigned integer to be written
 * @param width Number of bytes to write to the stream
 */
ArrayDataStream.prototype.writeUnsignedIntBE = function (u, width) {
    if (width === undefined) {
        width = this.measureUnsignedInt(u);
    }

    // Each case falls through:
    switch (width) {
        case 5:
            this.writeU8(Math.floor(u / 4294967296)); // Need to use division to access >32 bits of floating point var
        case 4:
            this.writeU8(u >> 24);
        case 3:
            this.writeU8(u >> 16);
        case 2:
            this.writeU8(u >> 8);
        case 1:
            this.writeU8(u);
            break;
        default:
            throw new RuntimeException("Bad UINT size " + width);
    }
};

/**
 * Return the number of bytes needed to hold the non-zero bits of the given unsigned integer.
 */
ArrayDataStream.prototype.measureUnsignedInt = function (val) {
    // Force to 32-bit unsigned integer
    if (val < 1 << 8) {
        return 1;
    } else if (val < 1 << 16) {
        return 2;
    } else if (val < 1 << 24) {
        return 3;
    } else if (val < 4294967296) {
        return 4;
    } else {
        return 5;
    }
};

/**
 * Return a view on the portion of the buffer from the beginning to the current seek position as a Uint8Array.
 */
ArrayDataStream.prototype.getAsDataArray = function () {
    if (this.pos < this.data.byteLength) {
        return this.data.subarray(0, this.pos);
    } else if (this.pos == this.data.byteLength) {
        return this.data;
    } else {
        throw "ArrayDataStream's pos lies beyond end of buffer";
        // Chance is pretty good that you overflowed the end of the buffer during writing and your file is trash 
    }
};

ArrayDataStream.prototype.EOF = EOF;
module.exports = exports["default"];

},{}],46:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPBezier;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPBezier() {

    // How to use this class:
    //
    // 1 - set the 4 points coordinates (x0-3, y0-3)
    // two options:
    // 2a - call init() with desired dt then read the current coordinate (Bx, By) and use nextPoint() to compute the
    // next point
    // 2b - use one of the "compute" methods to compute the values for the whole curve in one step

    // The 4 points coordinates
    this.x0 = this.y0 = this.x1 = this.y1 = this.x2 = this.y2 = this.x3 = this.y3 = 0.0;

    // used to compute the Bezier curve with the forward differences method
    var Bx,
        dBx,
        ddBx,
        dddBx,
        By,
        dBy,
        ddBy,
        dddBy,
        that = this;

    function init(dt) {
        // Implements a fast degree-3 Bezier curve using the forward differences method
        //
        // Reference for this algorithm:
        // "Curves and Surfaces for Computer Graphics" by David Salomon, page 189

        var q1 = 3.0 * dt,
            q2 = q1 * dt,
            q3 = dt * dt * dt,
            q4 = 2.0 * q2,
            q5 = 6.0 * q3,
            q6x = that.x0 - 2.0 * that.x1 + that.x2,
            q6y = that.y0 - 2.0 * that.y1 + that.y2,
            q7x = 3.0 * (that.x1 - that.x2) - that.x0 + that.x3,
            q7y = 3.0 * (that.y1 - that.y2) - that.y0 + that.y3;

        Bx = that.x0;
        By = that.y0;

        dBx = (that.x1 - that.x0) * q1 + q6x * q2 + q7x * q3;
        dBy = (that.y1 - that.y0) * q1 + q6y * q2 + q7y * q3;

        ddBx = q6x * q4 + q7x * q5;
        ddBy = q6y * q4 + q7y * q5;

        dddBx = q7x * q5;
        dddBy = q7y * q5;
    }

    /**
     * Fill the given x,y arrays with a series of points on the curve.
     * 
     * @param x int[]
     * @param y int[]
     * @param elements int Count of elements to fill x and y arrays
     */
    this.compute = function (x, y, elements) {
        init(1.0 / elements);

        x[0] = ~~Bx;
        y[0] = ~~By;

        for (var i = 1; i < elements; i++) {
            Bx += dBx;
            By += dBy;
            dBx += ddBx;
            dBy += ddBy;
            ddBx += dddBx;
            ddBy += dddBy;

            x[i] = ~~Bx;
            y[i] = ~~By;
        }
    };
}
module.exports = exports["default"];

},{}],47:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPColor;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPColor(rgb) {
    var that = this;

    this.rgb = 0; // in RGB byte order

    this.hue = 0;
    this.saturation = 0;
    this.value = 0;

    function rgbToHsv() {
        var r = that.rgb >> 16 & 0xff,
            g = that.rgb >> 8 & 0xff,
            b = that.rgb & 0xff;

        // Value
        that.value = Math.max(r, Math.max(g, b));

        // Saturation
        var mini = Math.min(r, Math.min(g, b));

        if (that.value == 0) {
            that.saturation = 0;
        } else {
            that.saturation = ~~((that.value - mini) / that.value * 255);
        }

        // Hue
        if (that.saturation == 0) {
            that.hue = 0;
        } else {
            var cr = (that.value - r) / (that.value - mini),
                cg = (that.value - g) / (that.value - mini),
                cb = (that.value - b) / (that.value - mini);

            var _hue = 0;

            if (that.value == r) {
                _hue = cb - cg;
            }
            if (that.value == g) {
                _hue = 2 + cr - cb;
            }
            if (that.value == b) {
                _hue = 4 + cg - cr;
            }

            _hue *= 60;
            if (_hue < 0) {
                _hue += 360;
            }

            that.hue = ~~_hue;
        }
    }

    function hsvToRgb() {
        // no saturation means it's just a shade of grey
        if (that.saturation == 0) {
            that.rgb = that.value << 16 | that.value << 8 | that.value;
        } else {
            var f = that.hue / 60;

            f = f - Math.floor(f);

            var s = that.saturation / 255,
                m = ~~(that.value * (1 - s)),
                n = ~~(that.value * (1 - s * f)),
                k = ~~(that.value * (1 - s * (1 - f)));

            switch (~~(that.hue / 60)) {
                case 0:
                    that.rgb = that.value << 16 | k << 8 | m;
                    break;
                case 1:
                    that.rgb = n << 16 | that.value << 8 | m;
                    break;
                case 2:
                    that.rgb = m << 16 | that.value << 8 | k;
                    break;
                case 3:
                    that.rgb = m << 16 | n << 8 | that.value;
                    break;
                case 4:
                    that.rgb = k << 16 | m << 8 | that.value;
                    break;
                case 5:
                    that.rgb = that.value << 16 | m << 8 | n;
                    break;
                default:
                    that.rgb = 0; // invalid hue
                    break;
            }
        }
    }

    this.getRgb = function () {
        return this.rgb;
    };

    this.getSaturation = function () {
        return this.saturation;
    };

    this.getHue = function () {
        return this.hue;
    };

    this.getValue = function () {
        return this.value;
    };

    this.setRgbComponents = function (r, g, b) {
        this.setRgb(r << 16 | g << 8 | b);
    };

    this.setRgb = function (rgb) {
        this.rgb = rgb;
        rgbToHsv();
    };

    this.setHsv = function (hue, value, saturation) {
        this.hue = hue;
        this.saturation = saturation;
        this.value = value;

        hsvToRgb();
    };

    this.setHue = function (hue) {
        this.hue = hue;
        hsvToRgb();
    };

    this.setSaturation = function (saturation) {
        this.saturation = saturation;
        hsvToRgb();
    };

    this.setValue = function (value) {
        this.value = value;
        hsvToRgb();
    };

    this.clone = function () {
        var result = new CPColor();

        result.copyFrom(this);

        return result;
    };

    this.copyFrom = function (c) {
        this.rgb = c.rgb;
        this.hue = c.hue;
        this.saturation = c.saturation;
        this.value = c.value;
    };

    this.isEqual = function (color) {
        return this.rgb == color.rgb && this.hue == color.hue && this.saturation == color.saturation && this.value == color.value;
    };

    this.setRgb(rgb || 0);
}
module.exports = exports["default"];

},{}],48:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPColorFloat;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

// An RGB color with floating point values for each channel (between 0.0 and 1.0)
function CPColorFloat(r, g, b) {
    this.r = r;
    this.g = g;
    this.b = b;
}

CPColorFloat.prototype.toInt = function () {
    return Math.max(0, Math.min(255, Math.round(this.r * 255))) << 16 | Math.max(0, Math.min(255, Math.round(this.g * 255))) << 8 | Math.max(0, Math.min(255, Math.round(this.b * 255)));
};

CPColorFloat.prototype.mixWith = function (color, alpha) {
    this.r = this.r * (1.0 - alpha) + color.r * alpha;
    this.g = this.g * (1.0 - alpha) + color.g * alpha;
    this.b = this.b * (1.0 - alpha) + color.b * alpha;
};

CPColorFloat.prototype.clone = function () {
    return new CPColorFloat(this.r, this.g, this.b);
};

CPColorFloat.createFromInt = function (color) {
    return new CPColorFloat((color >>> 16 & 0xff) / 255, (color >>> 8 & 0xff) / 255, (color & 0xff) / 255);
};
module.exports = exports["default"];

},{}],49:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.isCanvasInterpolationSupported = isCanvasInterpolationSupported;
exports.setCanvasInterpolation = setCanvasInterpolation;
exports.isEventSupported = isEventSupported;
exports.isCanvasSupported = isCanvasSupported;
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function getCanvasInterpolationPropName(canvasContext) {
	var browserProperties = ["imageSmoothingEnabled", "mozImageSmoothingEnabled", "webkitImageSmoothingEnabled", "msImageSmoothingEnabled"];

	for (var i = 0; i < browserProperties.length; i++) {
		if (browserProperties[i] in canvasContext) {
			return browserProperties[i];
		}
	}

	return null;
}

function isCanvasInterpolationSupported() {
	var canvas = document.createElement("canvas"),
	    canvasContext = canvas.getContext("2d");

	return !!getCanvasInterpolationPropName(canvasContext);
}

function setCanvasInterpolation(canvasContext, enabled) {
	var propName = getCanvasInterpolationPropName(canvasContext);

	if (propName) {
		canvasContext[propName] = enabled;
	}
}

function isEventSupported(eventName) {
	var isSupported = eventName in window;

	if (!isSupported) {
		var el = document.createElement('div');
		el.setAttribute(eventName, 'return;');

		isSupported = typeof el[eventName] == 'function';
	}

	return isSupported;
}

function isCanvasSupported() {
	var elem = document.createElement('canvas');
	return !!(elem.getContext && elem.getContext('2d'));
}

},{}],50:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = CPPolygon;

var _CPTransform = require('./CPTransform');

var _CPTransform2 = _interopRequireDefault(_CPTransform);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CPPolygon(points) {
	this.points = points || [];
} /*
  	ChickenPaint
  
  	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
  	by Nicholas Sherlock / Chicken Smoothie.
  
  	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer
  
  	ChickenPaint is free software: you can redistribute it and/or modify
  	it under the terms of the GNU General Public License as published by
  	the Free Software Foundation, either version 3 of the License, or
  	(at your option) any later version.
  
  	ChickenPaint is distributed in the hope that it will be useful,
  	but WITHOUT ANY WARRANTY; without even the implied warranty of
  	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  	GNU General Public License for more details.
  
  	You should have received a copy of the GNU General Public License
  	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
  */

CPPolygon.prototype.clone = function () {
	var result = new CPPolygon(new Array(this.points.length));

	for (var i = 0; i < this.points.length; i++) {
		// Deep clone
		result.points[i] = { x: this.points[i].x, y: this.points[i].y };
	}

	return result;
};

/**
 * Get a new polygon which is the result of transforming the points of this polygon with the given affine transform.
 *
 * @param {CPTransform} affineTransform
 * @returns {CPPolygon}
 */
CPPolygon.prototype.getTransformed = function (affineTransform) {
	var result = new CPPolygon(new Array(this.points.length));

	for (var i = 0; i < this.points.length; i++) {
		result.points[i] = affineTransform.getTransformedPoint(this.points[i]);
	}

	return result;
};

CPPolygon.prototype.getCenter = function () {
	var centerX = this.points[0].x,
	    centerY = this.points[0].y;

	for (var i = 1; i < this.points.length; i++) {
		centerX += this.points[i].x;
		centerY += this.points[i].y;
	}

	return { x: centerX / this.points.length, y: centerY / this.points.length };
};

/**
 * From https://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
 *
 * @param point
 * @returns {boolean}
 */
CPPolygon.prototype.containsPoint = function (point) {
	var i,
	    j,
	    contained = false;

	for (i = 0, j = this.points.length - 1; i < this.points.length; j = i++) {
		if (this.points[i].y > point.y != this.points[j].y > point.y && point.x < (this.points[j].x - this.points[i].x) * (point.y - this.points[i].y) / (this.points[j].y - this.points[i].y) + this.points[i].x) {
			contained = !contained;
		}
	}

	return contained;
};
module.exports = exports['default'];

},{"./CPTransform":53}],51:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPRandom;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPRandom() {
    var nextNextGaussian,
        haveNextNextGaussian = false;

    /**
     * Definition from Java, mean of 0.0 and standard deviation 1.0.
     */
    this.nextGaussian = function () {
        if (haveNextNextGaussian) {
            haveNextNextGaussian = false;
            return nextNextGaussian;
        } else {

            var v1, v2, s;

            do {
                v1 = 2 * Math.random() - 1; // between -1.0 and 1.0
                v2 = 2 * Math.random() - 1; // between -1.0 and 1.0
                s = v1 * v1 + v2 * v2;
            } while (s >= 1 || s == 0);

            var multiplier = Math.sqrt(-2 * Math.log(s) / s);

            nextNextGaussian = v2 * multiplier;
            haveNextNextGaussian = true;

            return v1 * multiplier;
        }
    };
};
module.exports = exports["default"];

},{}],52:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPRect;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPRect(left, top, right, bottom) {
    /*
    if (left === undefined || top === undefined || right === undefined || bottom === undefined) {
        throw "Bad rect";
    }
    
    if (~~left !== left || ~~top !== top || ~~right !== right || ~~bottom !== bottom) {
        throw "Bad rect";
    }
    */

    this.left = left;
    this.top = top;
    this.right = right;
    this.bottom = bottom;
}

CPRect.prototype.makeEmpty = function () {
    this.left = 0;
    this.top = 0;
    this.right = 0;
    this.bottom = 0;
};

CPRect.prototype.union = function (that) {
    if (this.isEmpty()) {
        this.set(that);
    } else {
        this.left = Math.min(this.left, that.left);
        this.top = Math.min(this.top, that.top);
        this.right = Math.max(this.right, that.right);
        this.bottom = Math.max(this.bottom, that.bottom);
    }
};

CPRect.prototype.getUnion = function (that) {
    var result = this.clone();

    result.union(that);

    return result;
};

/**
 * Clip this rectangle to fit within `that`.
 * 
 * @returns a reference to this rectangle for chaining
 */
CPRect.prototype.clip = function (that) {
    if (!this.isEmpty()) {
        if (that.isEmpty()) {
            this.makeEmpty();
        } else {
            this.left = Math.max(this.left, that.left);
            this.top = Math.max(this.top, that.top);
            this.right = Math.min(this.right, that.right);
            this.bottom = Math.min(this.bottom, that.bottom);
        }
    }

    return this;
};

CPRect.prototype.containsPoint = function (p) {
    return !(p.x < this.left || p.y < this.top || p.x >= this.right || p.y >= this.bottom);
};

CPRect.prototype.isInside = function (that) {
    return this.left >= that.left && this.top >= that.top && this.right <= that.right && this.bottom <= that.bottom;
};

/**
 * Use this rectangle as bounds to clip the placement of the area of srcRect at the position of dstRect inside
 * our bounds.
 *
 * dstRect has its right and bottom set by this operation to match the area that would be copied from the source.
 * srcRect has its coordinates tweaked to match the area that will be copied.
 */
CPRect.prototype.clipSourceDest = function (srcRect, dstRect) {
    dstRect.right = dstRect.left + srcRect.getWidth();
    dstRect.bottom = dstRect.top + srcRect.getHeight();

    if (this.isEmpty() || dstRect.left >= this.right || dstRect.top >= this.bottom || dstRect.right <= this.left || dstRect.bottom <= this.top) {
        srcRect.makeEmpty();
        dstRect.makeEmpty();
    } else {
        // bottom/right
        if (dstRect.right > this.right) {
            srcRect.right -= dstRect.right - this.right;
            dstRect.right = this.right;
        }

        if (dstRect.bottom > this.bottom) {
            srcRect.bottom -= dstRect.bottom - this.bottom;
            dstRect.bottom = this.bottom;
        }

        // top/left
        if (dstRect.left < this.left) {
            srcRect.left += this.left - dstRect.left;
            dstRect.left = this.left;
        }

        if (dstRect.top < this.top) {
            srcRect.top += this.top - dstRect.top;
            dstRect.top = this.top;
        }
    }
};

CPRect.prototype.getWidth = function () {
    return this.right - this.left;
};

CPRect.prototype.getHeight = function () {
    return this.bottom - this.top;
};

CPRect.prototype.getArea = function () {
    return this.getWidth() * this.getHeight();
};

CPRect.prototype.isEmpty = function () {
    return this.right <= this.left || this.bottom <= this.top;
};

CPRect.prototype.set = function (r) {
    this.left = r.left;
    this.top = r.top;
    this.right = r.right;
    this.bottom = r.bottom;
};

CPRect.prototype.clone = function () {
    return new CPRect(this.left, this.top, this.right, this.bottom);
};

CPRect.prototype.translate = function (x, y) {
    this.left += x;
    this.right += x;
    this.top += y;
    this.bottom += y;
};

CPRect.prototype.moveTo = function (x, y) {
    this.translate(x - this.left, y - this.top);
};

CPRect.prototype.equals = function (that) {
    return this.left == that.left && this.right == that.right && this.top == that.top && this.bottom == that.bottom;
};

/**
 * Add h pixels to both the left and right sides of the rectangle, and v pixels to both the top and bottom sides.
 *  
 * @param h
 * @param v
 */
CPRect.prototype.grow = function (h, v) {
    // TODO checks for rectangles with zero-extent
    this.left -= h;
    this.right += h;
    this.top -= v;
    this.bottom += v;
};

CPRect.prototype.toString = function () {
    return "(" + this.left + "," + this.top + "," + this.right + "," + this.bottom + ")";
};

/**
 * Convert the rectangle into an array of points of the corners of the rectangle (clockwise starting from the top left
 * point).
 */
CPRect.prototype.toPoints = function () {
    return [{ x: this.left, y: this.top }, { x: this.right, y: this.top }, { x: this.right, y: this.bottom }, { x: this.left, y: this.bottom }];
};

/**
 * Round the rectangle coordinates to the nearest integer.
 */
CPRect.prototype.roundNearest = function () {
    this.left = Math.round(this.left);
    this.top = Math.round(this.top);
    this.right = Math.round(this.right);
    this.bottom = Math.round(this.bottom);
};

/**
 * Round the rectangle coordinates to integers so that the old rectangle is contained by the new one.
 */
CPRect.prototype.roundContain = function () {
    this.left = Math.floor(this.left);
    this.top = Math.floor(this.top);
    this.right = Math.ceil(this.right);
    this.bottom = Math.ceil(this.bottom);
};

/**
 * Create an AABB CPRect which encloses the given array of points.
 */
CPRect.createBoundingBox = function (points) {
    var result = new CPRect(points[0].x, points[0].y, points[0].x, points[0].y);

    for (var i = 1; i < points.length; i++) {
        result.left = Math.min(result.left, points[i].x);
        result.top = Math.min(result.top, points[i].y);
        result.right = Math.max(result.right, points[i].x);
        result.bottom = Math.max(result.bottom, points[i].y);
    }

    return result;
};

/* 
 * Chrome is initially eager to optimize CPRect and users assuming that all the fields are SMIs, then later on decides
 * that they should be tagged numbers after all. This causes all the blending operation functions to be reoptimized
 * a couple of times. 
 * 
 * Avoid that mess by starting things off with floats in the members.  
 */
window.cpRectGarbage = new CPRect(1.5, 2.5, 3.5, 4.5);
module.exports = exports["default"];

},{}],53:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPTransform;
// Modifications by Nicholas Sherlock. Original docs below:

// Last updated November 2011
// By Simon Sarris
// www.simonsarris.com
// sarris@acm.org
//
// Free to use and distribute at will
// So long as you are nice to people, etc

// Simple class for keeping track of the current transformation matrix

// For instance:
//    var t = new Transform();
//    t.rotate(5);
//    var m = t.m;
//    ctx.setTransform(m[0], m[1], m[2], m[3], m[4], m[5]);

// Is equivalent to:
//    ctx.rotate(5);

// But now you can retrieve it :)

// Remember that this does not account for any CSS transforms applied to the canvas

function CPTransform() {
    this.setToIdentity();
}

CPTransform.prototype.setToIdentity = function () {
    /* Matrix components are stored in this order in 'm':
     * [0 2 4]
     * [1 3 5]
     * [x x x]
     *
     * Last row is always 0, 0, 1 so we don't store it.
     */
    this.m = [1, 0, 0, 1, 0, 0];
};

/**
 * Multiply this matrix with the given transformation one like so:
 *
 * [this] = [this] * [matrix]
 *
 * @param {CPTransform} matrix
 */
CPTransform.prototype.multiply = function (matrix) {
    var m11 = this.m[0] * matrix.m[0] + this.m[2] * matrix.m[1],
        m12 = this.m[1] * matrix.m[0] + this.m[3] * matrix.m[1],
        m21 = this.m[0] * matrix.m[2] + this.m[2] * matrix.m[3],
        m22 = this.m[1] * matrix.m[2] + this.m[3] * matrix.m[3],
        dx = this.m[0] * matrix.m[4] + this.m[2] * matrix.m[5] + this.m[4],
        dy = this.m[1] * matrix.m[4] + this.m[3] * matrix.m[5] + this.m[5];

    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    this.m[4] = dx;
    this.m[5] = dy;
};

/**
 * Multiply this matrix with the given transformation one like so:
 *
 * [this] = [matrix] * [this]
 *
 * @param {CPTransform} matrix
 */
CPTransform.prototype.preMultiply = function (matrix) {
    var m11 = matrix.m[0] * this.m[0] + matrix.m[2] * this.m[1],
        m12 = matrix.m[1] * this.m[0] + matrix.m[3] * this.m[1],
        m21 = matrix.m[0] * this.m[2] + matrix.m[2] * this.m[3],
        m22 = matrix.m[1] * this.m[2] + matrix.m[3] * this.m[3],
        dx = matrix.m[0] * this.m[4] + matrix.m[2] * this.m[5] + matrix.m[4],
        dy = matrix.m[1] * this.m[4] + matrix.m[3] * this.m[5] + matrix.m[5];

    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
    this.m[4] = dx;
    this.m[5] = dy;
};

CPTransform.prototype.invert = function () {
    var d = 1 / (this.m[0] * this.m[3] - this.m[1] * this.m[2]),
        m0 = this.m[3] * d,
        m1 = -this.m[1] * d,
        m2 = -this.m[2] * d,
        m3 = this.m[0] * d,
        m4 = d * (this.m[2] * this.m[5] - this.m[3] * this.m[4]),
        m5 = d * (this.m[1] * this.m[4] - this.m[0] * this.m[5]);

    this.m[0] = m0;
    this.m[1] = m1;
    this.m[2] = m2;
    this.m[3] = m3;
    this.m[4] = m4;
    this.m[5] = m5;
};

CPTransform.prototype.getInverted = function () {
    var result = new CPTransform();

    result.m[0] = this.m[0];
    result.m[1] = this.m[1];
    result.m[2] = this.m[2];
    result.m[3] = this.m[3];
    result.m[4] = this.m[4];
    result.m[5] = this.m[5];

    result.invert();

    return result;
};

/**
 * Multiply this transform by a rotation matrix for the given angle:
 *
 * [ cos(a) -sin(a) 0]
 * [ sin(a)  cos(a) 0]
 * [   0       0    1]
 */
CPTransform.prototype.rotate = function (rad) {
    var c = Math.cos(rad),
        s = Math.sin(rad),
        m11 = this.m[0] * c + this.m[2] * s,
        m12 = this.m[1] * c + this.m[3] * s,
        m21 = this.m[0] * -s + this.m[2] * c,
        m22 = this.m[1] * -s + this.m[3] * c;

    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
};

CPTransform.prototype.rotateAroundPoint = function (rad, x, y) {
    this.translate(x, y);
    this.rotate(rad);
    this.translate(-x, -y);
};

/**
 * Multiply this transform by a translation matrix:
 *
 * [1  0  x]
 * [0  1  y]
 * [0  0  1]
 *
 * @param x
 * @param y
 */
CPTransform.prototype.translate = function (x, y) {
    this.m[4] += this.m[0] * x + this.m[2] * y;
    this.m[5] += this.m[1] * x + this.m[3] * y;
};

/**
 * Multiply this transform by a scale matrix:
 *
 * [sx 0  0]
 * [0  sy 0]
 * [0  0  1]
 *
 * @param sx
 * @param sy
 */
CPTransform.prototype.scale = function (sx, sy) {
    this.m[0] *= sx;
    this.m[1] *= sx;
    this.m[2] *= sy;
    this.m[3] *= sy;
};

CPTransform.prototype.scaleAroundPoint = function (sx, sy, px, py) {
    this.translate(px, py);
    this.scale(sx, sy);
    this.translate(-px, -py);
};

/**
 * Multiply this transform by a shear matrix:
 *
 * [1  sx 0]
 * [sy 1  0]
 * [0  0  1]
 *
 * @param sx
 * @param sy
 */
CPTransform.prototype.shear = function (x, y) {
    var m11 = this.m[0] + this.m[2] * y,
        m12 = this.m[1] + this.m[3] * y,
        m21 = this.m[2] + this.m[0] * x,
        m22 = this.m[3] + this.m[1] * x;

    this.m[0] = m11;
    this.m[1] = m12;
    this.m[2] = m21;
    this.m[3] = m22;
};

CPTransform.prototype.getTransformedPoint = function (p) {
    return {
        x: p.x * this.m[0] + p.y * this.m[2] + this.m[4],
        y: p.x * this.m[1] + p.y * this.m[3] + this.m[5]
    };
};

CPTransform.prototype.transformPoints = function (points) {
    for (var i = 0; i < points.length; i++) {
        points[i] = this.getTransformedPoint(points[i]);
    }
};

CPTransform.prototype.getTranslateX = function () {
    return this.m[4];
};

CPTransform.prototype.getTranslateY = function () {
    return this.m[5];
};

CPTransform.prototype.clone = function () {
    var result = new CPTransform();

    result.m[0] = this.m[0];
    result.m[1] = this.m[1];
    result.m[2] = this.m[2];
    result.m[3] = this.m[3];
    result.m[4] = this.m[4];
    result.m[5] = this.m[5];

    return result;
};

CPTransform.prototype.getDeterminant = function () {
    return this.m[0] * this.m[3] - this.m[1] * this.m[2];
};

/**
 * Break down the matrix into a translation, scale, rotation, then shear operation.
 *
 * x or y scale must not be zero.
 *
 * http://www.maths-informatique-jeux.com/blog/frederic/?post/2013/12/01/Decomposition-of-2D-transform-matrices
 */
CPTransform.prototype.decompose = function () {
    var determinant = this.getDeterminant(),
        r = Math.sqrt(this.m[0] * this.m[0] + this.m[1] * this.m[1]);

    return {
        translate: { x: this.m[4], y: this.m[5] },
        rotate: Math.sign(this.m[1]) * Math.acos(this.m[0] / r),
        scale: { x: r, y: determinant / r },
        shear: { x: Math.atan((this.m[0] * this.m[2] + this.m[1] * this.m[3]) / (r * r)), y: 0 }
    };
};

CPTransform.prototype.toString = function () {
    var PLACES = 2;

    return "[" + this.m[0].toFixed(PLACES) + " " + this.m[2].toFixed(PLACES) + " " + this.m[4].toFixed(PLACES) + "]\n" + "[" + this.m[1].toFixed(PLACES) + " " + this.m[3].toFixed(PLACES) + " " + this.m[5].toFixed(PLACES) + "]\n" + "[0.00 0.00 1.00]";
};

Math.sign = Math.sign || function (x) {
    x = +x; // convert to a number
    if (x === 0 || isNaN(x)) {
        return x;
    }
    return x > 0 ? 1 : -1;
};
module.exports = exports["default"];

},{}],54:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.default = CPVector;
/*
	ChickenPaint

	ChickenPaint is a translation of ChibiPaint from Java to JavaScript
	by Nicholas Sherlock / Chicken Smoothie.

	ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

	ChickenPaint is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.

	ChickenPaint is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPVector(x, y) {
	this.x = x;
	this.y = y;
}

CPVector.prototype.getLength = function () {
	return Math.sqrt(this.x * this.x + this.y * this.y);
};

/**
 *
 * @returns {CPVector} This vector for chaining
 */
CPVector.prototype.normalize = function () {
	var length = this.getLength();

	this.x /= length;
	this.y /= length;

	return this;
};

/**
 *
 * @param {CPVector} that
 */
CPVector.prototype.getDotProduct = function (that) {
	return this.x * that.x + this.y * that.y;
};

/**
 *
 * @param scaleFactor
 * @returns {CPVector} This vector for chaining
 */
CPVector.prototype.scale = function (scaleFactor) {
	this.x *= scaleFactor;
	this.y *= scaleFactor;

	return this;
};

CPVector.prototype.getScaled = function (scaleFactor) {
	var result = new CPVector(this.x, this.y);

	result.scale(scaleFactor);

	return result;
};

CPVector.prototype.getRounded = function () {
	return new CPVector(Math.round(this.x), Math.round(this.y));
};

CPVector.prototype.getTruncated = function () {
	return new CPVector(~~this.x, ~~this.y);
};

CPVector.prototype.getPerpendicular = function () {
	return new CPVector(-this.y, this.x);
};

/**
 * Add that vector to this one
 *
 * @param {CPVector} that
 * @returns {CPVector} This vector for chaining
 */
CPVector.prototype.add = function (that) {
	this.x += that.x;
	this.y += that.y;

	return this;
};

/**
 * Subtract that vector from this one
 *
 * @param {CPVector} that
 * @returns {CPVector} This vector for chaining
 */
CPVector.prototype.subtract = function (that) {
	this.x -= that.x;
	this.y -= that.y;

	return this;
};

/**
 * Get the sum of this vector and that one.
 *
 * @param {CPVector} that
 * @returns {CPVector}
 */
CPVector.prototype.getSum = function (that) {
	return new CPVector(this.x + that.x, this.y + that.y);
};

/**
 * Create a new vector by p1 - p2
 *
 * @param p1
 * @param p2
 *
 * @returns {CPVector}
 */
CPVector.subtractPoints = function (p1, p2) {
	return new CPVector(p1.x - p2.x, p1.y - p2.y);
};
module.exports = exports["default"];

},{}],55:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = CPWacomTablet;
/*
    ChickenPaint
    
    ChickenPaint is a translation of ChibiPaint from Java to JavaScript
    by Nicholas Sherlock / Chicken Smoothie.
    
    ChibiPaint is Copyright (c) 2006-2008 Marc Schefer

    ChickenPaint is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    ChickenPaint is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with ChickenPaint. If not, see <http://www.gnu.org/licenses/>.
*/

function CPWacomTablet() {
    var penAPI = null,
        pluginObject,
        that = this;

    /**
     * Is the pen currently interacting with the tablet surface?
     */
    this.isPen = function () {
        var pointerType;

        if (penAPI) {
            pointerType = penAPI.pointerType;

            return pointerType == 1 /* Pen */ || pointerType == 3 /* Eraser */;
        }

        return false;
    };

    this.getPressure = function () {
        if (penAPI) {
            return penAPI.pressure;
        }

        return 1.0;
    };

    this.pluginLoaded = function () {
        console.log("Wacom tablet support loaded!");

        penAPI = pluginObject.penAPI;
    };

    this.isTabletPresent = function () {
        return !!penAPI;
    };

    /**
     * Call after the document body is ready (needs DOM to be ready for loading the Wacom plugin).
     */
    this.detectTablet = function () {
        // Chrome has dropped NPAPI support, so the Wacom plugin cannot be installed
        if (/Chrome/i.test(navigator.userAgent) && !/OPR/.test(navigator.userAgent)) {
            // Prevent an ugly "this page has tried to load a plugin which is not supported" error message
            console.log("Not attempting to load Wacom tablet plugin, since this is Chrome");
            return;
        }

        console.log("Attempting to load Wacom tablet support...");

        pluginObject = document.createElement("object");

        if ("classid" in pluginObject) {
            // IE
            pluginObject.classid = "CLSID:092dfa86-5807-5a94-bf3b-5a53ba9e5308";
        } else {
            var param = document.createElement("param");

            param.name = "onload";
            param.value = "onWacomPluginLoaded";

            pluginObject.appendChild(param);

            pluginObject.type = "application/x-wacomtabletplugin";
        }

        pluginObject.style.position = "absolute";
        pluginObject.style.visibility = "hidden";
        pluginObject.onload = "onWacomPluginLoaded";

        document.body.appendChild(pluginObject);

        setTimeout(function () {
            if (!that.isTabletPresent()) {
                console.log("Looks like the Wacom plugin isn't installed, or failed to load.");
            }
        }, 5000);
    };
}

CPWacomTablet.getRef = function () {
    if (CPWacomTablet.instance == null) {
        CPWacomTablet.instance = new CPWacomTablet();
    }
    return CPWacomTablet.instance;
};

window.onWacomPluginLoaded = function () {
    CPWacomTablet.getRef().pluginLoaded();
};
module.exports = exports["default"];

},{}],56:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});
exports.throttle = throttle;
exports.debounce = debounce;
/*!
 * jQuery throttle / debounce - v1.1 - 3/7/2010
 * http://benalman.com/projects/jquery-throttle-debounce-plugin/
 * 
 * Copyright (c) 2010 "Cowboy" Ben Alman
 * Dual licensed under the MIT and GPL licenses.
 * http://benalman.com/about/license/
 */

// Script: jQuery throttle / debounce: Sometimes, less is more!
//
// *Version: 1.1, Last updated: 3/7/2010*
// 
// Project Home - http://benalman.com/projects/jquery-throttle-debounce-plugin/
// GitHub       - http://github.com/cowboy/jquery-throttle-debounce/
// Source       - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.js
// (Minified)   - http://github.com/cowboy/jquery-throttle-debounce/raw/master/jquery.ba-throttle-debounce.min.js (0.7kb)
// 
// About: License
// 
// Copyright (c) 2010 "Cowboy" Ben Alman,
// Dual licensed under the MIT and GPL licenses.
// http://benalman.com/about/license/
// 
// About: Examples
// 
// These working examples, complete with fully commented code, illustrate a few
// ways in which this plugin can be used.
// 
// Throttle - http://benalman.com/code/projects/jquery-throttle-debounce/examples/throttle/
// Debounce - http://benalman.com/code/projects/jquery-throttle-debounce/examples/debounce/
// 
// About: Support and Testing
// 
// Information about what version or versions of jQuery this plugin has been
// tested with, what browsers it has been tested in, and where the unit tests
// reside (so you can test it yourself).
// 
// jQuery Versions - none, 1.3.2, 1.4.2
// Browsers Tested - Internet Explorer 6-8, Firefox 2-3.6, Safari 3-4, Chrome 4-5, Opera 9.6-10.1.
// Unit Tests      - http://benalman.com/code/projects/jquery-throttle-debounce/unit/
// 
// About: Release History
// 
// 1.1 - (3/7/2010) Fixed a bug in <jQuery.throttle> where trailing callbacks
//       executed later than they should. Reworked a fair amount of internal
//       logic as well.
// 1.0 - (3/6/2010) Initial release as a stand-alone project. Migrated over
//       from jquery-misc repo v0.4 to jquery-throttle repo v1.0, added the
//       no_trailing throttle parameter and debounce functionality.

// Method: throttle
//
// Throttle execution of a function. Especially useful for rate limiting
// execution of handlers on events like resize and scroll. If you want to
// rate-limit execution of a function to a single time, see the
// <jQuery.debounce> method.
//
// In this visualization, | is a throttled-function call and X is the actual
// callback execution:
//
// > Throttled with `no_trailing` specified as false or unspecified:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// > X    X    X    X    X    X        X    X    X    X    X    X
// >
// > Throttled with `no_trailing` specified as true:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// > X    X    X    X    X             X    X    X    X    X
//
// Usage:
//
// > var throttled = jQuery.throttle( delay, [ no_trailing, ] callback );
// >
// > jQuery('selector').bind( 'someevent', throttled );
// > jQuery('selector').unbind( 'someevent', throttled );
//
// This also works in jQuery 1.4+:
//
// > jQuery('selector').bind( 'someevent', jQuery.throttle( delay, [ no_trailing, ] callback ) );
// > jQuery('selector').unbind( 'someevent', callback );
//
// Arguments:
//
//  delay - (Number) A zero-or-greater delay in milliseconds. For event
//    callbacks, values around 100 or 250 (or even higher) are most useful.
//  no_trailing - (Boolean) Optional, defaults to false. If no_trailing is
//    true, callback will only execute every `delay` milliseconds while the
//    throttled-function is being called. If no_trailing is false or
//    unspecified, callback will be executed one final time after the last
//    throttled-function call. (After the throttled-function has not been
//    called for `delay` milliseconds, the internal counter is reset)
//  callback - (Function) A function to be executed after delay milliseconds.
//    The `this` context and all arguments are passed through, as-is, to
//    `callback` when the throttled-function is executed.
//
// Returns:
//
//  (Function) A new, throttled, function.

function throttle(delay, no_trailing, callback, debounce_mode) {
	// After wrapper has stopped being called, this timeout ensures that
	// `callback` is executed at the proper times in `throttle` and `end`
	// debounce modes.
	var timeout_id,


	// Keep track of the last time `callback` was executed.
	last_exec = 0;

	// `no_trailing` defaults to falsy.
	if (typeof no_trailing !== 'boolean') {
		debounce_mode = callback;
		callback = no_trailing;
		no_trailing = undefined;
	}

	// The `wrapper` function encapsulates all of the throttling / debouncing
	// functionality and when executed will limit the rate at which `callback`
	// is executed.
	function wrapper() {
		var that = this,
		    elapsed = +new Date() - last_exec,
		    args = arguments;

		// Execute `callback` and update the `last_exec` timestamp.
		function exec() {
			last_exec = +new Date();
			callback.apply(that, args);
		}

		// If `debounce_mode` is true (at_begin) this is used to clear the flag
		// to allow future `callback` executions.
		function clear() {
			timeout_id = undefined;
		}

		if (debounce_mode && !timeout_id) {
			// Since `wrapper` is being called for the first time and
			// `debounce_mode` is true (at_begin), execute `callback`.
			exec();
		}

		// Clear any existing timeout.
		timeout_id && clearTimeout(timeout_id);

		if (debounce_mode === undefined && elapsed > delay) {
			// In throttle mode, if `delay` time has been exceeded, execute
			// `callback`.
			exec();
		} else if (no_trailing !== true) {
			// In trailing throttle mode, since `delay` time has not been
			// exceeded, schedule `callback` to execute `delay` ms after most
			// recent execution.
			//
			// If `debounce_mode` is true (at_begin), schedule `clear` to execute
			// after `delay` ms.
			//
			// If `debounce_mode` is false (at end), schedule `callback` to
			// execute after `delay` ms.
			timeout_id = setTimeout(debounce_mode ? clear : exec, debounce_mode === undefined ? delay - elapsed : delay);
		}
	}

	// Return the wrapper function.
	return wrapper;
}

// Method: jQuery.debounce
//
// Debounce execution of a function. Debouncing, unlike throttling,
// guarantees that a function is only executed a single time, either at the
// very beginning of a series of calls, or at the very end. If you want to
// simply rate-limit execution of a function, see the <jQuery.throttle>
// method.
//
// In this visualization, | is a debounced-function call and X is the actual
// callback execution:
//
// > Debounced with `at_begin` specified as false or unspecified:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// >                          X                                 X
// >
// > Debounced with `at_begin` specified as true:
// > ||||||||||||||||||||||||| (pause) |||||||||||||||||||||||||
// > X                                 X
//
// Usage:
//
// > var debounced = jQuery.debounce( delay, [ at_begin, ] callback );
// >
// > jQuery('selector').bind( 'someevent', debounced );
// > jQuery('selector').unbind( 'someevent', debounced );
//
// This also works in jQuery 1.4+:
//
// > jQuery('selector').bind( 'someevent', jQuery.debounce( delay, [ at_begin, ] callback ) );
// > jQuery('selector').unbind( 'someevent', callback );
//
// Arguments:
//
//  delay - (Number) A zero-or-greater delay in milliseconds. For event
//    callbacks, values around 100 or 250 (or even higher) are most useful.
//  at_begin - (Boolean) Optional, defaults to false. If at_begin is false or
//    unspecified, callback will only be executed `delay` milliseconds after
//    the last debounced-function call. If at_begin is true, callback will be
//    executed only at the first debounced-function call. (After the
//    throttled-function has not been called for `delay` milliseconds, the
//    internal counter is reset)
//  callback - (Function) A function to be executed after delay milliseconds.
//    The `this` context and all arguments are passed through, as-is, to
//    `callback` when the debounced-function is executed.
//
// Returns:
//
//  (Function) A new, debounced, function.

function debounce(delay, at_begin, callback) {
	return callback === undefined ? throttle(delay, at_begin, false) : throttle(delay, callback, at_begin !== false);
}

},{}]},{},[1])(1)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJqcy9DaGlja2VuUGFpbnQuanMiLCJqcy9lbmdpbmUvQ1BBcnR3b3JrLmpzIiwianMvZW5naW5lL0NQQml0bWFwLmpzIiwianMvZW5naW5lL0NQQmxlbmQuanMiLCJqcy9lbmdpbmUvQ1BCcnVzaEluZm8uanMiLCJqcy9lbmdpbmUvQ1BCcnVzaE1hbmFnZXIuanMiLCJqcy9lbmdpbmUvQ1BDaGliaUZpbGUuanMiLCJqcy9lbmdpbmUvQ1BDbGlwLmpzIiwianMvZW5naW5lL0NQQ29sb3JCbXAuanMiLCJqcy9lbmdpbmUvQ1BHcmV5Qm1wLmpzIiwianMvZW5naW5lL0NQTGF5ZXIuanMiLCJqcy9lbmdpbmUvQ1BMb29rVXBUYWJsZS5qcyIsImpzL2VuZ2luZS9DUFJlc291cmNlTG9hZGVyLmpzIiwianMvZW5naW5lL0NQUmVzb3VyY2VTYXZlci5qcyIsImpzL2VuZ2luZS9DUFVuZG8uanMiLCJqcy9ndWkvQ1BBYm91dERpYWxvZy5qcyIsImpzL2d1aS9DUEJveEJsdXJEaWFsb2cuanMiLCJqcy9ndWkvQ1BCcnVzaFBhbGV0dGUuanMiLCJqcy9ndWkvQ1BDYW52YXMuanMiLCJqcy9ndWkvQ1BDaGVja2JveC5qcyIsImpzL2d1aS9DUENvbG9yUGFsZXR0ZS5qcyIsImpzL2d1aS9DUENvbG9yU2VsZWN0LmpzIiwianMvZ3VpL0NQQ29sb3JTbGlkZXIuanMiLCJqcy9ndWkvQ1BDb2xvclN3YXRjaC5qcyIsImpzL2d1aS9DUENvbmZpcm1UcmFuc2Zvcm1EaWFsb2cuanMiLCJqcy9ndWkvQ1BHVUlVdGlscy5qcyIsImpzL2d1aS9DUEdyaWREaWFsb2cuanMiLCJqcy9ndWkvQ1BMYXllcnNQYWxldHRlLmpzIiwianMvZ3VpL0NQTWFpbkdVSS5qcyIsImpzL2d1aS9DUE1haW5NZW51LmpzIiwianMvZ3VpL0NQTWlzY1BhbGV0dGUuanMiLCJqcy9ndWkvQ1BQYWxldHRlLmpzIiwianMvZ3VpL0NQUGFsZXR0ZU1hbmFnZXIuanMiLCJqcy9ndWkvQ1BTY3JvbGxiYXIuanMiLCJqcy9ndWkvQ1BTZW5kRGlhbG9nLmpzIiwianMvZ3VpL0NQU2hvcnRjdXRzRGlhbG9nLmpzIiwianMvZ3VpL0NQU2xpZGVyLmpzIiwianMvZ3VpL0NQU3BsYXNoU2NyZWVuLmpzIiwianMvZ3VpL0NQU3Ryb2tlUGFsZXR0ZS5qcyIsImpzL2d1aS9DUFN3YXRjaGVzUGFsZXR0ZS5qcyIsImpzL2d1aS9DUFRhYmxldERpYWxvZy5qcyIsImpzL2d1aS9DUFRleHR1cmVQYWxldHRlLmpzIiwianMvZ3VpL0NQVG9vbFBhbGV0dGUuanMiLCJqcy91dGlsL0Fkb2JlQ29sb3JUYWJsZS5qcyIsImpzL3V0aWwvQXJyYXlEYXRhU3RyZWFtLmpzIiwianMvdXRpbC9DUEJlemllci5qcyIsImpzL3V0aWwvQ1BDb2xvci5qcyIsImpzL3V0aWwvQ1BDb2xvckZsb2F0LmpzIiwianMvdXRpbC9DUFBvbHlmaWxsLmpzIiwianMvdXRpbC9DUFBvbHlnb24uanMiLCJqcy91dGlsL0NQUmFuZG9tLmpzIiwianMvdXRpbC9DUFJlY3QuanMiLCJqcy91dGlsL0NQVHJhbnNmb3JtLmpzIiwianMvdXRpbC9DUFZlY3Rvci5qcyIsImpzL3V0aWwvQ1BXYWNvbVRhYmxldC5qcyIsImpzL3V0aWwvdGhyb3R0bGUtZGVib3VuY2UuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7OFFDQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBa1B3QixZOztBQTVOeEI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFHQTs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBLFNBQVMsa0JBQVQsR0FBOEI7QUFDMUIsV0FBTyx3Q0FBdUIsZ0JBQWdCLE1BQTlDO0FBQ0g7O0FBRUQsU0FBUyxrQkFBVCxHQUE4QjtBQUMxQixRQUNJLFFBQVEsSUFBSSxLQUFKLENBQVUsYUFBYSxLQUF2QixDQURaOztBQUdBLFVBQU0sYUFBYSxRQUFuQixJQUErQiwwQkFBZ0I7QUFDM0MsZ0JBQVEsYUFBYSxRQURzQjtBQUUzQyxjQUFNLEVBRnFDO0FBRzNDLGVBQU8sR0FIb0M7QUFJM0MsY0FBTSxJQUpxQztBQUszQyxvQkFBWSxHQUwrQjtBQU0zQyxpQkFBUyxJQU5rQztBQU8zQyxzQkFBYyxLQVA2QjtBQVEzQyx1QkFBZSxJQVI0QjtBQVMzQyxjQUFNLHNCQUFZLFVBVHlCO0FBVTNDLG1CQUFXLHNCQUFZO0FBVm9CLEtBQWhCLENBQS9COztBQWFBLFVBQU0sYUFBYSxRQUFuQixJQUErQiwwQkFBZ0I7QUFDM0MsZ0JBQVEsYUFBYSxRQURzQjtBQUUzQyxjQUFNLEVBRnFDO0FBRzNDLGVBQU8sR0FIb0M7QUFJM0MsY0FBTSxJQUpxQztBQUszQyxvQkFBWSxHQUwrQjtBQU0zQyxpQkFBUyxJQU5rQztBQU8zQyxzQkFBYyxLQVA2QjtBQVEzQyx1QkFBZSxLQVI0QjtBQVMzQyxjQUFNLHNCQUFZLFVBVHlCO0FBVTNDLG1CQUFXLHNCQUFZO0FBVm9CLEtBQWhCLENBQS9COztBQWFBLFVBQU0sYUFBYSxLQUFuQixJQUE0QiwwQkFBZ0I7QUFDeEMsZ0JBQVEsYUFBYSxLQURtQjtBQUV4QyxjQUFNLENBRmtDO0FBR3hDLGVBQU8sR0FIaUM7QUFJeEMsY0FBTSxJQUprQztBQUt4QyxvQkFBWSxHQUw0QjtBQU14QyxpQkFBUyxJQU4rQjtBQU94QyxzQkFBYyxJQVAwQjtBQVF4Qyx1QkFBZSxLQVJ5QjtBQVN4QyxjQUFNLHNCQUFZLFVBVHNCO0FBVXhDLG1CQUFXLHNCQUFZO0FBVmlCLEtBQWhCLENBQTVCOztBQWFBLFVBQU0sYUFBYSxZQUFuQixJQUFtQywwQkFBZ0I7QUFDL0MsZ0JBQVEsYUFBYSxZQUQwQjtBQUUvQyxjQUFNLEVBRnlDO0FBRy9DLGVBQU8sRUFId0M7QUFJL0MsY0FBTSxLQUp5QztBQUsvQyxvQkFBWSxJQUxtQztBQU0vQyxvQkFBWSxHQU5tQztBQU8vQyxpQkFBUyxJQVBzQztBQVEvQyxzQkFBYyxLQVJpQztBQVMvQyx1QkFBZSxJQVRnQztBQVUvQyxjQUFNLHNCQUFZLGdCQVY2QjtBQVcvQyxtQkFBVyxzQkFBWTtBQVh3QixLQUFoQixDQUFuQzs7QUFjQSxVQUFNLGFBQWEsVUFBbkIsSUFBaUMsMEJBQWdCO0FBQzdDLGdCQUFRLGFBQWEsVUFEd0I7QUFFN0MsY0FBTSxFQUZ1QztBQUc3QyxlQUFPLEVBSHNDO0FBSTdDLGNBQU0sS0FKdUM7QUFLN0Msb0JBQVksSUFMaUM7QUFNN0Msb0JBQVksR0FOaUM7QUFPN0MsaUJBQVMsSUFQb0M7QUFRN0Msc0JBQWMsS0FSK0I7QUFTN0MsdUJBQWUsSUFUOEI7QUFVN0MsY0FBTSxzQkFBWSxnQkFWMkI7QUFXN0MsbUJBQVcsc0JBQVk7QUFYc0IsS0FBaEIsQ0FBakM7O0FBY0EsVUFBTSxhQUFhLE9BQW5CLElBQThCLDBCQUFnQjtBQUMxQyxnQkFBUSxhQUFhLE9BRHFCO0FBRTFDLGNBQU0sRUFGb0M7QUFHMUMsZUFBTyxFQUhtQztBQUkxQyxjQUFNLEtBSm9DO0FBSzFDLG9CQUFZLElBTDhCO0FBTTFDLG9CQUFZLEdBTjhCO0FBTzFDLGlCQUFTLElBUGlDO0FBUTFDLHNCQUFjLEtBUjRCO0FBUzFDLHVCQUFlLElBVDJCO0FBVTFDLGNBQU0sc0JBQVksZ0JBVndCO0FBVzFDLG1CQUFXLHNCQUFZO0FBWG1CLEtBQWhCLENBQTlCOztBQWNBLFVBQU0sYUFBYSxNQUFuQixJQUE2QiwwQkFBZ0I7QUFDekMsZ0JBQVEsYUFBYSxNQURvQjtBQUV6QyxjQUFNLEVBRm1DO0FBR3pDLGVBQU8sRUFIa0M7QUFJekMsY0FBTSxLQUptQztBQUt6QyxvQkFBWSxJQUw2QjtBQU16QyxvQkFBWSxHQU42QjtBQU96QyxpQkFBUyxJQVBnQztBQVF6QyxzQkFBYyxLQVIyQjtBQVN6Qyx1QkFBZSxJQVQwQjtBQVV6QyxjQUFNLHNCQUFZLGdCQVZ1QjtBQVd6QyxtQkFBVyxzQkFBWTtBQVhrQixLQUFoQixDQUE3Qjs7QUFjQSxVQUFNLGFBQWEsT0FBbkIsSUFBOEIsMEJBQWdCO0FBQzFDLGdCQUFRLGFBQWEsT0FEcUI7QUFFMUMsY0FBTSxFQUZvQztBQUcxQyxlQUFPLEVBSG1DO0FBSTFDLGNBQU0sS0FKb0M7QUFLMUMsb0JBQVksSUFMOEI7QUFNMUMsb0JBQVksR0FOOEI7QUFPMUMsaUJBQVMsSUFQaUM7QUFRMUMsc0JBQWMsS0FSNEI7QUFTMUMsdUJBQWUsSUFUMkI7QUFVMUMsY0FBTSxzQkFBWSxVQVZ3QjtBQVcxQyxtQkFBVyxzQkFBWSxPQVhtQjtBQVkxQyxlQUFPLEdBWm1DO0FBYTFDLGVBQU87QUFibUMsS0FBaEIsQ0FBOUI7O0FBZ0JBLFVBQU0sYUFBYSxNQUFuQixJQUE2QiwwQkFBZ0I7QUFDekMsZ0JBQVEsYUFBYSxNQURvQjtBQUV6QyxjQUFNLEVBRm1DO0FBR3pDLGVBQU8sR0FIa0M7QUFJekMsY0FBTSxLQUptQztBQUt6QyxvQkFBWSxJQUw2QjtBQU16QyxvQkFBWSxHQU42QjtBQU96QyxpQkFBUyxJQVBnQztBQVF6QyxzQkFBYyxLQVIyQjtBQVN6Qyx1QkFBZSxJQVQwQjtBQVV6QyxjQUFNLHNCQUFZLGFBVnVCO0FBV3pDLG1CQUFXLHNCQUFZO0FBWGtCLEtBQWhCLENBQTdCOztBQWNBLFVBQU0sYUFBYSxRQUFuQixJQUErQiwwQkFBZ0I7QUFDM0MsZ0JBQVEsYUFBYSxRQURzQjtBQUUzQyxjQUFNLEVBRnFDO0FBRzNDLGVBQU8sR0FIb0M7QUFJM0MsY0FBTSxLQUpxQztBQUszQyxvQkFBWSxJQUwrQjtBQU0zQyxvQkFBWSxHQU4rQjtBQU8zQyxpQkFBUyxJQVBrQztBQVEzQyxzQkFBYyxLQVI2QjtBQVMzQyx1QkFBZSxJQVQ0QjtBQVUzQyxjQUFNLHNCQUFZLGdCQVZ5QjtBQVczQyxtQkFBVyxzQkFBWSxRQVhvQjtBQVkzQyxlQUFPLEdBWm9DO0FBYTNDLGVBQU87QUFib0MsS0FBaEIsQ0FBL0I7O0FBZ0JBLFVBQU0sYUFBYSxTQUFuQixJQUFnQywwQkFBZ0I7QUFDNUMsZ0JBQVEsYUFBYSxTQUR1QjtBQUU1QyxjQUFNLEVBRnNDO0FBRzVDLGVBQU8sRUFIcUM7QUFJNUMsY0FBTSxLQUpzQztBQUs1QyxvQkFBWSxJQUxnQztBQU01QyxvQkFBWSxHQU5nQztBQU81QyxpQkFBUyxHQVBtQztBQVE1QyxzQkFBYyxLQVI4QjtBQVM1Qyx1QkFBZSxJQVQ2QjtBQVU1QyxjQUFNLHNCQUFZLGdCQVYwQjtBQVc1QyxtQkFBVyxzQkFBWSxLQVhxQjtBQVk1QyxlQUFPLEdBWnFDO0FBYTVDLGVBQU87QUFicUMsS0FBaEIsQ0FBaEM7O0FBZ0JBLFdBQU8sS0FBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTZCZSxTQUFTLFlBQVQsQ0FBc0IsT0FBdEIsRUFBK0I7QUFDMUMsUUFDSSxPQUFPLElBRFg7QUFBQSxRQUdJLFNBQVMsUUFBUSxNQUhyQjtBQUFBLFFBS0ksTUFMSjtBQUFBLFFBTUksT0FOSjtBQUFBLFFBUUksV0FBVyxzQkFBWSxDQUFaLENBUmY7QUFBQSxRQVNJLFdBQVcsYUFBYSxRQVQ1QjtBQUFBLFFBVUksVUFBVSxhQUFhLE1BVjNCO0FBQUEsUUFXSSxtQkFBbUIsT0FYdkI7QUFBQSxRQVlJLGNBQWMsQ0FBQyxVQUFELEVBQWEsVUFBYixDQVpsQjtBQUFBLFFBY0ksaUJBQWlCLEtBZHJCO0FBQUEsUUFnQkksUUFBUSxvQkFoQlo7QUFBQSxRQWtCSSxhQWxCSjtBQUFBLFFBa0JtQixVQWxCbkI7QUFBQSxRQW9CSSxVQUFVO0FBQ047O0FBRUEsc0JBQWM7QUFDVixvQkFBUSxrQkFBWTtBQUNoQixpQ0FBaUIsQ0FBQyxjQUFsQjs7QUFFQSxrQkFBRSxNQUFGLEVBQVUsV0FBVixDQUFzQiwwQkFBdEIsRUFBa0QsY0FBbEQ7QUFDQSxrQkFBRSxNQUFGLEVBQVUsV0FBVixDQUFzQiwwQkFBdEIsRUFBa0QsY0FBbEQ7O0FBRUEsMkJBQVcsWUFBWTtBQUNuQiw0QkFBUSxpQkFBUixDQUEwQixjQUExQjtBQUNILGlCQUZELEVBRUcsR0FGSDtBQUdILGFBVlM7QUFXVix5QkFBYSx1QkFBVztBQUNwQix1QkFBTyxRQUFRLGVBQVIsS0FBNEIsS0FBbkM7QUFDSCxhQWJTO0FBY1Ysc0JBQVUsRUFBQyxLQUFLLElBQU47QUFkQSxTQUhSO0FBbUJOLGtCQUFVO0FBQ04sb0JBQVEsa0JBQVk7QUFDaEIsdUJBQU8sTUFBUDtBQUNILGFBSEs7QUFJTixzQkFBVSxFQUFDLEtBQUssSUFBTjtBQUpKLFNBbkJKO0FBeUJOLG1CQUFXO0FBQ1Asb0JBQVEsa0JBQVk7QUFDaEIsdUJBQU8sT0FBUDtBQUNILGFBSE07QUFJUCxzQkFBVSxFQUFDLEtBQUssSUFBTjtBQUpILFNBekJMO0FBK0JOLG1CQUFXO0FBQ1Asb0JBQVEsa0JBQVk7QUFDaEIsdUJBQU8sT0FBUDtBQUNILGFBSE07QUFJUCxzQkFBVSxFQUFDLEtBQUssSUFBTjtBQUpILFNBL0JMOztBQXNDTjs7QUFFQSxnQkFBUTtBQUNKLG9CQUFRLGtCQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxJQUFiO0FBQ0gsYUFIRztBQUlKLHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBSk4sU0F4Q0Y7QUE4Q04sZ0JBQVE7QUFDSixvQkFBUSxrQkFBWTtBQUNoQixxQkFBSyxPQUFMLENBQWEsSUFBYjtBQUNILGFBSEc7QUFJSixzQkFBVSxFQUFDLFVBQVUsSUFBWDtBQUpOLFNBOUNGO0FBb0ROLHdCQUFnQjtBQUNaLG9CQUFRLGtCQUFZO0FBQ2hCLG9CQUFJLFFBQVEsMEhBQVIsQ0FBSixFQUF5STtBQUNySSx5QkFBSyxPQUFMLENBQWEsWUFBYjtBQUNIO0FBQ0osYUFMVztBQU1aLHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBTkUsU0FwRFY7O0FBNkROOztBQUVBLGtCQUFjLElBQUksZ0JBQUosQ0FBcUIsYUFBYSxRQUFsQyxDQS9EUjtBQWdFTixlQUFjLElBQUksZ0JBQUosQ0FBcUIsYUFBYSxLQUFsQyxDQWhFUjtBQWlFTixrQkFBYyxJQUFJLGdCQUFKLENBQXFCLGFBQWEsUUFBbEMsQ0FqRVI7QUFrRU4sc0JBQWMsSUFBSSxnQkFBSixDQUFxQixhQUFhLFlBQWxDLENBbEVSO0FBbUVOLG9CQUFjLElBQUksZ0JBQUosQ0FBcUIsYUFBYSxVQUFsQyxDQW5FUjtBQW9FTixpQkFBYyxJQUFJLGdCQUFKLENBQXFCLGFBQWEsT0FBbEMsQ0FwRVI7QUFxRU4sZ0JBQWMsSUFBSSxnQkFBSixDQUFxQixhQUFhLE1BQWxDLENBckVSO0FBc0VOLGlCQUFjLElBQUksZ0JBQUosQ0FBcUIsYUFBYSxPQUFsQyxDQXRFUjtBQXVFTixnQkFBYyxJQUFJLGdCQUFKLENBQXFCLGFBQWEsTUFBbEMsQ0F2RVI7QUF3RU4sa0JBQWMsSUFBSSxnQkFBSixDQUFxQixhQUFhLFFBQWxDLENBeEVSO0FBeUVOLG1CQUFjLElBQUksZ0JBQUosQ0FBcUIsYUFBYSxTQUFsQyxDQXpFUjs7QUEyRU47O0FBRUEscUJBQWlCLElBQUksZ0JBQUosQ0FBcUIsYUFBYSxXQUFsQyxDQTdFWDtBQThFTix3QkFBaUIsSUFBSSxnQkFBSixDQUFxQixhQUFhLGNBQWxDLENBOUVYO0FBK0VOLHlCQUFpQixJQUFJLGdCQUFKLENBQXFCLGFBQWEsZ0JBQWxDLENBL0VYO0FBZ0ZOLG9CQUFpQixJQUFJLGdCQUFKLENBQXFCLGFBQWEsV0FBbEMsQ0FoRlg7QUFpRk4sd0JBQWlCLElBQUksZ0JBQUosQ0FBcUIsYUFBYSxlQUFsQyxDQWpGWDtBQWtGTix1QkFBaUIsSUFBSSxnQkFBSixDQUFxQixhQUFhLGNBQWxDLENBbEZYOztBQW9GTjs7QUFFQSxxQkFBYTtBQUNULG9CQUFRLGtCQUFZO0FBQ2hCLG9CQUNJLFFBQVEsS0FBSyxPQUFMLENBQWEsY0FBYixFQURaO0FBQUEsb0JBRUksYUFBYSxLQUFLLE9BQUwsQ0FBYSxtQkFBYixFQUZqQjs7QUFJQSxvQkFBSSxDQUFDLE1BQU0sT0FBWCxFQUFvQjtBQUNoQix5QkFBSyxxQkFBTCxDQUEyQixVQUEzQixFQUF1Qyx3Q0FBdkMsRUFBaUYsT0FBakY7QUFDSCxpQkFGRCxNQUVPLElBQUksTUFBTSxLQUFOLElBQWUsQ0FBbkIsRUFBc0I7QUFDekIseUJBQUsscUJBQUwsQ0FBMkIsVUFBM0IsRUFBdUMsOENBQXZDLEVBQXVGLFNBQXZGO0FBQ0gsaUJBRk0sTUFFQSxJQUFJLEtBQUssT0FBTCxDQUFhLG9CQUFiLE1BQXVDLElBQTNDLEVBQWlEO0FBQ3BELHlCQUFLLHFCQUFMLENBQTJCLFVBQTNCLEVBQXVDLHFEQUF2QyxFQUE4RixPQUE5RjtBQUNILGlCQUZNLE1BRUE7QUFDSCw0QkFBUSxhQUFhLFdBQXJCO0FBQ0g7QUFDSixhQWZRO0FBZ0JULHNCQUFVLEVBQUMsTUFBTSxJQUFQO0FBaEJELFNBdEZQO0FBd0dOLDJCQUFtQjtBQUNmLG9CQUFRLGtCQUFZO0FBQ2hCLG9CQUFJLFdBQVcsYUFBYSxXQUE1QixFQUF5QztBQUNyQyx5QkFBSyxPQUFMLENBQWEscUJBQWI7QUFDQSw0QkFBUSxnQkFBUjtBQUNIO0FBQ0osYUFOYztBQU9mLHNCQUFVLEVBQUMsTUFBTSxJQUFQO0FBUEssU0F4R2I7QUFpSE4sMkJBQW1CO0FBQ2Ysb0JBQVEsa0JBQVk7QUFDaEIsb0JBQUksV0FBVyxhQUFhLFdBQTVCLEVBQXlDO0FBQ3JDLHlCQUFLLE9BQUwsQ0FBYSxvQkFBYjtBQUNBLDRCQUFRLGdCQUFSO0FBQ0g7QUFDSixhQU5jO0FBT2Ysc0JBQVUsRUFBQyxVQUFVLElBQVgsRUFBaUIsTUFBTSxJQUF2QjtBQVBLLFNBakhiOztBQTJITjs7QUFFQSxvQkFBWTtBQUNSLG9CQUFRLGtCQUFZO0FBQ2hCLHNCQUFNLFFBQU4sRUFBZ0IsVUFBaEIsR0FBNkIsc0JBQVksV0FBekM7QUFDQTtBQUNILGFBSk87QUFLUixzQkFBVSxFQUFDLE1BQU0sSUFBUDtBQUxGLFNBN0hOO0FBb0lOLGdCQUFRO0FBQ0osb0JBQVEsa0JBQVk7QUFDaEIsc0JBQU0sUUFBTixFQUFnQixVQUFoQixHQUE2QixzQkFBWSxPQUF6QztBQUNBO0FBQ0gsYUFKRztBQUtKLHNCQUFVLEVBQUMsTUFBTSxJQUFQO0FBTE4sU0FwSUY7QUEySU4sa0JBQVU7QUFDTixvQkFBUSxrQkFBWTtBQUNoQixzQkFBTSxRQUFOLEVBQWdCLFVBQWhCLEdBQTZCLHNCQUFZLFNBQXpDO0FBQ0E7QUFDSCxhQUpLO0FBS04sc0JBQVUsRUFBQyxNQUFNLElBQVA7QUFMSixTQTNJSjs7QUFtSk47O0FBRUEsaUJBQVM7QUFDTCxvQkFBUSxrQkFBWTtBQUNoQiw0Q0FBa0IsTUFBbEIsRUFBMEIsSUFBMUI7QUFDSCxhQUhJO0FBSUwsc0JBQVU7QUFKTCxTQXJKSDtBQTJKTixxQkFBYTtBQUNULG9CQUFRLGtCQUFZO0FBQ2hCLGdEQUFzQixNQUF0QixFQUE4QixJQUE5QjtBQUNILGFBSFE7QUFJVCxzQkFBVTtBQUpELFNBM0pQO0FBaUtOLHlCQUFpQjtBQUNiLG9CQUFRLGtCQUFZO0FBQ2hCLDZDQUFtQixNQUFuQixFQUEyQixJQUEzQjtBQUNILGFBSFk7QUFJYixzQkFBVTtBQUpHLFNBaktYOztBQXdLTjs7QUFFQSwwQkFBa0I7QUFDZCxvQkFBUSxrQkFBWTtBQUNoQixxQkFBSyxPQUFMLENBQWEsY0FBYjtBQUNILGFBSGE7QUFJZCxzQkFBVSxFQUFDLFVBQVUsSUFBWDtBQUpJLFNBMUtaO0FBZ0xOLDBCQUFrQjtBQUNkLG9CQUFRLGtCQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxTQUFiLENBQXVCLElBQXZCO0FBQ0gsYUFIYTtBQUlkLHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBSkksU0FoTFo7QUFzTE4seUJBQWlCO0FBQ2Isb0JBQVEsa0JBQVk7QUFDaEIscUJBQUssT0FBTCxDQUFhLGNBQWIsQ0FBNEIsSUFBNUI7QUFDSCxhQUhZO0FBSWIsc0JBQVUsRUFBQyxVQUFVLElBQVg7QUFKRyxTQXRMWDtBQTRMTixnQkFBUTtBQUNKLG9CQUFRLGtCQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLEtBQUssY0FBTCxLQUF3QixVQUExQztBQUNILGFBSEc7QUFJSixzQkFBVSxFQUFDLFVBQVUsSUFBWDtBQUpOLFNBNUxGO0FBa01OLGlCQUFTO0FBQ0wsb0JBQVEsa0JBQVk7QUFDaEIscUJBQUssT0FBTCxDQUFhLEtBQWI7QUFDSCxhQUhJO0FBSUwsc0JBQVUsRUFBQyxVQUFVLElBQVg7QUFKTCxTQWxNSDtBQXdNTixxQkFBYTtBQUNULG9CQUFRLGtCQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxrQkFBYixDQUFnQyxLQUFLLE9BQUwsQ0FBYSxTQUFiLEVBQWhDO0FBQ0EsdUJBQU8sVUFBUDtBQUNILGFBSlE7QUFLVCxzQkFBVSxFQUFDLFVBQVUsSUFBWDtBQUxELFNBeE1QO0FBK01OLHVCQUFlO0FBQ1gsb0JBQVEsa0JBQVk7QUFDaEIscUJBQUssT0FBTCxDQUFhLGtCQUFiLENBQWdDLHFCQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBQWhDO0FBQ0EsdUJBQU8sVUFBUDtBQUNILGFBSlU7QUFLWCxzQkFBVSxFQUFDLFVBQVUsSUFBWDtBQUxDLFNBL01UO0FBc05OLGlCQUFTO0FBQ0wsb0JBQVEsa0JBQVk7QUFDaEIscUJBQUssT0FBTCxDQUFhLEtBQWI7QUFDSCxhQUhJO0FBSUwsc0JBQVUsRUFBQyxVQUFVLElBQVg7QUFKTCxTQXROSDtBQTROTixpQkFBUztBQUNMLG9CQUFRLGtCQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxLQUFiO0FBQ0gsYUFISTtBQUlMLHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBSkwsU0E1Tkg7QUFrT04sa0JBQVU7QUFDTixvQkFBUSxrQkFBWTtBQUNoQixxQkFBSyxPQUFMLENBQWEsa0JBQWI7QUFDSCxhQUhLO0FBSU4sc0JBQVUsRUFBQyxVQUFVLElBQVg7QUFKSixTQWxPSjtBQXdPTixrQkFBVTtBQUNOLG9CQUFRLGtCQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxVQUFiO0FBQ0gsYUFISztBQUlOLHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBSkosU0F4T0o7QUE4T04scUJBQWE7QUFDVCxvQkFBUSxrQkFBWTtBQUNoQjtBQUNILGFBSFE7QUFJVCxzQkFBVSxFQUFDLFVBQVUsSUFBWDtBQUpELFNBOU9QO0FBb1BOLG9CQUFZO0FBQ1Isb0JBQVEsa0JBQVk7QUFDaEIscUJBQUssT0FBTCxDQUFhLE1BQWI7QUFDSCxhQUhPO0FBSVIsc0JBQVUsRUFBQyxVQUFVLElBQVg7QUFKRixTQXBQTjs7QUEyUE4sZUFBTztBQUNILG9CQUFRLGtCQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxZQUFiLENBQTBCLElBQTFCO0FBQ0gsYUFIRTtBQUlILHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBSlAsU0EzUEQ7QUFpUU4sZ0JBQVE7QUFDSixvQkFBUSxrQkFBWTtBQUNoQixxQkFBSyxPQUFMLENBQWEsYUFBYjtBQUNILGFBSEc7QUFJSixzQkFBVSxFQUFDLFVBQVUsSUFBWDtBQUpOLFNBalFGO0FBdVFOLHNCQUFjO0FBQ1Ysb0JBQVEsa0JBQVk7QUFDaEIscUJBQUssT0FBTCxDQUFhLG1CQUFiO0FBQ0gsYUFIUztBQUlWLHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBSkEsU0F2UVI7QUE2UU4saUJBQVM7QUFDTCxvQkFBUSxrQkFBWTtBQUNoQixxQkFBSyxPQUFMLENBQWEsY0FBYixDQUE0QixJQUE1QjtBQUNILGFBSEk7QUFJTCxzQkFBVSxFQUFDLFVBQVUsSUFBWDtBQUpMLFNBN1FIOztBQW9STixzQkFBYztBQUNWLG9CQUFRLGdCQUFTLENBQVQsRUFBWTtBQUNoQix1QkFBTyxRQUFQLENBQWdCLEVBQUUsUUFBbEI7QUFDSCxhQUhTO0FBSVYsc0JBQVUsRUFBQyxLQUFLLElBQU47QUFKQSxTQXBSUjtBQTBSTix1QkFBZTtBQUNYLG9CQUFRLGtCQUFZO0FBQ2hCO0FBQ0gsYUFIVTtBQUlYLHNCQUFVLEVBQUMsS0FBSyxJQUFOO0FBSkMsU0ExUlQ7O0FBaVNOLCtCQUF1QjtBQUNuQixvQkFBUSxnQkFBUyxDQUFULEVBQVk7QUFDaEIsdUJBQU8sZ0JBQVAsQ0FBd0IsRUFBRSxRQUExQjtBQUNILGFBSGtCO0FBSW5CLHNCQUFVLEVBQUMsS0FBSyxJQUFOLEVBSlM7QUFLbkIseUJBQWEsdUJBQVc7QUFDcEIsdUJBQU8saURBQVA7QUFDSDtBQVBrQixTQWpTakI7QUEwU04sK0JBQXVCO0FBQ25CLG9CQUFRLGtCQUFZO0FBQ2hCLHVCQUFPLGFBQVA7QUFDSCxhQUhrQjtBQUluQixzQkFBVSxFQUFDLEtBQUssSUFBTjtBQUpTLFNBMVNqQjs7QUFpVE47O0FBRUEsb0JBQVk7QUFDUixvQkFBUSxrQkFBVztBQUNmLHFCQUFLLE9BQUwsQ0FBYSxRQUFiO0FBQ0gsYUFITztBQUlSLHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBSkYsU0FuVE47QUF5VE4sdUJBQWU7QUFDWCxvQkFBUSxrQkFBVztBQUNmLG9CQUFJLENBQUMsS0FBSyxPQUFMLENBQWEsV0FBYixFQUFMLEVBQWlDO0FBQzdCLDBCQUFNLGtFQUFOO0FBQ0g7QUFDSixhQUxVO0FBTVgsc0JBQVUsRUFBQyxVQUFVLElBQVg7QUFOQyxTQXpUVDtBQWlVTixxQkFBYTtBQUNULG9CQUFRLGdCQUFTLENBQVQsRUFBWTtBQUNoQixxQkFBSyxPQUFMLENBQWEsU0FBYixDQUF1QixFQUFFLFNBQXpCLEVBQW9DLEVBQUUsT0FBdEM7QUFDSCxhQUhRO0FBSVQsc0JBQVUsRUFBQyxVQUFVLElBQVg7QUFKRCxTQWpVUDtBQXVVTiwrQkFBdUI7QUFDbkIsb0JBQVEsZ0JBQVMsQ0FBVCxFQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxtQkFBYixDQUFpQyxFQUFFLFVBQW5DOztBQUVBO0FBQ0EscUJBQUssT0FBTCxDQUFhLGdCQUFiO0FBQ0gsYUFOa0I7QUFPbkIsc0JBQVUsRUFBQyxVQUFVLElBQVg7QUFQUyxTQXZVakI7QUFnVk4sOEJBQXNCO0FBQ2xCLG9CQUFRLGdCQUFTLENBQVQsRUFBWTtBQUNoQixxQkFBSyxPQUFMLENBQWEsa0JBQWIsQ0FBZ0MsRUFBRSxVQUFsQyxFQUE4QyxFQUFFLE9BQWhEO0FBQ0gsYUFIaUI7QUFJbEIsc0JBQVUsRUFBQyxXQUFXLElBQVo7QUFKUSxTQWhWaEI7QUFzVk4sd0JBQWdCO0FBQ1osb0JBQVEsZ0JBQVMsQ0FBVCxFQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxZQUFiLENBQTBCLEVBQUUsVUFBNUIsRUFBd0MsRUFBRSxJQUExQztBQUNILGFBSFc7QUFJWixzQkFBVSxFQUFDLFdBQVcsSUFBWjtBQUpFLFNBdFZWO0FBNFZOLDZCQUFxQjtBQUNqQixvQkFBUSxnQkFBUyxDQUFULEVBQVk7QUFDaEIscUJBQUssT0FBTCxDQUFhLGlCQUFiLENBQStCLEVBQUUsVUFBakMsRUFBNkMsRUFBRSxTQUEvQztBQUNILGFBSGdCO0FBSWpCLHNCQUFVLEVBQUMsV0FBVyxJQUFaO0FBSk8sU0E1VmY7QUFrV04seUJBQWlCO0FBQ2Isb0JBQVEsZ0JBQVMsQ0FBVCxFQUFZO0FBQ2hCLHFCQUFLLE9BQUwsQ0FBYSxhQUFiLENBQTJCLEVBQUUsVUFBN0IsRUFBeUMsRUFBRSxLQUEzQztBQUNILGFBSFk7QUFJYixzQkFBVSxFQUFDLFdBQVcsSUFBWjtBQUpHLFNBbFdYOztBQXlXTjs7QUFFQSxvQkFBWSxJQUFJLG1CQUFKLENBQXdCLE9BQXhCLENBM1dOO0FBNFdOLG9CQUFZLElBQUksbUJBQUosQ0FBd0IsT0FBeEIsQ0E1V047QUE2V04scUJBQWEsSUFBSSxtQkFBSixDQUF3QixRQUF4QixDQTdXUDtBQThXTixxQkFBYSxJQUFJLG1CQUFKLENBQXdCLFFBQXhCLENBOVdQO0FBK1dOLHVCQUFlLElBQUksbUJBQUosQ0FBd0IsVUFBeEIsQ0EvV1Q7QUFnWE4sbUJBQVcsSUFBSSxtQkFBSixDQUF3QixNQUF4QixDQWhYTDtBQWlYTixtQkFBVyxJQUFJLG1CQUFKLENBQXdCLE1BQXhCLENBalhMO0FBa1hOLHVCQUFlLElBQUksbUJBQUosQ0FBd0IsVUFBeEIsQ0FsWFQ7O0FBb1hOLDBCQUFrQjtBQUNkLG9CQUFRLGtCQUFZO0FBQ2hCLHdCQUFRLGNBQVI7QUFDSCxhQUhhO0FBSWQsc0JBQVUsRUFBQyxLQUFLLElBQU47QUFKSSxTQXBYWjtBQTBYTiwyQkFBbUI7QUFDZixvQkFBUSxrQkFBWTtBQUNoQix3QkFBUSxlQUFSO0FBQ0gsYUFIYztBQUlmLHNCQUFVLEVBQUMsS0FBSyxJQUFOO0FBSkssU0ExWGI7O0FBaVlOOztBQUVBLGdCQUFRO0FBQ0osb0JBQVEsa0JBQVk7QUFDaEI7QUFDSCxhQUhHO0FBSUoseUJBQWEsdUJBQVc7QUFDcEIsdUJBQU8sUUFBUSxhQUFSLEtBQTBCLEtBQWpDO0FBQ0gsYUFORztBQU9KLHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBUE4sU0FuWUY7QUE0WU4sZ0JBQVE7QUFDSixvQkFBUSxrQkFBWTtBQUNoQjtBQUNILGFBSEc7QUFJSix5QkFBYSx1QkFBVztBQUNwQix1QkFBTyxDQUFDLENBQUMsUUFBUSxPQUFqQjtBQUNILGFBTkc7QUFPSixzQkFBVSxFQUFDLFVBQVUsSUFBWDtBQVBOLFNBNVlGO0FBcVpOLGdCQUFRO0FBQ0osb0JBQVEsa0JBQVk7QUFDaEIsdUJBQU8sUUFBUCxHQUFrQixRQUFRLE9BQTFCO0FBQ0gsYUFIRztBQUlKLHlCQUFhLHVCQUFXO0FBQ3BCLHVCQUFPLENBQUMsQ0FBQyxRQUFRLE9BQWpCO0FBQ0gsYUFORztBQU9KLHNCQUFVLEVBQUMsVUFBVSxJQUFYO0FBUE4sU0FyWkY7QUE4Wk4sb0JBQVk7QUFDUixvQkFBUSxrQkFBVyxDQUNsQixDQUZPO0FBR1IseUJBQWEsdUJBQVc7QUFDcEIsdUJBQU8sQ0FBQyxDQUFDLFFBQVEsa0JBQWpCO0FBQ0g7QUFMTyxTQTlaTjtBQXFhTixnQkFBUTtBQUNKLG9CQUFRLGtCQUFZO0FBQ2hCO0FBQ0EsdUJBQU8sUUFBUCxHQUFrQixRQUFRLE9BQTFCO0FBQ0gsYUFKRztBQUtKLHlCQUFhLHVCQUFXO0FBQ3BCLHVCQUFPLENBQUMsQ0FBQyxRQUFRLE9BQWpCO0FBQ0gsYUFQRztBQVFKLHNCQUFVO0FBUk47QUFyYUYsS0FwQmQ7O0FBcWNBLGFBQVMsbUJBQVQsQ0FBNkIsT0FBN0IsRUFBc0M7QUFDbEMsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNIOztBQUVELHdCQUFvQixTQUFwQixDQUE4QixNQUE5QixHQUF1QyxVQUFTLENBQVQsRUFBWTtBQUMvQyxnQkFBUSxXQUFSLENBQW9CLEtBQUssT0FBekIsRUFBa0MsRUFBRSxRQUFwQztBQUNILEtBRkQ7QUFHQSx3QkFBb0IsU0FBcEIsQ0FBOEIsUUFBOUIsR0FBeUMsRUFBQyxLQUFLLElBQU4sRUFBekM7O0FBRUEsYUFBUyxnQkFBVCxDQUEwQixPQUExQixFQUFtQztBQUMvQixhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0g7O0FBRUQscUJBQWlCLFNBQWpCLENBQTJCLE1BQTNCLEdBQW9DLFlBQVc7QUFDM0MsZ0JBQVEsS0FBSyxPQUFiO0FBQ0gsS0FGRDs7QUFJQSxxQkFBaUIsU0FBakIsQ0FBMkIsUUFBM0IsR0FBc0MsRUFBQyxNQUFNLElBQVAsRUFBYSxNQUFNLElBQW5CLEVBQXRDOztBQUVBLGFBQVMsZ0JBQVQsQ0FBMEIsT0FBMUIsRUFBbUM7QUFDL0IsYUFBSyxPQUFMLEdBQWUsT0FBZjtBQUNIOztBQUVELHFCQUFpQixTQUFqQixDQUEyQixNQUEzQixHQUFvQyxZQUFXO0FBQzNDLGdCQUFRLEtBQUssT0FBYjtBQUNILEtBRkQ7QUFHQSxxQkFBaUIsU0FBakIsQ0FBMkIsUUFBM0IsR0FBc0MsRUFBQyxNQUFNLElBQVAsRUFBdEM7O0FBRUEsYUFBUyxpQkFBVCxHQUE2QjtBQUN6QixZQUFJLENBQUMsYUFBTCxFQUFvQjtBQUNoQiw0QkFBZ0IsOEJBQW9CLE1BQXBCLEVBQTRCLElBQTVCLENBQWhCO0FBQ0g7O0FBRUQsc0JBQWMsSUFBZDtBQUNIOztBQUVELGFBQVMscUJBQVQsR0FBaUM7QUFDN0IsWUFBSSxDQUFDLFVBQUwsRUFBaUI7QUFDYix5QkFBYSwyQkFBaUIsTUFBakIsRUFBeUIsTUFBekIsQ0FBYjtBQUNIOztBQUVELG1CQUFXLElBQVg7QUFDSDs7QUFFRCxhQUFTLGlCQUFULEdBQTZCO0FBQ3pCLGFBQUssU0FBTCxDQUFlLFlBQWYsRUFBNkIsQ0FBQyxRQUFELEVBQVcsTUFBTSxRQUFOLENBQVgsQ0FBN0I7QUFDSDs7QUFFRDtBQUNBLFNBQUssaUJBQUwsR0FBeUIsWUFBVztBQUNoQztBQUNILEtBRkQ7O0FBSUEsYUFBUyxpQkFBVCxHQUE2QjtBQUN6QixhQUFLLFNBQUwsQ0FBZSxZQUFmLEVBQTZCLENBQUMsT0FBRCxDQUE3QjtBQUNIOztBQUVELGFBQVMsaUJBQVQsQ0FBMkIsUUFBM0IsRUFBcUM7QUFDakMsYUFBSyxTQUFMLENBQWUsWUFBZixFQUE2QixDQUFDLFFBQUQsQ0FBN0I7QUFDSDs7QUFFRCxTQUFLLFVBQUwsR0FBa0IsWUFBVztBQUN6QixlQUFPLE9BQVA7QUFDSCxLQUZEOztBQUlBLFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLGVBQU8sS0FBSyxPQUFaO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLFNBQUwsR0FBaUIsVUFBUyxPQUFULEVBQWtCO0FBQy9CLGlCQUFTLE9BQVQ7QUFDSCxLQUZEOztBQUlIOzs7OztBQUtHLFNBQUsseUJBQUwsR0FBaUMsVUFBUyxhQUFULEVBQXdCO0FBQ3JELGFBQUssT0FBTCxDQUFhLHlCQUFiLENBQXVDLGFBQXZDO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLFdBQUwsR0FBbUIsVUFBUyxLQUFULEVBQWdCO0FBQy9CLFlBQUksQ0FBQyxTQUFTLE9BQVQsQ0FBaUIsS0FBakIsQ0FBTCxFQUE4QjtBQUMxQixpQkFBSyxPQUFMLENBQWEsa0JBQWIsQ0FBZ0MsTUFBTSxNQUFOLEVBQWhDOztBQUVBLHFCQUFTLFFBQVQsQ0FBa0IsS0FBbEI7O0FBRUEsaUJBQUssU0FBTCxDQUFlLGFBQWYsRUFBOEIsQ0FBQyxLQUFELENBQTlCO0FBQ0g7QUFDSixLQVJEOztBQVVBLFNBQUssV0FBTCxHQUFtQixZQUFXO0FBQzFCLGVBQU8sU0FBUyxLQUFULEVBQVA7QUFDSCxLQUZEOztBQUlBLFNBQUssY0FBTCxHQUFzQixZQUFXO0FBQzdCLGVBQU8sU0FBUyxNQUFULEVBQVA7QUFDSCxLQUZEOztBQUlBLFNBQUssY0FBTCxHQUFzQixVQUFTLEtBQVQsRUFBZ0I7QUFDbEMsYUFBSyxXQUFMLENBQWlCLHNCQUFZLEtBQVosQ0FBakI7QUFDSCxLQUZEOztBQUlBLFNBQUssY0FBTCxHQUFzQixVQUFTLFFBQVQsRUFBbUI7QUFDckMsc0JBQWMsU0FBUyxLQUFULENBQWUsQ0FBZixDQUFkLENBRHFDLENBQ0o7O0FBRWpDLGFBQUssU0FBTCxDQUFlLGdCQUFmLEVBQWlDLENBQUMsV0FBRCxDQUFqQztBQUNILEtBSkQ7O0FBTUEsU0FBSyxjQUFMLEdBQXNCLFlBQVc7QUFDN0IsZUFBTyxZQUFZLEtBQVosQ0FBa0IsQ0FBbEIsQ0FBUCxDQUQ2QixDQUNBO0FBQ2hDLEtBRkQ7O0FBSUEsU0FBSyxZQUFMLEdBQW9CLFVBQVMsSUFBVCxFQUFlO0FBQy9CLGNBQU0sUUFBTixFQUFnQixJQUFoQixHQUF1QixLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLElBQWQsQ0FBWixDQUF2QjtBQUNBO0FBQ0gsS0FIRDs7QUFLQSxTQUFLLFlBQUwsR0FBb0IsWUFBVztBQUMzQixlQUFPLE1BQU0sUUFBTixFQUFnQixJQUF2QjtBQUNILEtBRkQ7O0FBSUEsU0FBSyxRQUFMLEdBQWdCLFVBQVMsS0FBVCxFQUFnQjtBQUM1QixjQUFNLFFBQU4sRUFBZ0IsS0FBaEIsR0FBd0IsS0FBeEI7QUFDQTtBQUNILEtBSEQ7O0FBS0EsU0FBSyxRQUFMLEdBQWdCLFlBQVc7QUFDdkIsZUFBTyxNQUFNLFFBQU4sRUFBZ0IsS0FBdkI7QUFDSCxLQUZEOztBQUlBLFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLGVBQU8sT0FBUDtBQUNILEtBRkQ7O0FBSUEsYUFBUyxPQUFULENBQWlCLE9BQWpCLEVBQTBCO0FBQ3RCLFlBQUksV0FBVyxPQUFmLEVBQXdCO0FBQ3BCLGdCQUFJLFdBQVcsYUFBYSxXQUE1QixFQUF5QztBQUNyQyxtQ0FBbUIsT0FBbkI7QUFDSDtBQUNELHNCQUFVLE9BQVY7QUFDQTtBQUNIO0FBQ0o7O0FBRUQsU0FBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsZUFBTyxRQUFQO0FBQ0gsS0FGRDs7QUFJQSxhQUFTLE9BQVQsQ0FBaUIsSUFBakIsRUFBdUI7QUFDbkIsZ0JBQVEsYUFBYSxNQUFyQjtBQUNBLG1CQUFXLElBQVg7QUFDQSxhQUFLLE9BQUwsQ0FBYSxRQUFiLENBQXNCLE1BQU0sSUFBTixDQUF0QjtBQUNBO0FBQ0g7O0FBRUQsU0FBSyxZQUFMLEdBQW9CLFlBQVc7QUFDM0IsZUFBTyxNQUFNLFFBQU4sQ0FBUDtBQUNILEtBRkQ7O0FBSUEsYUFBUyxXQUFULEdBQXVCO0FBQ25CLFlBQ0ksUUFBUSw4QkFBb0I7QUFDeEIscUJBQVMsS0FBSyxVQUFMLEVBRGU7QUFFeEIsc0JBQVUsT0FBTyxhQUFQLEVBRmM7QUFHeEIsc0JBQVUsUUFBUSxXQUFSO0FBSGMsU0FBcEIsQ0FEWjs7QUFPQSxjQUFNLEVBQU4sQ0FBUyxnQkFBVCxFQUEyQixZQUFXO0FBQ2xDLGlCQUFLLE9BQUwsQ0FBYSxvQkFBYixDQUFrQyxLQUFsQztBQUNILFNBRkQ7O0FBSUEsY0FBTSxFQUFOLENBQVMsZUFBVCxFQUEwQixZQUFXO0FBQ2pDLGtCQUFNLHVFQUFOO0FBQ0gsU0FGRDs7QUFJQSxjQUFNLElBQU47QUFDSDs7QUFFRCxhQUFTLFdBQVQsR0FBdUI7QUFDbkIsWUFBSSxDQUFDLEtBQUssaUJBQUwsQ0FBdUIsWUFBdkIsQ0FBRCxJQUF5QyxDQUFDLFFBQVEsa0ZBQVIsQ0FBOUMsRUFBMkk7QUFDdkk7QUFDSDs7QUFFRCxZQUNJLFFBQVEsOEJBQW9CO0FBQ3hCLHFCQUFTLEtBQUssVUFBTCxFQURlO0FBRXhCLHNCQUFVLE9BQU8sYUFBUCxFQUZjO0FBR3hCLHNCQUFVLFFBQVEsV0FBUixFQUhjO0FBSXhCLGlCQUFLLFFBQVE7QUFKVyxTQUFwQixDQURaO0FBQUEsWUFPSSxhQUFhLDJCQUFpQixJQUFqQixFQUF1QixNQUF2QixFQUErQixLQUEvQixDQVBqQjs7QUFTQSxjQUFNLEVBQU4sQ0FBUyxnQkFBVCxFQUEyQixZQUFXO0FBQ2xDLGlCQUFLLE9BQUwsQ0FBYSxvQkFBYixDQUFrQyxLQUFsQzs7QUFFQTtBQUNBLGdCQUFJLENBQUMsS0FBSyxpQkFBTCxDQUF1QixZQUF2QixDQUFELElBQXlDLEtBQUssaUJBQUwsQ0FBdUIsUUFBdkIsQ0FBN0MsRUFBK0U7QUFDM0UscUJBQUssZUFBTCxDQUFxQixFQUFDLFFBQVEsUUFBVCxFQUFyQjtBQUNIO0FBQ0osU0FQRDs7QUFTQTtBQUNBLG1CQUFXLEVBQVgsQ0FBYyxPQUFkLEVBQXVCLFlBQVc7QUFDOUIsa0JBQU0sSUFBTjtBQUNILFNBRkQ7O0FBSUEsbUJBQVcsSUFBWDtBQUNIOztBQUVEOzs7O0FBSUEsU0FBSyxpQkFBTCxHQUF5QixVQUFTLFVBQVQsRUFBcUI7QUFDMUMsWUFBSSxRQUFRLFVBQVIsQ0FBSixFQUF5QjtBQUNyQixnQkFDSSx3QkFBdUIsUUFBUSxVQUFSLEVBQW9CLFdBQTNDLENBREo7O0FBR0EsZ0JBQUksaUJBQWlCLFVBQXJCLEVBQWlDO0FBQzdCLHVCQUFPLFFBQVEsVUFBUixFQUFvQixXQUFwQixFQUFQO0FBQ0gsYUFGRCxNQUVPLElBQUksaUJBQWlCLFdBQXJCLEVBQWtDO0FBQ3JDO0FBQ0EsdUJBQU8sSUFBUDtBQUNILGFBSE0sTUFHQTtBQUNILHVCQUFPLFFBQVEsVUFBUixFQUFvQixXQUEzQjtBQUNIO0FBQ0o7O0FBRUQsZUFBTyxLQUFQO0FBQ0gsS0FoQkQ7O0FBa0JBLFNBQUsscUJBQUwsR0FBNkIsVUFBUyxVQUFULEVBQXFCLE9BQXJCLEVBQThCLEtBQTlCLEVBQXFDO0FBQzlELGFBQUssU0FBTCxDQUFlLG1CQUFmLEVBQW9DLENBQUMsVUFBRCxFQUFhLE9BQWIsRUFBc0IsS0FBdEIsQ0FBcEM7QUFDSCxLQUZEOztBQUlBLFNBQUssZUFBTCxHQUF1QixVQUFTLENBQVQsRUFBWTtBQUMvQixZQUFJLEtBQUssT0FBTCxJQUFnQixJQUFoQixJQUF3QixVQUFVLElBQXRDLEVBQTRDO0FBQ3hDLG1CQUR3QyxDQUNoQztBQUNYOztBQUVELFlBQ0ksU0FBUyxRQUFRLEVBQUUsTUFBVixDQURiOztBQUdBLFlBQUksTUFBSixFQUFZO0FBQ1IsZ0JBQUksV0FBVyxhQUFhLFdBQXhCLEtBQXdDLE9BQU8sUUFBUCxDQUFnQixRQUFoQixJQUE0QixPQUFPLFFBQVAsQ0FBZ0IsSUFBcEYsS0FDTyxDQUFDLG1CQUFELEVBQXNCLG1CQUF0QixFQUEyQyxPQUEzQyxDQUFtRCxFQUFFLE1BQXJELEtBQWdFLENBQUMsQ0FENUUsRUFDK0U7QUFDM0Usb0JBQUksRUFBRSxNQUFGLElBQVksUUFBaEIsRUFBMEI7QUFDdEIsNEJBQVEsaUJBQVIsQ0FBMEIsTUFBMUI7QUFDSCxpQkFGRCxNQUVPLElBQUksRUFBRSxNQUFGLElBQVksYUFBaEIsRUFBK0I7QUFDbEM7QUFDSCxpQkFGTSxNQUVBO0FBQ0g7QUFDQSx3QkFDSSxTQUFTLHVDQUE2QixNQUE3QixFQUFxQyxJQUFyQyxDQURiOztBQUdBOzs7QUFHQSwyQkFBTyxFQUFQLENBQVUsUUFBVixFQUFvQixLQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBMEIsSUFBMUIsRUFBZ0MsQ0FBaEMsQ0FBcEI7QUFDQSwyQkFBTyxFQUFQLENBQVUsUUFBVixFQUFvQixLQUFLLGVBQUwsQ0FBcUIsSUFBckIsQ0FBMEIsSUFBMUIsRUFBZ0MsQ0FBaEMsQ0FBcEI7O0FBRUEsMkJBQU8sSUFBUDtBQUNIO0FBQ0osYUFuQkQsTUFtQk87QUFDSCx1QkFBTyxNQUFQLENBQWMsQ0FBZDtBQUNIO0FBQ0o7O0FBRUQ7QUFDSCxLQWxDRDs7QUFvQ0EsYUFBUyxxQkFBVCxHQUFpQztBQUM3QixZQUFJLGtDQUFpQixnQkFBakIsQ0FBSixFQUF3QztBQUNwQyxtQkFBTyxnQkFBUCxDQUF3QixjQUF4QixFQUF3QyxVQUFTLENBQVQsRUFBWTtBQUNoRCxvQkFBSSxLQUFLLE9BQUwsQ0FBYSxvQkFBYixFQUFKLEVBQXlDO0FBQ3JDLHdCQUNJLGlCQUFpQixtQ0FEckI7QUFFQSxzQkFBRSxXQUFGLEdBQWdCLGNBQWhCO0FBQ0EsMkJBQU8sY0FBUDtBQUNIO0FBQ0osYUFQRDtBQVFILFNBVEQsTUFTTztBQUNIO0FBQ0EsY0FBRSxHQUFGLEVBQU8sS0FBUCxDQUFhLFVBQVMsQ0FBVCxFQUFZO0FBQ3JCLG9CQUFJLEtBQUssWUFBTCxDQUFrQixNQUFsQixLQUE2QixHQUE3QixJQUFvQyxLQUFLLE9BQUwsQ0FBYSxvQkFBYixFQUF4QyxFQUE2RTtBQUN6RSwyQkFBTyxRQUFRLDBFQUFSLENBQVA7QUFDSDtBQUNKLGFBSkQ7QUFLSDtBQUNKOztBQUVELGFBQVMsWUFBVCxDQUFzQixRQUF0QixFQUFnQyxpQkFBaEMsRUFBbUQ7QUFDL0Msa0JBQVUsd0JBQWMsSUFBZCxFQUFvQixNQUFwQixDQUFWOztBQUVBLGdCQUFRLGFBQWEsS0FBckI7QUFDQSxnQkFBUSxlQUFSOztBQUVBLFlBQUksUUFBSixFQUFjO0FBQ1Ysb0JBQVEsV0FBUixDQUFvQixRQUFwQjtBQUNIOztBQUVELFlBQUksaUJBQUosRUFBdUI7QUFDbkIsb0JBQVEsV0FBUixDQUFvQixvQkFBb0IsS0FBSyxFQUF6QixHQUE4QixDQUFsRDtBQUNIOztBQUVELGdDQUFjLE1BQWQsR0FBdUIsWUFBdkI7O0FBRUE7QUFDSDs7QUFFRCxTQUFLLGdCQUFMLEdBQXdCLFlBQVc7QUFDL0IsZUFBTyxRQUFRLGFBQWY7QUFDSCxLQUZEOztBQUlBLFFBQUksQ0FBQyxvQkFBTCxFQUEyQjtBQUN2QixjQUFNLElBQUksYUFBYSwyQkFBakIsRUFBTjtBQUNIOztBQUVELFFBQUksT0FBTyxTQUFTLElBQVQsQ0FBYyxLQUFkLENBQW9CLFNBQTNCLElBQXdDLFFBQXhDLElBQW9ELE9BQU8sU0FBUyxJQUFULENBQWMsS0FBZCxDQUFvQixlQUEzQixJQUE4QyxRQUFsRyxJQUE4RyxTQUFTLElBQVQsQ0FBYyxVQUFVLFNBQXhCLENBQWxILEVBQXNKO0FBQ2xKLGVBQU8sU0FBUCxJQUFvQixhQUFwQjtBQUNIOztBQUVELFdBQU8sU0FBUCxJQUFvQixlQUFwQjs7QUFFQSxZQUFRLGFBQVIsR0FBd0IsUUFBUSxhQUFSLElBQXlCLGVBQWpEOztBQUVBLFFBQUksUUFBUSxtQkFBWixFQUFpQztBQUM3QixVQUFFLFFBQUYsRUFBWSxHQUFaLENBQWdCLFdBQWhCO0FBQ0g7O0FBRUQsUUFBSSxRQUFRLFlBQVIsSUFBd0IsUUFBUSxnQkFBcEMsRUFBc0Q7QUFDbEQsWUFDSSxTQUFTLCtCQUFxQixPQUFyQixDQURiOztBQUdBLHFDQUFrQixNQUFsQixFQUEwQixNQUExQixFQUFrQyxRQUFRLGFBQTFDOztBQUVBLGVBQU8sRUFBUCxDQUFVLGlCQUFWLEVBQTZCLFVBQVMsU0FBVCxFQUFvQjtBQUM3QyxpQkFBSyxPQUFMLEdBQWUsVUFBVSxNQUFWLElBQW9CLFVBQVUsSUFBN0M7O0FBRUEseUJBQWEsVUFBVSxRQUF2QixFQUFpQyxRQUFRLFFBQXpDO0FBQ0gsU0FKRDs7QUFNQSxlQUFPLElBQVA7QUFDSCxLQWJELE1BYU87QUFDSCxhQUFLLE9BQUwsR0FBZSx3QkFBYyxRQUFRLFdBQVIsSUFBdUIsR0FBckMsRUFBMEMsUUFBUSxZQUFSLElBQXdCLEdBQWxFLENBQWY7QUFDQSxhQUFLLE9BQUwsQ0FBYSxrQkFBYjs7QUFFQTtBQUNIO0FBQ0o7O0FBRUQsYUFBYSxTQUFiLEdBQXlCLE9BQU8sTUFBUCxDQUFjLGFBQWEsU0FBM0IsQ0FBekI7QUFDQSxhQUFhLFNBQWIsQ0FBdUIsV0FBdkIsR0FBcUMsWUFBckM7O0FBRUEsYUFBYSwyQkFBYixHQUEyQyxZQUFXLENBQ3JELENBREQ7O0FBR0EsYUFBYSwyQkFBYixDQUF5QyxTQUF6QyxDQUFtRCxRQUFuRCxHQUE4RCxZQUFXO0FBQ3JFLFdBQU8sMEhBQVA7QUFDSCxDQUZEOztBQUlBO0FBQ0E7QUFDQTs7QUFFQSxhQUFhLE1BQWIsR0FBc0IsQ0FBdEI7QUFDQSxhQUFhLFdBQWIsR0FBMkIsQ0FBM0I7QUFDQSxhQUFhLGdCQUFiLEdBQWdDLENBQWhDO0FBQ0EsYUFBYSxXQUFiLEdBQTJCLENBQTNCO0FBQ0EsYUFBYSxlQUFiLEdBQStCLENBQS9CO0FBQ0EsYUFBYSxjQUFiLEdBQThCLENBQTlCO0FBQ0EsYUFBYSxjQUFiLEdBQThCLENBQTlCO0FBQ0EsYUFBYSxXQUFiLEdBQTJCLENBQTNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBYixHQUF3QixDQUF4QjtBQUNBLGFBQWEsUUFBYixHQUF3QixDQUF4QjtBQUNBLGFBQWEsS0FBYixHQUFxQixDQUFyQjtBQUNBLGFBQWEsWUFBYixHQUE0QixDQUE1QjtBQUNBLGFBQWEsVUFBYixHQUEwQixDQUExQjtBQUNBLGFBQWEsT0FBYixHQUF1QixDQUF2QjtBQUNBLGFBQWEsTUFBYixHQUFzQixDQUF0QjtBQUNBLGFBQWEsT0FBYixHQUF1QixDQUF2QjtBQUNBLGFBQWEsTUFBYixHQUFzQixDQUF0QjtBQUNBLGFBQWEsUUFBYixHQUF3QixDQUF4QjtBQUNBLGFBQWEsU0FBYixHQUF5QixFQUF6QjtBQUNBLGFBQWEsS0FBYixHQUFxQixFQUFyQjs7Ozs7Ozs7O2tCQzVnQ3dCLFM7O0FBNUJ4Qjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBO0FBQ0EsSUFBSSxDQUFDLE9BQU8sU0FBUCxDQUFpQixRQUF0QixFQUFnQztBQUM1QixXQUFPLFNBQVAsQ0FBaUIsUUFBakIsR0FBNEIsVUFBUyxZQUFULEVBQXVCLFFBQXZCLEVBQWlDO0FBQ3pELFlBQUksZ0JBQWdCLEtBQUssUUFBTCxFQUFwQjtBQUNBLFlBQUksT0FBTyxRQUFQLEtBQW9CLFFBQXBCLElBQWdDLENBQUMsU0FBUyxRQUFULENBQWpDLElBQXVELEtBQUssS0FBTCxDQUFXLFFBQVgsTUFBeUIsUUFBaEYsSUFBNEYsV0FBVyxjQUFjLE1BQXpILEVBQWlJO0FBQzdILHVCQUFXLGNBQWMsTUFBekI7QUFDSDtBQUNELG9CQUFZLGFBQWEsTUFBekI7QUFDQSxZQUFJLFlBQVksY0FBYyxPQUFkLENBQXNCLFlBQXRCLEVBQW9DLFFBQXBDLENBQWhCO0FBQ0EsZUFBTyxjQUFjLENBQUMsQ0FBZixJQUFvQixjQUFjLFFBQXpDO0FBQ0gsS0FSRDtBQVNILEMsQ0FoREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFrRGUsU0FBUyxTQUFULENBQW1CLE1BQW5CLEVBQTJCLE9BQTNCLEVBQW9DOztBQUUvQyxhQUFTLFNBQVMsQ0FBbEI7QUFDQSxjQUFVLFVBQVUsQ0FBcEI7O0FBRUEsUUFDSSxXQUFXLEVBRGY7QUFBQSxRQUVJLHlCQUF5QixVQUY3QjtBQUFBLFFBR0ksb0JBQW9CLFVBSHhCO0FBQUEsUUFLSSxnQkFBZ0IsR0FMcEI7QUFBQSxRQU1JLFdBQVcsRUFOZjtBQUFBLFFBT0ksV0FBVyxDQVBmOztBQVNBLFFBQ0ksU0FBUyxFQURiO0FBQUEsUUFFSSxRQUZKO0FBQUEsUUFJSSxvQkFBb0IsS0FKeEI7QUFBQSxRQU1JLGVBQWUscUJBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FObkI7OztBQVFJOzs7OztBQUtBLG1CQUFlLHNCQUFZLE1BQVosRUFBb0IsT0FBcEIsQ0FibkI7OztBQWVJOzs7Ozs7QUFNQSxhQUFTLFlBckJiOzs7QUF1Qkk7Ozs7O0FBS0EsaUJBQWEsc0JBQVksTUFBWixFQUFvQixPQUFwQixDQTVCakI7OztBQThCSTs7Ozs7O0FBTUEsOEJBQTBCLHFCQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLE1BQWpCLEVBQXlCLE9BQXpCLENBcEM5Qjs7O0FBc0NJOzs7Ozs7QUFNQSxvQkFBZ0Isd0JBQWMsTUFBZCxFQUFzQixPQUF0QixFQUErQixFQUEvQixDQTVDcEI7OztBQThDSTs7O0FBR0Esa0JBQWMscUJBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FqRGxCOzs7QUFtREk7OztBQUdBLGlCQUFhLHFCQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLE1BQWpCLEVBQXlCLE9BQXpCLENBdERqQjs7O0FBd0RJOzs7O0FBSUEsZUFBVyxxQkFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixDQTVEZjtBQUFBLFFBOERJLE1BQU0sd0JBOURWO0FBQUEsUUFnRUksbUJBQW1CLElBaEV2QjtBQUFBLFFBa0VJLFlBQVksSUFsRWhCO0FBQUEsUUFrRXNCO0FBQ2xCLGVBQVcsRUFuRWY7QUFBQSxRQW1FbUIsV0FBVyxFQW5FOUI7QUFBQSxRQXFFSSxXQUFXLElBckVmO0FBQUEsUUF1RUksZUFBZSw4QkF2RW5CO0FBQUEsUUF5RUksUUFBUSxHQXpFWjtBQUFBLFFBeUVpQixRQUFRLEdBekV6QjtBQUFBLFFBeUU4QixlQUFlLEdBekU3QztBQUFBLFFBMEVJLGNBQWMsSUExRWxCO0FBQUEsUUE0RUksa0JBQWtCLEtBNUV0QjtBQUFBLFFBNkVJLFlBQVksS0E3RWhCO0FBQUEsUUErRUksV0FBVyxRQS9FZjtBQUFBLFFBK0V5QjtBQUNyQiw2QkFBeUIsUUFoRjdCO0FBQUEsUUFrRkksT0FBTyxJQWxGWDs7QUFvRkE7QUFDQTtBQUNBO0FBQ0EsYUFBUyxjQUFULENBQXdCLE9BQXhCLEVBQWlDLE9BQWpDLEVBQTBDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFRLEtBQVIsR0FBZ0IsUUFBUSxJQUFSLEdBQWUsUUFBUSxRQUFSLEVBQS9CO0FBQ0EsWUFBSSxRQUFRLEtBQVIsR0FBZ0IsS0FBSyxLQUF6QixFQUFnQztBQUM1QixvQkFBUSxLQUFSLElBQWlCLFFBQVEsS0FBUixHQUFnQixLQUFLLEtBQXRDO0FBQ0Esb0JBQVEsS0FBUixHQUFnQixLQUFLLEtBQXJCO0FBQ0g7O0FBRUQsZ0JBQVEsTUFBUixHQUFpQixRQUFRLEdBQVIsR0FBYyxRQUFRLFNBQVIsRUFBL0I7QUFDQSxZQUFJLFFBQVEsTUFBUixHQUFpQixLQUFLLE1BQTFCLEVBQWtDO0FBQzlCLG9CQUFRLE1BQVIsSUFBa0IsUUFBUSxNQUFSLEdBQWlCLEtBQUssTUFBeEM7QUFDQSxvQkFBUSxNQUFSLEdBQWlCLEtBQUssTUFBdEI7QUFDSDs7QUFFRDtBQUNBLFlBQUksUUFBUSxJQUFSLEdBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsb0JBQVEsSUFBUixJQUFnQixRQUFRLElBQXhCO0FBQ0Esb0JBQVEsSUFBUixHQUFlLENBQWY7QUFDSDs7QUFFRCxZQUFJLFFBQVEsR0FBUixHQUFjLENBQWxCLEVBQXFCO0FBQ2pCLG9CQUFRLEdBQVIsSUFBZSxRQUFRLEdBQXZCO0FBQ0Esb0JBQVEsR0FBUixHQUFjLENBQWQ7QUFDSDtBQUNKOztBQUVELGFBQVMseUJBQVQsQ0FBbUMsTUFBbkMsRUFBMkM7QUFDdkMsYUFBSyxTQUFMLENBQWUsY0FBZixFQUErQixDQUFDLE1BQUQsQ0FBL0I7QUFDSDs7QUFFRDtBQUNBLGFBQVMsd0JBQVQsQ0FBa0MsVUFBbEMsRUFBOEM7QUFDMUMsYUFBSyxTQUFMLENBQWUsYUFBZixFQUE4QixDQUFDLFVBQUQsQ0FBOUI7QUFDSDs7QUFFRDtBQUNBLGFBQVMsNEJBQVQsR0FBd0M7QUFDcEMsYUFBSyxTQUFMLENBQWUsaUJBQWYsRUFBa0MsRUFBbEM7QUFDSDs7QUFFRCxTQUFLLFNBQUwsR0FBaUIsWUFBVztBQUN4QixlQUFPLE1BQVA7QUFDSCxLQUZEOztBQUlBLFNBQUssYUFBTCxHQUFxQixZQUFXO0FBQzVCLGVBQU8sT0FBTyxNQUFkO0FBQ0gsS0FGRDs7QUFJQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0EsU0FBSyxzQkFBTCxHQUE4QixZQUFXO0FBQ3JDLFlBQ0ksQ0FESjs7QUFHQSxZQUFJLENBQUMsYUFBYSxPQUFiLEVBQUwsRUFBNkI7QUFDekIsZ0JBQUksYUFBYSxLQUFiLEVBQUo7QUFDSCxTQUZELE1BRU87QUFDSCxnQkFBSSxLQUFLLFNBQUwsRUFBSjtBQUNIOztBQUVELGVBQU8sQ0FBUDtBQUNILEtBWEQ7O0FBYUEsU0FBSyxZQUFMLEdBQW9CLFlBQVc7QUFDM0IsZUFBTyxhQUFhLEtBQWIsRUFBUDtBQUNILEtBRkQ7O0FBSUE7Ozs7OztBQU1BLGFBQVMsb0JBQVQsQ0FBOEIsSUFBOUIsRUFBb0M7QUFDaEMsbUJBQVcsS0FBWCxDQUFpQixJQUFqQjs7QUFFQTtBQUNBLGdDQUF3QixLQUF4QixDQUE4QixJQUE5Qjs7QUFFQSxrQ0FBMEIsSUFBMUI7QUFDSDs7QUFFRDs7O0FBR0EsYUFBUyxnQkFBVCxHQUE0QjtBQUN4Qiw2QkFBcUIscUJBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsS0FBSyxLQUF0QixFQUE2QixLQUFLLE1BQWxDLENBQXJCO0FBQ0g7O0FBRUQsU0FBSyxvQkFBTCxHQUE0QixVQUFTLEtBQVQsRUFBZ0I7QUFDeEMsNEJBQW9CLEtBQXBCO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLG9CQUFMLEdBQTRCLFlBQVc7QUFDbkMsZUFBTyxpQkFBUDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxrQkFBTCxHQUEwQixVQUFTLFVBQVQsRUFBcUIsT0FBckIsRUFBOEI7QUFDcEQsWUFDSSxRQUFRLEtBQUssUUFBTCxDQUFjLFVBQWQsQ0FEWjs7QUFHQSxnQkFBUSxJQUFJLGtCQUFKLENBQXVCLFVBQXZCLEVBQW1DLE1BQU0sT0FBekMsRUFBa0QsT0FBbEQsQ0FBUjtBQUNBLGNBQU0sT0FBTixHQUFnQixPQUFoQjs7QUFFQTtBQUNBLGlDQUF5QixVQUF6QjtBQUNILEtBVEQ7O0FBV0EsU0FBSyxRQUFMLEdBQWdCLFlBQVc7QUFDdkIsWUFDSSxXQUFXLHNCQUFZLEtBQUssS0FBakIsRUFBd0IsS0FBSyxNQUE3QixFQUFxQyxLQUFLLG1CQUFMLEVBQXJDLENBRGY7QUFBQSxZQUVJLG1CQUFtQixLQUFLLG1CQUFMLEVBRnZCOztBQUlBLGlCQUFTLFFBQVQsQ0FBa0IsaUJBQWxCLEVBTHVCLENBS2U7O0FBRXRDLGdCQUFRLElBQUksY0FBSixDQUFtQixnQkFBbkIsQ0FBUjs7QUFFQSxlQUFPLE1BQVAsQ0FBYyxtQkFBbUIsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsUUFBdkM7QUFDQSxhQUFLLG1CQUFMLENBQXlCLG1CQUFtQixDQUE1Qzs7QUFFQTtBQUNBO0FBQ0gsS0FkRDs7QUFnQkEsU0FBSyxjQUFMLEdBQXNCLFVBQVMsS0FBVCxFQUFnQjtBQUNsQyxlQUFPLElBQVAsQ0FBWSxLQUFaOztBQUVBLFlBQUksT0FBTyxNQUFQLElBQWlCLENBQXJCLEVBQXdCO0FBQ3BCLHVCQUFXLE9BQU8sQ0FBUCxDQUFYO0FBQ0g7O0FBRUQ7QUFDQTtBQUNILEtBVEQ7O0FBV0E7Ozs7OztBQU1BLFNBQUssV0FBTCxHQUFtQixZQUFXO0FBQzFCLFlBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ25CLGdCQUNJLG1CQUFtQixLQUFLLG1CQUFMLEVBRHZCOztBQUdBLG9CQUFRLElBQUksaUJBQUosQ0FBc0IsZ0JBQXRCLEVBQXdDLFFBQXhDLENBQVI7O0FBRUEsbUJBQU8sTUFBUCxDQUFjLGdCQUFkLEVBQWdDLENBQWhDO0FBQ0EsaUJBQUssbUJBQUwsQ0FBeUIsbUJBQW1CLE9BQU8sTUFBMUIsR0FBbUMsZ0JBQW5DLEdBQXNELG1CQUFtQixDQUFsRzs7QUFFQTtBQUNBOztBQUVBLG1CQUFPLElBQVA7QUFDSDs7QUFFRCxlQUFPLEtBQVA7QUFDSCxLQWpCRDs7QUFtQkEsU0FBSyxjQUFMLEdBQXNCLFlBQVc7QUFDN0IsWUFDSSxhQUFhLE9BRGpCO0FBQUEsWUFFSSxXQUFXLHNCQUFZLEtBQUssS0FBakIsRUFBd0IsS0FBSyxNQUE3QixDQUZmO0FBQUEsWUFHSSxtQkFBbUIsS0FBSyxtQkFBTCxFQUh2Qjs7QUFLQSxnQkFBUSxJQUFJLG9CQUFKLENBQXlCLGdCQUF6QixDQUFSOztBQUVBLGlCQUFTLFFBQVQsQ0FBa0IsT0FBTyxnQkFBUCxDQUFsQjs7QUFFQSxZQUFJLENBQUMsU0FBUyxJQUFULENBQWMsUUFBZCxDQUF1QixVQUF2QixDQUFMLEVBQXlDO0FBQ3JDLHFCQUFTLElBQVQsSUFBaUIsVUFBakI7QUFDSDs7QUFFRCxlQUFPLE1BQVAsQ0FBYyxtQkFBbUIsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsUUFBdkM7QUFDQSxhQUFLLG1CQUFMLENBQXlCLG1CQUFtQixDQUE1Qzs7QUFFQTtBQUNBO0FBQ0gsS0FuQkQ7O0FBcUJBLFNBQUssU0FBTCxHQUFpQixVQUFTLFVBQVQsRUFBcUI7QUFDbEMsWUFDSSxtQkFBbUIsS0FBSyxtQkFBTCxFQUR2Qjs7QUFHQSxZQUFJLE9BQU8sTUFBUCxHQUFnQixDQUFoQixJQUFxQixtQkFBbUIsQ0FBNUMsRUFBK0M7QUFDM0MsZ0JBQUksVUFBSixFQUFnQjtBQUNaLHdCQUFRLElBQUksb0JBQUosQ0FBeUIsZ0JBQXpCLENBQVI7QUFDSDs7QUFFRCw4QkFBUSxTQUFSLENBQWtCLE9BQU8sbUJBQW1CLENBQTFCLENBQWxCLEVBQWdELElBQWhELEVBQXNELE9BQU8sZ0JBQVAsQ0FBdEQsRUFBZ0YsS0FBSyxTQUFMLEVBQWhGO0FBQ0EsbUJBQU8sTUFBUCxDQUFjLGdCQUFkLEVBQWdDLENBQWhDO0FBQ0EsaUJBQUssbUJBQUwsQ0FBeUIsbUJBQW1CLENBQTVDOztBQUVBO0FBQ0E7QUFDSDtBQUNKLEtBaEJEOztBQWtCQSxTQUFLLGNBQUwsR0FBc0IsVUFBUyxVQUFULEVBQXFCO0FBQ3ZDLFlBQUksT0FBTyxNQUFQLEdBQWdCLENBQXBCLEVBQXVCO0FBQ25CLGdCQUFJLFVBQUosRUFBZ0I7QUFDWix3QkFBUSxJQUFJLG9CQUFKLEVBQVI7QUFDSDs7QUFFRCxpQkFBSyxZQUFMO0FBQ0EscUJBQVMsRUFBVDs7QUFFQSxnQkFDSSxRQUFRLHNCQUFZLEtBQUssS0FBakIsRUFBd0IsS0FBSyxNQUE3QixFQUFxQyxLQUFLLG1CQUFMLEVBQXJDLENBRFo7O0FBR0Esa0JBQU0sWUFBTixDQUFtQixNQUFuQjs7QUFFQSxtQkFBTyxJQUFQLENBQVksS0FBWjtBQUNBLGlCQUFLLG1CQUFMLENBQXlCLENBQXpCOztBQUVBO0FBQ0E7QUFDSDtBQUNKLEtBcEJEOztBQXNCQSxhQUFTLGFBQVQsQ0FBdUIsSUFBdkIsRUFBNkIsRUFBN0IsRUFBaUM7QUFDN0IsWUFDSSxRQUFRLE9BQU8sTUFBUCxDQUFjLElBQWQsRUFBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsQ0FEWjs7QUFHQSxZQUFJLE1BQU0sSUFBVixFQUFnQjtBQUNaLG1CQUFPLE1BQVAsQ0FBYyxFQUFkLEVBQWtCLENBQWxCLEVBQXFCLEtBQXJCO0FBQ0EsaUJBQUssbUJBQUwsQ0FBeUIsRUFBekI7QUFDSCxTQUhELE1BR087QUFDSCxtQkFBTyxNQUFQLENBQWMsS0FBSyxDQUFuQixFQUFzQixDQUF0QixFQUF5QixLQUF6QjtBQUNBLGlCQUFLLG1CQUFMLENBQXlCLEtBQUssQ0FBOUI7QUFDSDs7QUFFRDtBQUNBO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLFNBQUssU0FBTCxHQUFpQixVQUFTLElBQVQsRUFBZSxFQUFmLEVBQW1CO0FBQ2hDLFlBQUksT0FBTyxDQUFQLElBQVksUUFBUSxLQUFLLGFBQUwsRUFBcEIsSUFBNEMsS0FBSyxDQUFqRCxJQUFzRCxLQUFLLEtBQUssYUFBTCxFQUEzRCxJQUFtRixRQUFRLEVBQS9GLEVBQW1HO0FBQy9GO0FBQ0g7O0FBRUQsZ0JBQVEsSUFBSSxlQUFKLENBQW9CLElBQXBCLEVBQTBCLEVBQTFCLENBQVI7QUFDQSxzQkFBYyxJQUFkLEVBQW9CLEVBQXBCO0FBQ0gsS0FQRDs7QUFTQSxTQUFLLGFBQUwsR0FBcUIsVUFBUyxVQUFULEVBQXFCLEtBQXJCLEVBQTRCO0FBQzdDLFlBQ0ksUUFBUSxLQUFLLFFBQUwsQ0FBYyxVQUFkLENBRFo7O0FBR0EsWUFBSSxNQUFNLFFBQU4sTUFBb0IsS0FBeEIsRUFBK0I7QUFDM0Isb0JBQVEsSUFBSSxnQkFBSixDQUFxQixVQUFyQixFQUFpQyxLQUFqQyxDQUFSO0FBQ0Esa0JBQU0sUUFBTixDQUFlLEtBQWY7O0FBRUE7QUFDQSxxQ0FBeUIsVUFBekI7QUFDSDtBQUNKLEtBWEQ7O0FBYUEsU0FBSyxpQkFBTCxHQUF5QixVQUFTLFVBQVQsRUFBcUIsU0FBckIsRUFBZ0M7QUFDckQsWUFDSSxRQUFRLEtBQUssUUFBTCxDQUFjLFVBQWQsQ0FEWjs7QUFHQSxZQUFJLE1BQU0sWUFBTixNQUF3QixTQUE1QixFQUF1QztBQUNuQyxvQkFBUSxJQUFJLGVBQUosQ0FBb0IsVUFBcEIsRUFBZ0MsU0FBaEMsQ0FBUjtBQUNBLGtCQUFNLFlBQU4sQ0FBbUIsU0FBbkI7O0FBRUE7QUFDQSxxQ0FBeUIsVUFBekI7QUFDSDtBQUNKLEtBWEQ7O0FBYUEsU0FBSyxZQUFMLEdBQW9CLFVBQVMsVUFBVCxFQUFxQixJQUFyQixFQUEyQjtBQUMzQyxZQUNJLFFBQVEsS0FBSyxRQUFMLENBQWMsVUFBZCxDQURaOztBQUdBLFlBQUksU0FBUyxNQUFNLElBQU4sSUFBYyxJQUEzQixFQUFpQztBQUM3QixvQkFBUSxJQUFJLGlCQUFKLENBQXNCLFVBQXRCLEVBQWtDLElBQWxDLENBQVI7QUFDQSxrQkFBTSxJQUFOLEdBQWEsSUFBYjs7QUFFQSxxQ0FBeUIsVUFBekI7QUFDSDtBQUNKLEtBVkQ7O0FBWUEsYUFBUyxlQUFULEdBQTJCLENBQzFCOztBQUVELG9CQUFnQixTQUFoQixDQUEwQixXQUExQixHQUF3QyxVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsUUFBZixFQUF5QjtBQUM3RDtBQUNBLGlCQUFTLFNBQVQ7O0FBRUEsc0JBQWMsUUFBZCxDQUF1QixDQUF2QjtBQUNBLG9CQUFZLFNBQVo7O0FBRUEsZ0JBQVEsQ0FBUjtBQUNBLGdCQUFRLENBQVI7QUFDQSx1QkFBZSxRQUFmOztBQUVBLGFBQUssaUJBQUwsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsUUFBN0I7QUFDSCxLQVpEOztBQWNBLG9CQUFnQixTQUFoQixDQUEwQixjQUExQixHQUEyQyxVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsUUFBZixFQUF5QjtBQUNoRSxZQUNJLE9BQU8sS0FBSyxJQUFMLENBQVcsQ0FBQyxRQUFRLENBQVQsS0FBZSxRQUFRLENBQXZCLElBQTRCLENBQUMsUUFBUSxDQUFULEtBQWUsUUFBUSxDQUF2QixDQUF2QyxDQURYO0FBQUEsWUFFSSxVQUFVLEtBQUssR0FBTCxDQUFTLFNBQVMsVUFBbEIsRUFBOEIsU0FBUyxPQUFULEdBQW1CLFNBQVMsT0FBMUQsQ0FGZDs7QUFJQSxZQUFJLE9BQU8sT0FBWCxFQUFvQjtBQUNoQixnQkFDSSxLQUFLLEtBRFQ7QUFBQSxnQkFDZ0IsS0FBSyxLQURyQjtBQUFBLGdCQUM0QixLQUFLLFlBRGpDO0FBQUEsZ0JBRUksS0FBSyxDQUFDLFVBQVUsS0FBWCxJQUFvQixJQUY3Qjs7QUFJQSxpQkFBSyxJQUFJLElBQUksRUFBYixFQUFpQixLQUFLLEdBQXRCLEVBQTJCLEtBQUssRUFBaEMsRUFBb0M7QUFDaEMscUJBQUssSUFBSSxDQUFKLEdBQVEsQ0FBQyxNQUFNLENBQVAsSUFBWSxLQUF6QjtBQUNBLHFCQUFLLElBQUksQ0FBSixHQUFRLENBQUMsTUFBTSxDQUFQLElBQVksS0FBekI7QUFDQSxxQkFBSyxJQUFJLFFBQUosR0FBZSxDQUFDLE1BQU0sQ0FBUCxJQUFZLFlBQWhDO0FBQ0EscUJBQUssaUJBQUwsQ0FBdUIsRUFBdkIsRUFBMkIsRUFBM0IsRUFBK0IsRUFBL0I7QUFDSDtBQUNELG9CQUFRLEVBQVI7QUFDQSxvQkFBUSxFQUFSO0FBQ0EsMkJBQWUsRUFBZjtBQUNIO0FBQ0osS0FwQkQ7O0FBc0JBLG9CQUFnQixTQUFoQixDQUEwQixTQUExQixHQUFzQyxZQUFXO0FBQzdDLGlCQUFTLElBQVQsQ0FBYyxLQUFLLFNBQUwsRUFBZDs7QUFFQTtBQUNBLFlBQUksQ0FBQyxTQUFTLE9BQVQsRUFBTCxFQUF5QjtBQUNyQiwrQkFBbUIsUUFBbkIsRUFBNkIsS0FBN0I7QUFDQSxvQkFBUSxJQUFJLFdBQUosRUFBUjs7QUFFQTs7O0FBR0E7QUFDSDtBQUNELHNCQUFjLElBQWQ7QUFDSCxLQWREOztBQWdCQTs7Ozs7OztBQU9BLG9CQUFnQixTQUFoQixDQUEwQixpQkFBMUIsR0FBOEMsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlLFFBQWYsRUFBeUI7QUFDbkUsaUJBQVMsYUFBVCxDQUF1QixRQUF2Qjs7QUFFQSxZQUFJLFNBQVMsVUFBVCxHQUFzQixHQUExQixFQUErQjtBQUMzQixpQkFBSyxJQUFJLFlBQUosS0FBcUIsU0FBUyxhQUE5QixHQUE4QyxHQUFuRDtBQUNBLGlCQUFLLElBQUksWUFBSixLQUFxQixTQUFTLGFBQTlCLEdBQThDLEdBQW5EO0FBQ0g7O0FBRUQsWUFDSSxNQUFNLGFBQWEsTUFBYixDQUFvQixDQUFwQixFQUF1QixDQUF2QixFQUEwQixRQUExQixDQURWOztBQUdBLGFBQUssUUFBTCxDQUFjLEdBQWQ7QUFDSCxLQVpEOztBQWNBOzs7OztBQUtBLG9CQUFnQixTQUFoQixDQUEwQixRQUExQixHQUFxQyxVQUFTLEdBQVQsRUFBYztBQUMvQyxZQUNJLFVBQVUscUJBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsSUFBSSxLQUFyQixFQUE0QixJQUFJLE1BQWhDLENBRGQ7QUFBQSxZQUVJLFVBQVUscUJBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsSUFBSSxLQUFyQixFQUE0QixJQUFJLE1BQWhDLENBRmQ7O0FBSUEsZ0JBQVEsU0FBUixDQUFrQixJQUFJLENBQXRCLEVBQXlCLElBQUksQ0FBN0I7O0FBRUEsdUJBQWUsT0FBZixFQUF3QixPQUF4Qjs7QUFFQTtBQUNBLFlBQUksUUFBUSxPQUFSLEVBQUosRUFBdUI7QUFDbkI7QUFDSDs7QUFFRCxpQkFBUyxLQUFULENBQWUsT0FBZjtBQUNBLG9CQUFZLEtBQVosQ0FBa0IsT0FBbEI7O0FBRUEsYUFBSyxzQkFBTCxDQUE0QixPQUE1QixFQUFxQyxPQUFyQyxFQUE4QyxHQUE5Qzs7QUFFQSw2QkFBcUIsT0FBckI7QUFDSCxLQXBCRDs7QUFzQkEsYUFBUyxzQkFBVCxHQUFrQyxDQUNqQzs7QUFFRCwyQkFBdUIsU0FBdkIsR0FBbUMsT0FBTyxNQUFQLENBQWMsZ0JBQWdCLFNBQTlCLENBQW5DO0FBQ0EsMkJBQXVCLFNBQXZCLENBQWlDLFdBQWpDLEdBQStDLHNCQUEvQzs7QUFFQSwyQkFBdUIsU0FBdkIsQ0FBaUMsc0JBQWpDLEdBQTBELFVBQVMsT0FBVCxFQUFrQixPQUFsQixFQUEyQixHQUEzQixFQUFnQztBQUN0RjtBQUNBO0FBQ0EsWUFBSSxTQUFTLFVBQWIsRUFBeUI7QUFDckIsaUJBQUssU0FBTCxDQUFlLE9BQWYsRUFBd0IsT0FBeEIsRUFBaUMsSUFBSSxLQUFyQyxFQUE0QyxJQUFJLEtBQWhELEVBQXVELEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJLEtBQUosR0FBWSxDQUF4QixDQUF2RDtBQUNILFNBRkQsTUFFTyxJQUFJLFNBQVMsTUFBVCxJQUFtQixhQUFhLEtBQXBDLEVBQTJDO0FBQzlDLGlCQUFLLFNBQUwsQ0FBZSxPQUFmLEVBQXdCLE9BQXhCLEVBQWlDLElBQUksS0FBckMsRUFBNEMsSUFBSSxLQUFoRCxFQUF1RCxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSSxLQUFKLEdBQVksQ0FBeEIsQ0FBdkQ7QUFDSCxTQUZNLE1BRUE7QUFDSCxpQkFBSyxZQUFMLENBQWtCLE9BQWxCLEVBQTJCLE9BQTNCLEVBQW9DLElBQUksS0FBeEMsRUFBK0MsSUFBSSxLQUFuRCxFQUEwRCxJQUFJLEtBQTlEO0FBQ0g7QUFDSixLQVZEOztBQVlBLDJCQUF1QixTQUF2QixDQUFpQyxlQUFqQyxHQUFtRCxVQUFTLE9BQVQsRUFBa0IsS0FBbEIsQ0FBd0IsU0FBeEIsRUFBbUM7QUFDbEYsWUFDSSxjQUFjLGNBQWMsSUFEaEM7QUFBQSxZQUVJLFdBQVcsV0FBVyxJQUYxQjtBQUFBLFlBSUksTUFBTyxTQUFTLEVBQVYsR0FBZ0IsSUFKMUI7QUFBQSxZQUtJLFFBQVMsU0FBUyxDQUFWLEdBQWUsSUFMM0I7QUFBQSxZQU1JLE9BQU8sUUFBUSxJQU5uQjtBQUFBLFlBUUksUUFBUSxRQUFRLFFBQVIsS0FBcUIsQ0FSakM7QUFBQSxZQVNJLFNBQVMsUUFBUSxTQUFSLEtBQXNCLENBVG5DO0FBQUEsWUFXSSxZQUFZLFNBQVMsYUFBVCxDQUF1QixRQUFRLElBQS9CLEVBQXFDLFFBQVEsR0FBN0MsQ0FYaEI7QUFBQSxZQVlJLFlBQVksY0FBYyxhQUFkLENBQTRCLFFBQVEsSUFBcEMsRUFBMEMsUUFBUSxHQUFsRCxDQVpoQjtBQUFBLFlBY0ksYUFBYyxjQUFjLEtBQWQsR0FBc0IsS0FBdkIsR0FBZ0MsQ0FkakQ7QUFBQSxZQWVJLGFBQWMsQ0FBQyxTQUFTLEtBQVQsR0FBaUIsS0FBbEIsSUFBMkIscUJBQVcsZUFBdkMsR0FBMEQsQ0FmM0U7O0FBaUJBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFwQixFQUE0QixLQUFLLGFBQWEsVUFBbEIsRUFBOEIsYUFBYSxVQUF2RSxFQUFtRjtBQUMvRSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEtBQUssV0FBTCxFQUFrQixhQUFhLHFCQUFXLGVBQXJFLEVBQXNGO0FBQ2xGLG9CQUNJLGVBQWdCLFlBQVksU0FBWixJQUF5QixHQUExQixHQUFpQyxDQURwRDs7QUFHQSxvQkFBSSxlQUFlLENBQW5CLEVBQXNCO0FBQ2xCLHdCQUNJLFlBQVksU0FBUyxZQUFZLHFCQUFXLGlCQUFoQyxDQURoQjtBQUFBLHdCQUdJLGdCQUFpQixlQUFlLGFBQWEsTUFBTSxZQUFuQixJQUFtQyxHQUFuRCxHQUEwRCxDQUg5RTtBQUFBLHdCQUlJLFlBQWEsTUFBTSxZQUFOLEdBQXFCLGFBQXRCLEdBQXVDLENBSnZEO0FBQUEsd0JBS0ksV0FBVyxNQUFNLFNBTHJCOztBQU9BLDZCQUFTLElBQVQsQ0FBYyxTQUFkLElBQTRCLENBQUMsTUFBTSxTQUFOLEdBQWtCLFNBQVMsU0FBVCxJQUFzQixRQUF6QyxJQUFxRCxHQUF0RCxHQUE2RCxJQUF4RjtBQUNBLDZCQUFTLElBQVQsQ0FBYyxZQUFZLENBQTFCLElBQWdDLENBQUMsUUFBUSxTQUFSLEdBQW9CLFNBQVMsWUFBWSxDQUFyQixJQUEwQixRQUEvQyxJQUEyRCxHQUE1RCxHQUFtRSxJQUFsRztBQUNBLDZCQUFTLElBQVQsQ0FBYyxZQUFZLENBQTFCLElBQWdDLENBQUMsT0FBTyxTQUFQLEdBQW1CLFNBQVMsWUFBWSxDQUFyQixJQUEwQixRQUE5QyxJQUEwRCxHQUEzRCxHQUFrRSxJQUFqRztBQUNBLDZCQUFTLElBQVQsQ0FBYyxZQUFZLENBQTFCLElBQStCLGFBQS9CO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0F0Q0Q7O0FBd0NBOzs7Ozs7OztBQVFBLDJCQUF1QixTQUF2QixDQUFpQyxZQUFqQyxHQUFnRCxVQUFTLE9BQVQsRUFBa0IsT0FBbEIsRUFBMkIsS0FBM0IsRUFBa0MsVUFBbEMsRUFBOEMsS0FBOUMsRUFBcUQ7QUFDakcsWUFDSSxjQUFjLGNBQWMsSUFEaEM7QUFBQSxZQUdJLFlBQVksUUFBUSxJQUFSLEdBQWUsUUFBUSxHQUFSLEdBQWMsVUFIN0M7QUFBQSxZQUlJLFlBQVksY0FBYyxhQUFkLENBQTRCLFFBQVEsSUFBcEMsRUFBMEMsUUFBUSxHQUFsRCxDQUpoQjtBQUFBLFlBTUksV0FBVyxRQUFRLFFBQVIsRUFOZjtBQUFBLFlBUUksYUFBYSxhQUFhLFFBUjlCO0FBQUEsWUFTSSxhQUFhLEtBQUssS0FBTCxHQUFhLFFBVDlCOztBQVdBLGdCQUFRLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFkLENBQVI7O0FBRUEsYUFBSyxJQUFJLElBQUksUUFBUSxHQUFyQixFQUEwQixJQUFJLFFBQVEsTUFBdEMsRUFBOEMsS0FBSyxhQUFhLFVBQWxCLEVBQThCLGFBQWEsVUFBekYsRUFBcUc7QUFDakcsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxRQUFwQixFQUE4QixLQUFLLFdBQUwsRUFBa0IsV0FBaEQsRUFBNkQ7QUFDekQsNEJBQVksU0FBWixJQUF5QixLQUFLLEdBQUwsQ0FBUyxNQUFNLFNBQU4sSUFBbUIsS0FBNUIsRUFBbUMsWUFBWSxTQUFaLENBQW5DLENBQXpCO0FBQ0g7QUFDSjtBQUNKLEtBbkJEOztBQXFCQSwyQkFBdUIsU0FBdkIsQ0FBaUMsU0FBakMsR0FBNkMsVUFBUyxPQUFULEVBQWtCLE9BQWxCLEVBQTJCLEtBQTNCLEVBQWtDLFVBQWxDLEVBQThDLEtBQTlDLEVBQXFEO0FBQzlGLFlBQ0ksY0FBYyxjQUFjLElBRGhDO0FBQUEsWUFHSSxZQUFZLFFBQVEsSUFBUixHQUFlLFFBQVEsR0FBUixHQUFjLFVBSDdDO0FBQUEsWUFJSSxZQUFZLGNBQWMsYUFBZCxDQUE0QixRQUFRLElBQXBDLEVBQTBDLFFBQVEsR0FBbEQsQ0FKaEI7QUFBQSxZQU1JLFdBQVcsUUFBUSxRQUFSLEVBTmY7QUFBQSxZQVFJLGFBQWEsYUFBYSxRQVI5QjtBQUFBLFlBU0ksYUFBYSxLQUFLLEtBQUwsR0FBYSxRQVQ5Qjs7QUFXQSxhQUFLLElBQUksSUFBSSxRQUFRLEdBQXJCLEVBQTBCLElBQUksUUFBUSxNQUF0QyxFQUE4QyxLQUFLLGFBQWEsVUFBbEIsRUFBOEIsYUFBYSxVQUF6RixFQUFxRztBQUNqRyxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQXBCLEVBQThCLEtBQUssV0FBTCxFQUFrQixXQUFoRCxFQUE2RDtBQUN6RCxvQkFDSSxhQUFhLE1BQU0sU0FBTixJQUFtQixLQURwQzs7QUFHQSxvQkFBSSxjQUFjLENBQWxCLEVBQXFCO0FBQ2pCLHdCQUNJLGVBQWUsS0FBSyxHQUFMLENBQVMsTUFBTSxHQUFmLEVBQW9CLFlBQVksU0FBWixJQUF5QixDQUFDLE1BQU0sWUFBWSxTQUFaLElBQXlCLEdBQWhDLElBQXVDLFVBQXZDLEdBQW9ELEdBQWpHLENBRG5COztBQUdBLGdDQUFZLFNBQVosSUFBeUIsWUFBekI7QUFDSDtBQUNKO0FBQ0o7QUFDSixLQXpCRDs7QUEyQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBOEJBLGFBQVMsaUJBQVQsR0FBNkIsQ0FDNUI7O0FBRUQsc0JBQWtCLFNBQWxCLEdBQThCLE9BQU8sTUFBUCxDQUFjLHVCQUF1QixTQUFyQyxDQUE5QjtBQUNBLHNCQUFrQixTQUFsQixDQUE0QixXQUE1QixHQUEwQyxpQkFBMUM7O0FBRUEsc0JBQWtCLFNBQWxCLENBQTRCLGVBQTVCLEdBQThDLFVBQVMsT0FBVCxFQUFrQixLQUFsQixFQUF5QjtBQUNuRSxZQUNJLGNBQWMsY0FBYyxJQURoQztBQUFBLFlBRUksV0FBVyxXQUFXLElBRjFCOztBQUlBLGFBQUssSUFBSSxJQUFJLFFBQVEsR0FBckIsRUFBMEIsSUFBSSxRQUFRLE1BQXRDLEVBQThDLEdBQTlDLEVBQW1EO0FBQy9DLGdCQUNJLFlBQVksU0FBUyxhQUFULENBQXVCLFFBQVEsSUFBL0IsRUFBcUMsQ0FBckMsSUFBMEMscUJBQVcsaUJBRHJFO0FBQUEsZ0JBRUksWUFBWSxjQUFjLGFBQWQsQ0FBNEIsUUFBUSxJQUFwQyxFQUEwQyxDQUExQyxDQUZoQjs7QUFJQSxpQkFBSyxJQUFJLElBQUksUUFBUSxJQUFyQixFQUEyQixJQUFJLFFBQVEsS0FBdkMsRUFBOEMsS0FBSyxhQUFhLHFCQUFXLGVBQTNFLEVBQTRGO0FBQ3hGLG9CQUNJLGVBQWdCLFlBQVksV0FBWixJQUEyQixHQUE1QixHQUFtQyxDQUR0RDs7QUFHQSxvQkFBSSxlQUFlLENBQW5CLEVBQXNCO0FBQ2xCLHdCQUNJLFlBQVksU0FBUyxTQUFULENBRGhCO0FBQUEsd0JBRUksWUFBWSxhQUFhLE1BQU0sWUFBbkIsSUFBbUMsR0FGbkQ7O0FBSUEsNkJBQVMsSUFBVCxDQUFjLFNBQWQsSUFBMkIsU0FBM0I7QUFDSDtBQUNKO0FBQ0o7QUFDSixLQXZCRDs7QUF5QkEsYUFBUyxnQkFBVCxHQUE0QixDQUMzQjs7QUFFRCxxQkFBaUIsU0FBakIsR0FBNkIsT0FBTyxNQUFQLENBQWMsdUJBQXVCLFNBQXJDLENBQTdCO0FBQ0EscUJBQWlCLFNBQWpCLENBQTJCLFdBQTNCLEdBQXlDLGdCQUF6Qzs7QUFFQSxxQkFBaUIsU0FBakIsQ0FBMkIsZUFBM0IsR0FBNkMsVUFBUyxPQUFULEVBQWtCLEtBQWxCLEVBQXlCO0FBQ2xFLFlBQ0ksY0FBYyxjQUFjLElBRGhDO0FBQUEsWUFFSSxXQUFXLFdBQVcsSUFGMUI7O0FBSUEsYUFBSyxJQUFJLElBQUksUUFBUSxHQUFyQixFQUEwQixJQUFJLFFBQVEsTUFBdEMsRUFBOEMsR0FBOUMsRUFBbUQ7QUFDL0MsZ0JBQ0ksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsUUFBUSxJQUEvQixFQUFxQyxDQUFyQyxDQURoQjtBQUFBLGdCQUVJLFlBQVksY0FBYyxhQUFkLENBQTRCLFFBQVEsSUFBcEMsRUFBMEMsQ0FBMUMsQ0FGaEI7O0FBSUEsaUJBQUssSUFBSSxJQUFJLFFBQVEsSUFBckIsRUFBMkIsSUFBSSxRQUFRLEtBQXZDLEVBQThDLEtBQUssV0FBTCxFQUFrQixhQUFhLHFCQUFXLGVBQXhGLEVBQXlHO0FBQ3JHLG9CQUNJLGVBQWdCLFlBQVksU0FBWixJQUF5QixHQUExQixHQUFpQyxDQURwRDs7QUFHQSxvQkFBSSxlQUFlLENBQWYsSUFBb0IsU0FBUyxZQUFZLHFCQUFXLGlCQUFoQyxLQUFzRCxDQUE5RSxFQUFpRjtBQUM3RSxvQ0FBZ0IsR0FBaEI7O0FBRUEseUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixHQUF2QixFQUE0QjtBQUN4Qiw0QkFBSSxVQUFXLFNBQVMsWUFBWSxDQUFyQixJQUEwQixZQUExQixHQUF5QyxHQUExQyxHQUFpRCxDQUEvRDs7QUFFQSw0QkFBSSxVQUFVLEdBQWQsRUFBbUI7QUFDZixzQ0FBVSxHQUFWO0FBQ0g7O0FBRUQsaUNBQVMsSUFBVCxDQUFjLFlBQVksQ0FBMUIsSUFBK0IsT0FBL0I7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKLEtBN0JEOztBQStCQSxhQUFTLGVBQVQsR0FBMkIsQ0FDMUI7O0FBRUQsb0JBQWdCLFNBQWhCLEdBQTRCLE9BQU8sTUFBUCxDQUFjLHVCQUF1QixTQUFyQyxDQUE1QjtBQUNBLG9CQUFnQixTQUFoQixDQUEwQixXQUExQixHQUF3QyxlQUF4Qzs7QUFFQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsZUFBMUIsR0FBNEMsVUFBUyxPQUFULEVBQWtCLEtBQWxCLEVBQXlCO0FBQ2pFLFlBQ0ksY0FBYyxjQUFjLElBRGhDO0FBQUEsWUFFSSxXQUFXLFdBQVcsSUFGMUI7O0FBSUEsYUFBSyxJQUFJLElBQUksUUFBUSxHQUFyQixFQUEwQixJQUFJLFFBQVEsTUFBdEMsRUFBOEMsR0FBOUMsRUFBbUQ7QUFDL0MsZ0JBQ0ksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsUUFBUSxJQUEvQixFQUFxQyxDQUFyQyxDQURoQjtBQUFBLGdCQUVJLFlBQVksY0FBYyxhQUFkLENBQTRCLFFBQVEsSUFBcEMsRUFBMEMsQ0FBMUMsQ0FGaEI7O0FBSUEsaUJBQUssSUFBSSxJQUFJLFFBQVEsSUFBckIsRUFBMkIsSUFBSSxRQUFRLEtBQXZDLEVBQThDLEtBQUssV0FBTCxFQUFrQixhQUFhLHFCQUFXLGVBQXhGLEVBQXlHO0FBQ3JHLG9CQUNJLGVBQWdCLFlBQVksU0FBWixJQUF5QixHQUExQixHQUFpQyxDQURwRDs7QUFHQSxvQkFBSSxlQUFlLENBQWYsSUFBb0IsU0FBUyxZQUFZLHFCQUFXLGlCQUFoQyxLQUFzRCxDQUE5RSxFQUFpRjtBQUM3RSx5QkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLDRCQUFJLFVBQVUsU0FBUyxZQUFZLENBQXJCLENBQWQ7O0FBRUEsa0NBQVcsVUFBVSxDQUFDLGdCQUFnQixPQUFqQixJQUE0QixZQUE1QixHQUEyQyxHQUF0RCxHQUE2RCxDQUF2RTs7QUFFQSw0QkFBSSxVQUFVLENBQWQsRUFBaUI7QUFDYixzQ0FBVSxDQUFWO0FBQ0g7O0FBRUQsaUNBQVMsSUFBVCxDQUFjLFlBQVksQ0FBMUIsSUFBK0IsT0FBL0I7QUFDSDtBQUNKO0FBQ0o7QUFDSjtBQUNKLEtBN0JEOztBQStCQSxhQUFTLGVBQVQsR0FBMkIsQ0FDMUI7O0FBRUQsb0JBQWdCLFNBQWhCLEdBQTRCLE9BQU8sTUFBUCxDQUFjLHVCQUF1QixTQUFyQyxDQUE1QjtBQUNBLG9CQUFnQixTQUFoQixDQUEwQixXQUExQixHQUF3QyxlQUF4Qzs7QUFFQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsZUFBMUIsR0FBNEMsVUFBUyxPQUFULEVBQWtCLEtBQWxCLEVBQXlCO0FBQ2pFLFlBQ0ksY0FBYyxjQUFjLElBRGhDO0FBQUEsWUFFSSxXQUFXLFdBQVcsSUFGMUI7QUFBQSxZQUlJLGFBQWEsV0FBVyxLQUFYLEdBQW1CLHFCQUFXLGVBSi9DO0FBQUEsWUFNSSxDQU5KO0FBQUEsWUFNTyxDQU5QO0FBQUEsWUFNVSxDQU5WO0FBQUEsWUFNYSxDQU5iOztBQVFBLGlCQUFTLFNBQVQsQ0FBbUIsWUFBbkIsRUFBaUM7QUFDN0IsaUJBQUssU0FBUyxlQUFlLHFCQUFXLGVBQW5DLENBQUw7QUFDQSxpQkFBSyxTQUFTLGVBQWUscUJBQVcsaUJBQW5DLENBQUw7QUFDQSxpQkFBSyxTQUFTLGVBQWUscUJBQVcsZ0JBQW5DLENBQUw7QUFDQSxpQkFBSyxTQUFTLGVBQWUscUJBQVcsaUJBQW5DLENBQUw7QUFDSDs7QUFFRCxhQUFLLElBQUksSUFBSSxRQUFRLEdBQXJCLEVBQTBCLElBQUksUUFBUSxNQUF0QyxFQUE4QyxHQUE5QyxFQUFtRDtBQUMvQyxnQkFDSSxZQUFZLFdBQVcsYUFBWCxDQUF5QixRQUFRLElBQWpDLEVBQXVDLENBQXZDLENBRGhCO0FBQUEsZ0JBRUksWUFBWSxjQUFjLGFBQWQsQ0FBNEIsUUFBUSxJQUFwQyxFQUEwQyxDQUExQyxDQUZoQjs7QUFJQSxpQkFBSyxJQUFJLElBQUksUUFBUSxJQUFyQixFQUEyQixJQUFJLFFBQVEsS0FBdkMsRUFBOEMsS0FBSyxhQUFhLHFCQUFXLGVBQTdCLEVBQThDLFdBQTVGLEVBQXlHO0FBQ3JHLG9CQUNJLGVBQWdCLFlBQVksU0FBWixJQUF5QixHQUExQixHQUFpQyxDQURwRDs7QUFHQSxvQkFBSSxlQUFlLENBQW5CLEVBQXNCO0FBQ2xCLHdCQUNJLE9BQVEsV0FBVyxDQUFDLFdBQVcsUUFBWixJQUF3QixZQUF4QixHQUF1QyxHQUFuRCxHQUEwRCxDQURyRTtBQUFBLHdCQUdJLE1BQU0sT0FBTyxDQUhqQjs7QUFLQSx3QkFBSSxPQUFPLFNBQVMsWUFBWSxxQkFBVyxlQUFoQyxDQUFYO0FBQ0Esd0JBQUksT0FBTyxTQUFTLFlBQVkscUJBQVcsaUJBQWhDLENBQVg7QUFDQSx3QkFBSSxPQUFPLFNBQVMsWUFBWSxxQkFBVyxnQkFBaEMsQ0FBWDtBQUNBLHdCQUFJLE9BQU8sU0FBUyxZQUFZLHFCQUFXLGlCQUFoQyxDQUFYOztBQUVBLDhCQUFVLElBQUksQ0FBSixHQUFRLFlBQVksVUFBcEIsR0FBaUMsU0FBM0M7QUFDQSw4QkFBVSxJQUFJLFdBQVcsTUFBWCxHQUFvQixDQUF4QixHQUE0QixZQUFZLFVBQXhDLEdBQXFELFNBQS9EO0FBQ0EsOEJBQVUsSUFBSSxDQUFKLEdBQVEsWUFBWSxxQkFBVyxlQUEvQixHQUFpRCxTQUEzRDtBQUNBLDhCQUFVLElBQUksV0FBVyxLQUFYLEdBQW1CLENBQXZCLEdBQTJCLFlBQVkscUJBQVcsZUFBbEQsR0FBb0UsU0FBOUU7O0FBRUEseUJBQUssR0FBTDtBQUNBLHlCQUFLLEdBQUw7QUFDQSx5QkFBSyxHQUFMO0FBQ0EseUJBQUssR0FBTDs7QUFFQSw2QkFBUyxJQUFULENBQWMsWUFBWSxxQkFBVyxlQUFyQyxJQUF3RCxJQUFJLENBQTVEO0FBQ0EsNkJBQVMsSUFBVCxDQUFjLFlBQVkscUJBQVcsaUJBQXJDLElBQTBELElBQUksQ0FBOUQ7QUFDQSw2QkFBUyxJQUFULENBQWMsWUFBWSxxQkFBVyxnQkFBckMsSUFBeUQsSUFBSSxDQUE3RDtBQUNBLDZCQUFTLElBQVQsQ0FBYyxZQUFZLHFCQUFXLGlCQUFyQyxJQUEwRCxJQUFJLENBQTlEO0FBQ0g7QUFDSjtBQUNKO0FBQ0osS0FyREQ7O0FBdURBO0FBQ0EsYUFBUyxzQkFBVCxHQUFrQyxDQUNqQzs7QUFFRCwyQkFBdUIsU0FBdkIsR0FBbUMsT0FBTyxNQUFQLENBQWMsdUJBQXVCLFNBQXJDLENBQW5DO0FBQ0EsMkJBQXVCLFNBQXZCLENBQWlDLFdBQWpDLEdBQStDLHNCQUEvQzs7QUFFQSwyQkFBdUIsU0FBdkIsQ0FBaUMsZUFBakMsR0FBbUQsVUFBUyxPQUFULEVBQWtCLEtBQWxCLEVBQXlCO0FBQ3hFLFlBQ0ksY0FBYyxjQUFjLElBRGhDO0FBQUEsWUFFSSxXQUFXLFdBQVcsSUFGMUI7QUFBQSxZQUlJLFlBQVksY0FBYyxhQUFkLENBQTRCLFFBQVEsSUFBcEMsRUFBMEMsUUFBUSxHQUFsRCxDQUpoQjtBQUFBLFlBS0ksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsUUFBUSxJQUEvQixFQUFxQyxRQUFRLEdBQTdDLENBTGhCO0FBQUEsWUFPSSxRQUFRLFFBQVEsUUFBUixLQUFxQixDQVBqQztBQUFBLFlBUUksU0FBUyxRQUFRLFNBQVIsS0FBc0IsQ0FSbkM7QUFBQSxZQVVJLGFBQWMsY0FBYyxLQUFkLEdBQXNCLEtBQXZCLEdBQWdDLENBVmpEO0FBQUEsWUFXSSxhQUFjLENBQUMsU0FBUyxLQUFULEdBQWlCLEtBQWxCLElBQTJCLHFCQUFXLGVBQXZDLEdBQTBELENBWDNFOztBQWFBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFwQixFQUE0QixLQUFLLGFBQWEsVUFBbEIsRUFBOEIsYUFBYSxVQUF2RSxFQUFtRjtBQUMvRSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEtBQUssV0FBTCxFQUFrQixhQUFhLHFCQUFXLGVBQXJFLEVBQXNGO0FBQ2xGLG9CQUNJLFNBQVMsWUFBWSxTQUFaLENBRGI7QUFBQSxvQkFFSSxTQUFTLFdBQVcsRUFGeEI7O0FBSUEsb0JBQUksVUFBVSxDQUFkLEVBQWlCO0FBQ2I7QUFDSDs7QUFFRDtBQUNBO0FBQ0kseUJBQVMsU0FBUyxZQUFZLHFCQUFXLGlCQUFoQyxDQUZiLENBRWdFO0FBRmhFO0FBQUEsb0JBR0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBSDNEOztBQUtBLG9CQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUNkLHdCQUNJLFlBQWEsU0FBUyxHQUFULEdBQWUsUUFBaEIsR0FBNEIsQ0FENUM7QUFBQSx3QkFFSSxXQUFXLE1BQU0sU0FGckI7O0FBSUEsNkJBQVMsSUFBVCxDQUFjLFNBQWQsSUFBNEIsQ0FBQyxDQUFFLFVBQVUsRUFBWCxHQUFpQixJQUFsQixJQUEwQixTQUExQixHQUFzQyxTQUFTLFNBQVQsSUFBc0IsUUFBN0QsSUFBeUUsR0FBMUUsR0FBaUYsQ0FBNUc7QUFDQSw2QkFBUyxJQUFULENBQWMsWUFBWSxDQUExQixJQUFnQyxDQUFDLENBQUUsVUFBVSxDQUFYLEdBQWdCLElBQWpCLElBQXlCLFNBQXpCLEdBQXFDLFNBQVMsWUFBWSxDQUFyQixJQUEwQixRQUFoRSxJQUE0RSxHQUE3RSxHQUFvRixDQUFuSDtBQUNBLDZCQUFTLElBQVQsQ0FBYyxZQUFZLENBQTFCLElBQWdDLENBQUMsQ0FBQyxTQUFTLElBQVYsSUFBa0IsU0FBbEIsR0FBOEIsU0FBUyxZQUFZLENBQXJCLElBQTBCLFFBQXpELElBQXFFLEdBQXRFLEdBQTZFLENBQTVHO0FBQ0EsNkJBQVMsSUFBVCxDQUFjLFlBQVksQ0FBMUIsSUFBK0IsUUFBL0I7QUFDSDtBQUNKO0FBQ0o7QUFDSixLQXpDRDs7QUEyQ0EsYUFBUyxxQkFBVCxHQUFpQztBQUM3QixZQUNJLFdBQVcsRUFEZjtBQUFBLFlBRUksb0JBQW9CLEVBRnhCOztBQUlBLFlBQ0ksa0JBQWtCLEVBRHRCOztBQUdBOzs7Ozs7O0FBT0EsaUJBQVMsV0FBVCxDQUFxQixDQUFyQixFQUF3QixDQUF4QixFQUEyQixFQUEzQixFQUErQixFQUEvQixFQUFtQztBQUMvQixnQkFDSSxVQUFVLEVBRGQ7QUFBQSxnQkFHSSxnQkFBZ0Isa0JBQWtCLE1BQWxCLEdBQTJCLEtBQUssY0FBTCxFQUgvQzs7QUFLQSxnQkFBSSxJQUFJLENBQVI7QUFDQSxnQkFBSSxJQUFJLENBQVI7O0FBRUEsb0JBQVEsSUFBUixDQUFhLHVCQUFhLGFBQWIsQ0FBMkIsY0FBYyxRQUFkLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLENBQTNCLENBQWI7O0FBRUEsaUJBQUssSUFBSSxJQUFJLElBQWIsRUFBbUIsSUFBSSxLQUF2QixFQUE4QixLQUFLLEdBQW5DLEVBQXdDO0FBQ3BDLHdCQUFRLElBQVIsQ0FBYSx1QkFBYSxhQUFiLENBQTJCLGNBQWMsUUFBZCxDQUF1QixDQUFDLEVBQUUsSUFBSSxJQUFJLEVBQVYsQ0FBeEIsRUFBdUMsQ0FBdkMsQ0FBM0IsQ0FBYjtBQUNBLHdCQUFRLElBQVIsQ0FBYSx1QkFBYSxhQUFiLENBQTJCLGNBQWMsUUFBZCxDQUF1QixDQUFDLEVBQUUsSUFBSSxJQUFJLEVBQVYsQ0FBeEIsRUFBdUMsQ0FBdkMsQ0FBM0IsQ0FBYjtBQUNBLHdCQUFRLElBQVIsQ0FBYSx1QkFBYSxhQUFiLENBQTJCLGNBQWMsUUFBZCxDQUF1QixDQUF2QixFQUEwQixDQUFDLEVBQUUsSUFBSSxJQUFJLEVBQVYsQ0FBM0IsQ0FBM0IsQ0FBYjtBQUNBLHdCQUFRLElBQVIsQ0FBYSx1QkFBYSxhQUFiLENBQTJCLGNBQWMsUUFBZCxDQUF1QixDQUF2QixFQUEwQixDQUFDLEVBQUUsSUFBSSxJQUFJLEVBQVYsQ0FBM0IsQ0FBM0IsQ0FBYjs7QUFFQSx3QkFBUSxJQUFSLENBQWEsdUJBQWEsYUFBYixDQUEyQixjQUFjLFFBQWQsQ0FBdUIsQ0FBQyxFQUFFLElBQUksSUFBSSxHQUFKLEdBQVUsRUFBaEIsQ0FBeEIsRUFBNkMsQ0FBQyxFQUFFLElBQUksSUFBSSxHQUFKLEdBQVUsRUFBaEIsQ0FBOUMsQ0FBM0IsQ0FBYjtBQUNBLHdCQUFRLElBQVIsQ0FBYSx1QkFBYSxhQUFiLENBQTJCLGNBQWMsUUFBZCxDQUF1QixDQUFDLEVBQUUsSUFBSSxJQUFJLEdBQUosR0FBVSxFQUFoQixDQUF4QixFQUE2QyxDQUFDLEVBQUUsSUFBSSxJQUFJLEdBQUosR0FBVSxFQUFoQixDQUE5QyxDQUEzQixDQUFiO0FBQ0Esd0JBQVEsSUFBUixDQUFhLHVCQUFhLGFBQWIsQ0FBMkIsY0FBYyxRQUFkLENBQXVCLENBQUMsRUFBRSxJQUFJLElBQUksR0FBSixHQUFVLEVBQWhCLENBQXhCLEVBQTZDLENBQUMsRUFBRSxJQUFJLElBQUksR0FBSixHQUFVLEVBQWhCLENBQTlDLENBQTNCLENBQWI7QUFDQSx3QkFBUSxJQUFSLENBQWEsdUJBQWEsYUFBYixDQUEyQixjQUFjLFFBQWQsQ0FBdUIsQ0FBQyxFQUFFLElBQUksSUFBSSxHQUFKLEdBQVUsRUFBaEIsQ0FBeEIsRUFBNkMsQ0FBQyxFQUFFLElBQUksSUFBSSxHQUFKLEdBQVUsRUFBaEIsQ0FBOUMsQ0FBM0IsQ0FBYjtBQUNIOztBQUVELGdCQUNJLFVBQVUsMkJBQWlCLENBQWpCLEVBQW9CLENBQXBCLEVBQXVCLENBQXZCLENBRGQ7O0FBR0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxRQUFRLE1BQTVCLEVBQW9DLEdBQXBDLEVBQXlDO0FBQ3JDLG9CQUNJLFNBQVMsUUFBUSxDQUFSLENBRGI7O0FBR0Esd0JBQVEsQ0FBUixJQUFhLE9BQU8sQ0FBcEI7QUFDQSx3QkFBUSxDQUFSLElBQWEsT0FBTyxDQUFwQjtBQUNBLHdCQUFRLENBQVIsSUFBYSxPQUFPLENBQXBCO0FBQ0g7O0FBRUQsb0JBQVEsQ0FBUixJQUFhLFFBQVEsTUFBckI7QUFDQSxvQkFBUSxDQUFSLElBQWEsUUFBUSxNQUFyQjtBQUNBLG9CQUFRLENBQVIsSUFBYSxRQUFRLE1BQXJCOztBQUVBLG1CQUFPLE9BQVA7QUFDSDs7QUFFRDtBQUNBLGlCQUFTLFdBQVQsQ0FBcUIsT0FBckIsRUFBOEIsT0FBOUIsRUFBdUMsS0FBdkMsRUFBOEMsVUFBOUMsRUFBMEQsS0FBMUQsRUFBaUUsTUFBakUsRUFBeUU7QUFDckUsZ0JBQ0ksY0FBYyxjQUFjLElBRGhDO0FBQUEsZ0JBR0ksS0FBSyxRQUFRLEdBSGpCOztBQUtBLGlCQUFLLElBQUksSUFBSSxRQUFRLEdBQXJCLEVBQTBCLElBQUksUUFBUSxNQUF0QyxFQUE4QyxLQUFLLElBQW5ELEVBQXlEO0FBQ3JELG9CQUNJLFlBQVksUUFBUSxJQUFSLEdBQWUsS0FBSyxVQURwQztBQUFBLG9CQUVJLFlBQVksY0FBYyxhQUFkLENBQTRCLFFBQVEsSUFBcEMsRUFBMEMsQ0FBMUMsQ0FGaEI7O0FBSUEscUJBQUssSUFBSSxJQUFJLFFBQVEsSUFBckIsRUFBMkIsSUFBSSxRQUFRLEtBQXZDLEVBQThDLEtBQUssV0FBTCxFQUFrQixXQUFoRSxFQUE2RTtBQUN6RSx3QkFDSSxTQUFVLENBQUMsTUFBTSxTQUFOLElBQW1CLElBQXBCLElBQTRCLEtBQTVCLEdBQW9DLEdBQXJDLEdBQTRDLENBRHpEOztBQUdBLHdCQUFJLFVBQVUsQ0FBZCxFQUFpQjtBQUNiO0FBQ0g7O0FBRUQsd0JBQ0ksU0FBUyxZQUFZLFNBQVosQ0FEYjtBQUFBLHdCQUVJLFNBQVMsV0FBVyxFQUZ4QjtBQUFBLHdCQUlJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUozRDs7QUFNQSx3QkFBSSxXQUFXLENBQWYsRUFBa0I7QUFDZCw0QkFDSSxZQUFhLFNBQVMsR0FBVCxHQUFlLFFBQWhCLEdBQTRCLENBRDVDO0FBQUEsNEJBRUksV0FBVyxNQUFNLFNBRnJCOztBQUlBO0FBQ0E7QUFDQTs7QUFFQSw0QkFDSSxXQUFXLFlBQVksRUFBWixHQUNKLENBQUMsV0FBVyxFQUFYLEdBQWdCLElBQWpCLElBQTBCLENBQUMsQ0FBQyxXQUFXLEVBQVgsR0FBZ0IsSUFBakIsSUFBeUIsUUFBekIsR0FBb0MsQ0FBQyxXQUFXLEVBQVgsR0FBZ0IsSUFBakIsSUFBeUIsUUFBOUQsSUFBMEUsR0FBckcsSUFBOEcsRUFEekcsR0FFSixDQUFDLFdBQVcsQ0FBWCxHQUFlLElBQWhCLElBQXlCLENBQUMsQ0FBQyxXQUFXLENBQVgsR0FBZSxJQUFoQixJQUF3QixRQUF4QixHQUFtQyxDQUFDLFdBQVcsQ0FBWCxHQUFlLElBQWhCLElBQXdCLFFBQTVELElBQXdFLEdBQWxHLElBQTJHLENBRnRHLEdBR0osQ0FBQyxTQUFTLElBQVYsSUFBbUIsQ0FBQyxDQUFDLFNBQVMsSUFBVixJQUFrQixRQUFsQixHQUE2QixDQUFDLFNBQVMsSUFBVixJQUFrQixRQUFoRCxJQUE0RCxHQUoxRjs7QUFNQSxvQ0FBWSxTQUFaLElBQXlCLFFBQXpCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQsYUFBSyxXQUFMLEdBQW1CLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxRQUFmLEVBQXlCO0FBQ3hDLDhCQUFrQixJQUFsQjs7QUFFQSxtQ0FBdUIsU0FBdkIsQ0FBaUMsV0FBakMsQ0FBNkMsSUFBN0MsQ0FBa0QsSUFBbEQsRUFBd0QsQ0FBeEQsRUFBMkQsQ0FBM0QsRUFBOEQsUUFBOUQ7QUFDSCxTQUpEOztBQU1BLGFBQUssc0JBQUwsR0FBOEIsVUFBUyxPQUFULEVBQWtCLE9BQWxCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzFELGdCQUFJLG1CQUFtQixJQUF2QixFQUE2QjtBQUN6QjtBQUNBLG9CQUNJLGFBQWEsWUFDVCxDQUFDLEVBQUUsQ0FBQyxRQUFRLElBQVIsR0FBZSxRQUFRLEtBQXhCLElBQWlDLENBQW5DLENBRFEsRUFFVCxDQUFDLEVBQUUsQ0FBQyxRQUFRLEdBQVIsR0FBYyxRQUFRLE1BQXZCLElBQWlDLENBQW5DLENBRlEsRUFHVCxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxHQUFMLENBQVMsaUJBQVQsRUFBNEIsUUFBUSxRQUFSLEtBQXFCLENBQXJCLEdBQXlCLENBQXJELENBQVosQ0FIUyxFQUlULEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLEdBQUwsQ0FBUyxpQkFBVCxFQUE0QixRQUFRLFNBQVIsS0FBc0IsQ0FBdEIsR0FBMEIsQ0FBdEQsQ0FBWixDQUpTLENBRGpCOztBQVFBLGtDQUFrQixFQUFsQjs7QUFFQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQXBCLEVBQThCLEdBQTlCLEVBQW1DO0FBQy9CLG9DQUFnQixJQUFoQixDQUFxQixVQUFyQjtBQUNIO0FBQ0o7O0FBRUQsZ0JBQ0ksVUFBVSwyQkFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsRUFBdUIsQ0FBdkIsQ0FEZDs7QUFHQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLGdCQUFnQixNQUFwQyxFQUE0QyxHQUE1QyxFQUFpRDtBQUM3QyxvQkFDSSxTQUFTLGdCQUFnQixDQUFoQixDQURiOztBQUdBLHdCQUFRLENBQVIsSUFBYSxPQUFPLENBQXBCO0FBQ0Esd0JBQVEsQ0FBUixJQUFhLE9BQU8sQ0FBcEI7QUFDQSx3QkFBUSxDQUFSLElBQWEsT0FBTyxDQUFwQjtBQUNIO0FBQ0Qsb0JBQVEsQ0FBUixJQUFhLGdCQUFnQixNQUE3QjtBQUNBLG9CQUFRLENBQVIsSUFBYSxnQkFBZ0IsTUFBN0I7QUFDQSxvQkFBUSxDQUFSLElBQWEsZ0JBQWdCLE1BQTdCOztBQUVBO0FBQ0Esb0JBQVEsT0FBUixDQUFnQix1QkFBYSxhQUFiLENBQTJCLFFBQTNCLENBQWhCLEVBQXNELFNBQVMsS0FBVCxHQUFpQixTQUFTLEtBQWhGOztBQUVBLGdCQUNJLFdBQVcsUUFBUSxLQUFSLEVBRGY7O0FBR0E7QUFDQSxvQkFBUSxPQUFSLENBQ0ksWUFDSSxDQUFDLFFBQVEsSUFBUixHQUFlLFFBQVEsS0FBeEIsSUFBaUMsQ0FEckMsRUFFSSxDQUFDLFFBQVEsR0FBUixHQUFjLFFBQVEsTUFBdkIsSUFBaUMsQ0FGckMsRUFHSSxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxHQUFMLENBQVMsaUJBQVQsRUFBNEIsUUFBUSxRQUFSLEtBQXFCLENBQXJCLEdBQXlCLENBQXJELENBQVosQ0FISixFQUlJLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLEdBQUwsQ0FBUyxpQkFBVCxFQUE0QixRQUFRLFNBQVIsS0FBc0IsQ0FBdEIsR0FBMEIsQ0FBdEQsQ0FBWixDQUpKLENBREosRUFPSSxTQUFTLEtBUGI7O0FBVUEsNEJBQWdCLElBQWhCLENBQXFCLE9BQXJCO0FBQ0EsNEJBQWdCLEtBQWhCOztBQUVBLHdCQUFZLE9BQVosRUFBcUIsT0FBckIsRUFBOEIsSUFBSSxLQUFsQyxFQUF5QyxJQUFJLEtBQTdDLEVBQW9ELEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJLEtBQUosR0FBWSxDQUF4QixDQUFwRCxFQUFnRixRQUFoRjtBQUNBLCtCQUFtQixDQUFuQixFQUFzQixLQUF0Qjs7QUFFQSxnQkFBSSxlQUFKLEVBQXFCO0FBQ2pCLHFCQUFLLFlBQUw7QUFDSDtBQUNKLFNBM0REO0FBNERIOztBQUVELDBCQUFzQixTQUF0QixHQUFrQyxPQUFPLE1BQVAsQ0FBYyx1QkFBdUIsU0FBckMsQ0FBbEM7QUFDQSwwQkFBc0IsU0FBdEIsQ0FBZ0MsV0FBaEMsR0FBOEMscUJBQTlDOztBQUVBLGFBQVMsY0FBVCxHQUEwQjs7QUFFdEIsaUJBQVMsY0FBVCxDQUF3QixPQUF4QixFQUFpQyxPQUFqQyxFQUEwQyxNQUExQyxFQUFrRCxDQUFsRCxFQUFxRCxLQUFyRCxFQUE0RDtBQUN4RCxnQkFDSSxnQkFBZ0Isa0JBQWtCLE1BQWxCLEdBQTJCLEtBQUssY0FBTCxFQUQvQztBQUFBLGdCQUdJLEtBQUssUUFBUSxHQUhqQjs7QUFLQSxpQkFBSyxJQUFJLElBQUksUUFBUSxHQUFyQixFQUEwQixJQUFJLFFBQVEsTUFBdEMsRUFBOEMsS0FBSyxJQUFuRCxFQUF5RDtBQUNyRCxvQkFDSSxZQUFZLFFBQVEsSUFBUixHQUFlLEtBQUssQ0FEcEM7QUFBQSxvQkFFSSxZQUFZLGNBQWMsYUFBZCxDQUE0QixRQUFRLElBQXBDLEVBQTBDLENBQTFDLENBRmhCOztBQUlBLHFCQUFLLElBQUksSUFBSSxRQUFRLElBQXJCLEVBQTJCLElBQUksUUFBUSxLQUF2QyxFQUE4QyxLQUFLLFdBQUwsRUFBa0IsYUFBYSxxQkFBVyxlQUF4RixFQUF5RztBQUNyRyx3QkFDSSxTQUFVLGNBQWMsSUFBZCxDQUFtQixZQUFZLHFCQUFXLGlCQUExQyxJQUErRCxLQUEvRCxHQUF1RSxHQUF4RSxHQUErRSxDQUQ1Rjs7QUFHQSx3QkFBSSxVQUFVLENBQWQsRUFBaUI7QUFDYjtBQUNIOztBQUVELHdCQUNJLFNBQVMsT0FBTyxTQUFQLENBRGI7QUFBQSx3QkFFSSxTQUFTLFdBQVcsRUFGeEI7QUFBQSx3QkFJSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FKM0Q7O0FBTUEsd0JBQUksV0FBVyxDQUFmLEVBQWtCO0FBQ2QsNEJBQ0ksWUFBYSxTQUFTLEdBQVQsR0FBZSxRQUFoQixHQUE0QixDQUQ1QztBQUFBLDRCQUVJLFdBQVcsTUFBTSxTQUZyQjtBQUFBLDRCQUlJLFlBQVksY0FBYyxJQUFkLENBQW1CLFlBQVkscUJBQVcsZUFBMUMsQ0FKaEI7QUFBQSw0QkFLSSxjQUFjLGNBQWMsSUFBZCxDQUFtQixZQUFZLHFCQUFXLGlCQUExQyxDQUxsQjtBQUFBLDRCQU1JLGFBQWEsY0FBYyxJQUFkLENBQW1CLFlBQVkscUJBQVcsZ0JBQTFDLENBTmpCO0FBQUEsNEJBUUksV0FBVyxZQUFZLEVBQVosR0FDSixZQUFhLENBQUMsQ0FBQyxXQUFXLEVBQVgsR0FBZ0IsSUFBakIsSUFBeUIsUUFBekIsR0FBb0MsWUFBWSxRQUFqRCxJQUE2RCxHQUEzRSxJQUFvRixFQUQvRSxHQUVKLGNBQWUsQ0FBQyxDQUFDLFdBQVcsQ0FBWCxHQUFlLElBQWhCLElBQXdCLFFBQXhCLEdBQW1DLGNBQWMsUUFBbEQsSUFBOEQsR0FBOUUsSUFBdUYsQ0FGbEYsR0FHSixhQUFjLENBQUMsQ0FBQyxTQUFTLElBQVYsSUFBa0IsUUFBbEIsR0FBNkIsYUFBYSxRQUEzQyxJQUF1RCxHQVhoRjs7QUFhQSwrQkFBTyxTQUFQLElBQW9CLFFBQXBCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQsaUJBQVMsY0FBVCxDQUF3QixPQUF4QixFQUFpQyxPQUFqQyxFQUEwQyxNQUExQyxFQUFrRCxDQUFsRCxFQUFxRCxNQUFyRCxFQUE2RCxNQUE3RCxFQUFxRTtBQUNqRSxnQkFDSSxLQUFLLFFBQVEsR0FEakI7O0FBR0EsZ0JBQUksVUFBVSxDQUFkLEVBQWlCO0FBQ2I7QUFDSDs7QUFFRCxpQkFBSyxJQUFJLElBQUksUUFBUSxHQUFyQixFQUEwQixJQUFJLFFBQVEsTUFBdEMsRUFBOEMsS0FBSyxJQUFuRCxFQUF5RDtBQUNyRCxvQkFDSSxZQUFZLFFBQVEsSUFBUixHQUFlLEtBQUssQ0FEcEM7O0FBR0EscUJBQUssSUFBSSxJQUFJLFFBQVEsSUFBckIsRUFBMkIsSUFBSSxRQUFRLEtBQXZDLEVBQThDLEtBQUssV0FBbkQsRUFBZ0U7QUFDNUQsd0JBQ0ksU0FBUyxPQUFPLFNBQVAsQ0FEYjtBQUFBLHdCQUVJLFNBQVUsV0FBVyxFQUZ6QjtBQUFBLHdCQUlJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUozRDs7QUFNQSx3QkFBSSxXQUFXLENBQWYsRUFBa0I7QUFDZCw0QkFDSSxZQUFhLFNBQVMsR0FBVCxHQUFlLFFBQWhCLEdBQTRCLENBRDVDO0FBQUEsNEJBRUksV0FBVyxNQUFNLFNBRnJCO0FBQUEsNEJBSUksV0FBVyxZQUFZLEVBQVosR0FDSixDQUFDLFdBQVcsRUFBWCxHQUFnQixJQUFqQixJQUEwQixDQUFDLENBQUMsV0FBVyxFQUFYLEdBQWdCLElBQWpCLElBQXlCLFFBQXpCLEdBQW9DLENBQUMsV0FBVyxFQUFYLEdBQWdCLElBQWpCLElBQXlCLFFBQTlELElBQTBFLEdBQXJHLElBQThHLEVBRHpHLEdBRUosQ0FBQyxXQUFXLENBQVgsR0FBZSxJQUFoQixJQUF5QixDQUFDLENBQUMsV0FBVyxDQUFYLEdBQWUsSUFBaEIsSUFBd0IsUUFBeEIsR0FBbUMsQ0FBQyxXQUFXLENBQVgsR0FBZSxJQUFoQixJQUF3QixRQUE1RCxJQUF3RSxHQUFsRyxJQUEyRyxDQUZ0RyxHQUdKLENBQUMsU0FBUyxJQUFWLElBQW1CLENBQUMsQ0FBQyxTQUFTLElBQVYsSUFBa0IsUUFBbEIsR0FBNkIsQ0FBQyxTQUFTLElBQVYsSUFBa0IsUUFBaEQsSUFBNEQsR0FQMUY7O0FBU0EsK0JBQU8sU0FBUCxJQUFvQixRQUFwQjtBQUNIO0FBQ0o7QUFDSjtBQUNKOztBQUVELGlCQUFTLGNBQVQsQ0FBd0IsT0FBeEIsRUFBaUMsT0FBakMsRUFBMEMsTUFBMUMsRUFBa0QsS0FBbEQsRUFBeUQsQ0FBekQsRUFBNEQsS0FBNUQsRUFBbUU7QUFDL0QsZ0JBQ0ksY0FBYyxjQUFjLElBRGhDO0FBQUEsZ0JBR0ksS0FBSyxRQUFRLEdBSGpCOztBQUtBLGlCQUFLLElBQUksSUFBSSxRQUFRLEdBQXJCLEVBQTBCLElBQUksUUFBUSxNQUF0QyxFQUE4QyxLQUFLLElBQW5ELEVBQXlEO0FBQ3JELG9CQUNJLGVBQWUsUUFBUSxJQUFSLEdBQWUsS0FBSyxDQUR2QztBQUFBLG9CQUMwQztBQUN0QyxnQ0FBZ0IsUUFBUSxJQUFSLEdBQWUsSUFBSSxLQUFLLEtBRjVDO0FBQUEsb0JBRW1EO0FBQy9DLDhCQUFjLFNBQVMsYUFBVCxDQUF1QixRQUFRLElBQS9CLEVBQXFDLENBQXJDLENBSGxCLENBRHFELENBSU07O0FBRTNELHFCQUFLLElBQUksSUFBSSxRQUFRLElBQXJCLEVBQTJCLElBQUksUUFBUSxLQUF2QyxFQUE4QyxLQUFLLGNBQUwsRUFBcUIsZUFBZSxxQkFBVyxlQUEvQyxFQUFnRSxlQUE5RyxFQUErSDtBQUMzSCx3QkFDSSxTQUFTLE9BQU8sWUFBUCxDQURiO0FBQUEsd0JBRUksU0FBVSxDQUFDLFdBQVcsRUFBWixLQUFtQixNQUFNLFlBQU4sSUFBc0IsSUFBekMsSUFBaUQsS0FBakQsSUFBMEQsTUFBTSxHQUFoRSxDQUFELEdBQXlFLENBRnRGOztBQUlBLHdCQUFJLFVBQVUsQ0FBZCxFQUFpQjtBQUNiO0FBQ0g7O0FBRUQsd0JBQ0ksU0FBUyxTQUFTLElBQVQsQ0FBYyxjQUFjLHFCQUFXLGlCQUF2QyxDQURiO0FBQUEsd0JBR0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBSDNEOztBQUtBLHdCQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUNkLDRCQUNJLFlBQVksU0FBUyxJQUFULENBQWMsY0FBYyxxQkFBVyxlQUF2QyxDQURoQjtBQUFBLDRCQUVJLGNBQWMsU0FBUyxJQUFULENBQWMsY0FBYyxxQkFBVyxpQkFBdkMsQ0FGbEI7QUFBQSw0QkFHSSxhQUFhLFNBQVMsSUFBVCxDQUFjLGNBQWMscUJBQVcsZ0JBQXZDLENBSGpCO0FBQUEsNEJBS0ksWUFBYSxTQUFTLEdBQVQsR0FBZSxRQUFoQixHQUE0QixDQUw1QztBQUFBLDRCQU1JLFdBQVcsTUFBTSxTQU5yQjtBQUFBLDRCQVFJLFdBQVcsWUFBWSxFQUFaLEdBQ0osQ0FBQyxXQUFXLEVBQVgsR0FBZ0IsSUFBakIsSUFBMEIsQ0FBQyxZQUFZLFFBQVosR0FBdUIsQ0FBQyxXQUFXLEVBQVgsR0FBZ0IsSUFBakIsSUFBeUIsUUFBakQsSUFBNkQsR0FBeEYsSUFBaUcsRUFENUYsR0FFSixDQUFDLFdBQVcsQ0FBWCxHQUFlLElBQWhCLElBQXlCLENBQUMsY0FBYyxRQUFkLEdBQXlCLENBQUMsV0FBVyxDQUFYLEdBQWUsSUFBaEIsSUFBd0IsUUFBbEQsSUFBOEQsR0FBeEYsSUFBaUcsQ0FGNUYsR0FHSixDQUFDLFNBQVMsSUFBVixJQUFtQixDQUFDLGFBQWEsUUFBYixHQUF3QixDQUFDLFNBQVMsSUFBVixJQUFrQixRQUEzQyxJQUF1RCxHQVhyRjs7QUFhQSxvQ0FBWSxhQUFaLElBQTZCLFFBQTdCO0FBQ0g7QUFDSjtBQUNKO0FBQ0o7O0FBRUQsYUFBSyxzQkFBTCxHQUE4QixVQUFTLE9BQVQsRUFBa0IsT0FBbEIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDMUQsZ0JBQUksZUFBZSxJQUFuQixFQUF5QjtBQUNyQiw4QkFBYyxJQUFJLFdBQUosQ0FBZ0IsSUFBSSxLQUFKLEdBQVksSUFBSSxNQUFoQyxDQUFkLENBRHFCLENBQ2tDOztBQUV2RCwrQkFBZSxPQUFmLEVBQXdCLE9BQXhCLEVBQWlDLFdBQWpDLEVBQThDLElBQUksS0FBbEQsRUFBeUQsR0FBekQ7QUFDSCxhQUpELE1BSU87QUFDSCwrQkFBZSxPQUFmLEVBQXdCLE9BQXhCLEVBQWlDLFdBQWpDLEVBQThDLElBQUksS0FBbEQsRUFBeUQsQ0FBQyxFQUFHLFNBQVMsS0FBVCxJQUFrQixHQUFuQixHQUEwQixDQUExQixHQUE4QixLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQWEsU0FBUyxLQUFULEdBQWlCLFNBQVMsS0FBM0IsR0FBb0MsR0FBaEQsQ0FBaEMsQ0FBMUQsRUFBaUosV0FBVyxRQUE1SjtBQUNBLCtCQUFlLE9BQWYsRUFBd0IsT0FBeEIsRUFBaUMsV0FBakMsRUFBOEMsSUFBSSxLQUFsRCxFQUF5RCxJQUFJLEtBQTdELEVBQW9FLElBQUksS0FBeEU7QUFDQSwrQkFBZSxPQUFmLEVBQXdCLE9BQXhCLEVBQWlDLFdBQWpDLEVBQThDLElBQUksS0FBbEQsRUFBeUQsQ0FBQyxFQUFFLFNBQVMsS0FBVCxHQUFpQixHQUFuQixDQUExRDtBQUNIOztBQUVELCtCQUFtQixDQUFuQixFQUFzQixLQUF0Qjs7QUFFQSxnQkFBSSxlQUFKLEVBQXFCO0FBQ2pCLHFCQUFLLFlBQUw7QUFDSDtBQUNKLFNBaEJEO0FBaUJIOztBQUVELG1CQUFlLFNBQWYsR0FBMkIsT0FBTyxNQUFQLENBQWMsdUJBQXVCLFNBQXJDLENBQTNCO0FBQ0EsbUJBQWUsU0FBZixDQUF5QixXQUF6QixHQUF1QyxjQUF2Qzs7QUFFQSxhQUFTLGlCQUFULEdBQTZCOztBQUV6Qjs7Ozs7Ozs7QUFRQSxpQkFBUyxpQkFBVCxDQUEyQixPQUEzQixFQUFvQyxPQUFwQyxFQUE2QyxNQUE3QyxFQUFxRCxDQUFyRCxFQUF3RCxLQUF4RCxFQUErRDtBQUMzRCxnQkFDSSxnQkFBZ0Isa0JBQWtCLE1BQWxCLEdBQTJCLEtBQUssY0FBTCxFQUQvQztBQUFBLGdCQUdJLEtBQUssUUFBUSxHQUhqQjs7QUFLQSxpQkFBSyxJQUFJLElBQUksUUFBUSxHQUFyQixFQUEwQixJQUFJLFFBQVEsTUFBdEMsRUFBOEMsS0FBSyxJQUFuRCxFQUF5RDtBQUNyRCxvQkFDSSxZQUFZLFFBQVEsSUFBUixHQUFlLEtBQUssQ0FEcEM7QUFBQSxvQkFFSSxZQUFZLGNBQWMsYUFBZCxDQUE0QixRQUFRLElBQXBDLEVBQTBDLENBQTFDLENBRmhCOztBQUlBLHFCQUFLLElBQUksSUFBSSxRQUFRLElBQXJCLEVBQTJCLElBQUksUUFBUSxLQUF2QyxFQUE4QyxLQUFLLFdBQUwsRUFBa0IsYUFBYSxxQkFBVyxlQUF4RixFQUF5RztBQUNyRyx3QkFDSSxXQUFXLGNBQWMsSUFBZCxDQUFtQixZQUFZLHFCQUFXLGVBQTFDLENBRGY7QUFBQSx3QkFFSSxhQUFhLGNBQWMsSUFBZCxDQUFtQixZQUFZLHFCQUFXLGlCQUExQyxDQUZqQjtBQUFBLHdCQUdJLFlBQVksY0FBYyxJQUFkLENBQW1CLFlBQVkscUJBQVcsZ0JBQTFDLENBSGhCO0FBQUEsd0JBSUksYUFBYSxjQUFjLElBQWQsQ0FBbUIsWUFBWSxxQkFBVyxpQkFBMUMsQ0FKakI7QUFBQSx3QkFNSSxlQUFlLE1BQU0sS0FOekI7O0FBUUEsd0JBQUksZUFBZSxDQUFuQixFQUFzQjtBQUNsQiw0QkFDSSxZQUFZLE9BQU8sU0FBUCxDQURoQjtBQUFBLDRCQUdJLFlBQVksR0FIaEI7QUFBQSw0QkFJSSxnQkFBaUIsZUFBZSxhQUFhLE1BQU0sWUFBbkIsSUFBbUMsR0FBbkQsR0FBMEQsQ0FKOUU7QUFBQSw0QkFLSSxZQUFhLE1BQU0sWUFBTixHQUFxQixhQUF0QixHQUF1QyxDQUx2RDtBQUFBLDRCQU1JLFdBQVcsTUFBTSxTQU5yQjtBQUFBLDRCQVFJLFdBQ0ssQ0FBQyxhQUFhLFNBQWIsR0FBeUIsQ0FBQyxjQUFjLEVBQWQsR0FBbUIsSUFBcEIsSUFBNEIsUUFBdEQsSUFBa0UsR0FBbkUsSUFBMkUsRUFBM0UsR0FBZ0YsVUFBaEYsR0FDRyxDQUFDLFdBQVcsU0FBWCxHQUF1QixDQUFDLGNBQWMsRUFBZCxHQUFtQixJQUFwQixJQUE0QixRQUFwRCxJQUFnRSxHQUFqRSxJQUF5RSxFQUF6RSxHQUE4RSxRQURoRixHQUVHLENBQUMsYUFBYSxTQUFiLEdBQXlCLENBQUMsY0FBYyxDQUFkLEdBQWtCLElBQW5CLElBQTJCLFFBQXJELElBQWlFLEdBQWxFLElBQTBFLENBQTFFLEdBQThFLE1BRmhGLEdBR0csQ0FBQyxZQUFZLFNBQVosR0FBd0IsQ0FBQyxZQUFZLElBQWIsSUFBcUIsUUFBOUMsSUFBMEQsR0FBM0QsR0FBa0UsSUFaNUU7O0FBY0EsNEJBQUksWUFBWSxTQUFoQixFQUEyQjtBQUN2QixnQ0FBSSxZQUFZLFlBQVksUUFBeEIsQ0FBSixFQUF1QztBQUNuQyw0Q0FBWSxLQUFLLEVBQWpCO0FBQ0gsNkJBRkQsTUFFTyxJQUFJLFlBQVksWUFBWSxRQUF4QixDQUFKLEVBQXVDO0FBQzFDLDRDQUFZLEtBQUssRUFBakI7QUFDSDs7QUFFRCxnQ0FBSSxjQUFhLFlBQVksTUFBekIsQ0FBSixFQUFzQztBQUNsQyw0Q0FBWSxLQUFLLENBQWpCO0FBQ0gsNkJBRkQsTUFFTyxJQUFJLGNBQWMsWUFBWSxNQUExQixDQUFKLEVBQXVDO0FBQzFDLDRDQUFZLEtBQUssQ0FBakI7QUFDSDs7QUFFRCxnQ0FBSSxhQUFhLFlBQVksSUFBekIsQ0FBSixFQUFvQztBQUNoQyw0Q0FBWSxDQUFaO0FBQ0gsNkJBRkQsTUFFTyxJQUFJLGFBQWEsWUFBWSxJQUF6QixDQUFKLEVBQW9DO0FBQ3ZDLDRDQUFZLENBQVo7QUFDSDtBQUNKOztBQUVELCtCQUFPLFNBQVAsSUFBb0IsUUFBcEI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsZ0JBQUksUUFBUSxJQUFSLEdBQWUsQ0FBbkIsRUFBc0I7QUFDbEIsb0JBQ0ksT0FBTyxRQUFRLElBRG5COztBQUdBLHFCQUFLLElBQUksSUFBSSxRQUFRLEdBQXJCLEVBQTBCLElBQUksUUFBUSxNQUF0QyxFQUE4QyxHQUE5QyxFQUFtRDtBQUMvQyx3QkFDSSxTQUFTLElBQUksQ0FEakI7QUFBQSx3QkFFSSxZQUFZLE9BQU8sU0FBUyxRQUFRLElBQXhCLENBRmhCOztBQUlBLHlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBcEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDM0IsK0JBQU8sUUFBUCxJQUFtQixTQUFuQjtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxnQkFBSSxRQUFRLEtBQVIsR0FBZ0IsQ0FBcEIsRUFBdUI7QUFDbkIsb0JBQ0ksT0FBTyxJQUFJLFFBQVEsS0FEdkI7O0FBR0EscUJBQUssSUFBSSxJQUFJLFFBQVEsR0FBckIsRUFBMEIsSUFBSSxRQUFRLE1BQXRDLEVBQThDLEdBQTlDLEVBQW1EO0FBQy9DLHdCQUNJLFNBQVMsSUFBSSxDQUFKLEdBQVEsUUFBUSxLQUQ3QjtBQUFBLHdCQUVJLFlBQVksT0FBTyxTQUFTLENBQWhCLENBRmhCOztBQUlBLHlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBcEIsRUFBMEIsR0FBMUIsRUFBK0I7QUFDM0IsK0JBQU8sUUFBUCxJQUFtQixTQUFuQjtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsR0FBNUIsRUFBaUMsR0FBakMsRUFBc0M7QUFDbEMsb0JBQ0ksWUFBWSxRQUFRLEdBQVIsR0FBYyxDQUQ5QjtBQUFBLG9CQUVJLFlBQVksSUFBSSxDQUZwQjs7QUFJQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssV0FBTCxFQUFrQixXQUF6QyxFQUFzRDtBQUNsRCwyQkFBTyxTQUFQLElBQW9CLE9BQU8sU0FBUCxDQUFwQjtBQUNIO0FBQ0o7O0FBRUQsaUJBQUssSUFBSSxJQUFJLFFBQVEsTUFBckIsRUFBNkIsSUFBSSxDQUFqQyxFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyxvQkFDSSxZQUFZLENBQUMsUUFBUSxNQUFSLEdBQWlCLENBQWxCLElBQXVCLENBRHZDO0FBQUEsb0JBRUksWUFBWSxJQUFJLENBRnBCOztBQUlBLHFCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxXQUFMLEVBQWtCLFdBQXpDLEVBQXNEO0FBQ2xELDJCQUFPLFNBQVAsSUFBb0IsT0FBTyxTQUFQLENBQXBCO0FBQ0g7QUFDSjtBQUNKOztBQUVEOzs7Ozs7Ozs7QUFTQSxpQkFBUyxpQkFBVCxDQUEyQixPQUEzQixFQUFvQyxPQUFwQyxFQUE2QyxNQUE3QyxFQUFxRCxLQUFyRCxFQUE0RCxDQUE1RCxFQUErRCxLQUEvRCxFQUFzRTtBQUNsRSxnQkFDSSxLQUFLLFFBQVEsR0FEakI7O0FBR0EsaUJBQUssSUFBSSxJQUFJLFFBQVEsR0FBckIsRUFBMEIsSUFBSSxRQUFRLE1BQXRDLEVBQThDLEtBQUssSUFBbkQsRUFBeUQ7QUFDckQsb0JBQ0ksWUFBWSxRQUFRLElBQVIsR0FBZSxLQUFLLENBRHBDO0FBQUEsb0JBRUksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsUUFBUSxJQUEvQixFQUFxQyxDQUFyQyxDQUZoQjs7QUFJQSxxQkFBSyxJQUFJLElBQUksUUFBUSxJQUFyQixFQUEyQixJQUFJLFFBQVEsS0FBdkMsRUFBOEMsS0FBSyxXQUFMLEVBQWtCLGFBQWEscUJBQVcsZUFBeEYsRUFBeUc7QUFDckcsd0JBQ0ksY0FBYyxPQUFPLFNBQVAsQ0FEbEI7QUFBQSx3QkFFSSxlQUFlLENBQUMsZ0JBQWdCLEVBQWpCLEtBQXdCLE1BQU0sU0FBTixJQUFtQixJQUEzQyxJQUFtRCxHQUZ0RTs7QUFJQSx3QkFBSSxlQUFlLENBQW5CLEVBQXNCO0FBQ2xCLGlDQUFTLElBQVQsQ0FBYyxZQUFZLHFCQUFXLGVBQXJDLElBQXlELGVBQWUsRUFBaEIsR0FBc0IsSUFBOUU7QUFDQSxpQ0FBUyxJQUFULENBQWMsWUFBWSxxQkFBVyxpQkFBckMsSUFBMkQsZUFBZSxDQUFoQixHQUFxQixJQUEvRTtBQUNBLGlDQUFTLElBQVQsQ0FBYyxZQUFZLHFCQUFXLGdCQUFyQyxJQUF5RCxjQUFjLElBQXZFO0FBQ0EsaUNBQVMsSUFBVCxDQUFjLFlBQVkscUJBQVcsaUJBQXJDLElBQTJELGVBQWUsRUFBaEIsR0FBc0IsSUFBaEY7QUFDSDtBQUNKO0FBQ0o7QUFDSjs7QUFFRDs7Ozs7QUFLQSxhQUFLLHNCQUFMLEdBQThCLFVBQVMsT0FBVCxFQUFrQixPQUFsQixFQUEyQixHQUEzQixFQUFnQztBQUMxRCxnQkFBSSxlQUFlLElBQW5CLEVBQXlCO0FBQ3JCLDhCQUFjLElBQUksV0FBSixDQUFnQixJQUFJLEtBQUosR0FBWSxJQUFJLE1BQWhDLENBQWQ7QUFDQSxrQ0FBa0IsT0FBbEIsRUFBMkIsT0FBM0IsRUFBb0MsV0FBcEMsRUFBaUQsSUFBSSxLQUFyRCxFQUE0RCxDQUE1RDtBQUNILGFBSEQsTUFHTztBQUNILGtDQUFrQixPQUFsQixFQUEyQixPQUEzQixFQUFvQyxXQUFwQyxFQUFpRCxJQUFJLEtBQXJELEVBQTRELElBQUksS0FBaEU7QUFDQSxrQ0FBa0IsT0FBbEIsRUFBMkIsT0FBM0IsRUFBb0MsV0FBcEMsRUFBaUQsSUFBSSxLQUFyRCxFQUE0RCxJQUFJLEtBQWhFLEVBQXVFLElBQUksS0FBM0U7O0FBRUEsb0JBQUksU0FBSixFQUFlO0FBQ1gsaUNBQWEsT0FBYjtBQUNIO0FBQ0o7O0FBRUQsd0JBQVksU0FBWjs7QUFFQSxnQkFBSSxlQUFKLEVBQXFCO0FBQ2pCLHFCQUFLLFlBQUw7QUFDSDtBQUNKLFNBbEJEO0FBbUJIOztBQUVELHNCQUFrQixTQUFsQixHQUE4QixPQUFPLE1BQVAsQ0FBYyx1QkFBdUIsU0FBckMsQ0FBOUI7QUFDQSxzQkFBa0IsU0FBbEIsQ0FBNEIsV0FBNUIsR0FBMEMsaUJBQTFDOztBQUVBLHNCQUFrQixTQUFsQixDQUE0QixlQUE1QixHQUE4QyxVQUFTLE9BQVQsRUFBa0IsS0FBbEIsRUFBeUIsQ0FDdEUsQ0FERDs7QUFHQSxRQUFJLGdCQUFnQixDQUNoQixJQUFJLHNCQUFKLEVBRGdCLEVBQ2MsSUFBSSxpQkFBSixFQURkLEVBQ3VDLElBQUksZ0JBQUosRUFEdkMsRUFFaEIsSUFBSSxlQUFKLEVBRmdCLEVBRU8sSUFBSSxxQkFBSixFQUZQLEVBRW9DLElBQUksZUFBSixFQUZwQyxFQUUyRCxJQUFJLGlCQUFKLEVBRjNELEVBR2hCLElBQUksY0FBSixFQUhnQixDQUFwQjs7QUFNQSxTQUFLLEtBQUwsR0FBYSxNQUFiO0FBQ0EsU0FBSyxNQUFMLEdBQWMsT0FBZDs7QUFFQSxTQUFLLG1CQUFMLEdBQTJCLFlBQVc7QUFDbEMsWUFDSSxTQUFTLFFBRGI7QUFBQSxZQUVJLGlCQUFpQixDQUZyQjs7QUFJQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUNwQyxnQkFDSSxRQUFRLE9BQU8sQ0FBUCxDQURaOztBQUdBLGdCQUFJLGlCQUFpQixJQUFqQixDQUFzQixNQUFNLElBQTVCLENBQUosRUFBdUM7QUFDbkMsaUNBQWlCLEtBQUssR0FBTCxDQUFTLGNBQVQsRUFBeUIsU0FBUyxNQUFNLElBQU4sQ0FBVyxTQUFYLENBQXFCLE9BQU8sTUFBNUIsQ0FBVCxFQUE4QyxFQUE5QyxDQUF6QixDQUFqQjtBQUNIO0FBQ0o7QUFDRCxlQUFPLFVBQVUsaUJBQWlCLENBQTNCLENBQVA7QUFDSCxLQWREOztBQWdCQSxhQUFTLFlBQVQsQ0FBc0IsSUFBdEIsRUFBNEI7QUFDeEIsYUFBSyxjQUFMLEdBQXNCLGFBQXRCLENBQW9DLFVBQXBDLEVBQWdELElBQWhEO0FBQ0g7O0FBRUQ7OztBQUdBLGFBQVMsa0JBQVQsQ0FBNEIsS0FBNUIsRUFBbUMsS0FBbkMsRUFBMEM7QUFDdEMsWUFBSSxDQUFDLFlBQVksT0FBWixFQUFMLEVBQTRCO0FBQ3hCLGdCQUFJLFNBQVMsU0FBVCxJQUFzQixzQkFBWSxPQUFsQyxJQUE2QyxDQUFDLFNBQWxELEVBQTZEO0FBQ3pELDhCQUFjLFNBQVMsU0FBdkIsRUFBa0MsZUFBbEMsQ0FBa0QsV0FBbEQsRUFBK0QsS0FBL0Q7QUFDSCxhQUZELE1BRU87QUFDSDtBQUNBLDhCQUFjLHNCQUFZLE9BQTFCLEVBQW1DLGVBQW5DLENBQW1ELFdBQW5ELEVBQWdFLGlCQUFoRTtBQUNIOztBQUVELGdCQUFJLFNBQUosRUFBZTtBQUNYLDZCQUFhLFdBQWI7QUFDSDs7QUFFRCxnQkFBSSxLQUFKLEVBQVc7QUFDUCw4QkFBYyxTQUFkLENBQXdCLFdBQXhCLEVBQXFDLENBQXJDO0FBQ0g7O0FBRUQsd0JBQVksU0FBWjtBQUNIO0FBQ0o7O0FBRUQsU0FBSyxrQkFBTCxHQUEwQixZQUFXO0FBQ2pDLFlBQ0ksUUFBUSxzQkFBWSxLQUFLLEtBQWpCLEVBQXdCLEtBQUssTUFBN0IsRUFBcUMsS0FBSyxtQkFBTCxFQUFyQyxDQURaOztBQUdBLGNBQU0sUUFBTixDQUFlLHNCQUFmOztBQUVBLGFBQUssY0FBTCxDQUFvQixLQUFwQjtBQUNILEtBUEQ7O0FBU0E7Ozs7O0FBS0EsU0FBSyxZQUFMLEdBQW9CLFlBQVc7QUFDM0I7QUFDQSxZQUFJLENBQUMsV0FBVyxPQUFYLEVBQUwsRUFBMkI7QUFDdkI7QUFDQSwrQkFBbUIsUUFBbkIsRUFBNkIsS0FBN0I7O0FBRUE7QUFDQSxnQkFBSSxPQUFPLE1BQVAsSUFBaUIsQ0FBakIsSUFBc0IsT0FBTyxDQUFQLEVBQVUsS0FBVixJQUFtQixHQUF6QyxJQUFnRCxPQUFPLENBQVAsRUFBVSxPQUE5RCxFQUF1RTtBQUNuRSx5QkFBUyxPQUFPLENBQVAsQ0FBVDtBQUNILGFBRkQsTUFFTztBQUNIO0FBQ0EseUJBQVMsWUFBVDs7QUFFQSxvQkFDSSwwQkFBMEIsSUFEOUI7QUFBQSxvQkFFSSxRQUFRLElBRlo7O0FBSUEsdUJBQU8sT0FBUCxDQUFlLFVBQVUsS0FBVixFQUFpQjtBQUM1Qix3QkFBSSxDQUFDLEtBQUwsRUFBWTtBQUNSLGtEQUEwQiwyQkFBMkIsT0FBTyxjQUFQLENBQXNCLFVBQXRCLENBQXJEO0FBQ0g7O0FBRUQsd0JBQUksTUFBTSxPQUFOLElBQWlCLE1BQU0sS0FBTixHQUFjLENBQW5DLEVBQXNDO0FBQ2xDLDRCQUFJLEtBQUosRUFBVztBQUNQLG9DQUFRLEtBQVI7O0FBRUEsZ0NBQUksTUFBTSxLQUFOLElBQWUsR0FBbkIsRUFBd0I7QUFDcEI7Ozs7O0FBS0EsdUNBQU8sY0FBUCxDQUFzQixLQUF0QixFQUE2QixXQUFXLElBQXhDLEVBQThDLFdBQVcsR0FBekQsRUFBOEQsVUFBOUQ7QUFDQTtBQUNIOztBQUVELG1DQUFPLFNBQVAsQ0FBaUIsVUFBakIsRUFBNkIsVUFBN0IsRUFiTyxDQWFtQztBQUM3Qzs7QUFFRCwwQ0FBUSxTQUFSLENBQWtCLE1BQWxCLEVBQTBCLHVCQUExQixFQUFtRCxLQUFuRCxFQUEwRCxVQUExRDtBQUNIO0FBQ0osaUJBeEJEOztBQTBCQSxvQkFBSSxLQUFKLEVBQVc7QUFDUDtBQUNBLDJCQUFPLFNBQVAsQ0FBaUIsVUFBakIsRUFBNkIsVUFBN0IsRUFGTyxDQUVtQztBQUM3QztBQUNKOztBQUVELHVCQUFXLFNBQVg7QUFDSDs7QUFFRCxlQUFPLE9BQU8sWUFBUCxFQUFQO0FBQ0gsS0FyREQ7O0FBdURBLFNBQUssbUJBQUwsR0FBMkIsVUFBUyxRQUFULEVBQW1CO0FBQzFDLFlBQUksV0FBVyxDQUFYLElBQWdCLFlBQVksT0FBTyxNQUF2QyxFQUErQztBQUMzQztBQUNIOztBQUVELFlBQUksWUFBWSxPQUFPLFFBQVAsQ0FBaEIsRUFBa0M7QUFDOUIsZ0JBQ0ksV0FBVyxLQUFLLG1CQUFMLEVBRGY7O0FBR0EsdUJBQVcsT0FBTyxRQUFQLENBQVg7O0FBRUE7QUFDQSxnQkFBSSxZQUFZLENBQUMsQ0FBakIsRUFBb0I7QUFDaEI7QUFDSCxhQUZELE1BRU87QUFDSCx5Q0FBeUIsUUFBekIsRUFERyxDQUNpQztBQUNwQyx5Q0FBeUIsUUFBekIsRUFGRyxDQUVpQztBQUN2Qzs7QUFFRDtBQUNIO0FBQ0osS0FyQkQ7O0FBdUJBLFNBQUssbUJBQUwsR0FBMkIsWUFBVztBQUNsQyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUNwQyxnQkFBSSxPQUFPLENBQVAsS0FBYSxRQUFqQixFQUEyQjtBQUN2Qix1QkFBTyxDQUFQO0FBQ0g7QUFDSjs7QUFFRCxlQUFPLENBQUMsQ0FBUjtBQUNILEtBUkQ7O0FBVUE7OztBQUdBLFNBQUssc0JBQUwsR0FBOEIsWUFBVztBQUNyQyxhQUFLLElBQUksSUFBSSxPQUFPLE1BQVAsR0FBZ0IsQ0FBN0IsRUFBZ0MsS0FBSyxDQUFyQyxFQUF3QyxHQUF4QyxFQUE2QztBQUN6QyxnQkFBSSxPQUFPLENBQVAsRUFBVSxPQUFkLEVBQXVCO0FBQ25CLHVCQUFPLENBQVA7QUFDSDtBQUNKOztBQUVELGVBQU8sQ0FBUDtBQUNILEtBUkQ7O0FBVUg7Ozs7OztBQU1HLFNBQUssUUFBTCxHQUFnQixVQUFTLENBQVQsRUFBWTtBQUN4QixlQUFPLE9BQU8sQ0FBUCxDQUFQO0FBQ0gsS0FGRDs7QUFJSDs7Ozs7QUFLRyxTQUFLLGNBQUwsR0FBc0IsWUFBVztBQUM3QixlQUFPLFFBQVA7QUFDSCxLQUZEOztBQUlBLFNBQUssZ0JBQUwsR0FBd0IsWUFBVztBQUMvQixZQUNJLFFBQVEsYUFBYSxhQUFiLE1BQWdDLElBQUksT0FBTyxNQUEzQyxDQURaOztBQUdBLFlBQUksYUFBYSxJQUFqQixFQUF1QjtBQUNuQixxQkFBUyxVQUFVLEdBQVYsQ0FBYyxhQUFkLEVBQVQ7QUFDSDs7QUFFRCxlQUFPLEtBQVA7QUFDSCxLQVREOztBQVdBLFNBQUssaUJBQUwsR0FBeUIsWUFBVztBQUNoQyxZQUNJLFFBQVEsQ0FEWjs7QUFHQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxnQkFDSSxPQUFPLFNBQVMsQ0FBVCxDQURYOztBQUdBLHFCQUFTLEtBQUssYUFBTCxDQUFtQixJQUFuQixFQUF5QixJQUF6QixDQUFUO0FBQ0g7O0FBRUQsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFNBQVMsTUFBN0IsRUFBcUMsR0FBckMsRUFBMEM7QUFDdEMsZ0JBQ0ksT0FBTyxTQUFTLENBQVQsQ0FEWDs7QUFHQSxxQkFBUyxLQUFLLGFBQUwsQ0FBbUIsS0FBbkIsRUFBMEIsSUFBMUIsQ0FBVDtBQUNIOztBQUVELGVBQU8sS0FBUDtBQUNILEtBbkJEOztBQXFCQSxhQUFTLE9BQVQsR0FBbUI7QUFDZixlQUFPLFNBQVMsTUFBVCxHQUFrQixDQUF6QjtBQUNIOztBQUVELGFBQVMsT0FBVCxHQUFtQjtBQUNmLGVBQU8sU0FBUyxNQUFULEdBQWtCLENBQXpCO0FBQ0g7O0FBRUQ7QUFDQTtBQUNBOztBQUVBLFNBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsWUFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDWjtBQUNIO0FBQ0QsNEJBQW9CLElBQXBCOztBQUVBLFlBQ0ksT0FBTyxTQUFTLEdBQVQsRUFEWDs7QUFHQSxhQUFLLElBQUw7O0FBRUEsaUJBQVMsSUFBVCxDQUFjLElBQWQ7QUFDSCxLQVpEOztBQWNBLFNBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsWUFBSSxDQUFDLFNBQUwsRUFBZ0I7QUFDWjtBQUNIO0FBQ0QsNEJBQW9CLElBQXBCOztBQUVBLFlBQ0ksT0FBTyxTQUFTLEdBQVQsRUFEWDs7QUFHQSxhQUFLLElBQUw7O0FBRUEsaUJBQVMsSUFBVCxDQUFjLElBQWQ7QUFDSCxLQVpEOztBQWNBOzs7QUFHQSxhQUFTLG1CQUFULEdBQStCO0FBQzNCLFlBQUksQ0FBQyx3QkFBd0IsT0FBeEIsRUFBTCxFQUF3QztBQUNwQztBQUNBLHVCQUFXLGNBQVgsQ0FBMEIsUUFBMUIsRUFBb0Msd0JBQXdCLElBQTVELEVBQWtFLHdCQUF3QixHQUExRixFQUErRix1QkFBL0Y7QUFDQSxvQ0FBd0IsU0FBeEI7QUFDSDtBQUNKOztBQUVEOzs7O0FBSUEsYUFBUyxtQkFBVCxHQUErQjtBQUMzQixrQ0FBMEIsS0FBSyxTQUFMLEVBQTFCO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLFNBQUssZ0JBQUwsR0FBd0IsWUFBVztBQUMvQjtBQUNILEtBRkQ7O0FBSUEsYUFBUyxPQUFULENBQWlCLElBQWpCLEVBQXVCO0FBQ25CLDRCQUFvQixJQUFwQjs7QUFFQSxZQUFJLFNBQVMsTUFBVCxHQUFrQixDQUF0QixFQUF5QjtBQUNyQix1QkFBVyxFQUFYO0FBQ0g7O0FBRUQsWUFBSSxTQUFTLE1BQVQsSUFBbUIsQ0FBbkIsSUFBd0IsQ0FBQyxTQUFTLFNBQVMsTUFBVCxHQUFrQixDQUEzQixFQUE4QixLQUE5QixDQUFvQyxJQUFwQyxDQUE3QixFQUF3RTtBQUNwRSxnQkFBSSxTQUFTLE1BQVQsSUFBbUIsUUFBdkIsRUFBaUM7QUFDN0IseUJBQVMsT0FBVDtBQUNIO0FBQ0QsZ0JBQUksU0FBUyxNQUFULEdBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLHlCQUFTLFNBQVMsTUFBVCxHQUFrQixDQUEzQixFQUE4QixPQUE5QjtBQUNIO0FBQ0QscUJBQVMsSUFBVCxDQUFjLElBQWQ7QUFDSCxTQVJELE1BUU8sSUFBSSxTQUFTLFNBQVMsTUFBVCxHQUFrQixDQUEzQixFQUE4QixRQUE5QixFQUFKLEVBQThDO0FBQ2pEO0FBQ0E7QUFDQSxxQkFBUyxHQUFUO0FBQ0g7QUFDSjs7QUFFRCxTQUFLLFlBQUwsR0FBb0IsWUFBVztBQUMzQixtQkFBVyxFQUFYO0FBQ0EsbUJBQVcsRUFBWDtBQUNILEtBSEQ7O0FBS0EsU0FBSyxXQUFMLEdBQW1CLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUM5QjtBQUNBO0FBQ0E7O0FBRUEsZUFBTyxPQUFPLFFBQVAsQ0FBZ0IsQ0FBQyxDQUFDLENBQWxCLEVBQXFCLENBQUMsQ0FBQyxDQUF2QixJQUE0QixRQUFuQztBQUNILEtBTkQ7O0FBUUEsU0FBSyxZQUFMLEdBQW9CLFVBQVMsSUFBVCxFQUFlO0FBQy9CLHFCQUFhLEdBQWIsQ0FBaUIsSUFBakI7QUFDQSxxQkFBYSxJQUFiLENBQWtCLEtBQUssU0FBTCxFQUFsQjtBQUNILEtBSEQ7O0FBS0EsU0FBSyxjQUFMLEdBQXNCLFlBQVc7QUFDN0IscUJBQWEsU0FBYjtBQUNILEtBRkQ7O0FBSUEsU0FBSyxTQUFMLEdBQWlCLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUM1QjtBQUNBLG1CQUFXLEtBQUssU0FBTCxFQUFYOztBQUVBLGlCQUFTLFNBQVQsQ0FBbUIsQ0FBQyxDQUFDLENBQXJCLEVBQXdCLENBQUMsQ0FBQyxDQUExQixFQUE2QixXQUFXLFVBQXhDOztBQUVBLGdCQUFRLElBQUksV0FBSixFQUFSO0FBQ0E7QUFDSCxLQVJEOztBQVVBLFNBQUssWUFBTCxHQUFvQixVQUFTLEtBQVQsRUFBZ0IsS0FBaEIsRUFBdUIsR0FBdkIsRUFBNEIsR0FBNUIsRUFBaUMsY0FBakMsRUFBaUQ7QUFDakUsWUFDSSxJQUFJLEtBQUssc0JBQUwsRUFEUjs7QUFHQTtBQUNBLG1CQUFXLENBQVg7O0FBRUEsaUJBQVMsUUFBVCxDQUFrQixDQUFsQixFQUFxQixLQUFyQixFQUE0QixLQUE1QixFQUFtQyxHQUFuQyxFQUF3QyxHQUF4QyxFQUE2QyxjQUE3Qzs7QUFFQSxZQUFJLFNBQUosRUFBZTtBQUNYLHlCQUFhLENBQWI7QUFDSDs7QUFFRCxnQkFBUSxJQUFJLFdBQUosRUFBUjtBQUNBO0FBQ0gsS0FmRDs7QUFpQkEsU0FBSyxJQUFMLEdBQVksVUFBUyxLQUFULEVBQWdCO0FBQ3hCLFlBQ0ksSUFBSSxLQUFLLHNCQUFMLEVBRFI7O0FBR0E7QUFDQSxtQkFBVyxDQUFYOztBQUVBLGlCQUFTLFNBQVQsQ0FBbUIsQ0FBbkIsRUFBc0IsS0FBdEI7O0FBRUEsZ0JBQVEsSUFBSSxXQUFKLEVBQVI7QUFDQTtBQUNILEtBWEQ7O0FBYUEsU0FBSyxLQUFMLEdBQWEsWUFBVztBQUNwQixhQUFLLElBQUwsQ0FBVSxRQUFWO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLEtBQUwsR0FBYSxZQUFXO0FBQ3BCLFlBQ0ksSUFBSSxLQUFLLHNCQUFMLEVBRFI7O0FBR0E7QUFDQSxtQkFBVyxDQUFYOztBQUVBLGlCQUFTLGVBQVQsQ0FBeUIsQ0FBekIsRUFBNEIsVUFBNUI7O0FBRUEsZ0JBQVEsSUFBSSxXQUFKLEVBQVI7QUFDQTtBQUNILEtBWEQ7O0FBYUEsU0FBSyxLQUFMLEdBQWEsWUFBVztBQUNwQixZQUNJLElBQUksS0FBSyxzQkFBTCxFQURSOztBQUdBO0FBQ0EsbUJBQVcsQ0FBWDs7QUFFQSxpQkFBUyxlQUFULENBQXlCLENBQXpCLEVBQTRCLFVBQTVCOztBQUVBLGdCQUFRLElBQUksV0FBSixFQUFSO0FBQ0E7QUFDSCxLQVhEOztBQWFBLFNBQUssa0JBQUwsR0FBMEIsWUFBVztBQUNqQyxZQUNJLElBQUksS0FBSyxzQkFBTCxFQURSOztBQUdBO0FBQ0EsbUJBQVcsQ0FBWDs7QUFFQSxpQkFBUyxhQUFULENBQXVCLENBQXZCOztBQUVBLGdCQUFRLElBQUksV0FBSixFQUFSO0FBQ0E7QUFDSCxLQVhEOztBQWFBLFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLFlBQ0ksSUFBSSxLQUFLLHNCQUFMLEVBRFI7O0FBR0E7QUFDQSxtQkFBVyxDQUFYOztBQUVBLGlCQUFTLGtCQUFULENBQTRCLENBQTVCOztBQUVBLGdCQUFRLElBQUksV0FBSixFQUFSO0FBQ0E7QUFDSCxLQVhEOztBQWFBLFNBQUssTUFBTCxHQUFjLFlBQVc7QUFDckIsWUFDSSxJQUFJLEtBQUssc0JBQUwsRUFEUjs7QUFHQTtBQUNBLG1CQUFXLENBQVg7O0FBRUEsaUJBQVMsTUFBVCxDQUFnQixDQUFoQjs7QUFFQSxnQkFBUSxJQUFJLFdBQUosRUFBUjtBQUNBO0FBQ0gsS0FYRDs7QUFhQSxTQUFLLE9BQUwsR0FBZSxVQUFTLE9BQVQsRUFBa0IsT0FBbEIsRUFBMkIsVUFBM0IsRUFBdUM7QUFDbEQsWUFDSSxJQUFJLEtBQUssc0JBQUwsRUFEUjs7QUFHQTtBQUNBLG1CQUFXLENBQVg7O0FBRUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQXBCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLHFCQUFTLE9BQVQsQ0FBaUIsQ0FBakIsRUFBb0IsT0FBcEIsRUFBNkIsT0FBN0I7QUFDSDs7QUFFRCxnQkFBUSxJQUFJLFdBQUosRUFBUjtBQUNBO0FBQ0gsS0FiRDs7QUFlQSxTQUFLLGtCQUFMLEdBQTBCLFVBQVMsQ0FBVCxFQUFZO0FBQ2xDLFlBQ0ksZUFBZSxFQUFFLEtBQUYsRUFEbkI7O0FBR0EscUJBQWEsSUFBYixDQUFrQixLQUFLLFNBQUwsRUFBbEI7O0FBRUEsZ0JBQVEsSUFBSSx3QkFBSixDQUE2QixLQUFLLFlBQUwsRUFBN0IsRUFBa0QsWUFBbEQsQ0FBUjs7QUFFQSxhQUFLLFlBQUwsQ0FBa0IsWUFBbEI7QUFDSCxLQVREOztBQVdBOzs7OztBQUtBLGFBQVMsa0JBQVQsR0FBOEI7QUFDMUIsWUFBSSxTQUFTLE1BQVQsR0FBa0IsQ0FBdEIsRUFBeUI7QUFDckIsbUJBQU8sU0FBUyxTQUFTLE1BQVQsR0FBa0IsQ0FBM0IsQ0FBUDtBQUNIOztBQUVELGVBQU8sSUFBUDtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsU0FBSyxJQUFMLEdBQVksVUFBUyxPQUFULEVBQWtCLE9BQWxCLEVBQTJCLElBQTNCLEVBQWlDO0FBQ3pDOzs7O0FBSUEsbUJBQVcsQ0FBWDtBQUNBLG1CQUFXLENBQVg7O0FBRUEsWUFBSSxXQUFXLENBQVgsSUFBZ0IsV0FBVyxDQUEvQixFQUFrQztBQUM5QjtBQUNIOztBQUVELG9CQUFZLFNBQVosR0FaeUMsQ0FZaEI7O0FBRXpCLFlBQ0ksV0FBVyxvQkFEZjs7QUFHQTtBQUNBLFlBQUksQ0FBQyxJQUFELElBQVMsb0JBQW9CLHFCQUE3QixJQUFzRCxTQUFTLFVBQVQsSUFBdUIsS0FBSyxtQkFBTCxFQUFqRixFQUE2RztBQUN6RyxxQkFBUyxLQUFULENBQWUsT0FBZixFQUF3QixPQUF4QjtBQUNBLHVCQUFXLEVBQVg7QUFDQSxnQ0FBb0IsSUFBcEI7QUFDSCxTQUpELE1BSU87QUFDSCx1QkFBVyxJQUFJLHFCQUFKLENBQTBCLEtBQUssc0JBQUwsRUFBMUIsRUFBeUQsT0FBekQsRUFBa0UsT0FBbEUsRUFBMkUsSUFBM0UsQ0FBWDs7QUFFQSxvQkFBUSxRQUFSO0FBQ0g7QUFDSixLQTNCRDs7QUE2QkE7Ozs7O0FBS0EsU0FBSyx5QkFBTCxHQUFpQyxVQUFTLGFBQVQsRUFBd0I7QUFDckQsaUNBQXlCLGFBQXpCO0FBQ0EsWUFBSSw0QkFBNEIsMEJBQWhDLEVBQTREO0FBQ3hELDZCQUFpQixnQkFBakIsQ0FBa0MsYUFBbEM7QUFDSDtBQUNKLEtBTEQ7O0FBT0g7OztBQUdHLFNBQUssb0JBQUwsR0FBNEIsWUFBVztBQUNuQyxZQUFJLDRCQUE0QiwwQkFBaEMsRUFBNEQ7QUFDeEQsNkJBQWlCLElBQWpCO0FBQ0EsK0JBQW1CLElBQW5CO0FBQ0g7QUFDSixLQUxEOztBQU9IOzs7Ozs7Ozs7QUFTRyxTQUFLLG9CQUFMLEdBQTRCLFlBQVc7QUFDbkM7QUFDQSxZQUFJLDRCQUE0QiwwQkFBaEMsRUFBNEQ7QUFDeEQsbUJBQU8sRUFBQyxXQUFXLGlCQUFpQixZQUFqQixFQUFaLEVBQTZDLE1BQU0saUJBQWlCLHVCQUFqQixFQUFuRCxFQUErRixXQUFXLGlCQUFpQix1QkFBakIsRUFBMUcsRUFBUDtBQUNIOztBQUVEO0FBQ0EsWUFDSSxRQUFRLEtBQUssY0FBTCxFQURaO0FBQUEsWUFFSSxZQUFZLEtBQUssc0JBQUwsRUFGaEI7QUFBQSxZQUdJLGNBQWMsTUFBTSx1QkFBTixDQUE4QixTQUE5QixDQUhsQjtBQUFBLFlBSUksbUJBQW1CLDJCQUp2Qjs7QUFNQSxZQUFJLFlBQVksT0FBWixFQUFKLEVBQTJCO0FBQ3ZCLG1CQUFPLElBQVA7QUFDSDs7QUFFRDs7O0FBR0EsMkJBQW1CLElBQUksMEJBQUosQ0FBK0IsV0FBL0IsRUFBNEMsZ0JBQTVDLEVBQThELHNCQUE5RCxDQUFuQjs7QUFFQSxvQkFBWSxTQUFaLEdBdEJtQyxDQXNCVjs7QUFFekIsZUFBTyxFQUFDLFdBQVcsZ0JBQVosRUFBOEIsTUFBTSxXQUFwQyxFQUFpRCxXQUFXLFNBQTVELEVBQVA7QUFDSCxLQXpCRDs7QUEyQkg7OztBQUdHLFNBQUsscUJBQUwsR0FBNkIsWUFBVztBQUNwQyxZQUFJLDRCQUE0QiwwQkFBaEMsRUFBNEQ7QUFDeEQsb0JBQVEsZ0JBQVI7QUFDQSwrQkFBbUIsSUFBbkI7QUFDSDtBQUNKLEtBTEQ7O0FBT0E7Ozs7O0FBS0EsU0FBSyxvQkFBTCxHQUE0QixVQUFTLGVBQVQsRUFBMEI7QUFDbEQsWUFBSSw0QkFBNEIsMEJBQWhDLEVBQTREO0FBQ3hELDZCQUFpQixLQUFqQixDQUF1QixlQUF2QjtBQUNIO0FBQ0osS0FKRDs7QUFNQTs7QUFFQSxTQUFLLFlBQUwsR0FBb0IsVUFBUyxVQUFULEVBQXFCO0FBQ3JDLFlBQ0ksWUFBWSxLQUFLLFlBQUwsRUFEaEI7O0FBR0EsWUFBSSxVQUFVLE9BQVYsRUFBSixFQUF5QjtBQUNyQjtBQUNIOztBQUVELG9CQUFZLHFCQUFXLFNBQVMsU0FBVCxDQUFtQixTQUFuQixDQUFYLEVBQTBDLFVBQVUsSUFBcEQsRUFBMEQsVUFBVSxHQUFwRSxDQUFaOztBQUVBLFlBQUksVUFBSixFQUFnQjtBQUNaLG9CQUFRLElBQUksU0FBSixDQUFjLFVBQVUsR0FBeEIsRUFBNkIsS0FBSyxtQkFBTCxFQUE3QixFQUF5RCxTQUF6RCxDQUFSO0FBQ0g7O0FBRUQsaUJBQVMsU0FBVCxDQUFtQixTQUFuQixFQUE4QixpQkFBOUI7QUFDQSw2QkFBcUIsU0FBckI7QUFDSCxLQWhCRDs7QUFrQkEsU0FBSyxhQUFMLEdBQXFCLFlBQVc7QUFDNUIsWUFDSSxZQUFZLEtBQUssWUFBTCxFQURoQjs7QUFHQSxZQUFJLFVBQVUsT0FBVixFQUFKLEVBQXlCO0FBQ3JCO0FBQ0g7O0FBRUQsb0JBQVkscUJBQVcsU0FBUyxTQUFULENBQW1CLFNBQW5CLENBQVgsRUFBMEMsVUFBVSxJQUFwRCxFQUEwRCxVQUFVLEdBQXBFLENBQVo7QUFDSCxLQVREOztBQVdBLFNBQUssbUJBQUwsR0FBMkIsWUFBVztBQUNsQyxZQUNJLFlBQVksS0FBSyxZQUFMLEVBRGhCOztBQUdBLFlBQUksVUFBVSxPQUFWLEVBQUosRUFBeUI7QUFDckI7QUFDSDs7QUFFRDtBQUNBLGFBQUssWUFBTDtBQUNBLG9CQUFZLHFCQUFXLE9BQU8sU0FBUCxDQUFpQixTQUFqQixDQUFYLEVBQXdDLFVBQVUsSUFBbEQsRUFBd0QsVUFBVSxHQUFsRSxDQUFaO0FBQ0gsS0FYRDs7QUFhQTs7Ozs7QUFLQSxhQUFTLFNBQVQsQ0FBbUIsVUFBbkIsRUFBK0IsSUFBL0IsRUFBcUM7QUFDakMsWUFDSSxtQkFBbUIsS0FBSyxtQkFBTCxFQUR2Qjs7QUFHQSxZQUFJLFVBQUosRUFBZ0I7QUFDWixvQkFBUSxJQUFJLFdBQUosQ0FBZ0IsSUFBaEIsRUFBc0IsZ0JBQXRCLEVBQXdDLEtBQUssWUFBTCxFQUF4QyxDQUFSO0FBQ0g7O0FBRUQsWUFDSSxXQUFXLHNCQUFZLEtBQUssS0FBakIsRUFBd0IsS0FBSyxNQUE3QixFQUFxQyxLQUFLLG1CQUFMLEVBQXJDLENBRGY7QUFBQSxZQUVJLGFBQWEsS0FBSyxHQUFMLENBQVMsU0FBVCxFQUZqQjtBQUFBLFlBR0ksQ0FISjtBQUFBLFlBR08sQ0FIUDs7QUFLQSxlQUFPLE1BQVAsQ0FBYyxtQkFBbUIsQ0FBakMsRUFBb0MsQ0FBcEMsRUFBdUMsUUFBdkM7QUFDQSxhQUFLLG1CQUFMLENBQXlCLG1CQUFtQixDQUE1Qzs7QUFFQSxZQUFJLFdBQVcsUUFBWCxDQUFvQixLQUFLLFNBQUwsRUFBcEIsQ0FBSixFQUEyQztBQUN2QyxnQkFBSSxLQUFLLENBQVQ7QUFDQSxnQkFBSSxLQUFLLENBQVQ7QUFDSCxTQUhELE1BR087QUFDSCxnQkFBSyxDQUFDLEtBQUssS0FBTCxHQUFhLEtBQUssR0FBTCxDQUFTLEtBQXZCLElBQWdDLENBQWpDLEdBQXNDLENBQTFDO0FBQ0EsZ0JBQUssQ0FBQyxLQUFLLE1BQUwsR0FBYyxLQUFLLEdBQUwsQ0FBUyxNQUF4QixJQUFrQyxDQUFuQyxHQUF3QyxDQUE1QztBQUNIOztBQUVELGlCQUFTLGNBQVQsQ0FBd0IsS0FBSyxHQUE3QixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxVQUF4QztBQUNBLGFBQUssY0FBTDs7QUFFQTtBQUNBO0FBQ0g7O0FBRUQsU0FBSyxjQUFMLEdBQXNCLFVBQVMsVUFBVCxFQUFxQjtBQUN2QyxZQUFJLGFBQWEsSUFBakIsRUFBdUI7QUFDbkIsc0JBQVUsVUFBVixFQUFzQixTQUF0QjtBQUNIO0FBQ0osS0FKRDs7QUFNQSxTQUFLLGtCQUFMLEdBQTBCLFVBQVMsQ0FBVCxFQUFZO0FBQ2xDLDBCQUFrQixDQUFsQjtBQUNILEtBRkQ7O0FBSUEsU0FBSyxZQUFMLEdBQW9CLFVBQVMsQ0FBVCxFQUFZO0FBQzVCLG9CQUFZLENBQVo7QUFDSCxLQUZEOztBQUlBLFNBQUssa0JBQUwsR0FBMEIsVUFBUyxLQUFULEVBQWdCO0FBQ3RDLG1CQUFXLEtBQVg7QUFDSCxLQUZEOztBQUlBLFNBQUssUUFBTCxHQUFnQixVQUFTLEtBQVQsRUFBZ0I7QUFDNUIsbUJBQVcsS0FBWDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxlQUFMLEdBQXVCLFVBQVMsT0FBVCxFQUFrQjtBQUNyQyxxQkFBYSxVQUFiLENBQXdCLE9BQXhCO0FBQ0gsS0FGRDs7QUFJQTtBQUNBO0FBQ0E7O0FBRUEsU0FBSyxXQUFMLEdBQW1CLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxRQUFmLEVBQXlCO0FBQ3hDLFlBQUksWUFBWSxJQUFoQixFQUFzQjtBQUNsQjtBQUNIOztBQUVELHNCQUFjLFNBQVMsU0FBdkIsRUFBa0MsV0FBbEMsQ0FBOEMsQ0FBOUMsRUFBaUQsQ0FBakQsRUFBb0QsUUFBcEQ7QUFDSCxLQU5EOztBQVFBLFNBQUssY0FBTCxHQUFzQixVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsUUFBZixFQUF5QjtBQUMzQyxZQUFJLFlBQVksSUFBaEIsRUFBc0I7QUFDbEI7QUFDSDs7QUFFRCxzQkFBYyxTQUFTLFNBQXZCLEVBQWtDLGNBQWxDLENBQWlELENBQWpELEVBQW9ELENBQXBELEVBQXVELFFBQXZEO0FBQ0gsS0FORDs7QUFRQSxTQUFLLFNBQUwsR0FBaUIsWUFBVztBQUN4QixZQUFJLFlBQVksSUFBaEIsRUFBc0I7QUFDbEI7QUFDSDs7QUFFRCxzQkFBYyxTQUFTLFNBQXZCLEVBQWtDLFNBQWxDO0FBQ0gsS0FORDs7QUFRQSxTQUFLLFFBQUwsR0FBZ0IsWUFBVztBQUN2QixlQUFPLE9BQU8sUUFBUCxFQUFQO0FBQ0gsS0FGRDs7QUFJQTs7Ozs7Ozs7QUFRQSxTQUFLLFVBQUwsR0FBa0IsVUFBUyxRQUFULEVBQW1CO0FBQ2pDLGFBQUssWUFBTDs7QUFFQSxlQUFPLE9BQU8sUUFBUCxDQUFnQixRQUFoQixDQUFQO0FBQ0gsS0FKRDs7QUFNQTs7OztBQUlBLFNBQUssZUFBTCxHQUF1QixZQUFXO0FBQzlCLGVBQU8sS0FBSyxhQUFMLE1BQXdCLENBQXhCLElBQTZCLEtBQUssUUFBTCxDQUFjLENBQWQsRUFBaUIsUUFBakIsTUFBK0IsR0FBbkU7QUFDSCxLQUZEOztBQUlBO0FBQ0E7O0FBRUE7Ozs7OztBQU1BLGFBQVMsV0FBVCxHQUF1QjtBQUNuQixZQUNJLE9BQU8sU0FBUyxLQUFULEVBRFg7QUFBQSxZQUVJLE9BQU8sV0FBVyxXQUFYLENBQXVCLFFBQXZCLEVBQWlDLElBQWpDLENBRlg7O0FBSUEsYUFBSyxLQUFMLEdBQWEsS0FBSyxtQkFBTCxFQUFiOztBQUVBLGlCQUFTLFNBQVQ7O0FBRUEsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQixpQkFBSyxRQUFMLENBQWMsS0FBSyxLQUFuQixFQUEwQixVQUExQixDQUFxQyxJQUFyQyxFQUEyQyxJQUEzQztBQUNBLGlDQUFxQixJQUFyQjtBQUNILFNBSEQ7O0FBS0EsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQixpQkFBSyxRQUFMLENBQWMsS0FBSyxLQUFuQixFQUEwQixVQUExQixDQUFxQyxJQUFyQyxFQUEyQyxJQUEzQztBQUNBLGlDQUFxQixJQUFyQjtBQUNILFNBSEQ7O0FBS0EsYUFBSyxhQUFMLEdBQXFCLFVBQVMsTUFBVCxFQUFpQixLQUFqQixFQUF3QjtBQUN6QyxtQkFBTyxLQUFLLE1BQVo7QUFDSCxTQUZEO0FBR0g7O0FBRUQsZ0JBQVksU0FBWixHQUF3QixPQUFPLE1BQVAsQ0FBYyxpQkFBTyxTQUFyQixDQUF4QjtBQUNBLGdCQUFZLFNBQVosQ0FBc0IsV0FBdEIsR0FBb0MsV0FBcEM7O0FBRUEsYUFBUyxrQkFBVCxDQUE0QixXQUE1QixFQUF5QyxPQUF6QyxFQUFrRCxPQUFsRCxFQUEyRDtBQUN2RCxhQUFLLFVBQUwsR0FBa0IsV0FBbEI7QUFDQSxhQUFLLE1BQUwsR0FBYyxPQUFkO0FBQ0EsYUFBSyxNQUFMLEdBQWMsT0FBZDtBQUNIOztBQUVELHVCQUFtQixTQUFuQixHQUErQixPQUFPLE1BQVAsQ0FBYyxpQkFBTyxTQUFyQixDQUEvQjtBQUNBLHVCQUFtQixTQUFuQixDQUE2QixXQUE3QixHQUEyQyxrQkFBM0M7O0FBRUEsdUJBQW1CLFNBQW5CLENBQTZCLElBQTdCLEdBQW9DLFlBQVc7QUFDM0MsYUFBSyxRQUFMLENBQWMsS0FBSyxVQUFuQixFQUErQixPQUEvQixHQUF5QyxLQUFLLE1BQTlDOztBQUVBO0FBQ0EsaUNBQXlCLEtBQUssVUFBOUI7QUFDSCxLQUxEOztBQU9BLHVCQUFtQixTQUFuQixDQUE2QixJQUE3QixHQUFvQyxZQUFXO0FBQzNDLGFBQUssUUFBTCxDQUFjLEtBQUssVUFBbkIsRUFBK0IsT0FBL0IsR0FBeUMsS0FBSyxNQUE5Qzs7QUFFQTtBQUNBLGlDQUF5QixLQUFLLFVBQTlCO0FBQ0gsS0FMRDs7QUFPQSx1QkFBbUIsU0FBbkIsQ0FBNkIsS0FBN0IsR0FBcUMsVUFBUyxDQUFULEVBQVk7QUFDN0MsWUFBSSxhQUFhLGtCQUFiLElBQW1DLEtBQUssVUFBTCxJQUFtQixFQUFFLFVBQTVELEVBQXdFO0FBQ3BFLGlCQUFLLE1BQUwsR0FBYyxFQUFFLE1BQWhCO0FBQ0EsbUJBQU8sSUFBUDtBQUNIO0FBQ0QsZUFBTyxLQUFQO0FBQ0gsS0FORDs7QUFRQSx1QkFBbUIsU0FBbkIsQ0FBNkIsUUFBN0IsR0FBd0MsWUFBVztBQUMvQyxlQUFPLEtBQUssTUFBTCxJQUFlLEtBQUssTUFBM0I7QUFDSCxLQUZEOztBQUlBLGFBQVMsY0FBVCxDQUF3QixVQUF4QixFQUFvQztBQUNoQyxhQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLG1CQUFPLE1BQVAsQ0FBYyxhQUFhLENBQTNCLEVBQThCLENBQTlCO0FBQ0EsaUJBQUssbUJBQUwsQ0FBeUIsVUFBekI7QUFDQTtBQUNBO0FBQ0gsU0FMRDs7QUFPQSxhQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLGdCQUNJLFdBQVcsc0JBQVksS0FBSyxLQUFqQixFQUF3QixLQUFLLE1BQTdCLEVBQXFDLEtBQUssbUJBQUwsRUFBckMsQ0FEZjtBQUVBLHFCQUFTLFFBQVQsQ0FBa0IsaUJBQWxCO0FBQ0EsbUJBQU8sTUFBUCxDQUFjLGFBQWEsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsUUFBakM7QUFDQSxpQkFBSyxtQkFBTCxDQUF5QixhQUFhLENBQXRDOztBQUVBO0FBQ0E7QUFDSCxTQVREO0FBVUg7O0FBRUQsbUJBQWUsU0FBZixHQUEyQixPQUFPLE1BQVAsQ0FBYyxpQkFBTyxTQUFyQixDQUEzQjtBQUNBLG1CQUFlLFNBQWYsQ0FBeUIsV0FBekIsR0FBdUMsY0FBdkM7O0FBRUEsYUFBUyxvQkFBVCxDQUE4QixVQUE5QixFQUEwQztBQUN0QyxhQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLG1CQUFPLE1BQVAsQ0FBYyxhQUFhLENBQTNCLEVBQThCLENBQTlCO0FBQ0EsaUJBQUssbUJBQUwsQ0FBeUIsVUFBekI7O0FBRUE7QUFDQTtBQUNILFNBTkQ7O0FBUUEsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQixnQkFDSSxhQUFhLE9BRGpCO0FBQUEsZ0JBR0ksY0FBYyxPQUFPLFVBQVAsQ0FIbEI7QUFBQSxnQkFJSSxXQUFXLHNCQUFZLEtBQUssS0FBakIsRUFBd0IsS0FBSyxNQUE3QixDQUpmO0FBQUEsZ0JBTUksZUFBZSxZQUFZLElBTi9COztBQVFBLGdCQUFJLENBQUMsYUFBYSxRQUFiLENBQXNCLFVBQXRCLENBQUwsRUFBd0M7QUFDcEMsZ0NBQWdCLFVBQWhCO0FBQ0g7O0FBRUQscUJBQVMsUUFBVCxDQUFrQixXQUFsQjtBQUNBLHFCQUFTLElBQVQsR0FBZ0IsWUFBaEI7O0FBRUEsbUJBQU8sTUFBUCxDQUFjLGFBQWEsQ0FBM0IsRUFBOEIsQ0FBOUIsRUFBaUMsUUFBakM7O0FBRUEsaUJBQUssbUJBQUwsQ0FBeUIsYUFBYSxDQUF0Qzs7QUFFQTtBQUNBO0FBQ0gsU0F0QkQ7QUF1Qkg7O0FBRUQseUJBQXFCLFNBQXJCLEdBQWlDLE9BQU8sTUFBUCxDQUFjLGlCQUFPLFNBQXJCLENBQWpDO0FBQ0EseUJBQXFCLFNBQXJCLENBQStCLFdBQS9CLEdBQTZDLG9CQUE3Qzs7QUFFQTs7OztBQUlBLGFBQVMsaUJBQVQsQ0FBMkIsVUFBM0IsRUFBdUMsS0FBdkMsRUFBOEM7QUFDMUMsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQixtQkFBTyxNQUFQLENBQWMsVUFBZCxFQUEwQixDQUExQixFQUE2QixLQUE3QjtBQUNBLGlCQUFLLG1CQUFMLENBQXlCLFVBQXpCOztBQUVBO0FBQ0E7QUFDSCxTQU5EOztBQVFBLGFBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsbUJBQU8sTUFBUCxDQUFjLFVBQWQsRUFBMEIsQ0FBMUI7QUFDQSxpQkFBSyxtQkFBTCxDQUF5QixhQUFhLE9BQU8sTUFBcEIsR0FBNkIsVUFBN0IsR0FBMEMsYUFBYSxDQUFoRjs7QUFFQTtBQUNBO0FBQ0gsU0FORDs7QUFRQSxhQUFLLGFBQUwsR0FBcUIsVUFBUyxNQUFULEVBQWlCO0FBQ2xDLG1CQUFPLFNBQVMsQ0FBVCxHQUFhLE1BQU0sS0FBTixHQUFjLE1BQU0sTUFBcEIsR0FBNkIscUJBQVcsZUFBNUQ7QUFDSCxTQUZEO0FBR0g7O0FBRUQsc0JBQWtCLFNBQWxCLEdBQThCLE9BQU8sTUFBUCxDQUFjLGlCQUFPLFNBQXJCLENBQTlCO0FBQ0Esc0JBQWtCLFNBQWxCLENBQTRCLFdBQTVCLEdBQTBDLGlCQUExQzs7QUFFQSxhQUFTLG9CQUFULENBQThCLFVBQTlCLEVBQTBDO0FBQ3RDLFlBQ0ksY0FBYyxzQkFBWSxLQUFLLEtBQWpCLEVBQXdCLEtBQUssTUFBN0IsQ0FEbEI7QUFBQSxZQUVJLFFBRko7O0FBSUEsb0JBQVksUUFBWixDQUFxQixPQUFPLGFBQWEsQ0FBcEIsQ0FBckI7QUFDQSxtQkFBVyxPQUFPLFVBQVAsQ0FBWDs7QUFFQSxhQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLG1CQUFPLGFBQWEsQ0FBcEIsRUFBdUIsUUFBdkIsQ0FBZ0MsV0FBaEM7QUFDQSxtQkFBTyxNQUFQLENBQWMsVUFBZCxFQUEwQixDQUExQixFQUE2QixRQUE3QjtBQUNBLGlCQUFLLG1CQUFMLENBQXlCLFVBQXpCOztBQUVBLDBCQUFjLFdBQVcsSUFBekI7O0FBRUE7QUFDQTtBQUNILFNBVEQ7O0FBV0EsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQiwwQkFBYyxzQkFBWSxLQUFLLEtBQWpCLEVBQXdCLEtBQUssTUFBN0IsQ0FBZDtBQUNBLHdCQUFZLFFBQVosQ0FBcUIsT0FBTyxhQUFhLENBQXBCLENBQXJCO0FBQ0EsdUJBQVcsT0FBTyxVQUFQLENBQVg7O0FBRUEsaUJBQUssbUJBQUwsQ0FBeUIsVUFBekI7QUFDQSxpQkFBSyxTQUFMLENBQWUsS0FBZjtBQUNILFNBUEQ7O0FBU0EsYUFBSyxhQUFMLEdBQXFCLFVBQVMsTUFBVCxFQUFpQixLQUFqQixFQUF3QjtBQUN6QyxtQkFBTyxTQUFTLENBQVQsR0FBYSxLQUFLLEtBQUwsR0FBYSxLQUFLLE1BQWxCLEdBQTJCLHFCQUFXLGVBQXRDLEdBQXdELENBQTVFO0FBQ0gsU0FGRDtBQUdIOztBQUVELHlCQUFxQixTQUFyQixHQUFpQyxPQUFPLE1BQVAsQ0FBYyxpQkFBTyxTQUFyQixDQUFqQztBQUNBLHlCQUFxQixTQUFyQixDQUErQixXQUEvQixHQUE2QyxvQkFBN0M7O0FBRUEsYUFBUyxvQkFBVCxHQUFnQztBQUM1QixZQUNJLHNCQUFzQixLQUFLLG1CQUFMLEVBRDFCO0FBQUEsWUFFSSxZQUFZLE9BQU8sS0FBUCxDQUFhLENBQWIsQ0FGaEIsQ0FENEIsQ0FHSzs7QUFFakMsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQixxQkFBUyxVQUFVLEtBQVYsQ0FBZ0IsQ0FBaEIsQ0FBVDtBQUNBLGlCQUFLLG1CQUFMLENBQXlCLG1CQUF6Qjs7QUFFQTtBQUNBO0FBQ0gsU0FORDs7QUFRQSxhQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLGlCQUFLLGNBQUwsQ0FBb0IsS0FBcEI7QUFDSCxTQUZEOztBQUlBLGFBQUssYUFBTCxHQUFxQixVQUFTLE1BQVQsRUFBaUIsS0FBakIsRUFBd0I7QUFDekMsbUJBQU8sU0FBUyxDQUFULEdBQWEsVUFBVSxNQUFWLEdBQW1CLEtBQW5CLEdBQTJCLE1BQTNCLEdBQW9DLHFCQUFXLGVBQW5FO0FBQ0gsU0FGRDtBQUdIOztBQUVELHlCQUFxQixTQUFyQixHQUFpQyxPQUFPLE1BQVAsQ0FBYyxpQkFBTyxTQUFyQixDQUFqQztBQUNBLHlCQUFxQixTQUFyQixDQUErQixXQUEvQixHQUE2QyxvQkFBN0M7O0FBRUEsYUFBUyxlQUFULENBQXlCLElBQXpCLEVBQStCLEVBQS9CLEVBQW1DO0FBQy9CLGFBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsZ0JBQUksTUFBTSxJQUFWLEVBQWdCO0FBQ1osOEJBQWMsRUFBZCxFQUFrQixPQUFPLENBQXpCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsOEJBQWMsS0FBSyxDQUFuQixFQUFzQixJQUF0QjtBQUNIO0FBQ0osU0FORDs7QUFRQSxhQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLDBCQUFjLElBQWQsRUFBb0IsRUFBcEI7QUFDSCxTQUZEO0FBR0g7O0FBRUQsb0JBQWdCLFNBQWhCLEdBQTRCLE9BQU8sTUFBUCxDQUFjLGlCQUFPLFNBQXJCLENBQTVCO0FBQ0Esb0JBQWdCLFNBQWhCLENBQTBCLFdBQTFCLEdBQXdDLGVBQXhDOztBQUVBLGFBQVMsZ0JBQVQsQ0FBMEIsVUFBMUIsRUFBc0MsS0FBdEMsRUFBNkM7QUFDekMsYUFBSyxJQUFMLEdBQVksS0FBSyxRQUFMLENBQWMsVUFBZCxFQUEwQixRQUExQixFQUFaO0FBQ0EsYUFBSyxFQUFMLEdBQVUsS0FBVjtBQUNBLGFBQUssVUFBTCxHQUFrQixVQUFsQjtBQUNIOztBQUVELHFCQUFpQixTQUFqQixHQUE2QixPQUFPLE1BQVAsQ0FBYyxpQkFBTyxTQUFyQixDQUE3QjtBQUNBLHFCQUFpQixTQUFqQixDQUEyQixXQUEzQixHQUF5QyxnQkFBekM7O0FBRUEscUJBQWlCLFNBQWpCLENBQTJCLElBQTNCLEdBQWtDLFlBQVc7QUFDekMsYUFBSyxRQUFMLENBQWMsS0FBSyxVQUFuQixFQUErQixRQUEvQixDQUF3QyxLQUFLLElBQTdDOztBQUVBO0FBQ0EsaUNBQXlCLEtBQUssVUFBOUI7QUFDSCxLQUxEOztBQU9BLHFCQUFpQixTQUFqQixDQUEyQixJQUEzQixHQUFrQyxZQUFXO0FBQ3pDLGFBQUssUUFBTCxDQUFjLEtBQUssVUFBbkIsRUFBK0IsUUFBL0IsQ0FBd0MsS0FBSyxFQUE3Qzs7QUFFQTtBQUNBLGlDQUF5QixLQUFLLFVBQTlCO0FBQ0gsS0FMRDs7QUFPQSxxQkFBaUIsU0FBakIsQ0FBMkIsS0FBM0IsR0FBbUMsVUFBUyxDQUFULEVBQVk7QUFDM0MsWUFBSSxhQUFhLGdCQUFiLElBQWlDLEtBQUssVUFBTCxJQUFtQixFQUFFLFVBQTFELEVBQXNFO0FBQ2xFLGlCQUFLLEVBQUwsR0FBVSxFQUFFLEVBQVo7QUFDQSxtQkFBTyxJQUFQO0FBQ0g7QUFDRCxlQUFPLEtBQVA7QUFDSCxLQU5EOztBQVFBLHFCQUFpQixTQUFqQixDQUEyQixRQUEzQixHQUFzQyxZQUFXO0FBQzdDLGVBQU8sS0FBSyxJQUFMLElBQWEsS0FBSyxFQUF6QjtBQUNILEtBRkQ7O0FBSUEsYUFBUyxlQUFULENBQXlCLFVBQXpCLEVBQXFDLEVBQXJDLEVBQXlDO0FBQ3JDLGFBQUssVUFBTCxHQUFrQixVQUFsQjtBQUNBLGFBQUssSUFBTCxHQUFZLEtBQUssUUFBTCxDQUFjLFVBQWQsRUFBMEIsWUFBMUIsRUFBWjtBQUNBLGFBQUssRUFBTCxHQUFVLEVBQVY7QUFDSDs7QUFFRCxvQkFBZ0IsU0FBaEIsR0FBNEIsT0FBTyxNQUFQLENBQWMsaUJBQU8sU0FBckIsQ0FBNUI7QUFDQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsV0FBMUIsR0FBd0MsZUFBeEM7O0FBRUEsb0JBQWdCLFNBQWhCLENBQTBCLElBQTFCLEdBQWlDLFlBQVc7QUFDeEMsYUFBSyxRQUFMLENBQWMsS0FBSyxVQUFuQixFQUErQixZQUEvQixDQUE0QyxLQUFLLElBQWpEOztBQUVBO0FBQ0E7QUFDSCxLQUxEOztBQU9BLG9CQUFnQixTQUFoQixDQUEwQixJQUExQixHQUFpQyxZQUFXO0FBQ3hDLGFBQUssUUFBTCxDQUFjLEtBQUssVUFBbkIsRUFBK0IsWUFBL0IsQ0FBNEMsS0FBSyxFQUFqRDs7QUFFQTtBQUNBO0FBQ0gsS0FMRDs7QUFPQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsS0FBMUIsR0FBa0MsVUFBUyxDQUFULEVBQVk7QUFDMUMsWUFBSSxhQUFhLGVBQWIsSUFBZ0MsS0FBSyxVQUFMLElBQW1CLEVBQUUsVUFBekQsRUFBcUU7QUFDakUsaUJBQUssRUFBTCxHQUFVLEVBQUUsRUFBWjtBQUNBLG1CQUFPLElBQVA7QUFDSDtBQUNELGVBQU8sS0FBUDtBQUNILEtBTkQ7O0FBUUEsb0JBQWdCLFNBQWhCLENBQTBCLFFBQTFCLEdBQXFDLFlBQVc7QUFDNUMsZUFBTyxLQUFLLElBQUwsSUFBYSxLQUFLLEVBQXpCO0FBQ0gsS0FGRDs7QUFJQSxhQUFTLGlCQUFULENBQTJCLFVBQTNCLEVBQXVDLEVBQXZDLEVBQTJDO0FBQ3ZDLGFBQUssVUFBTCxHQUFrQixVQUFsQjtBQUNBLGFBQUssRUFBTCxHQUFVLEVBQVY7QUFDQSxhQUFLLElBQUwsR0FBWSxLQUFLLFFBQUwsQ0FBYyxVQUFkLEVBQTBCLElBQXRDO0FBQ0g7O0FBRUQsc0JBQWtCLFNBQWxCLEdBQThCLE9BQU8sTUFBUCxDQUFjLGlCQUFPLFNBQXJCLENBQTlCO0FBQ0Esc0JBQWtCLFNBQWxCLENBQTRCLFdBQTVCLEdBQTBDLGlCQUExQzs7QUFFQSxzQkFBa0IsU0FBbEIsQ0FBNEIsSUFBNUIsR0FBbUMsWUFBVztBQUMxQyxhQUFLLFFBQUwsQ0FBYyxLQUFLLFVBQW5CLEVBQStCLElBQS9CLEdBQXNDLEtBQUssSUFBM0M7QUFDQSxpQ0FBeUIsS0FBSyxVQUE5QjtBQUNILEtBSEQ7O0FBS0Esc0JBQWtCLFNBQWxCLENBQTRCLElBQTVCLEdBQW1DLFlBQVc7QUFDMUMsYUFBSyxRQUFMLENBQWMsS0FBSyxVQUFuQixFQUErQixJQUEvQixHQUFzQyxLQUFLLEVBQTNDO0FBQ0EsaUNBQXlCLEtBQUssVUFBOUI7QUFDSCxLQUhEOztBQUtBLHNCQUFrQixTQUFsQixDQUE0QixLQUE1QixHQUFvQyxVQUFTLENBQVQsRUFBWTtBQUM1QyxZQUFJLGFBQWEsaUJBQWIsSUFBa0MsS0FBSyxVQUFMLElBQW1CLEVBQUUsVUFBM0QsRUFBdUU7QUFDbkUsaUJBQUssRUFBTCxHQUFVLEVBQUUsRUFBWjtBQUNBLG1CQUFPLElBQVA7QUFDSDtBQUNELGVBQU8sS0FBUDtBQUNILEtBTkQ7O0FBUUEsc0JBQWtCLFNBQWxCLENBQTRCLFFBQTVCLEdBQXVDLFlBQVc7QUFDOUMsZUFBTyxLQUFLLElBQUwsSUFBYSxLQUFLLEVBQXpCO0FBQ0gsS0FGRDs7QUFJQTs7OztBQUlBLGFBQVMsd0JBQVQsQ0FBa0MsSUFBbEMsRUFBd0MsRUFBeEMsRUFBNEM7QUFDeEMsZUFBTyxLQUFLLEtBQUwsRUFBUDtBQUNBLGFBQUssR0FBRyxLQUFILEVBQUw7O0FBRUEsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQixpQkFBSyxZQUFMLENBQWtCLElBQWxCO0FBQ0Esc0NBQTBCLEtBQUssU0FBTCxFQUExQjtBQUNILFNBSEQ7O0FBS0EsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQixpQkFBSyxZQUFMLENBQWtCLEVBQWxCO0FBQ0Esc0NBQTBCLEtBQUssU0FBTCxFQUExQjtBQUNILFNBSEQ7O0FBS0EsYUFBSyxRQUFMLEdBQWdCLFlBQVc7QUFDdkIsbUJBQU8sS0FBSyxNQUFMLENBQVksRUFBWixDQUFQO0FBQ0gsU0FGRDtBQUdIOztBQUVELDZCQUF5QixTQUF6QixHQUFxQyxPQUFPLE1BQVAsQ0FBYyxpQkFBTyxTQUFyQixDQUFyQztBQUNBLDZCQUF5QixTQUF6QixDQUFtQyxXQUFuQyxHQUFpRCx3QkFBakQ7O0FBRUE7Ozs7Ozs7QUFPQSxhQUFTLDBCQUFULENBQW9DLE9BQXBDLEVBQTZDLGVBQTdDLEVBQThELGFBQTlELEVBQTZFO0FBQ3pFLFlBQ0ksZ0JBQWdCLEtBQUssWUFBTCxFQURwQjtBQUFBLFlBRUksVUFBVSxJQUZkO0FBQUEsWUFJSSxhQUFhLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUpqQjtBQUFBLFlBS0ksb0JBQW9CLFdBQVcsVUFBWCxDQUFzQixJQUF0QixDQUx4QjtBQUFBLFlBT0ksUUFQSjtBQUFBLFlBT2M7QUFDVixvQkFSSjs7O0FBVUk7QUFDQSx5QkFBaUIsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBWHJCO0FBQUEsWUFZSSx3QkFBd0IsZUFBZSxVQUFmLENBQTBCLElBQTFCLENBWjVCOztBQWNBLDBCQUFrQixnQkFBZ0IsS0FBaEIsRUFBbEI7QUFDQSx3QkFBZ0IsaUJBQWlCLFFBQWpDOztBQUVBLGFBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsZ0JBQ0ksUUFBUSxLQUFLLFFBQUwsQ0FBYyxLQUFLLFVBQW5CLENBRFo7QUFBQSxnQkFFSSxtQkFBbUIsUUFBUSxLQUFSLEVBRnZCO0FBQUEsZ0JBR0ksYUFISjs7QUFLQSw2QkFBaUIsS0FBakIsQ0FBdUIsT0FBdkI7O0FBRUEsNEJBQWdCLGlCQUFpQixLQUFqQixFQUFoQjtBQUNBLDBCQUFjLFNBQWQsQ0FBd0IsQ0FBQyxhQUFhLElBQXRDLEVBQTRDLENBQUMsYUFBYSxHQUExRDs7QUFFQSxrQkFBTSxjQUFOLENBQXFCLFFBQXJCLEVBQStCLGlCQUFpQixJQUFoRCxFQUFzRCxpQkFBaUIsR0FBdkUsRUFBNEUsYUFBNUU7O0FBRUEsaUJBQUssWUFBTCxDQUFrQixhQUFsQjtBQUNBLGlCQUFLLG1CQUFMLENBQXlCLEtBQUssVUFBOUI7O0FBRUEsaUNBQXFCLGdCQUFyQjs7QUFFQTs7OztBQUlBO0FBQ0gsU0F2QkQ7O0FBeUJBLGFBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsZ0JBQ0ksUUFBUSxLQUFLLFFBQUwsQ0FBYyxLQUFLLFVBQW5CLENBRFo7O0FBR0E7QUFDQSxrQ0FBc0IsWUFBdEIsQ0FBbUMsTUFBTSxZQUFOLEVBQW5DLEVBQXlELENBQXpELEVBQTRELENBQTVEOztBQUVBO0FBQ0Esa0NBQXNCLFNBQXRCLENBQWdDLFFBQVEsSUFBeEMsRUFBOEMsUUFBUSxHQUF0RCxFQUEyRCxRQUFRLFFBQVIsRUFBM0QsRUFBK0UsUUFBUSxTQUFSLEVBQS9FOztBQUVBLG9EQUF1QixxQkFBdkIsRUFBOEMsaUJBQWlCLFFBQS9EOztBQUVBLGtDQUFzQixJQUF0Qjs7QUFFQTtBQUNBLGtDQUFzQixZQUF0QixDQUNJLGdCQUFnQixDQUFoQixDQUFrQixDQUFsQixDQURKLEVBQzBCLGdCQUFnQixDQUFoQixDQUFrQixDQUFsQixDQUQxQixFQUNnRCxnQkFBZ0IsQ0FBaEIsQ0FBa0IsQ0FBbEIsQ0FEaEQsRUFFSSxnQkFBZ0IsQ0FBaEIsQ0FBa0IsQ0FBbEIsQ0FGSixFQUUwQixnQkFBZ0IsQ0FBaEIsQ0FBa0IsQ0FBbEIsQ0FGMUIsRUFFZ0QsZ0JBQWdCLENBQWhCLENBQWtCLENBQWxCLENBRmhEO0FBSUEsa0NBQXNCLFNBQXRCLENBQWdDLFVBQWhDLEVBQTRDLFFBQVEsSUFBcEQsRUFBMEQsUUFBUSxHQUFsRTs7QUFFQSxrQ0FBc0IsT0FBdEI7O0FBRUE7QUFDQSxrQkFBTSxZQUFOLENBQW1CLHNCQUFzQixZQUF0QixDQUFtQyxDQUFuQyxFQUFzQyxDQUF0QyxFQUF5QyxNQUFNLEtBQS9DLEVBQXNELE1BQU0sTUFBNUQsQ0FBbkI7O0FBRUE7QUFDQSxnQkFDSSxtQkFBbUIsUUFBUSxLQUFSLEVBRHZCO0FBQUEsZ0JBRUksYUFBYSxRQUFRLFFBQVIsRUFGakI7O0FBSUEsNEJBQWdCLGVBQWhCLENBQWdDLFVBQWhDOztBQUVBLHNCQUFVLGlCQUFPLGlCQUFQLENBQXlCLFVBQXpCLENBQVY7QUFDQSxvQkFBUSxZQUFSO0FBQ0Esa0JBQU0sU0FBTixHQUFrQixJQUFsQixDQUF1QixPQUF2Qjs7QUFFQSw2QkFBaUIsS0FBakIsQ0FBdUIsT0FBdkI7O0FBRUEsaUNBQXFCLGdCQUFyQjs7QUFFQTtBQUNBLGdCQUFJLENBQUMsY0FBYyxPQUFkLEVBQUwsRUFBOEI7QUFDMUIsb0JBQ0ksb0JBQW9CLGNBQWMsUUFBZCxFQUR4QjtBQUFBLG9CQUVJLGVBRko7O0FBSUEsZ0NBQWdCLGVBQWhCLENBQWdDLGlCQUFoQzs7QUFFQSxrQ0FBa0IsaUJBQU8saUJBQVAsQ0FBeUIsaUJBQXpCLENBQWxCO0FBQ0EsZ0NBQWdCLFlBQWhCO0FBQ0Esc0JBQU0sU0FBTixHQUFrQixJQUFsQixDQUF1QixlQUF2Qjs7QUFFQSxxQkFBSyxZQUFMLENBQWtCLGVBQWxCO0FBQ0E7QUFDSDtBQUNKLFNBeEREOztBQTBEQTs7Ozs7QUFLQSxhQUFLLEtBQUwsR0FBYSxVQUFTLGdCQUFULEVBQTJCO0FBQ3BDLGdCQUNJLFFBQVEsS0FBSyxRQUFMLENBQWMsS0FBSyxVQUFuQixDQURaOztBQUdBLGlCQUFLLElBQUw7O0FBRUEsZ0JBQUksYUFBYSxRQUFiLEtBQTBCLE1BQU0sS0FBaEMsSUFBeUMsYUFBYSxTQUFiLEtBQTJCLE1BQU0sTUFBOUUsRUFBc0Y7QUFDbEY7Ozs7QUFJQSwyQkFBVyxNQUFNLEtBQU4sRUFBWDtBQUNBLCtCQUFlLE1BQU0sU0FBTixFQUFmO0FBQ0g7O0FBRUQsOEJBQWtCLGlCQUFpQixLQUFqQixFQUFsQjtBQUNBLGlCQUFLLElBQUw7QUFDSCxTQWpCRDs7QUFtQkEsYUFBSyxnQkFBTCxHQUF3QixVQUFTLGdCQUFULEVBQTJCO0FBQy9DLGdCQUFJLG9CQUFvQixhQUF4QixFQUF1QztBQUNuQyxnQ0FBZ0IsZ0JBQWhCOztBQUVBLHFCQUFLLElBQUw7QUFDQSxxQkFBSyxJQUFMO0FBQ0g7QUFDSixTQVBEOztBQVNBOzs7O0FBSUEsYUFBSyxPQUFMLEdBQWUsWUFBVztBQUN0QixnQkFDSSxRQUFRLEtBQUssUUFBTCxDQUFjLEtBQUssVUFBbkIsQ0FEWjs7QUFHQTtBQUNBLGdCQUFJLGFBQWEsUUFBYixNQUEyQixNQUFNLEtBQWpDLElBQTBDLGFBQWEsU0FBYixNQUE0QixNQUFNLE1BQWhGLEVBQXdGO0FBQ3BGLG9CQUNJLFlBQVksUUFBUSxRQUFSLENBQWlCLE9BQWpCLENBRGhCOztBQUdBLG9CQUFJLFVBQVUsT0FBVixLQUFzQixDQUF0QixHQUEwQixNQUFNLEtBQU4sR0FBYyxNQUFNLE1BQWxELEVBQTBEO0FBQ3RELG1DQUFlLFNBQWY7QUFDQSwrQkFBVyxTQUFTLFNBQVQsQ0FBbUIsWUFBbkIsQ0FBWDtBQUNIO0FBQ0o7QUFDSixTQWREOztBQWdCQSxhQUFLLGFBQUwsR0FBcUIsVUFBUyxNQUFULEVBQWlCLEtBQWpCLEVBQXdCO0FBQ3pDLG1CQUFPLFNBQVMsYUFBVCxFQUFQO0FBQ0gsU0FGRDs7QUFJSDs7O0FBR0csYUFBSyxZQUFMLEdBQW9CLFlBQVc7QUFDM0IsbUJBQU8sZ0JBQWdCLEtBQWhCLEVBQVA7QUFDSCxTQUZEOztBQUlBOzs7OztBQUtBLGFBQUssdUJBQUwsR0FBK0IsWUFBVztBQUN0QyxtQkFBTyxRQUFRLEtBQVIsRUFBUDtBQUNILFNBRkQ7O0FBSUE7Ozs7OztBQU1BLGFBQUssdUJBQUwsR0FBK0IsWUFBVztBQUN0QyxtQkFBTyxjQUFjLEtBQWQsRUFBUDtBQUNILFNBRkQ7O0FBSUEsYUFBSyxVQUFMLEdBQWtCLEtBQUssbUJBQUwsRUFBbEI7O0FBRUEsWUFDSSxRQUFRLEtBQUssUUFBTCxDQUFjLEtBQUssVUFBbkIsQ0FEWjs7QUFHQSxtQkFBVyxNQUFNLEtBQU4sRUFBWDtBQUNBLHVCQUFlLE1BQU0sU0FBTixFQUFmO0FBQ0EsdUJBQWUsS0FBZixHQUF1QixNQUFNLEtBQTdCO0FBQ0EsdUJBQWUsTUFBZixHQUF3QixNQUFNLE1BQTlCOztBQUVBO0FBQ0EsbUJBQVcsS0FBWCxHQUFtQixRQUFRLFFBQVIsRUFBbkI7QUFDQSxtQkFBVyxNQUFYLEdBQW9CLFFBQVEsU0FBUixFQUFwQjtBQUNBLDBCQUFrQixZQUFsQixDQUErQixTQUFTLFlBQVQsRUFBL0IsRUFBd0QsQ0FBQyxRQUFRLElBQWpFLEVBQXVFLENBQUMsUUFBUSxHQUFoRixFQUFxRixRQUFRLElBQTdGLEVBQW1HLFFBQVEsR0FBM0csRUFBZ0gsUUFBUSxRQUFSLEVBQWhILEVBQW9JLFFBQVEsU0FBUixFQUFwSTs7QUFFQSxhQUFLLElBQUw7QUFDSDs7QUFFRCwrQkFBMkIsU0FBM0IsR0FBdUMsT0FBTyxNQUFQLENBQWMsaUJBQU8sU0FBckIsQ0FBdkM7QUFDQSwrQkFBMkIsU0FBM0IsQ0FBcUMsV0FBckMsR0FBbUQsMEJBQW5EOztBQUVBOzs7Ozs7Ozs7O0FBVUEsYUFBUyxxQkFBVCxDQUErQixPQUEvQixFQUF3QyxPQUF4QyxFQUFpRCxPQUFqRCxFQUEwRCxJQUExRCxFQUFnRTtBQUM1RCxZQUNJLGdCQUFnQixLQUFLLFlBQUwsRUFEcEI7QUFBQSxZQUVJLFVBQVUsSUFGZDtBQUFBLFlBSUksUUFKSjtBQUFBLFlBSWM7QUFDVixrQkFBVSxJQUxkO0FBQUEsWUFLb0I7QUFDaEIsa0JBQVUsSUFOZCxDQU1tQjtBQU5uQjs7QUFTQSxhQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLGdCQUNJLFFBQVEsS0FBSyxRQUFMLENBQWMsS0FBSyxVQUFuQixDQURaO0FBQUEsZ0JBRUksbUJBQW1CLFFBQVEsS0FBUixFQUZ2Qjs7QUFJQSxnQkFBSSxDQUFDLElBQUwsRUFBVztBQUNQLGlDQUFpQixLQUFqQixDQUF1QixPQUF2QjtBQUNIOztBQUVELGdCQUFJLFFBQUosRUFBYztBQUNWLHNCQUFNLGNBQU4sQ0FBcUIsUUFBckIsRUFBK0IsaUJBQWlCLElBQWhELEVBQXNELGlCQUFpQixHQUF2RSxFQUE0RSxnQkFBNUU7QUFDSCxhQUZELE1BRU87QUFDSCxzQkFBTSxjQUFOLENBQXFCLE9BQXJCLEVBQThCLFFBQVEsSUFBdEMsRUFBNEMsUUFBUSxHQUFwRCxFQUF5RCxRQUFRLFNBQVIsRUFBekQ7O0FBRUEsb0JBQUksT0FBSixFQUFhO0FBQ1QsMEJBQU0sY0FBTixDQUFxQixPQUFyQixFQUE4QixRQUFRLElBQXRDLEVBQTRDLFFBQVEsR0FBcEQsRUFBeUQsUUFBUSxTQUFSLEVBQXpEO0FBQ0g7QUFDSjs7QUFFRCxpQkFBSyxZQUFMLENBQWtCLGFBQWxCO0FBQ0EsaUJBQUssbUJBQUwsQ0FBeUIsS0FBSyxVQUE5Qjs7QUFFQSxpQ0FBcUIsZ0JBQXJCOztBQUVBOzs7O0FBSUE7QUFDSCxTQTdCRDs7QUErQkEsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQixnQkFDSSxRQUFRLEtBQUssUUFBTCxDQUFjLEtBQUssVUFBbkIsQ0FEWjtBQUFBLGdCQUVJLG1CQUFtQixxQkFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUZ2Qjs7QUFJQSxnQkFBSSxDQUFDLElBQUwsRUFBVztBQUNQLHNCQUFNLFNBQU4sQ0FBZ0IsT0FBaEIsRUFBeUIsQ0FBekI7QUFDQSxpQ0FBaUIsR0FBakIsQ0FBcUIsT0FBckI7QUFDSDs7QUFFRCxzQkFBVSxRQUFRLEtBQVIsRUFBVjtBQUNBLG9CQUFRLFNBQVIsQ0FBa0IsT0FBbEIsRUFBMkIsT0FBM0I7QUFDQSxrQkFBTSxTQUFOLEdBQWtCLElBQWxCLENBQXVCLE9BQXZCOztBQUVBOzs7O0FBSUEsZ0JBQUksUUFBSixFQUFjO0FBQ1Ysc0JBQU0sY0FBTixDQUFxQixRQUFyQixFQUErQixPQUEvQixFQUF3QyxRQUFRLElBQWhELEVBQXNELFFBQVEsR0FBOUQ7QUFDSCxhQUZELE1BRU87QUFDSCxzQkFBTSxjQUFOLENBQXFCLE9BQXJCLEVBQThCLFFBQVEsU0FBUixFQUE5QixFQUFtRCxRQUFRLElBQTNELEVBQWlFLFFBQVEsR0FBekU7QUFDSDs7QUFFRCw2QkFBaUIsS0FBakIsQ0FBdUIsT0FBdkI7O0FBRUEsaUNBQXFCLGdCQUFyQjs7QUFFQSxnQkFBSSxDQUFDLGNBQWMsT0FBZCxFQUFMLEVBQThCO0FBQzFCLG9CQUNJLGNBQWMsY0FBYyxLQUFkLEVBRGxCO0FBRUEsNEJBQVksU0FBWixDQUFzQixPQUF0QixFQUErQixPQUEvQjtBQUNBLHFCQUFLLFlBQUwsQ0FBa0IsV0FBbEI7QUFDQTtBQUNIO0FBQ0osU0FuQ0Q7O0FBcUNBOzs7Ozs7QUFNQSxhQUFLLEtBQUwsR0FBYSxVQUFTLFFBQVQsRUFBbUIsUUFBbkIsRUFBNkI7QUFDdEMsZ0JBQ0ksUUFBUSxLQUFLLFFBQUwsQ0FBYyxLQUFLLFVBQW5CLENBRFo7O0FBR0EsZ0JBQUksUUFBSixFQUFjO0FBQ1Ysb0JBQUksSUFBSixFQUFVO0FBQ04seUJBQUssSUFBTDtBQUNILGlCQUZELE1BRU87QUFDSDs7OztBQUlBLDBCQUFNLGNBQU4sQ0FBcUIsUUFBckIsRUFBK0IsUUFBUSxJQUF2QyxFQUE2QyxRQUFRLEdBQXJELEVBQTBELE9BQTFEO0FBQ0EseUNBQXFCLE9BQXJCO0FBQ0g7QUFDSixhQVhELE1BV087QUFDSDs7O0FBR0EscUJBQUssSUFBTDs7QUFFQSwyQkFBVyxNQUFNLEtBQU4sRUFBWDtBQUNBLDBCQUFVLElBQVY7QUFDQSwwQkFBVSxJQUFWO0FBQ0g7O0FBRUQsdUJBQVcsUUFBWDtBQUNBLHVCQUFXLFFBQVg7QUFDQSxpQkFBSyxJQUFMO0FBQ0gsU0E3QkQ7O0FBK0JBOzs7O0FBSUEsYUFBSyxPQUFMLEdBQWUsWUFBVztBQUN0QixnQkFBSSxZQUFZLFFBQVEsT0FBUixLQUFvQixDQUFwQixHQUF3QixLQUFLLEtBQUwsR0FBYSxLQUFLLE1BQTFELEVBQWtFO0FBQzlEOztBQUVBLDBCQUFVLFNBQVMsU0FBVCxDQUFtQixPQUFuQixDQUFWOztBQUVBLG9CQUFJLENBQUMsSUFBRCxJQUFTLFFBQVEsUUFBUixDQUFpQixPQUFqQixDQUFiLEVBQXdDO0FBQ3BDLDhCQUFVLElBQVY7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsOEJBQVUsU0FBUyxTQUFULENBQW1CLE9BQW5CLENBQVY7QUFDSDs7QUFFRCwyQkFBVyxJQUFYO0FBQ0g7QUFDSixTQWREOztBQWdCQSxhQUFLLGFBQUwsR0FBcUIsWUFBVztBQUM1QixnQkFDSSxPQUFPLENBRFg7O0FBR0EsZ0JBQUksUUFBSixFQUFjO0FBQ1Ysd0JBQVEsU0FBUyxhQUFULEVBQVI7QUFDSDtBQUNELGdCQUFJLE9BQUosRUFBYTtBQUNULHdCQUFRLFFBQVEsYUFBUixFQUFSO0FBQ0g7QUFDRCxnQkFBSSxPQUFKLEVBQWE7QUFDVCx3QkFBUSxRQUFRLGFBQVIsRUFBUjtBQUNIOztBQUVELG1CQUFPLElBQVA7QUFDSCxTQWZEOztBQWlCQSxhQUFLLFVBQUwsR0FBa0IsS0FBSyxtQkFBTCxFQUFsQjtBQUNBLG1CQUFXLEtBQUssUUFBTCxDQUFjLEtBQUssVUFBbkIsRUFBK0IsS0FBL0IsRUFBWDs7QUFFQSxhQUFLLElBQUw7QUFDSDs7QUFFRCwwQkFBc0IsU0FBdEIsR0FBa0MsT0FBTyxNQUFQLENBQWMsaUJBQU8sU0FBckIsQ0FBbEM7QUFDQSwwQkFBc0IsU0FBdEIsQ0FBZ0MsV0FBaEMsR0FBOEMscUJBQTlDOztBQUVBOzs7OztBQUtBLGFBQVMsV0FBVCxDQUFxQixNQUFyQixFQUE2QjtBQUN6QixhQUFLLE1BQUwsR0FBYyxNQUFkO0FBQ0g7O0FBRUQsZ0JBQVksU0FBWixHQUF3QixPQUFPLE1BQVAsQ0FBYyxpQkFBTyxTQUFyQixDQUF4QjtBQUNBLGdCQUFZLFNBQVosQ0FBc0IsV0FBdEIsR0FBb0MsV0FBcEM7O0FBRUEsZ0JBQVksU0FBWixDQUFzQixJQUF0QixHQUE2QixZQUFXO0FBQ3BDLGFBQUssSUFBSSxJQUFJLEtBQUssTUFBTCxDQUFZLE1BQVosR0FBcUIsQ0FBbEMsRUFBcUMsS0FBSyxDQUExQyxFQUE2QyxHQUE3QyxFQUFrRDtBQUM5QyxpQkFBSyxNQUFMLENBQVksQ0FBWixFQUFlLElBQWY7QUFDSDtBQUNKLEtBSkQ7O0FBTUEsZ0JBQVksU0FBWixDQUFzQixJQUF0QixHQUE2QixZQUFXO0FBQ3BDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQUwsQ0FBWSxNQUFoQyxFQUF3QyxHQUF4QyxFQUE2QztBQUN6QyxpQkFBSyxNQUFMLENBQVksQ0FBWixFQUFlLElBQWY7QUFDSDtBQUNKLEtBSkQ7O0FBTUEsZ0JBQVksU0FBWixDQUFzQixRQUF0QixHQUFpQyxZQUFXO0FBQ3hDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQTNCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLGdCQUFJLENBQUMsT0FBTyxDQUFQLEVBQVUsUUFBVixFQUFMLEVBQTJCO0FBQ3ZCLHVCQUFPLEtBQVA7QUFDSDtBQUNKOztBQUVELGVBQU8sSUFBUDtBQUNILEtBUkQ7O0FBVUEsZ0JBQVksU0FBWixDQUFzQixhQUF0QixHQUFzQyxVQUFTLE1BQVQsRUFBaUIsS0FBakIsRUFBd0I7QUFDMUQsWUFDSSxRQUFRLENBRFo7O0FBR0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDcEMscUJBQVMsT0FBTyxDQUFQLEVBQVUsYUFBVixDQUF3QixNQUF4QixFQUFnQyxLQUFoQyxDQUFUO0FBQ0g7O0FBRUQsZUFBTyxLQUFQO0FBQ0gsS0FURDs7QUFXQTs7Ozs7OztBQU9BLGFBQVMsU0FBVCxDQUFtQixHQUFuQixFQUF3QixVQUF4QixFQUFvQyxTQUFwQyxFQUErQztBQUMzQyxvQkFBWSxVQUFVLEtBQVYsRUFBWjs7QUFFQSxhQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLGlCQUFLLG1CQUFMLENBQXlCLFVBQXpCO0FBQ0EscUJBQVMsY0FBVCxDQUF3QixHQUF4QixFQUE2QixVQUFVLElBQXZDLEVBQTZDLFVBQVUsR0FBdkQsRUFBNEQsSUFBSSxTQUFKLEVBQTVEO0FBQ0EsaUJBQUssWUFBTCxDQUFrQixTQUFsQjtBQUNBLGlDQUFxQixTQUFyQjtBQUNILFNBTEQ7O0FBT0EsYUFBSyxJQUFMLEdBQVksWUFBVztBQUNuQixpQkFBSyxtQkFBTCxDQUF5QixVQUF6QjtBQUNBLHFCQUFTLFNBQVQsQ0FBbUIsU0FBbkIsRUFBOEIsaUJBQTlCO0FBQ0EsaUJBQUssY0FBTDtBQUNBLGlDQUFxQixTQUFyQjtBQUNILFNBTEQ7O0FBT0EsYUFBSyxhQUFMLEdBQXFCLFVBQVMsTUFBVCxFQUFpQixLQUFqQixFQUF3QjtBQUN6QyxtQkFBTyxPQUFPLEtBQVAsR0FBZSxDQUFmLEdBQW1CLElBQUksS0FBSixHQUFZLElBQUksTUFBaEIsR0FBeUIscUJBQVcsZUFBOUQ7QUFDSCxTQUZEO0FBR0g7O0FBRUQsY0FBVSxTQUFWLEdBQXNCLE9BQU8sTUFBUCxDQUFjLGlCQUFPLFNBQXJCLENBQXRCO0FBQ0EsY0FBVSxTQUFWLENBQW9CLFdBQXBCLEdBQWtDLFNBQWxDOztBQUVBOzs7Ozs7O0FBT0EsYUFBUyxXQUFULENBQXFCLElBQXJCLEVBQTJCLFVBQTNCLEVBQXVDLFNBQXZDLEVBQWtEO0FBQzlDLG9CQUFZLFVBQVUsS0FBVixFQUFaOztBQUVBLGFBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsbUJBQU8sTUFBUCxDQUFjLGFBQWEsQ0FBM0IsRUFBOEIsQ0FBOUI7O0FBRUEsaUJBQUssbUJBQUwsQ0FBeUIsVUFBekI7QUFDQSxpQkFBSyxZQUFMLENBQWtCLFNBQWxCOztBQUVBLGlDQUFxQixTQUFyQjtBQUNBO0FBQ0gsU0FSRDs7QUFVQSxhQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLGlCQUFLLG1CQUFMLENBQXlCLFVBQXpCO0FBQ0Esc0JBQVUsS0FBVixFQUFpQixJQUFqQjtBQUNILFNBSEQ7O0FBS0EsYUFBSyxhQUFMLEdBQXFCLFVBQVMsTUFBVCxFQUFpQixLQUFqQixFQUF3QjtBQUN6QyxtQkFBTyxLQUFLLEdBQUwsSUFBWSxLQUFaLEdBQW9CLENBQXBCLEdBQXdCLEtBQUssR0FBTCxDQUFTLEtBQVQsR0FBaUIsS0FBSyxHQUFMLENBQVMsTUFBMUIsR0FBbUMsQ0FBbEU7QUFDSCxTQUZEO0FBR0g7O0FBRUQsZ0JBQVksU0FBWixHQUF3QixPQUFPLE1BQVAsQ0FBYyxpQkFBTyxTQUFyQixDQUF4QjtBQUNBLGdCQUFZLFNBQVosQ0FBc0IsV0FBdEIsR0FBb0MsV0FBcEM7QUFDSDs7QUFFRCxVQUFVLFNBQVYsR0FBc0IsT0FBTyxNQUFQLENBQWMsYUFBYSxTQUEzQixDQUF0QjtBQUNBLFVBQVUsU0FBVixDQUFvQixXQUFwQixHQUFrQyxTQUFsQzs7QUFFQSxVQUFVLFNBQVYsQ0FBb0IsU0FBcEIsR0FBZ0MsWUFBVztBQUN2QyxXQUFPLHFCQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLEtBQUssS0FBdEIsRUFBNkIsS0FBSyxNQUFsQyxDQUFQO0FBQ0gsQ0FGRDs7QUFJQSxVQUFVLFNBQVYsQ0FBb0IsYUFBcEIsR0FBb0MsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQy9DLFdBQU8sS0FBSyxDQUFMLElBQVUsS0FBSyxDQUFmLElBQW9CLElBQUksS0FBSyxLQUE3QixJQUFzQyxJQUFJLEtBQUssTUFBdEQ7QUFDSCxDQUZEOzs7Ozs7Ozs7a0JDdjlGd0IsUTs7QUFGeEI7Ozs7OztBQUVlLFNBQVMsUUFBVCxDQUFrQixLQUFsQixFQUF5QixNQUF6QixFQUFpQztBQUM1QztBQUNBLFNBQUssS0FBTCxHQUFhLFFBQVEsQ0FBckI7QUFDQSxTQUFLLE1BQUwsR0FBYyxTQUFTLENBQXZCO0FBQ0gsQyxDQTVCRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQThCQSxTQUFTLFNBQVQsQ0FBbUIsU0FBbkIsR0FBK0IsWUFBVztBQUN0QyxXQUFPLHFCQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLEtBQUssS0FBdEIsRUFBNkIsS0FBSyxNQUFsQyxDQUFQO0FBQ0gsQ0FGRDs7QUFJQSxTQUFTLFNBQVQsQ0FBbUIsUUFBbkIsR0FBOEIsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3pDLFdBQU8sS0FBSyxDQUFMLElBQVUsS0FBSyxDQUFmLElBQW9CLElBQUksS0FBSyxLQUE3QixJQUFzQyxJQUFJLEtBQUssTUFBdEQ7QUFDSCxDQUZEOzs7Ozs7Ozs7a0JDaEM0QixPO0FBRjVCOztBQUVtQixTQUFTLE9BQVQsR0FBbUIsQ0FDakM7O0FBRUQsSUFDSSxrQkFBa0IsQ0FEdEI7QUFBQSxJQUVJLG9CQUFvQixDQUZ4QjtBQUFBLElBSUksbUJBQW1CLENBQ2YsUUFEZSxFQUVmLFVBRmUsRUFHZixLQUhlLEVBSWYsUUFKZSxFQUtmLFNBTGUsRUFNZixRQU5lLEVBT2YsVUFQZSxFQVFmLE9BUmUsRUFTZixNQVRlLEVBVWYsU0FWZSxFQVdmLFdBWGUsRUFZZixXQVplLEVBYWYsWUFiZSxFQWNmLGFBZGUsRUFlZixVQWZlLENBSnZCO0FBQUEsSUFzQkkscUJBQXFCLElBQUksS0FBSixDQUFVLEdBQVYsQ0F0QnpCO0FBQUEsSUF1QkkseUJBQXlCLElBQUksS0FBSixDQUFVLEdBQVYsQ0F2QjdCOztBQTBCWTs7Ozs7Ozs7QUFRQSxRQUFRLHVDQUFSLEdBQWtELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUM1RSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCOztBQUlBLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZOztBQUdSLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUF5QixTQUFTLENBQUMsTUFBTSxJQUFOLENBQVcsUUFBWCxJQUF1QixJQUF4QixJQUFnQyxNQUFoQyxHQUF5QyxNQUF6QyxJQUFtRCxNQUFNLEdBQXpELENBQVYsR0FBMkUsQ0FBbkc7O0FBRUkseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLFNBQVMsQ0FBQyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLElBQTJCLElBQTVCLElBQW9DLE1BQXBDLEdBQTZDLE1BQTdDLElBQXVELE1BQU0sR0FBN0QsQ0FBVixHQUErRSxDQUEzRzs7QUFFSSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsU0FBUyxDQUFDLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsSUFBMkIsSUFBNUIsSUFBb0MsTUFBcEMsR0FBNkMsTUFBN0MsSUFBdUQsTUFBTSxHQUE3RCxDQUFWLEdBQStFLENBQTNHO0FBSUM7QUFFSTtBQUNKO0FBQ0osQ0FyQ0Q7O0FBdUNBOzs7Ozs7QUFNQSxRQUFRLDRDQUFSLEdBQXVELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNqRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCOztBQUlBLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR1IseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXlCLFNBQVMsQ0FBQyxNQUFNLElBQU4sQ0FBVyxRQUFYLElBQXVCLElBQXhCLElBQWdDLE1BQWhDLEdBQXlDLE1BQXpDLElBQW1ELE1BQU0sR0FBekQsQ0FBVixHQUEyRSxDQUFuRzs7QUFFSSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsU0FBUyxDQUFDLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsSUFBMkIsSUFBNUIsSUFBb0MsTUFBcEMsR0FBNkMsTUFBN0MsSUFBdUQsTUFBTSxHQUE3RCxDQUFWLEdBQStFLENBQTNHOztBQUVJLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixTQUFTLENBQUMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixJQUEyQixJQUE1QixJQUFvQyxNQUFwQyxHQUE2QyxNQUE3QyxJQUF1RCxNQUFNLEdBQTdELENBQVYsR0FBK0UsQ0FBM0c7QUFJQztBQUVJO0FBQ0o7QUFDSixDQXJDRDs7QUF1Q0E7Ozs7Ozs7O0FBUUEsUUFBUSw0Q0FBUixHQUF1RCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDakYsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0QixFQUk1QixNQUo0Qjs7QUFNQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTtBQUNSLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLENBQVQ7O0FBR1Isb0JBQ0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBRDNEO0FBQUEsb0JBR0ksVUFBVyxTQUFTLE1BQVQsR0FBa0IsR0FBbkIsR0FBMEIsQ0FIeEM7QUFBQSxvQkFJSSxXQUFZLFVBQVUsU0FBUyxJQUFuQixJQUEyQixHQUE1QixHQUFtQyxDQUpsRDtBQUFBLG9CQUtJLFdBQVksQ0FBQyxTQUFTLElBQVYsSUFBa0IsTUFBbEIsR0FBMkIsR0FBNUIsR0FBbUMsQ0FMbEQ7O0FBT1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUF5QixDQUFDLFNBQVMsUUFBVCxHQUFvQixTQUFTLFFBQTdCLEdBQXdDLFNBQVMsTUFBVCxHQUFrQixPQUFsQixHQUE0QixHQUFyRSxJQUE0RSxRQUE3RSxHQUF5RixDQUFqSDs7QUFFSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLENBQUMsU0FBUyxRQUFULEdBQW9CLFNBQVMsUUFBN0IsR0FBd0MsU0FBUyxNQUFULEdBQWtCLE9BQWxCLEdBQTRCLEdBQXJFLElBQTRFLFFBQTdFLEdBQXlGLENBQXJIOztBQUVJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsQ0FBQyxTQUFTLFFBQVQsR0FBb0IsU0FBUyxRQUE3QixHQUF3QyxTQUFTLE1BQVQsR0FBa0IsT0FBbEIsR0FBNEIsR0FBckUsSUFBNEUsUUFBN0UsR0FBeUYsQ0FBckg7O0FBRVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0F2REQ7O0FBeURBOzs7Ozs7QUFNQSxRQUFRLGlEQUFSLEdBQTRELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUN0RixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUdJLFVBQVcsU0FBUyxNQUFULEdBQWtCLEdBQW5CLEdBQTBCLENBSHhDO0FBQUEsb0JBSUksV0FBWSxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsR0FBNUIsR0FBbUMsQ0FKbEQ7QUFBQSxvQkFLSSxXQUFZLENBQUMsU0FBUyxJQUFWLElBQWtCLE1BQWxCLEdBQTJCLEdBQTVCLEdBQW1DLENBTGxEOztBQU9RLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFBeUIsQ0FBQyxTQUFTLFFBQVQsR0FBb0IsU0FBUyxRQUE3QixHQUF3QyxTQUFTLE1BQVQsR0FBa0IsT0FBbEIsR0FBNEIsR0FBckUsSUFBNEUsUUFBN0UsR0FBeUYsQ0FBakg7O0FBRUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixDQUFDLFNBQVMsUUFBVCxHQUFvQixTQUFTLFFBQTdCLEdBQXdDLFNBQVMsTUFBVCxHQUFrQixPQUFsQixHQUE0QixHQUFyRSxJQUE0RSxRQUE3RSxHQUF5RixDQUFySDs7QUFFSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLENBQUMsU0FBUyxRQUFULEdBQW9CLFNBQVMsUUFBN0IsR0FBd0MsU0FBUyxNQUFULEdBQWtCLE9BQWxCLEdBQTRCLEdBQXJFLElBQTRFLFFBQTdFLEdBQXlGLENBQXJIOztBQUVSLHVCQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixJQUE0QyxRQUE1QztBQUlTO0FBRUk7QUFDSjtBQUNKLENBdkREOztBQXlEQTs7Ozs7Ozs7QUFRQSxRQUFRLHFDQUFSLEdBQWdELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUMxRSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCOztBQUlBLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZOztBQUdoQixvQkFBSSxVQUFVLEdBQWQsRUFBbUI7O0FBRWYsMkJBQU8sSUFBUCxDQUFZLFFBQVosSUFBd0IsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUF4Qjs7QUFFQSwyQkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQTVCOztBQUVBLDJCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBNUI7QUFFSCxpQkFSRCxNQVFPO0FBQ0gsd0JBQ0ksWUFBWSxNQUFNLE1BRHRCOztBQUdJLDZCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFSiwyQkFBTyxJQUFQLENBQVksUUFBWixJQUF5QixDQUFDLFNBQVMsTUFBVCxHQUFrQixPQUFPLElBQVAsQ0FBWSxRQUFaLElBQXdCLFNBQTNDLElBQXdELEdBQXpELEdBQWdFLENBQXhGOztBQUVJLDZCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFSiwyQkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixDQUFDLFNBQVMsTUFBVCxHQUFrQixPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLFNBQS9DLElBQTRELEdBQTdELEdBQW9FLENBQWhHOztBQUVJLDZCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFSiwyQkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixDQUFDLFNBQVMsTUFBVCxHQUFrQixPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLFNBQS9DLElBQTRELEdBQTdELEdBQW9FLENBQWhHO0FBRUg7QUFHSTtBQUVJO0FBQ0o7QUFDSixDQWxERDs7QUFvREE7Ozs7OztBQU1BLFFBQVEsMENBQVIsR0FBcUQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQy9FLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEI7O0FBSUEscUJBQVksTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBRCxHQUE2QyxNQUFNLEtBQW5ELEdBQTJELEdBQTVELEdBQW9FLENBQTlFOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHaEIsb0JBQUksVUFBVSxHQUFkLEVBQW1COztBQUVmLDJCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXdCLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBeEI7O0FBRUEsMkJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUE1Qjs7QUFFQSwyQkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQTVCO0FBRUgsaUJBUkQsTUFRTztBQUNILHdCQUNJLFlBQVksTUFBTSxNQUR0Qjs7QUFHSSw2QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUosMkJBQU8sSUFBUCxDQUFZLFFBQVosSUFBeUIsQ0FBQyxTQUFTLE1BQVQsR0FBa0IsT0FBTyxJQUFQLENBQVksUUFBWixJQUF3QixTQUEzQyxJQUF3RCxHQUF6RCxHQUFnRSxDQUF4Rjs7QUFFSSw2QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUosMkJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsQ0FBQyxTQUFTLE1BQVQsR0FBa0IsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixTQUEvQyxJQUE0RCxHQUE3RCxHQUFvRSxDQUFoRzs7QUFFSSw2QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUosMkJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsQ0FBQyxTQUFTLE1BQVQsR0FBa0IsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixTQUEvQyxJQUE0RCxHQUE3RCxHQUFvRSxDQUFoRztBQUVIO0FBR0k7QUFFSTtBQUNKO0FBQ0osQ0FsREQ7O0FBb0RBOzs7Ozs7OztBQVFBLFFBQVEsMENBQVIsR0FBcUQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQy9FLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEI7O0FBSUEscUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBVDs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUVJLFlBQWEsU0FBUyxHQUFULEdBQWUsUUFBaEIsR0FBNEIsQ0FGNUM7QUFBQSxvQkFHSSxXQUFXLE1BQU0sU0FIckI7O0FBS0ksdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFBd0IsQ0FBQyxNQUFNLElBQU4sQ0FBVyxRQUFYLElBQXVCLFNBQXZCLEdBQW1DLE9BQU8sSUFBUCxDQUFZLFFBQVosSUFBd0IsUUFBNUQsSUFBd0UsR0FBaEc7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsQ0FBQyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLElBQTJCLFNBQTNCLEdBQXVDLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsUUFBcEUsSUFBZ0YsR0FBNUc7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsQ0FBQyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLElBQTJCLFNBQTNCLEdBQXVDLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsUUFBcEUsSUFBZ0YsR0FBNUc7O0FBRVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0F2Q0Q7O0FBeUNBOzs7Ozs7QUFNQSxRQUFRLCtDQUFSLEdBQTBELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNwRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCOztBQUlBLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUVJLFlBQWEsU0FBUyxHQUFULEdBQWUsUUFBaEIsR0FBNEIsQ0FGNUM7QUFBQSxvQkFHSSxXQUFXLE1BQU0sU0FIckI7O0FBS0ksdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFBd0IsQ0FBQyxNQUFNLElBQU4sQ0FBVyxRQUFYLElBQXVCLFNBQXZCLEdBQW1DLE9BQU8sSUFBUCxDQUFZLFFBQVosSUFBd0IsUUFBNUQsSUFBd0UsR0FBaEc7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsQ0FBQyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLElBQTJCLFNBQTNCLEdBQXVDLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsUUFBcEUsSUFBZ0YsR0FBNUc7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsQ0FBQyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLElBQTJCLFNBQTNCLEdBQXVDLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsUUFBcEUsSUFBZ0YsR0FBNUc7O0FBRVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0F2Q0Q7O0FBeUNBOzs7Ozs7OztBQVFBLFFBQVEsa0NBQVIsR0FBNkMsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ3ZFLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREo7O0FBR0EscUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBVDs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR1osdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFBeUIsT0FBTyxJQUFQLENBQVksUUFBWixJQUF3QixTQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVCxHQUFnQyxHQUF6RCxHQUFnRSxDQUF4Rjs7QUFFQSx1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLFNBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFULEdBQW9DLEdBQWpFLEdBQXdFLENBQXBHOztBQUVBLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsU0FBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQsR0FBb0MsR0FBakUsR0FBd0UsQ0FBcEc7QUFJQztBQUVJO0FBQ0o7QUFDSixDQTlCRDs7QUFnQ0E7Ozs7OztBQU1BLFFBQVEsdUNBQVIsR0FBa0QsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQzVFLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREo7O0FBR0EscUJBQVksTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBRCxHQUE2QyxNQUFNLEtBQW5ELEdBQTJELEdBQTVELEdBQW9FLENBQTlFOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHWix1QkFBTyxJQUFQLENBQVksUUFBWixJQUF5QixPQUFPLElBQVAsQ0FBWSxRQUFaLElBQXdCLFNBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFULEdBQWdDLEdBQXpELEdBQWdFLENBQXhGOztBQUVBLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsU0FBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQsR0FBb0MsR0FBakUsR0FBd0UsQ0FBcEc7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixTQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVCxHQUFvQyxHQUFqRSxHQUF3RSxDQUFwRztBQUlDO0FBRUk7QUFDSjtBQUNKLENBOUJEOztBQWdDQTs7Ozs7Ozs7QUFRQSxRQUFRLHVDQUFSLEdBQWtELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUM1RSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCOztBQUlBLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZO0FBQ1IseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsQ0FBVDs7QUFHUixvQkFDSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FEM0Q7O0FBR0E7O0FBRUksdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFBeUIsQ0FBQyxTQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVCxHQUFpQyxTQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBM0MsSUFBbUUsUUFBcEUsR0FBZ0YsQ0FBeEc7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsQ0FBQyxTQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVCxHQUFxQyxTQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBL0MsSUFBMkUsUUFBNUUsR0FBd0YsQ0FBcEg7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsQ0FBQyxTQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVCxHQUFxQyxTQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBL0MsSUFBMkUsUUFBNUUsR0FBd0YsQ0FBcEg7O0FBRVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0F2Q0Q7O0FBeUNBOzs7Ozs7QUFNQSxRQUFRLDRDQUFSLEdBQXVELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNqRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCOztBQUlBLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDs7QUFHQTs7QUFFSSx1QkFBTyxJQUFQLENBQVksUUFBWixJQUF5QixDQUFDLFNBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFULEdBQWlDLFNBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUEzQyxJQUFtRSxRQUFwRSxHQUFnRixDQUF4Rzs7QUFFQSx1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixDQUFDLFNBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFULEdBQXFDLFNBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUEvQyxJQUEyRSxRQUE1RSxHQUF3RixDQUFwSDs7QUFFQSx1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixDQUFDLFNBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFULEdBQXFDLFNBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUEvQyxJQUEyRSxRQUE1RSxHQUF3RixDQUFwSDs7QUFFUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQXZDRDs7QUF5Q0E7Ozs7Ozs7O0FBUUEsUUFBUSx1Q0FBUixHQUFrRCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDNUUsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESjs7QUFHQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHWix1QkFBTyxJQUFQLENBQVksUUFBWixJQUF5QixPQUFPLElBQVAsQ0FBWSxRQUFaLElBQXdCLFNBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFULEdBQWdDLEdBQXhELEdBQThELE1BQS9ELEdBQXlFLENBQWpHOztBQUVBLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsU0FBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQsR0FBb0MsR0FBaEUsR0FBc0UsTUFBdkUsR0FBaUYsQ0FBN0c7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixTQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVCxHQUFvQyxHQUFoRSxHQUFzRSxNQUF2RSxHQUFpRixDQUE3RztBQUlDO0FBRUk7QUFDSjtBQUNKLENBOUJEOztBQWdDQTs7Ozs7O0FBTUEsUUFBUSw0Q0FBUixHQUF1RCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDakYsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESjs7QUFHQSxxQkFBWSxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFELEdBQTZDLE1BQU0sS0FBbkQsR0FBMkQsR0FBNUQsR0FBb0UsQ0FBOUU7O0FBR1IsZ0JBQUksTUFBSixFQUFZOztBQUdaLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXlCLE9BQU8sSUFBUCxDQUFZLFFBQVosSUFBd0IsU0FBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQsR0FBZ0MsR0FBeEQsR0FBOEQsTUFBL0QsR0FBeUUsQ0FBakc7O0FBRUEsdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixTQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVCxHQUFvQyxHQUFoRSxHQUFzRSxNQUF2RSxHQUFpRixDQUE3Rzs7QUFFQSx1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLFNBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFULEdBQW9DLEdBQWhFLEdBQXNFLE1BQXZFLEdBQWlGLENBQTdHO0FBSUM7QUFFSTtBQUNKO0FBQ0osQ0E5QkQ7O0FBZ0NBOzs7Ozs7OztBQVFBLFFBQVEsNENBQVIsR0FBdUQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ2pGLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEI7O0FBSUEscUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBVDs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUVJLFVBQVUsU0FBUyxNQUZ2Qjs7QUFJQTs7QUFFSSx1QkFBTyxJQUFQLENBQVksUUFBWixJQUF5QixDQUFDLFNBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFULEdBQWlDLFNBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUExQyxHQUFpRSxPQUFsRSxJQUE2RSxRQUE5RSxHQUEwRixDQUFsSDs7QUFFQSx1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixDQUFDLFNBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFULEdBQXFDLFNBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUE5QyxHQUF5RSxPQUExRSxJQUFxRixRQUF0RixHQUFrRyxDQUE5SDs7QUFFQSx1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixDQUFDLFNBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFULEdBQXFDLFNBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUE5QyxHQUF5RSxPQUExRSxJQUFxRixRQUF0RixHQUFrRyxDQUE5SDs7QUFFUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQXhDRDs7QUEwQ0E7Ozs7OztBQU1BLFFBQVEsaURBQVIsR0FBNEQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ3RGLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEI7O0FBSUEscUJBQVksTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBRCxHQUE2QyxNQUFNLEtBQW5ELEdBQTJELEdBQTVELEdBQW9FLENBQTlFOztBQUdSLGdCQUFJLE1BQUosRUFBWTtBQUNSLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLENBQVQ7O0FBR1Isb0JBQ0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBRDNEO0FBQUEsb0JBRUksVUFBVSxTQUFTLE1BRnZCOztBQUlBOztBQUVJLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXlCLENBQUMsU0FBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQsR0FBaUMsU0FBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQTFDLEdBQWlFLE9BQWxFLElBQTZFLFFBQTlFLEdBQTBGLENBQWxIOztBQUVBLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLENBQUMsU0FBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQsR0FBcUMsU0FBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQTlDLEdBQXlFLE9BQTFFLElBQXFGLFFBQXRGLEdBQWtHLENBQTlIOztBQUVBLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLENBQUMsU0FBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQsR0FBcUMsU0FBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQTlDLEdBQXlFLE9BQTFFLElBQXFGLFFBQXRGLEdBQWtHLENBQTlIOztBQUVSLHVCQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixJQUE0QyxRQUE1QztBQUlTO0FBRUk7QUFDSjtBQUNKLENBeENEOztBQTBDQTs7Ozs7Ozs7QUFRQSxRQUFRLHFDQUFSLEdBQWdELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUMxRSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCOztBQUlBLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZOztBQUdoQixvQkFDSSxZQUFZLFNBQVMsSUFEekI7O0FBR1EseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXdCLE9BQ3hCLENBQ0ksQ0FBQyxTQUFTLElBQVYsSUFBa0IsU0FBbEIsR0FDRSxDQUFDLE1BQU0sSUFBTixDQUFXLFFBQVgsSUFBdUIsSUFBeEIsS0FBaUMsU0FBUyxJQUExQyxJQUFrRCxNQUFsRCxHQUEyRCxHQUZqRSxJQUlFLEdBTEY7O0FBUUkseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLE9BQzVCLENBQ0ksQ0FBQyxTQUFTLElBQVYsSUFBa0IsU0FBbEIsR0FDRSxDQUFDLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsSUFBMkIsSUFBNUIsS0FBcUMsU0FBUyxJQUE5QyxJQUFzRCxNQUF0RCxHQUErRCxHQUZyRSxJQUlFLEdBTEY7O0FBUUkseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLE9BQzVCLENBQ0ksQ0FBQyxTQUFTLElBQVYsSUFBa0IsU0FBbEIsR0FDRSxDQUFDLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsSUFBMkIsSUFBNUIsS0FBcUMsU0FBUyxJQUE5QyxJQUFzRCxNQUF0RCxHQUErRCxHQUZyRSxJQUlFLEdBTEY7QUFVQztBQUVJO0FBQ0o7QUFDSixDQTFERDs7QUE0REE7Ozs7OztBQU1BLFFBQVEsMENBQVIsR0FBcUQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQy9FLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEI7O0FBSUEscUJBQVksTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBRCxHQUE2QyxNQUFNLEtBQW5ELEdBQTJELEdBQTVELEdBQW9FLENBQTlFOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHaEIsb0JBQ0ksWUFBWSxTQUFTLElBRHpCOztBQUdRLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUF3QixPQUN4QixDQUNJLENBQUMsU0FBUyxJQUFWLElBQWtCLFNBQWxCLEdBQ0UsQ0FBQyxNQUFNLElBQU4sQ0FBVyxRQUFYLElBQXVCLElBQXhCLEtBQWlDLFNBQVMsSUFBMUMsSUFBa0QsTUFBbEQsR0FBMkQsR0FGakUsSUFJRSxHQUxGOztBQVFJLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixPQUM1QixDQUNJLENBQUMsU0FBUyxJQUFWLElBQWtCLFNBQWxCLEdBQ0UsQ0FBQyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLElBQTJCLElBQTVCLEtBQXFDLFNBQVMsSUFBOUMsSUFBc0QsTUFBdEQsR0FBK0QsR0FGckUsSUFJRSxHQUxGOztBQVFJLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixPQUM1QixDQUNJLENBQUMsU0FBUyxJQUFWLElBQWtCLFNBQWxCLEdBQ0UsQ0FBQyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLElBQTJCLElBQTVCLEtBQXFDLFNBQVMsSUFBOUMsSUFBc0QsTUFBdEQsR0FBK0QsR0FGckUsSUFJRSxHQUxGO0FBVUM7QUFFSTtBQUNKO0FBQ0osQ0ExREQ7O0FBNERBOzs7Ozs7OztBQVFBLFFBQVEsMENBQVIsR0FBcUQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQy9FLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEIsRUFJNUIsTUFKNEI7O0FBTUEscUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBVDs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUdJLFVBQVcsU0FBUyxNQUFULEdBQWtCLEdBQW5CLEdBQTBCLENBSHhDO0FBQUEsb0JBSUksV0FBWSxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsR0FBNUIsR0FBbUMsQ0FKbEQ7QUFBQSxvQkFLSSxXQUFZLENBQUMsU0FBUyxJQUFWLElBQWtCLE1BQWxCLEdBQTJCLEdBQTVCLEdBQW1DLENBTGxEOztBQU9RLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFBd0IsT0FDeEIsQ0FDSSxDQUFDLFNBQVMsSUFBVixJQUFrQixRQUFsQixHQUNFLENBQUMsU0FBUyxJQUFWLElBQWtCLFFBRHBCLEdBRUUsQ0FBQyxTQUFTLElBQVYsS0FBbUIsU0FBUyxJQUE1QixJQUFvQyxPQUFwQyxHQUE4QyxHQUhwRCxJQUtFLFFBTkY7O0FBU0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixPQUM1QixDQUNJLENBQUMsU0FBUyxJQUFWLElBQWtCLFFBQWxCLEdBQ0UsQ0FBQyxTQUFTLElBQVYsSUFBa0IsUUFEcEIsR0FFRSxDQUFDLFNBQVMsSUFBVixLQUFtQixTQUFTLElBQTVCLElBQW9DLE9BQXBDLEdBQThDLEdBSHBELElBS0UsUUFORjs7QUFTSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLE9BQzVCLENBQ0ksQ0FBQyxTQUFTLElBQVYsSUFBa0IsUUFBbEIsR0FDRSxDQUFDLFNBQVMsSUFBVixJQUFrQixRQURwQixHQUVFLENBQUMsU0FBUyxJQUFWLEtBQW1CLFNBQVMsSUFBNUIsSUFBb0MsT0FBcEMsR0FBOEMsR0FIcEQsSUFLRSxRQU5GOztBQVNSLHVCQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixJQUE0QyxRQUE1QztBQUlTO0FBRUk7QUFDSjtBQUNKLENBNUVEOztBQThFQTs7Ozs7O0FBTUEsUUFBUSwrQ0FBUixHQUEwRCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDcEYsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0QixFQUk1QixNQUo0Qjs7QUFNQSxxQkFBWSxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFELEdBQTZDLE1BQU0sS0FBbkQsR0FBMkQsR0FBNUQsR0FBb0UsQ0FBOUU7O0FBR1IsZ0JBQUksTUFBSixFQUFZO0FBQ1IseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsQ0FBVDs7QUFHUixvQkFDSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FEM0Q7QUFBQSxvQkFHSSxVQUFXLFNBQVMsTUFBVCxHQUFrQixHQUFuQixHQUEwQixDQUh4QztBQUFBLG9CQUlJLFdBQVksVUFBVSxTQUFTLElBQW5CLElBQTJCLEdBQTVCLEdBQW1DLENBSmxEO0FBQUEsb0JBS0ksV0FBWSxDQUFDLFNBQVMsSUFBVixJQUFrQixNQUFsQixHQUEyQixHQUE1QixHQUFtQyxDQUxsRDs7QUFPUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXdCLE9BQ3hCLENBQ0ksQ0FBQyxTQUFTLElBQVYsSUFBa0IsUUFBbEIsR0FDRSxDQUFDLFNBQVMsSUFBVixJQUFrQixRQURwQixHQUVFLENBQUMsU0FBUyxJQUFWLEtBQW1CLFNBQVMsSUFBNUIsSUFBb0MsT0FBcEMsR0FBOEMsR0FIcEQsSUFLRSxRQU5GOztBQVNJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsT0FDNUIsQ0FDSSxDQUFDLFNBQVMsSUFBVixJQUFrQixRQUFsQixHQUNFLENBQUMsU0FBUyxJQUFWLElBQWtCLFFBRHBCLEdBRUUsQ0FBQyxTQUFTLElBQVYsS0FBbUIsU0FBUyxJQUE1QixJQUFvQyxPQUFwQyxHQUE4QyxHQUhwRCxJQUtFLFFBTkY7O0FBU0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixPQUM1QixDQUNJLENBQUMsU0FBUyxJQUFWLElBQWtCLFFBQWxCLEdBQ0UsQ0FBQyxTQUFTLElBQVYsSUFBa0IsUUFEcEIsR0FFRSxDQUFDLFNBQVMsSUFBVixLQUFtQixTQUFTLElBQTVCLElBQW9DLE9BQXBDLEdBQThDLEdBSHBELElBS0UsUUFORjs7QUFTUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQTVFRDs7QUE4RUE7Ozs7Ozs7O0FBUUEsUUFBUSxzQ0FBUixHQUFpRCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDM0UsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0Qjs7QUFLQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHaEIsb0JBQ0ksWUFBWSxTQUFTLElBRHpCOztBQUdRLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFBd0IsVUFBVSxNQUFWLEdBQW1CLE1BQW5CLEdBQTRCLENBQUMsU0FBUyxTQUFULEdBQXFCLFNBQVMsTUFBL0IsSUFBeUMsR0FBN0Y7O0FBRUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixVQUFVLE1BQVYsR0FBbUIsTUFBbkIsR0FBNEIsQ0FBQyxTQUFTLFNBQVQsR0FBcUIsU0FBUyxNQUEvQixJQUF5QyxHQUFqRzs7QUFFSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLFVBQVUsTUFBVixHQUFtQixNQUFuQixHQUE0QixDQUFDLFNBQVMsU0FBVCxHQUFxQixTQUFTLE1BQS9CLElBQXlDLEdBQWpHO0FBSUM7QUFFSTtBQUNKO0FBQ0osQ0EvQ0Q7O0FBaURBOzs7Ozs7QUFNQSxRQUFRLDJDQUFSLEdBQXNELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNoRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCOztBQUtBLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR2hCLG9CQUNJLFlBQVksU0FBUyxJQUR6Qjs7QUFHUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXdCLFVBQVUsTUFBVixHQUFtQixNQUFuQixHQUE0QixDQUFDLFNBQVMsU0FBVCxHQUFxQixTQUFTLE1BQS9CLElBQXlDLEdBQTdGOztBQUVJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsVUFBVSxNQUFWLEdBQW1CLE1BQW5CLEdBQTRCLENBQUMsU0FBUyxTQUFULEdBQXFCLFNBQVMsTUFBL0IsSUFBeUMsR0FBakc7O0FBRUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixVQUFVLE1BQVYsR0FBbUIsTUFBbkIsR0FBNEIsQ0FBQyxTQUFTLFNBQVQsR0FBcUIsU0FBUyxNQUEvQixJQUF5QyxHQUFqRztBQUlDO0FBRUk7QUFDSjtBQUNKLENBL0NEOztBQWlEQTs7Ozs7Ozs7QUFRQSxRQUFRLDJDQUFSLEdBQXNELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNoRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZO0FBQ1IseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsQ0FBVDs7QUFHUixvQkFDSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FEM0Q7OztBQUdBO0FBQ0ksMEJBQVcsVUFBVSxTQUFTLElBQW5CLElBQTJCLFFBQTVCLEdBQXdDLENBSnREO0FBQUEsb0JBS0ksYUFBYyxVQUFVLElBQVgsR0FBbUIsQ0FMcEM7OztBQU9BO0FBQ0ksMEJBQVcsVUFBVSxTQUFTLElBQW5CLElBQTJCLFFBQTVCLEdBQXdDLENBUnREO0FBQUEsb0JBU0ksYUFBYyxVQUFVLElBQVgsR0FBbUIsQ0FUcEM7O0FBV1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUF5QixDQUFFLFVBQVUsTUFBWCxHQUFzQixTQUFTLE9BQVQsR0FBbUIsU0FBUyxVQUFsRCxHQUFpRSxTQUFTLE9BQVQsR0FBbUIsU0FBUyxVQUE5RixJQUE2RyxHQUE5RyxHQUFxSCxDQUE3STs7QUFFSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLENBQUUsVUFBVSxNQUFYLEdBQXNCLFNBQVMsT0FBVCxHQUFtQixTQUFTLFVBQWxELEdBQWlFLFNBQVMsT0FBVCxHQUFtQixTQUFTLFVBQTlGLElBQTZHLEdBQTlHLEdBQXFILENBQWpKOztBQUVJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsQ0FBRSxVQUFVLE1BQVgsR0FBc0IsU0FBUyxPQUFULEdBQW1CLFNBQVMsVUFBbEQsR0FBaUUsU0FBUyxPQUFULEdBQW1CLFNBQVMsVUFBOUYsSUFBNkcsR0FBOUcsR0FBcUgsQ0FBako7O0FBRVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0EzREQ7O0FBNkRBOzs7Ozs7QUFNQSxRQUFRLGdEQUFSLEdBQTJELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNyRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDs7O0FBR0E7QUFDSSwwQkFBVyxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsUUFBNUIsR0FBd0MsQ0FKdEQ7QUFBQSxvQkFLSSxhQUFjLFVBQVUsSUFBWCxHQUFtQixDQUxwQzs7O0FBT0E7QUFDSSwwQkFBVyxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsUUFBNUIsR0FBd0MsQ0FSdEQ7QUFBQSxvQkFTSSxhQUFjLFVBQVUsSUFBWCxHQUFtQixDQVRwQzs7QUFXUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXlCLENBQUUsVUFBVSxNQUFYLEdBQXNCLFNBQVMsT0FBVCxHQUFtQixTQUFTLFVBQWxELEdBQWlFLFNBQVMsT0FBVCxHQUFtQixTQUFTLFVBQTlGLElBQTZHLEdBQTlHLEdBQXFILENBQTdJOztBQUVJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsQ0FBRSxVQUFVLE1BQVgsR0FBc0IsU0FBUyxPQUFULEdBQW1CLFNBQVMsVUFBbEQsR0FBaUUsU0FBUyxPQUFULEdBQW1CLFNBQVMsVUFBOUYsSUFBNkcsR0FBOUcsR0FBcUgsQ0FBako7O0FBRUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixDQUFFLFVBQVUsTUFBWCxHQUFzQixTQUFTLE9BQVQsR0FBbUIsU0FBUyxVQUFsRCxHQUFpRSxTQUFTLE9BQVQsR0FBbUIsU0FBUyxVQUE5RixJQUE2RyxHQUE5RyxHQUFxSCxDQUFqSjs7QUFFUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQTNERDs7QUE2REE7Ozs7Ozs7O0FBUUEsUUFBUSxxQ0FBUixHQUFnRCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDMUUsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0Qjs7QUFLQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHaEIsb0JBQ0ksWUFBWSxTQUFTLElBRHpCOztBQUdRLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFBd0IsVUFBVSxNQUFWLEdBQW1CLENBQUMsU0FBUyxTQUFULEdBQXFCLFNBQVMsTUFBL0IsSUFBeUMsR0FBNUQsR0FBa0UsTUFBMUY7O0FBRUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixVQUFVLE1BQVYsR0FBbUIsQ0FBQyxTQUFTLFNBQVQsR0FBcUIsU0FBUyxNQUEvQixJQUF5QyxHQUE1RCxHQUFrRSxNQUE5Rjs7QUFFSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTRCLFVBQVUsTUFBVixHQUFtQixDQUFDLFNBQVMsU0FBVCxHQUFxQixTQUFTLE1BQS9CLElBQXlDLEdBQTVELEdBQWtFLE1BQTlGO0FBSUM7QUFFSTtBQUNKO0FBQ0osQ0EvQ0Q7O0FBaURBOzs7Ozs7QUFNQSxRQUFRLDBDQUFSLEdBQXFELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUMvRSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCOztBQUtBLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR2hCLG9CQUNJLFlBQVksU0FBUyxJQUR6Qjs7QUFHUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXdCLFVBQVUsTUFBVixHQUFtQixDQUFDLFNBQVMsU0FBVCxHQUFxQixTQUFTLE1BQS9CLElBQXlDLEdBQTVELEdBQWtFLE1BQTFGOztBQUVJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNEIsVUFBVSxNQUFWLEdBQW1CLENBQUMsU0FBUyxTQUFULEdBQXFCLFNBQVMsTUFBL0IsSUFBeUMsR0FBNUQsR0FBa0UsTUFBOUY7O0FBRUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE0QixVQUFVLE1BQVYsR0FBbUIsQ0FBQyxTQUFTLFNBQVQsR0FBcUIsU0FBUyxNQUEvQixJQUF5QyxHQUE1RCxHQUFrRSxNQUE5RjtBQUlDO0FBRUk7QUFDSjtBQUNKLENBL0NEOztBQWlEQTs7Ozs7Ozs7QUFRQSxRQUFRLDBDQUFSLEdBQXFELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUMvRSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZO0FBQ1IseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsQ0FBVDs7QUFHUixvQkFDSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FEM0Q7OztBQUdBO0FBQ0ksMEJBQVcsVUFBVSxTQUFTLElBQW5CLElBQTJCLFFBQTVCLEdBQXdDLENBSnREO0FBQUEsb0JBS0ksYUFBYyxVQUFVLElBQVgsR0FBbUIsQ0FMcEM7OztBQU9BO0FBQ0ksMEJBQVcsVUFBVSxTQUFTLElBQW5CLElBQTJCLFFBQTVCLEdBQXdDLENBUnREO0FBQUEsb0JBU0ksYUFBYyxVQUFVLElBQVgsR0FBbUIsQ0FUcEM7O0FBV1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUF5QixDQUFFLFVBQVUsTUFBWCxHQUFzQixTQUFTLE9BQVQsR0FBbUIsU0FBUyxVQUFsRCxHQUFpRSxTQUFTLE9BQVQsR0FBbUIsU0FBUyxVQUE5RixJQUE2RyxHQUE5RyxHQUFxSCxDQUE3STs7QUFFSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQTZCLENBQUUsVUFBVSxNQUFYLEdBQXNCLFNBQVMsT0FBVCxHQUFtQixTQUFTLFVBQWxELEdBQWlFLFNBQVMsT0FBVCxHQUFtQixTQUFTLFVBQTlGLElBQTZHLEdBQTlHLEdBQXFILENBQWpKOztBQUVJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsQ0FBRSxVQUFVLE1BQVgsR0FBc0IsU0FBUyxPQUFULEdBQW1CLFNBQVMsVUFBbEQsR0FBaUUsU0FBUyxPQUFULEdBQW1CLFNBQVMsVUFBOUYsSUFBNkcsR0FBOUcsR0FBcUgsQ0FBako7O0FBRVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0EzREQ7O0FBNkRBOzs7Ozs7QUFNQSxRQUFRLCtDQUFSLEdBQTBELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNwRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDs7O0FBR0E7QUFDSSwwQkFBVyxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsUUFBNUIsR0FBd0MsQ0FKdEQ7QUFBQSxvQkFLSSxhQUFjLFVBQVUsSUFBWCxHQUFtQixDQUxwQzs7O0FBT0E7QUFDSSwwQkFBVyxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsUUFBNUIsR0FBd0MsQ0FSdEQ7QUFBQSxvQkFTSSxhQUFjLFVBQVUsSUFBWCxHQUFtQixDQVRwQzs7QUFXUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQXlCLENBQUUsVUFBVSxNQUFYLEdBQXNCLFNBQVMsT0FBVCxHQUFtQixTQUFTLFVBQWxELEdBQWlFLFNBQVMsT0FBVCxHQUFtQixTQUFTLFVBQTlGLElBQTZHLEdBQTlHLEdBQXFILENBQTdJOztBQUVJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFBNkIsQ0FBRSxVQUFVLE1BQVgsR0FBc0IsU0FBUyxPQUFULEdBQW1CLFNBQVMsVUFBbEQsR0FBaUUsU0FBUyxPQUFULEdBQW1CLFNBQVMsVUFBOUYsSUFBNkcsR0FBOUcsR0FBcUgsQ0FBako7O0FBRUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUE2QixDQUFFLFVBQVUsTUFBWCxHQUFzQixTQUFTLE9BQVQsR0FBbUIsU0FBUyxVQUFsRCxHQUFpRSxTQUFTLE9BQVQsR0FBbUIsU0FBUyxVQUE5RixJQUE2RyxHQUE5RyxHQUFxSCxDQUFqSjs7QUFFUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQTNERDs7QUE2REE7Ozs7Ozs7O0FBUUEsUUFBUSxvQ0FBUixHQUErQyxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDekUsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0Qjs7QUFLQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHaEIsb0JBQ0ksWUFBWSxTQUFTLElBRHpCOztBQUdRLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFNBQVMsU0FBVCxHQUNFLFVBQVUsVUFBVSxHQUFWLEdBQWdCLEdBQWhCLEdBQXNCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBZSxNQUFNLE1BQU4sSUFBZ0IsU0FBUyxJQUF6QixDQUFELEdBQW1DLENBQWpELENBQWhDLENBRk4sSUFHSSxHQUpvQixHQUt4QixDQUxBOztBQU9JLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFNBQVMsU0FBVCxHQUNFLFVBQVUsVUFBVSxHQUFWLEdBQWdCLEdBQWhCLEdBQXNCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBZSxNQUFNLE1BQU4sSUFBZ0IsU0FBUyxJQUF6QixDQUFELEdBQW1DLENBQWpELENBQWhDLENBRk4sSUFHSSxHQUp3QixHQUs1QixDQUxBOztBQU9JLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFNBQVMsU0FBVCxHQUNFLFVBQVUsVUFBVSxHQUFWLEdBQWdCLEdBQWhCLEdBQXNCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBZSxNQUFNLE1BQU4sSUFBZ0IsU0FBUyxJQUF6QixDQUFELEdBQW1DLENBQWpELENBQWhDLENBRk4sSUFHSSxHQUp3QixHQUs1QixDQUxBO0FBU0M7QUFFSTtBQUNKO0FBQ0osQ0E5REQ7O0FBZ0VBOzs7Ozs7QUFNQSxRQUFRLHlDQUFSLEdBQW9ELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUM5RSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCOztBQUtBLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR2hCLG9CQUNJLFlBQVksU0FBUyxJQUR6Qjs7QUFHUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSSxTQUFTLFNBQVQsR0FDRSxVQUFVLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWUsTUFBTSxNQUFOLElBQWdCLFNBQVMsSUFBekIsQ0FBRCxHQUFtQyxDQUFqRCxDQUFoQyxDQUZOLElBR0ksR0FKb0IsR0FLeEIsQ0FMQTs7QUFPSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxTQUFTLFNBQVQsR0FDRSxVQUFVLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWUsTUFBTSxNQUFOLElBQWdCLFNBQVMsSUFBekIsQ0FBRCxHQUFtQyxDQUFqRCxDQUFoQyxDQUZOLElBR0ksR0FKd0IsR0FLNUIsQ0FMQTs7QUFPSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxTQUFTLFNBQVQsR0FDRSxVQUFVLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWUsTUFBTSxNQUFOLElBQWdCLFNBQVMsSUFBekIsQ0FBRCxHQUFtQyxDQUFqRCxDQUFoQyxDQUZOLElBR0ksR0FKd0IsR0FLNUIsQ0FMQTtBQVNDO0FBRUk7QUFDSjtBQUNKLENBOUREOztBQWdFQTs7Ozs7Ozs7QUFRQSxRQUFRLHlDQUFSLEdBQW9ELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUM5RSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZO0FBQ1IseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsQ0FBVDs7QUFHUixvQkFDSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FEM0Q7QUFBQSxvQkFFSSxVQUFXLFNBQVMsTUFBVCxHQUFrQixHQUFuQixHQUEwQixDQUZ4QztBQUFBLG9CQUdJLFdBQVksVUFBVSxTQUFTLElBQW5CLElBQTJCLEdBQTVCLEdBQW1DLENBSGxEO0FBQUEsb0JBSUksV0FBWSxDQUFDLFNBQVMsSUFBVixJQUFrQixNQUFsQixHQUEyQixHQUE1QixHQUFtQyxDQUpsRDs7QUFNUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSyxTQUFTLFFBQVYsR0FDRyxTQUFTLFFBRFosR0FFRSxXQUFXLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWUsTUFBTSxNQUFOLElBQWdCLFNBQVMsSUFBekIsQ0FBRCxHQUFtQyxDQUFqRCxDQUFqQyxDQUhOLElBSUksUUFMb0IsR0FNeEIsQ0FOQTs7QUFRSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSyxTQUFTLFFBQVYsR0FDRyxTQUFTLFFBRFosR0FFRSxXQUFXLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWUsTUFBTSxNQUFOLElBQWdCLFNBQVMsSUFBekIsQ0FBRCxHQUFtQyxDQUFqRCxDQUFqQyxDQUhOLElBSUksUUFMd0IsR0FNNUIsQ0FOQTs7QUFRSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSyxTQUFTLFFBQVYsR0FDRyxTQUFTLFFBRFosR0FFRSxXQUFXLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWUsTUFBTSxNQUFOLElBQWdCLFNBQVMsSUFBekIsQ0FBRCxHQUFtQyxDQUFqRCxDQUFqQyxDQUhOLElBSUksUUFMd0IsR0FNNUIsQ0FOQTs7QUFRUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQXhFRDs7QUEwRUE7Ozs7OztBQU1BLFFBQVEsOENBQVIsR0FBeUQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ25GLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEIsRUFJNUIsTUFKNEI7O0FBTUEscUJBQVksTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBRCxHQUE2QyxNQUFNLEtBQW5ELEdBQTJELEdBQTVELEdBQW9FLENBQTlFOztBQUdSLGdCQUFJLE1BQUosRUFBWTtBQUNSLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLENBQVQ7O0FBR1Isb0JBQ0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBRDNEO0FBQUEsb0JBRUksVUFBVyxTQUFTLE1BQVQsR0FBa0IsR0FBbkIsR0FBMEIsQ0FGeEM7QUFBQSxvQkFHSSxXQUFZLFVBQVUsU0FBUyxJQUFuQixJQUEyQixHQUE1QixHQUFtQyxDQUhsRDtBQUFBLG9CQUlJLFdBQVksQ0FBQyxTQUFTLElBQVYsSUFBa0IsTUFBbEIsR0FBMkIsR0FBNUIsR0FBbUMsQ0FKbEQ7O0FBTVEseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ssU0FBUyxRQUFWLEdBQ0csU0FBUyxRQURaLEdBRUUsV0FBVyxVQUFVLEdBQVYsR0FBZ0IsR0FBaEIsR0FBc0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFlLE1BQU0sTUFBTixJQUFnQixTQUFTLElBQXpCLENBQUQsR0FBbUMsQ0FBakQsQ0FBakMsQ0FITixJQUlJLFFBTG9CLEdBTXhCLENBTkE7O0FBUUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ssU0FBUyxRQUFWLEdBQ0csU0FBUyxRQURaLEdBRUUsV0FBVyxVQUFVLEdBQVYsR0FBZ0IsR0FBaEIsR0FBc0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFlLE1BQU0sTUFBTixJQUFnQixTQUFTLElBQXpCLENBQUQsR0FBbUMsQ0FBakQsQ0FBakMsQ0FITixJQUlJLFFBTHdCLEdBTTVCLENBTkE7O0FBUUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ssU0FBUyxRQUFWLEdBQ0csU0FBUyxRQURaLEdBRUUsV0FBVyxVQUFVLEdBQVYsR0FBZ0IsR0FBaEIsR0FBc0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFlLE1BQU0sTUFBTixJQUFnQixTQUFTLElBQXpCLENBQUQsR0FBbUMsQ0FBakQsQ0FBakMsQ0FITixJQUlJLFFBTHdCLEdBTTVCLENBTkE7O0FBUVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0F4RUQ7O0FBMEVBOzs7Ozs7OztBQVFBLFFBQVEsbUNBQVIsR0FBOEMsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ3hFLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEI7O0FBS0EscUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBVDs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR2hCLG9CQUNJLFlBQVksU0FBUyxJQUR6Qjs7QUFHUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSSxTQUFTLFNBQVQsR0FDRSxVQUFVLFVBQVUsQ0FBVixHQUFjLENBQWQsR0FBa0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLE9BQU8sU0FBUyxJQUFoQixJQUF3QixNQUF0QyxJQUFnRCxJQUE1RSxDQUZOLElBSUUsR0FMc0IsR0FNeEIsQ0FOQTs7QUFRSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxTQUFTLFNBQVQsR0FDRSxVQUFVLFVBQVUsQ0FBVixHQUFjLENBQWQsR0FBa0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLE9BQU8sU0FBUyxJQUFoQixJQUF3QixNQUF0QyxJQUFnRCxJQUE1RSxDQUZOLElBSUUsR0FMMEIsR0FNNUIsQ0FOQTs7QUFRSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxTQUFTLFNBQVQsR0FDRSxVQUFVLFVBQVUsQ0FBVixHQUFjLENBQWQsR0FBa0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLE9BQU8sU0FBUyxJQUFoQixJQUF3QixNQUF0QyxJQUFnRCxJQUE1RSxDQUZOLElBSUUsR0FMMEIsR0FNNUIsQ0FOQTtBQVVDO0FBRUk7QUFDSjtBQUNKLENBakVEOztBQW1FQTs7Ozs7O0FBTUEsUUFBUSx3Q0FBUixHQUFtRCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDN0UsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0Qjs7QUFLQSxxQkFBWSxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFELEdBQTZDLE1BQU0sS0FBbkQsR0FBMkQsR0FBNUQsR0FBb0UsQ0FBOUU7O0FBR1IsZ0JBQUksTUFBSixFQUFZOztBQUdoQixvQkFDSSxZQUFZLFNBQVMsSUFEekI7O0FBR1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksU0FBUyxTQUFULEdBQ0UsVUFBVSxVQUFVLENBQVYsR0FBYyxDQUFkLEdBQWtCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxPQUFPLFNBQVMsSUFBaEIsSUFBd0IsTUFBdEMsSUFBZ0QsSUFBNUUsQ0FGTixJQUlFLEdBTHNCLEdBTXhCLENBTkE7O0FBUUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksU0FBUyxTQUFULEdBQ0UsVUFBVSxVQUFVLENBQVYsR0FBYyxDQUFkLEdBQWtCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxPQUFPLFNBQVMsSUFBaEIsSUFBd0IsTUFBdEMsSUFBZ0QsSUFBNUUsQ0FGTixJQUlFLEdBTDBCLEdBTTVCLENBTkE7O0FBUUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksU0FBUyxTQUFULEdBQ0UsVUFBVSxVQUFVLENBQVYsR0FBYyxDQUFkLEdBQWtCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxPQUFPLFNBQVMsSUFBaEIsSUFBd0IsTUFBdEMsSUFBZ0QsSUFBNUUsQ0FGTixJQUlFLEdBTDBCLEdBTTVCLENBTkE7QUFVQztBQUVJO0FBQ0o7QUFDSixDQWpFRDs7QUFtRUE7Ozs7Ozs7O0FBUUEsUUFBUSx3Q0FBUixHQUFtRCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDN0UsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0QixFQUk1QixNQUo0Qjs7QUFNQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTtBQUNSLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLENBQVQ7O0FBR1Isb0JBQ0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBRDNEO0FBQUEsb0JBR0ksVUFBVyxTQUFTLE1BQVQsR0FBa0IsR0FBbkIsR0FBMEIsQ0FIeEM7QUFBQSxvQkFJSSxXQUFZLFVBQVUsU0FBUyxJQUFuQixJQUEyQixHQUE1QixHQUFtQyxDQUpsRDtBQUFBLG9CQUtJLFdBQVksQ0FBQyxTQUFTLElBQVYsSUFBa0IsTUFBbEIsR0FBMkIsR0FBNUIsR0FBbUMsQ0FMbEQ7O0FBT1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksU0FBUyxRQUFULEdBQ0UsU0FBUyxRQURYLEdBRUUsV0FBVyxVQUFVLENBQVYsR0FBYyxDQUFkLEdBQWtCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxPQUFPLFNBQVMsSUFBaEIsSUFBd0IsTUFBdEMsSUFBZ0QsSUFBN0UsQ0FITixJQUtFLFFBTnNCLEdBT3hCLENBUEE7O0FBU0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksU0FBUyxRQUFULEdBQ0UsU0FBUyxRQURYLEdBRUUsV0FBVyxVQUFVLENBQVYsR0FBYyxDQUFkLEdBQWtCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxPQUFPLFNBQVMsSUFBaEIsSUFBd0IsTUFBdEMsSUFBZ0QsSUFBN0UsQ0FITixJQUtFLFFBTjBCLEdBTzVCLENBUEE7O0FBU0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksU0FBUyxRQUFULEdBQ0UsU0FBUyxRQURYLEdBRUUsV0FBVyxVQUFVLENBQVYsR0FBYyxDQUFkLEdBQWtCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxPQUFPLFNBQVMsSUFBaEIsSUFBd0IsTUFBdEMsSUFBZ0QsSUFBN0UsQ0FITixJQUtFLFFBTjBCLEdBTzVCLENBUEE7O0FBU1IsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0E1RUQ7O0FBOEVBOzs7Ozs7QUFNQSxRQUFRLDZDQUFSLEdBQXdELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNsRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUdJLFVBQVcsU0FBUyxNQUFULEdBQWtCLEdBQW5CLEdBQTBCLENBSHhDO0FBQUEsb0JBSUksV0FBWSxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsR0FBNUIsR0FBbUMsQ0FKbEQ7QUFBQSxvQkFLSSxXQUFZLENBQUMsU0FBUyxJQUFWLElBQWtCLE1BQWxCLEdBQTJCLEdBQTVCLEdBQW1DLENBTGxEOztBQU9RLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFNBQVMsUUFBVCxHQUNFLFNBQVMsUUFEWCxHQUVFLFdBQVcsVUFBVSxDQUFWLEdBQWMsQ0FBZCxHQUFrQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsT0FBTyxTQUFTLElBQWhCLElBQXdCLE1BQXRDLElBQWdELElBQTdFLENBSE4sSUFLRSxRQU5zQixHQU94QixDQVBBOztBQVNJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFNBQVMsUUFBVCxHQUNFLFNBQVMsUUFEWCxHQUVFLFdBQVcsVUFBVSxDQUFWLEdBQWMsQ0FBZCxHQUFrQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsT0FBTyxTQUFTLElBQWhCLElBQXdCLE1BQXRDLElBQWdELElBQTdFLENBSE4sSUFLRSxRQU4wQixHQU81QixDQVBBOztBQVNJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFNBQVMsUUFBVCxHQUNFLFNBQVMsUUFEWCxHQUVFLFdBQVcsVUFBVSxDQUFWLEdBQWMsQ0FBZCxHQUFrQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsT0FBTyxTQUFTLElBQWhCLElBQXdCLE1BQXRDLElBQWdELElBQTdFLENBSE4sSUFLRSxRQU4wQixHQU81QixDQVBBOztBQVNSLHVCQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixJQUE0QyxRQUE1QztBQUlTO0FBRUk7QUFDSjtBQUNKLENBNUVEOztBQThFQTs7Ozs7Ozs7QUFRQSxRQUFRLHNDQUFSLEdBQWlELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUMzRSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCOztBQUtBLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZOztBQUdoQixvQkFDSSxZQUFZLFNBQVMsSUFEekI7O0FBR1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksWUFBWSxNQUFaLElBRUksVUFBVSxHQUFWLEdBQ08sU0FBUyxDQUFULEdBQWEsTUFBYixHQUFzQixNQUF0QixHQUErQixHQUR0QyxHQUVPLFVBQVcsS0FBSyxTQUFTLElBQWQsS0FBdUIsU0FBUyxJQUFoQyxJQUF3QyxHQUF6QyxHQUFnRCxJQUExRCxDQUpYLENBREosSUFPSSxHQVJvQixHQVN4QixDQVRBOztBQVdJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFlBQVksTUFBWixJQUVJLFVBQVUsR0FBVixHQUNPLFNBQVMsQ0FBVCxHQUFhLE1BQWIsR0FBc0IsTUFBdEIsR0FBK0IsR0FEdEMsR0FFTyxVQUFXLEtBQUssU0FBUyxJQUFkLEtBQXVCLFNBQVMsSUFBaEMsSUFBd0MsR0FBekMsR0FBZ0QsSUFBMUQsQ0FKWCxDQURKLElBT0ksR0FSd0IsR0FTNUIsQ0FUQTs7QUFXSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosSUFFSSxVQUFVLEdBQVYsR0FDTyxTQUFTLENBQVQsR0FBYSxNQUFiLEdBQXNCLE1BQXRCLEdBQStCLEdBRHRDLEdBRU8sVUFBVyxLQUFLLFNBQVMsSUFBZCxLQUF1QixTQUFTLElBQWhDLElBQXdDLEdBQXpDLEdBQWdELElBQTFELENBSlgsQ0FESixJQU9JLEdBUndCLEdBUzVCLENBVEE7QUFhQztBQUVJO0FBQ0o7QUFDSixDQTFFRDs7QUE0RUE7Ozs7OztBQU1BLFFBQVEsMkNBQVIsR0FBc0QsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ2hGLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEI7O0FBS0EscUJBQVksTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBRCxHQUE2QyxNQUFNLEtBQW5ELEdBQTJELEdBQTVELEdBQW9FLENBQTlFOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHaEIsb0JBQ0ksWUFBWSxTQUFTLElBRHpCOztBQUdRLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFlBQVksTUFBWixJQUVJLFVBQVUsR0FBVixHQUNPLFNBQVMsQ0FBVCxHQUFhLE1BQWIsR0FBc0IsTUFBdEIsR0FBK0IsR0FEdEMsR0FFTyxVQUFXLEtBQUssU0FBUyxJQUFkLEtBQXVCLFNBQVMsSUFBaEMsSUFBd0MsR0FBekMsR0FBZ0QsSUFBMUQsQ0FKWCxDQURKLElBT0ksR0FSb0IsR0FTeEIsQ0FUQTs7QUFXSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosSUFFSSxVQUFVLEdBQVYsR0FDTyxTQUFTLENBQVQsR0FBYSxNQUFiLEdBQXNCLE1BQXRCLEdBQStCLEdBRHRDLEdBRU8sVUFBVyxLQUFLLFNBQVMsSUFBZCxLQUF1QixTQUFTLElBQWhDLElBQXdDLEdBQXpDLEdBQWdELElBQTFELENBSlgsQ0FESixJQU9JLEdBUndCLEdBUzVCLENBVEE7O0FBV0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksWUFBWSxNQUFaLElBRUksVUFBVSxHQUFWLEdBQ08sU0FBUyxDQUFULEdBQWEsTUFBYixHQUFzQixNQUF0QixHQUErQixHQUR0QyxHQUVPLFVBQVcsS0FBSyxTQUFTLElBQWQsS0FBdUIsU0FBUyxJQUFoQyxJQUF3QyxHQUF6QyxHQUFnRCxJQUExRCxDQUpYLENBREosSUFPSSxHQVJ3QixHQVM1QixDQVRBO0FBYUM7QUFFSTtBQUNKO0FBQ0osQ0ExRUQ7O0FBNEVBOzs7Ozs7OztBQVFBLFFBQVEsMkNBQVIsR0FBc0QsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ2hGLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEIsRUFJNUIsTUFKNEI7O0FBTUEscUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBVDs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUVJLFVBQVcsU0FBUyxNQUFULEdBQWtCLEdBQW5CLEdBQTBCLENBRnhDO0FBQUEsb0JBR0ksV0FBWSxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsR0FBNUIsR0FBbUMsQ0FIbEQ7QUFBQSxvQkFJSSxXQUFZLENBQUMsU0FBUyxJQUFWLElBQWtCLE1BQWxCLEdBQTJCLEdBQTVCLEdBQW1DLENBSmxEOztBQU1RLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixJQUdJLFVBQVUsR0FBVixHQUNPLFVBQVUsQ0FBVixHQUFjLE1BQWQsR0FBdUIsTUFBdkIsR0FBZ0MsR0FEdkMsR0FFTyxXQUFZLEtBQUssU0FBUyxJQUFkLEtBQXVCLFNBQVMsSUFBaEMsSUFBd0MsR0FBekMsR0FBZ0QsSUFBM0QsQ0FMWCxDQURKLElBUUksUUFUb0IsR0FVeEIsQ0FWQTs7QUFZSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsSUFHSSxVQUFVLEdBQVYsR0FDTyxVQUFVLENBQVYsR0FBYyxNQUFkLEdBQXVCLE1BQXZCLEdBQWdDLEdBRHZDLEdBRU8sV0FBWSxLQUFLLFNBQVMsSUFBZCxLQUF1QixTQUFTLElBQWhDLElBQXdDLEdBQXpDLEdBQWdELElBQTNELENBTFgsQ0FESixJQVFJLFFBVHdCLEdBVTVCLENBVkE7O0FBWUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLElBR0ksVUFBVSxHQUFWLEdBQ08sVUFBVSxDQUFWLEdBQWMsTUFBZCxHQUF1QixNQUF2QixHQUFnQyxHQUR2QyxHQUVPLFdBQVksS0FBSyxTQUFTLElBQWQsS0FBdUIsU0FBUyxJQUFoQyxJQUF3QyxHQUF6QyxHQUFnRCxJQUEzRCxDQUxYLENBREosSUFRSSxRQVR3QixHQVU1QixDQVZBOztBQVlSLHVCQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixJQUE0QyxRQUE1QztBQUlTO0FBRUk7QUFDSjtBQUNKLENBcEZEOztBQXNGQTs7Ozs7O0FBTUEsUUFBUSxnREFBUixHQUEyRCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDckYsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0QixFQUk1QixNQUo0Qjs7QUFNQSxxQkFBWSxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFELEdBQTZDLE1BQU0sS0FBbkQsR0FBMkQsR0FBNUQsR0FBb0UsQ0FBOUU7O0FBR1IsZ0JBQUksTUFBSixFQUFZO0FBQ1IseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsQ0FBVDs7QUFHUixvQkFDSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FEM0Q7QUFBQSxvQkFFSSxVQUFXLFNBQVMsTUFBVCxHQUFrQixHQUFuQixHQUEwQixDQUZ4QztBQUFBLG9CQUdJLFdBQVksVUFBVSxTQUFTLElBQW5CLElBQTJCLEdBQTVCLEdBQW1DLENBSGxEO0FBQUEsb0JBSUksV0FBWSxDQUFDLFNBQVMsSUFBVixJQUFrQixNQUFsQixHQUEyQixHQUE1QixHQUFtQyxDQUpsRDs7QUFNUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsSUFHSSxVQUFVLEdBQVYsR0FDTyxVQUFVLENBQVYsR0FBYyxNQUFkLEdBQXVCLE1BQXZCLEdBQWdDLEdBRHZDLEdBRU8sV0FBWSxLQUFLLFNBQVMsSUFBZCxLQUF1QixTQUFTLElBQWhDLElBQXdDLEdBQXpDLEdBQWdELElBQTNELENBTFgsQ0FESixJQVFJLFFBVG9CLEdBVXhCLENBVkE7O0FBWUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLElBR0ksVUFBVSxHQUFWLEdBQ08sVUFBVSxDQUFWLEdBQWMsTUFBZCxHQUF1QixNQUF2QixHQUFnQyxHQUR2QyxHQUVPLFdBQVksS0FBSyxTQUFTLElBQWQsS0FBdUIsU0FBUyxJQUFoQyxJQUF3QyxHQUF6QyxHQUFnRCxJQUEzRCxDQUxYLENBREosSUFRSSxRQVR3QixHQVU1QixDQVZBOztBQVlJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixJQUdJLFVBQVUsR0FBVixHQUNPLFVBQVUsQ0FBVixHQUFjLE1BQWQsR0FBdUIsTUFBdkIsR0FBZ0MsR0FEdkMsR0FFTyxXQUFZLEtBQUssU0FBUyxJQUFkLEtBQXVCLFNBQVMsSUFBaEMsSUFBd0MsR0FBekMsR0FBZ0QsSUFBM0QsQ0FMWCxDQURKLElBUUksUUFUd0IsR0FVNUIsQ0FWQTs7QUFZUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQXBGRDs7QUFzRkE7Ozs7Ozs7O0FBUUEsUUFBUSx3Q0FBUixHQUFtRCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDN0UsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0Qjs7QUFLQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHaEIsb0JBQ0ksWUFBWSxTQUFTLElBRHpCOztBQUdRLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFlBQVksTUFBWixJQUVJLFVBQVUsR0FBVixHQUNPLFNBQVMsQ0FBVCxHQUFhLE1BQWIsR0FBc0IsTUFBdEIsR0FBK0IsR0FEdEMsR0FFTyxVQUFXLEtBQUssU0FBUyxJQUFkLEtBQXVCLFNBQVMsSUFBaEMsSUFBd0MsR0FBekMsR0FBZ0QsSUFBMUQsQ0FKWCxDQURKLElBT0ksR0FSb0IsR0FTeEIsQ0FUQTs7QUFXSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosSUFFSSxVQUFVLEdBQVYsR0FDTyxTQUFTLENBQVQsR0FBYSxNQUFiLEdBQXNCLE1BQXRCLEdBQStCLEdBRHRDLEdBRU8sVUFBVyxLQUFLLFNBQVMsSUFBZCxLQUF1QixTQUFTLElBQWhDLElBQXdDLEdBQXpDLEdBQWdELElBQTFELENBSlgsQ0FESixJQU9JLEdBUndCLEdBUzVCLENBVEE7O0FBV0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksWUFBWSxNQUFaLElBRUksVUFBVSxHQUFWLEdBQ08sU0FBUyxDQUFULEdBQWEsTUFBYixHQUFzQixNQUF0QixHQUErQixHQUR0QyxHQUVPLFVBQVcsS0FBSyxTQUFTLElBQWQsS0FBdUIsU0FBUyxJQUFoQyxJQUF3QyxHQUF6QyxHQUFnRCxJQUExRCxDQUpYLENBREosSUFPSSxHQVJ3QixHQVM1QixDQVRBO0FBYUM7QUFFSTtBQUNKO0FBQ0osQ0ExRUQ7O0FBNEVBOzs7Ozs7QUFNQSxRQUFRLDZDQUFSLEdBQXdELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNsRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCOztBQUtBLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR2hCLG9CQUNJLFlBQVksU0FBUyxJQUR6Qjs7QUFHUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSSxZQUFZLE1BQVosSUFFSSxVQUFVLEdBQVYsR0FDTyxTQUFTLENBQVQsR0FBYSxNQUFiLEdBQXNCLE1BQXRCLEdBQStCLEdBRHRDLEdBRU8sVUFBVyxLQUFLLFNBQVMsSUFBZCxLQUF1QixTQUFTLElBQWhDLElBQXdDLEdBQXpDLEdBQWdELElBQTFELENBSlgsQ0FESixJQU9JLEdBUm9CLEdBU3hCLENBVEE7O0FBV0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksWUFBWSxNQUFaLElBRUksVUFBVSxHQUFWLEdBQ08sU0FBUyxDQUFULEdBQWEsTUFBYixHQUFzQixNQUF0QixHQUErQixHQUR0QyxHQUVPLFVBQVcsS0FBSyxTQUFTLElBQWQsS0FBdUIsU0FBUyxJQUFoQyxJQUF3QyxHQUF6QyxHQUFnRCxJQUExRCxDQUpYLENBREosSUFPSSxHQVJ3QixHQVM1QixDQVRBOztBQVdJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFlBQVksTUFBWixJQUVJLFVBQVUsR0FBVixHQUNPLFNBQVMsQ0FBVCxHQUFhLE1BQWIsR0FBc0IsTUFBdEIsR0FBK0IsR0FEdEMsR0FFTyxVQUFXLEtBQUssU0FBUyxJQUFkLEtBQXVCLFNBQVMsSUFBaEMsSUFBd0MsR0FBekMsR0FBZ0QsSUFBMUQsQ0FKWCxDQURKLElBT0ksR0FSd0IsR0FTNUIsQ0FUQTtBQWFDO0FBRUk7QUFDSjtBQUNKLENBMUVEOztBQTRFQTs7Ozs7Ozs7QUFRQSxRQUFRLDZDQUFSLEdBQXdELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNsRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZO0FBQ1IseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsQ0FBVDs7QUFHUixvQkFDSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FEM0Q7QUFBQSxvQkFFSSxVQUFXLFNBQVMsTUFBVCxHQUFrQixHQUFuQixHQUEwQixDQUZ4QztBQUFBLG9CQUdJLFdBQVksVUFBVSxTQUFTLElBQW5CLElBQTJCLEdBQTVCLEdBQW1DLENBSGxEO0FBQUEsb0JBSUksV0FBWSxDQUFDLFNBQVMsSUFBVixJQUFrQixNQUFsQixHQUEyQixHQUE1QixHQUFtQyxDQUpsRDs7QUFNUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsSUFHSSxVQUFVLEdBQVYsR0FDTyxVQUFVLENBQVYsR0FBYyxNQUFkLEdBQXVCLE1BQXZCLEdBQWdDLEdBRHZDLEdBRU8sV0FBWSxLQUFLLFNBQVMsSUFBZCxLQUF1QixTQUFTLElBQWhDLElBQXdDLEdBQXpDLEdBQWdELElBQTNELENBTFgsQ0FESixJQVFJLFFBVG9CLEdBVXhCLENBVkE7O0FBWUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLElBR0ksVUFBVSxHQUFWLEdBQ08sVUFBVSxDQUFWLEdBQWMsTUFBZCxHQUF1QixNQUF2QixHQUFnQyxHQUR2QyxHQUVPLFdBQVksS0FBSyxTQUFTLElBQWQsS0FBdUIsU0FBUyxJQUFoQyxJQUF3QyxHQUF6QyxHQUFnRCxJQUEzRCxDQUxYLENBREosSUFRSSxRQVR3QixHQVU1QixDQVZBOztBQVlJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixJQUdJLFVBQVUsR0FBVixHQUNPLFVBQVUsQ0FBVixHQUFjLE1BQWQsR0FBdUIsTUFBdkIsR0FBZ0MsR0FEdkMsR0FFTyxXQUFZLEtBQUssU0FBUyxJQUFkLEtBQXVCLFNBQVMsSUFBaEMsSUFBd0MsR0FBekMsR0FBZ0QsSUFBM0QsQ0FMWCxDQURKLElBUUksUUFUd0IsR0FVNUIsQ0FWQTs7QUFZUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQXBGRDs7QUFzRkE7Ozs7OztBQU1BLFFBQVEsa0RBQVIsR0FBNkQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ3ZGLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEIsRUFJNUIsTUFKNEI7O0FBTUEscUJBQVksTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBRCxHQUE2QyxNQUFNLEtBQW5ELEdBQTJELEdBQTVELEdBQW9FLENBQTlFOztBQUdSLGdCQUFJLE1BQUosRUFBWTtBQUNSLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLENBQVQ7O0FBR1Isb0JBQ0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBRDNEO0FBQUEsb0JBRUksVUFBVyxTQUFTLE1BQVQsR0FBa0IsR0FBbkIsR0FBMEIsQ0FGeEM7QUFBQSxvQkFHSSxXQUFZLFVBQVUsU0FBUyxJQUFuQixJQUEyQixHQUE1QixHQUFtQyxDQUhsRDtBQUFBLG9CQUlJLFdBQVksQ0FBQyxTQUFTLElBQVYsSUFBa0IsTUFBbEIsR0FBMkIsR0FBNUIsR0FBbUMsQ0FKbEQ7O0FBTVEseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLElBR0ksVUFBVSxHQUFWLEdBQ08sVUFBVSxDQUFWLEdBQWMsTUFBZCxHQUF1QixNQUF2QixHQUFnQyxHQUR2QyxHQUVPLFdBQVksS0FBSyxTQUFTLElBQWQsS0FBdUIsU0FBUyxJQUFoQyxJQUF3QyxHQUF6QyxHQUFnRCxJQUEzRCxDQUxYLENBREosSUFRSSxRQVRvQixHQVV4QixDQVZBOztBQVlJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixJQUdJLFVBQVUsR0FBVixHQUNPLFVBQVUsQ0FBVixHQUFjLE1BQWQsR0FBdUIsTUFBdkIsR0FBZ0MsR0FEdkMsR0FFTyxXQUFZLEtBQUssU0FBUyxJQUFkLEtBQXVCLFNBQVMsSUFBaEMsSUFBd0MsR0FBekMsR0FBZ0QsSUFBM0QsQ0FMWCxDQURKLElBUUksUUFUd0IsR0FVNUIsQ0FWQTs7QUFZSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsSUFHSSxVQUFVLEdBQVYsR0FDTyxVQUFVLENBQVYsR0FBYyxNQUFkLEdBQXVCLE1BQXZCLEdBQWdDLEdBRHZDLEdBRU8sV0FBWSxLQUFLLFNBQVMsSUFBZCxLQUF1QixTQUFTLElBQWhDLElBQXdDLEdBQXpDLEdBQWdELElBQTNELENBTFgsQ0FESixJQVFJLFFBVHdCLEdBVTVCLENBVkE7O0FBWVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0FwRkQ7O0FBc0ZBOzs7Ozs7OztBQVFBLFFBQVEsd0NBQVIsR0FBbUQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQzdFLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEI7O0FBS0EscUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBVDs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR2hCLG9CQUNJLFlBQVksU0FBUyxJQUR6Qjs7QUFHUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSSxZQUFZLE1BQVosR0FDRSxVQUNFLFVBQVUsR0FBVixHQUNPLENBQUMsSUFBSSxNQUFKLEdBQWEsR0FBZCxJQUFxQixtQkFBbUIsTUFBbkIsQ0FBckIsR0FBa0QsR0FBbEQsR0FBd0QsTUFEL0QsR0FFTyxDQUFDLElBQUksTUFBSixHQUFhLEdBQWQsSUFBcUIsdUJBQXVCLE1BQXZCLENBQXJCLEdBQXNELEdBQXRELEdBQTRELE1BSHJFLENBRk4sSUFPSSxHQVJvQixHQVN4QixDQVRBOztBQVdJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFlBQVksTUFBWixHQUNFLFVBQ0UsVUFBVSxHQUFWLEdBQ08sQ0FBQyxJQUFJLE1BQUosR0FBYSxHQUFkLElBQXFCLG1CQUFtQixNQUFuQixDQUFyQixHQUFrRCxHQUFsRCxHQUF3RCxNQUQvRCxHQUVPLENBQUMsSUFBSSxNQUFKLEdBQWEsR0FBZCxJQUFxQix1QkFBdUIsTUFBdkIsQ0FBckIsR0FBc0QsR0FBdEQsR0FBNEQsTUFIckUsQ0FGTixJQU9JLEdBUndCLEdBUzVCLENBVEE7O0FBV0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksWUFBWSxNQUFaLEdBQ0UsVUFDRSxVQUFVLEdBQVYsR0FDTyxDQUFDLElBQUksTUFBSixHQUFhLEdBQWQsSUFBcUIsbUJBQW1CLE1BQW5CLENBQXJCLEdBQWtELEdBQWxELEdBQXdELE1BRC9ELEdBRU8sQ0FBQyxJQUFJLE1BQUosR0FBYSxHQUFkLElBQXFCLHVCQUF1QixNQUF2QixDQUFyQixHQUFzRCxHQUF0RCxHQUE0RCxNQUhyRSxDQUZOLElBT0ksR0FSd0IsR0FTNUIsQ0FUQTtBQWFDO0FBRUk7QUFDSjtBQUNKLENBMUVEOztBQTRFQTs7Ozs7O0FBTUEsUUFBUSw2Q0FBUixHQUF3RCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDbEYsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0Qjs7QUFLQSxxQkFBWSxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFELEdBQTZDLE1BQU0sS0FBbkQsR0FBMkQsR0FBNUQsR0FBb0UsQ0FBOUU7O0FBR1IsZ0JBQUksTUFBSixFQUFZOztBQUdoQixvQkFDSSxZQUFZLFNBQVMsSUFEekI7O0FBR1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksWUFBWSxNQUFaLEdBQ0UsVUFDRSxVQUFVLEdBQVYsR0FDTyxDQUFDLElBQUksTUFBSixHQUFhLEdBQWQsSUFBcUIsbUJBQW1CLE1BQW5CLENBQXJCLEdBQWtELEdBQWxELEdBQXdELE1BRC9ELEdBRU8sQ0FBQyxJQUFJLE1BQUosR0FBYSxHQUFkLElBQXFCLHVCQUF1QixNQUF2QixDQUFyQixHQUFzRCxHQUF0RCxHQUE0RCxNQUhyRSxDQUZOLElBT0ksR0FSb0IsR0FTeEIsQ0FUQTs7QUFXSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosR0FDRSxVQUNFLFVBQVUsR0FBVixHQUNPLENBQUMsSUFBSSxNQUFKLEdBQWEsR0FBZCxJQUFxQixtQkFBbUIsTUFBbkIsQ0FBckIsR0FBa0QsR0FBbEQsR0FBd0QsTUFEL0QsR0FFTyxDQUFDLElBQUksTUFBSixHQUFhLEdBQWQsSUFBcUIsdUJBQXVCLE1BQXZCLENBQXJCLEdBQXNELEdBQXRELEdBQTRELE1BSHJFLENBRk4sSUFPSSxHQVJ3QixHQVM1QixDQVRBOztBQVdJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFlBQVksTUFBWixHQUNFLFVBQ0UsVUFBVSxHQUFWLEdBQ08sQ0FBQyxJQUFJLE1BQUosR0FBYSxHQUFkLElBQXFCLG1CQUFtQixNQUFuQixDQUFyQixHQUFrRCxHQUFsRCxHQUF3RCxNQUQvRCxHQUVPLENBQUMsSUFBSSxNQUFKLEdBQWEsR0FBZCxJQUFxQix1QkFBdUIsTUFBdkIsQ0FBckIsR0FBc0QsR0FBdEQsR0FBNEQsTUFIckUsQ0FGTixJQU9JLEdBUndCLEdBUzVCLENBVEE7QUFhQztBQUVJO0FBQ0o7QUFDSixDQTFFRDs7QUE0RUE7Ozs7Ozs7O0FBUUEsUUFBUSw2Q0FBUixHQUF3RCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDbEYsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0QixFQUk1QixNQUo0Qjs7QUFNQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTtBQUNSLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLENBQVQ7O0FBR1Isb0JBQ0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBRDNEO0FBQUEsb0JBR0ksVUFBVyxTQUFTLE1BQVQsR0FBa0IsR0FBbkIsR0FBMEIsQ0FIeEM7QUFBQSxvQkFJSSxXQUFZLFVBQVUsU0FBUyxJQUFuQixJQUEyQixHQUE1QixHQUFtQyxDQUpsRDtBQUFBLG9CQUtJLFdBQVksQ0FBQyxTQUFTLElBQVYsSUFBa0IsTUFBbEIsR0FBMkIsR0FBNUIsR0FBbUMsQ0FMbEQ7O0FBT1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLElBR0ksVUFBVSxHQUFWLEdBQ00sV0FBVyxDQUFDLElBQUksTUFBSixHQUFhLEdBQWQsSUFBcUIsbUJBQW1CLE1BQW5CLENBQXJCLEdBQWtELEdBQWxELEdBQXdELE1BQW5FLENBRE4sR0FFTSxXQUFXLENBQUMsSUFBSSxNQUFKLEdBQWEsR0FBZCxJQUFxQix1QkFBdUIsTUFBdkIsQ0FBckIsR0FBc0QsR0FBdEQsR0FBNEQsTUFBdkUsQ0FMVixDQURKLElBUUksUUFUb0IsR0FVeEIsQ0FWQTs7QUFZSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsSUFHSSxVQUFVLEdBQVYsR0FDTSxXQUFXLENBQUMsSUFBSSxNQUFKLEdBQWEsR0FBZCxJQUFxQixtQkFBbUIsTUFBbkIsQ0FBckIsR0FBa0QsR0FBbEQsR0FBd0QsTUFBbkUsQ0FETixHQUVNLFdBQVcsQ0FBQyxJQUFJLE1BQUosR0FBYSxHQUFkLElBQXFCLHVCQUF1QixNQUF2QixDQUFyQixHQUFzRCxHQUF0RCxHQUE0RCxNQUF2RSxDQUxWLENBREosSUFRSSxRQVR3QixHQVU1QixDQVZBOztBQVlJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixJQUdJLFVBQVUsR0FBVixHQUNNLFdBQVcsQ0FBQyxJQUFJLE1BQUosR0FBYSxHQUFkLElBQXFCLG1CQUFtQixNQUFuQixDQUFyQixHQUFrRCxHQUFsRCxHQUF3RCxNQUFuRSxDQUROLEdBRU0sV0FBVyxDQUFDLElBQUksTUFBSixHQUFhLEdBQWQsSUFBcUIsdUJBQXVCLE1BQXZCLENBQXJCLEdBQXNELEdBQXRELEdBQTRELE1BQXZFLENBTFYsQ0FESixJQVFJLFFBVHdCLEdBVTVCLENBVkE7O0FBWVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0FyRkQ7O0FBdUZBOzs7Ozs7QUFNQSxRQUFRLGtEQUFSLEdBQTZELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUN2RixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUdJLFVBQVcsU0FBUyxNQUFULEdBQWtCLEdBQW5CLEdBQTBCLENBSHhDO0FBQUEsb0JBSUksV0FBWSxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsR0FBNUIsR0FBbUMsQ0FKbEQ7QUFBQSxvQkFLSSxXQUFZLENBQUMsU0FBUyxJQUFWLElBQWtCLE1BQWxCLEdBQTJCLEdBQTVCLEdBQW1DLENBTGxEOztBQU9RLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixJQUdJLFVBQVUsR0FBVixHQUNNLFdBQVcsQ0FBQyxJQUFJLE1BQUosR0FBYSxHQUFkLElBQXFCLG1CQUFtQixNQUFuQixDQUFyQixHQUFrRCxHQUFsRCxHQUF3RCxNQUFuRSxDQUROLEdBRU0sV0FBVyxDQUFDLElBQUksTUFBSixHQUFhLEdBQWQsSUFBcUIsdUJBQXVCLE1BQXZCLENBQXJCLEdBQXNELEdBQXRELEdBQTRELE1BQXZFLENBTFYsQ0FESixJQVFJLFFBVG9CLEdBVXhCLENBVkE7O0FBWUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLElBR0ksVUFBVSxHQUFWLEdBQ00sV0FBVyxDQUFDLElBQUksTUFBSixHQUFhLEdBQWQsSUFBcUIsbUJBQW1CLE1BQW5CLENBQXJCLEdBQWtELEdBQWxELEdBQXdELE1BQW5FLENBRE4sR0FFTSxXQUFXLENBQUMsSUFBSSxNQUFKLEdBQWEsR0FBZCxJQUFxQix1QkFBdUIsTUFBdkIsQ0FBckIsR0FBc0QsR0FBdEQsR0FBNEQsTUFBdkUsQ0FMVixDQURKLElBUUksUUFUd0IsR0FVNUIsQ0FWQTs7QUFZSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsSUFHSSxVQUFVLEdBQVYsR0FDTSxXQUFXLENBQUMsSUFBSSxNQUFKLEdBQWEsR0FBZCxJQUFxQixtQkFBbUIsTUFBbkIsQ0FBckIsR0FBa0QsR0FBbEQsR0FBd0QsTUFBbkUsQ0FETixHQUVNLFdBQVcsQ0FBQyxJQUFJLE1BQUosR0FBYSxHQUFkLElBQXFCLHVCQUF1QixNQUF2QixDQUFyQixHQUFzRCxHQUF0RCxHQUE0RCxNQUF2RSxDQUxWLENBREosSUFRSSxRQVR3QixHQVU1QixDQVZBOztBQVlSLHVCQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixJQUE0QyxRQUE1QztBQUlTO0FBRUk7QUFDSjtBQUNKLENBckZEOztBQXVGQTs7Ozs7Ozs7QUFRQSxRQUFRLHlDQUFSLEdBQW9ELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUM5RSxRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCOztBQUtBLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZOztBQUdoQixvQkFDSSxZQUFZLFNBQVMsSUFEekI7O0FBR1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksWUFBWSxNQUFaLElBRUksVUFBVSxHQUFWLEdBQ08sVUFBVyxVQUFVLENBQVgsR0FBZ0IsQ0FBaEIsR0FBb0IsTUFBTSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsQ0FBQyxNQUFNLE1BQVAsSUFBaUIsR0FBakIsSUFBd0IsSUFBSSxNQUE1QixDQUFkLENBQXBDLENBRFAsR0FFTyxVQUFVLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsU0FBUyxHQUFULElBQWdCLEtBQUssTUFBTSxNQUFYLENBQWhCLENBQWQsQ0FBaEMsQ0FKWCxDQURKLElBT0ksR0FSb0IsR0FTeEIsQ0FUQTs7QUFXSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosSUFFSSxVQUFVLEdBQVYsR0FDTyxVQUFXLFVBQVUsQ0FBWCxHQUFnQixDQUFoQixHQUFvQixNQUFNLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxDQUFDLE1BQU0sTUFBUCxJQUFpQixHQUFqQixJQUF3QixJQUFJLE1BQTVCLENBQWQsQ0FBcEMsQ0FEUCxHQUVPLFVBQVUsVUFBVSxHQUFWLEdBQWdCLEdBQWhCLEdBQXNCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxTQUFTLEdBQVQsSUFBZ0IsS0FBSyxNQUFNLE1BQVgsQ0FBaEIsQ0FBZCxDQUFoQyxDQUpYLENBREosSUFPSSxHQVJ3QixHQVM1QixDQVRBOztBQVdJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFlBQVksTUFBWixJQUVJLFVBQVUsR0FBVixHQUNPLFVBQVcsVUFBVSxDQUFYLEdBQWdCLENBQWhCLEdBQW9CLE1BQU0sS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLENBQUMsTUFBTSxNQUFQLElBQWlCLEdBQWpCLElBQXdCLElBQUksTUFBNUIsQ0FBZCxDQUFwQyxDQURQLEdBRU8sVUFBVSxVQUFVLEdBQVYsR0FBZ0IsR0FBaEIsR0FBc0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLFNBQVMsR0FBVCxJQUFnQixLQUFLLE1BQU0sTUFBWCxDQUFoQixDQUFkLENBQWhDLENBSlgsQ0FESixJQU9JLEdBUndCLEdBUzVCLENBVEE7QUFhQztBQUVJO0FBQ0o7QUFDSixDQTFFRDs7QUE0RUE7Ozs7OztBQU1BLFFBQVEsOENBQVIsR0FBeUQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ25GLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEI7O0FBS0EscUJBQVksTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBRCxHQUE2QyxNQUFNLEtBQW5ELEdBQTJELEdBQTVELEdBQW9FLENBQTlFOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHaEIsb0JBQ0ksWUFBWSxTQUFTLElBRHpCOztBQUdRLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFlBQVksTUFBWixJQUVJLFVBQVUsR0FBVixHQUNPLFVBQVcsVUFBVSxDQUFYLEdBQWdCLENBQWhCLEdBQW9CLE1BQU0sS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLENBQUMsTUFBTSxNQUFQLElBQWlCLEdBQWpCLElBQXdCLElBQUksTUFBNUIsQ0FBZCxDQUFwQyxDQURQLEdBRU8sVUFBVSxVQUFVLEdBQVYsR0FBZ0IsR0FBaEIsR0FBc0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLFNBQVMsR0FBVCxJQUFnQixLQUFLLE1BQU0sTUFBWCxDQUFoQixDQUFkLENBQWhDLENBSlgsQ0FESixJQU9JLEdBUm9CLEdBU3hCLENBVEE7O0FBV0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksWUFBWSxNQUFaLElBRUksVUFBVSxHQUFWLEdBQ08sVUFBVyxVQUFVLENBQVgsR0FBZ0IsQ0FBaEIsR0FBb0IsTUFBTSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsQ0FBQyxNQUFNLE1BQVAsSUFBaUIsR0FBakIsSUFBd0IsSUFBSSxNQUE1QixDQUFkLENBQXBDLENBRFAsR0FFTyxVQUFVLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsU0FBUyxHQUFULElBQWdCLEtBQUssTUFBTSxNQUFYLENBQWhCLENBQWQsQ0FBaEMsQ0FKWCxDQURKLElBT0ksR0FSd0IsR0FTNUIsQ0FUQTs7QUFXSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosSUFFSSxVQUFVLEdBQVYsR0FDTyxVQUFXLFVBQVUsQ0FBWCxHQUFnQixDQUFoQixHQUFvQixNQUFNLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxDQUFDLE1BQU0sTUFBUCxJQUFpQixHQUFqQixJQUF3QixJQUFJLE1BQTVCLENBQWQsQ0FBcEMsQ0FEUCxHQUVPLFVBQVUsVUFBVSxHQUFWLEdBQWdCLEdBQWhCLEdBQXNCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxTQUFTLEdBQVQsSUFBZ0IsS0FBSyxNQUFNLE1BQVgsQ0FBaEIsQ0FBZCxDQUFoQyxDQUpYLENBREosSUFPSSxHQVJ3QixHQVM1QixDQVRBO0FBYUM7QUFFSTtBQUNKO0FBQ0osQ0ExRUQ7O0FBNEVBOzs7Ozs7OztBQVFBLFFBQVEsOENBQVIsR0FBeUQsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ25GLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEIsRUFJNUIsTUFKNEI7O0FBTUEscUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBVDs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUdJLFVBQVcsU0FBUyxNQUFULEdBQWtCLEdBQW5CLEdBQTBCLENBSHhDO0FBQUEsb0JBSUksV0FBWSxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsR0FBNUIsR0FBbUMsQ0FKbEQ7QUFBQSxvQkFLSSxXQUFZLENBQUMsU0FBUyxJQUFWLElBQWtCLE1BQWxCLEdBQTJCLEdBQTVCLEdBQW1DLENBTGxEOztBQU9RLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixJQUdJLFVBQVUsR0FBVixHQUNPLFdBQVksVUFBVSxDQUFYLEdBQWdCLENBQWhCLEdBQW9CLE1BQU0sS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLENBQUMsTUFBTSxNQUFQLElBQWlCLEdBQWpCLElBQXdCLElBQUksTUFBNUIsQ0FBZCxDQUFyQyxDQURQLEdBRU8sV0FBVyxVQUFVLEdBQVYsR0FBZ0IsR0FBaEIsR0FBc0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLFNBQVMsR0FBVCxJQUFnQixLQUFLLE1BQU0sTUFBWCxDQUFoQixDQUFkLENBQWpDLENBTFgsQ0FESixJQVFJLFFBVG9CLEdBVXhCLENBVkE7O0FBWUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLElBR0ksVUFBVSxHQUFWLEdBQ08sV0FBWSxVQUFVLENBQVgsR0FBZ0IsQ0FBaEIsR0FBb0IsTUFBTSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsQ0FBQyxNQUFNLE1BQVAsSUFBaUIsR0FBakIsSUFBd0IsSUFBSSxNQUE1QixDQUFkLENBQXJDLENBRFAsR0FFTyxXQUFXLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsU0FBUyxHQUFULElBQWdCLEtBQUssTUFBTSxNQUFYLENBQWhCLENBQWQsQ0FBakMsQ0FMWCxDQURKLElBUUksUUFUd0IsR0FVNUIsQ0FWQTs7QUFZSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsSUFHSSxVQUFVLEdBQVYsR0FDTyxXQUFZLFVBQVUsQ0FBWCxHQUFnQixDQUFoQixHQUFvQixNQUFNLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxDQUFDLE1BQU0sTUFBUCxJQUFpQixHQUFqQixJQUF3QixJQUFJLE1BQTVCLENBQWQsQ0FBckMsQ0FEUCxHQUVPLFdBQVcsVUFBVSxHQUFWLEdBQWdCLEdBQWhCLEdBQXNCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxTQUFTLEdBQVQsSUFBZ0IsS0FBSyxNQUFNLE1BQVgsQ0FBaEIsQ0FBZCxDQUFqQyxDQUxYLENBREosSUFRSSxRQVR3QixHQVU1QixDQVZBOztBQVlSLHVCQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixJQUE0QyxRQUE1QztBQUlTO0FBRUk7QUFDSjtBQUNKLENBckZEOztBQXVGQTs7Ozs7O0FBTUEsUUFBUSxtREFBUixHQUE4RCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDeEYsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0QixFQUk1QixNQUo0Qjs7QUFNQSxxQkFBWSxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFELEdBQTZDLE1BQU0sS0FBbkQsR0FBMkQsR0FBNUQsR0FBb0UsQ0FBOUU7O0FBR1IsZ0JBQUksTUFBSixFQUFZO0FBQ1IseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsQ0FBVDs7QUFHUixvQkFDSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FEM0Q7QUFBQSxvQkFHSSxVQUFXLFNBQVMsTUFBVCxHQUFrQixHQUFuQixHQUEwQixDQUh4QztBQUFBLG9CQUlJLFdBQVksVUFBVSxTQUFTLElBQW5CLElBQTJCLEdBQTVCLEdBQW1DLENBSmxEO0FBQUEsb0JBS0ksV0FBWSxDQUFDLFNBQVMsSUFBVixJQUFrQixNQUFsQixHQUEyQixHQUE1QixHQUFtQyxDQUxsRDs7QUFPUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsSUFHSSxVQUFVLEdBQVYsR0FDTyxXQUFZLFVBQVUsQ0FBWCxHQUFnQixDQUFoQixHQUFvQixNQUFNLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxDQUFDLE1BQU0sTUFBUCxJQUFpQixHQUFqQixJQUF3QixJQUFJLE1BQTVCLENBQWQsQ0FBckMsQ0FEUCxHQUVPLFdBQVcsVUFBVSxHQUFWLEdBQWdCLEdBQWhCLEdBQXNCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxTQUFTLEdBQVQsSUFBZ0IsS0FBSyxNQUFNLE1BQVgsQ0FBaEIsQ0FBZCxDQUFqQyxDQUxYLENBREosSUFRSSxRQVRvQixHQVV4QixDQVZBOztBQVlJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixJQUdJLFVBQVUsR0FBVixHQUNPLFdBQVksVUFBVSxDQUFYLEdBQWdCLENBQWhCLEdBQW9CLE1BQU0sS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLENBQUMsTUFBTSxNQUFQLElBQWlCLEdBQWpCLElBQXdCLElBQUksTUFBNUIsQ0FBZCxDQUFyQyxDQURQLEdBRU8sV0FBVyxVQUFVLEdBQVYsR0FBZ0IsR0FBaEIsR0FBc0IsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLFNBQVMsR0FBVCxJQUFnQixLQUFLLE1BQU0sTUFBWCxDQUFoQixDQUFkLENBQWpDLENBTFgsQ0FESixJQVFJLFFBVHdCLEdBVTVCLENBVkE7O0FBWUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLElBR0ksVUFBVSxHQUFWLEdBQ08sV0FBWSxVQUFVLENBQVgsR0FBZ0IsQ0FBaEIsR0FBb0IsTUFBTSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsQ0FBQyxNQUFNLE1BQVAsSUFBaUIsR0FBakIsSUFBd0IsSUFBSSxNQUE1QixDQUFkLENBQXJDLENBRFAsR0FFTyxXQUFXLFVBQVUsR0FBVixHQUFnQixHQUFoQixHQUFzQixLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsU0FBUyxHQUFULElBQWdCLEtBQUssTUFBTSxNQUFYLENBQWhCLENBQWQsQ0FBakMsQ0FMWCxDQURKLElBUUksUUFUd0IsR0FVNUIsQ0FWQTs7QUFZUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQXJGRDs7QUF1RkE7Ozs7Ozs7O0FBUUEsUUFBUSwwQ0FBUixHQUFxRCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDL0UsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0Qjs7QUFJQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTs7QUFHaEIsb0JBQ0ksWUFBWSxTQUFTLElBRHpCOztBQUdRLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksWUFBWSxNQUFaLEdBQ0UsU0FBUyxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFNBQVMsSUFBSSxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQWIsR0FBb0MsR0FBaEQsQ0FBZCxDQUZmLElBR0ksR0FKb0IsR0FLeEIsQ0FMQTs7QUFPSSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFlBQVksTUFBWixHQUNFLFNBQVMsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxTQUFTLElBQUksTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFiLEdBQXdDLEdBQXBELENBQWQsQ0FGZixJQUdJLEdBSndCLEdBSzVCLENBTEE7O0FBT0kseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosR0FDRSxTQUFTLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksU0FBUyxJQUFJLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBYixHQUF3QyxHQUFwRCxDQUFkLENBRmYsSUFHSSxHQUp3QixHQUs1QixDQUxBO0FBU0M7QUFFSTtBQUNKO0FBQ0osQ0F2REQ7O0FBeURBOzs7Ozs7QUFNQSxRQUFRLCtDQUFSLEdBQTBELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNwRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCOztBQUlBLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR2hCLG9CQUNJLFlBQVksU0FBUyxJQUR6Qjs7QUFHUSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFlBQVksTUFBWixHQUNFLFNBQVMsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxTQUFTLElBQUksTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFiLEdBQW9DLEdBQWhELENBQWQsQ0FGZixJQUdJLEdBSm9CLEdBS3hCLENBTEE7O0FBT0kseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosR0FDRSxTQUFTLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksU0FBUyxJQUFJLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBYixHQUF3QyxHQUFwRCxDQUFkLENBRmYsSUFHSSxHQUp3QixHQUs1QixDQUxBOztBQU9JLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksWUFBWSxNQUFaLEdBQ0UsU0FBUyxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFNBQVMsSUFBSSxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQWIsR0FBd0MsR0FBcEQsQ0FBZCxDQUZmLElBR0ksR0FKd0IsR0FLNUIsQ0FMQTtBQVNDO0FBRUk7QUFDSjtBQUNKLENBdkREOztBQXlEQTs7Ozs7Ozs7QUFRQSxRQUFRLCtDQUFSLEdBQTBELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUNwRixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQVQ7O0FBR1IsZ0JBQUksTUFBSixFQUFZO0FBQ1IseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsQ0FBVDs7QUFHUixvQkFDSSxXQUFZLFNBQVMsTUFBVCxHQUFrQixTQUFTLE1BQVQsR0FBa0IsR0FBckMsR0FBNEMsQ0FEM0Q7QUFBQSxvQkFHSSxVQUFXLFNBQVMsTUFBVCxHQUFrQixHQUFuQixHQUEwQixDQUh4QztBQUFBLG9CQUlJLFdBQVksVUFBVSxTQUFTLElBQW5CLElBQTJCLEdBQTVCLEdBQW1DLENBSmxEO0FBQUEsb0JBS0ksV0FBWSxDQUFDLFNBQVMsSUFBVixJQUFrQixNQUFsQixHQUEyQixHQUE1QixHQUFtQyxDQUxsRDs7QUFPUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsR0FFRSxVQUFVLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksU0FBUyxJQUFJLE1BQWIsR0FBc0IsR0FBbEMsQ0FBZCxDQUhoQixJQUlJLFFBTG9CLEdBTXhCLENBTkE7O0FBUUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLEdBRUUsVUFBVSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFNBQVMsSUFBSSxNQUFiLEdBQXNCLEdBQWxDLENBQWQsQ0FIaEIsSUFJSSxRQUx3QixHQU01QixDQU5BOztBQVFJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixHQUVFLFVBQVUsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxTQUFTLElBQUksTUFBYixHQUFzQixHQUFsQyxDQUFkLENBSGhCLElBSUksUUFMd0IsR0FNNUIsQ0FOQTs7QUFRUix1QkFBTyxJQUFQLENBQVksV0FBVyxpQkFBdkIsSUFBNEMsUUFBNUM7QUFJUztBQUVJO0FBQ0o7QUFDSixDQXpFRDs7QUEyRUE7Ozs7OztBQU1BLFFBQVEsb0RBQVIsR0FBK0QsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQ3pGLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEIsRUFJNUIsTUFKNEI7O0FBTUEscUJBQVksTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBRCxHQUE2QyxNQUFNLEtBQW5ELEdBQTJELEdBQTVELEdBQW9FLENBQTlFOztBQUdSLGdCQUFJLE1BQUosRUFBWTtBQUNSLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLENBQVQ7O0FBR1Isb0JBQ0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBRDNEO0FBQUEsb0JBR0ksVUFBVyxTQUFTLE1BQVQsR0FBa0IsR0FBbkIsR0FBMEIsQ0FIeEM7QUFBQSxvQkFJSSxXQUFZLFVBQVUsU0FBUyxJQUFuQixJQUEyQixHQUE1QixHQUFtQyxDQUpsRDtBQUFBLG9CQUtJLFdBQVksQ0FBQyxTQUFTLElBQVYsSUFBa0IsTUFBbEIsR0FBMkIsR0FBNUIsR0FBbUMsQ0FMbEQ7O0FBT1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLEdBRUUsVUFBVSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLFNBQVMsSUFBSSxNQUFiLEdBQXNCLEdBQWxDLENBQWQsQ0FIaEIsSUFJSSxRQUxvQixHQU14QixDQU5BOztBQVFJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixHQUVFLFVBQVUsS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxTQUFTLElBQUksTUFBYixHQUFzQixHQUFsQyxDQUFkLENBSGhCLElBSUksUUFMd0IsR0FNNUIsQ0FOQTs7QUFRSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxXQUFXLE1BQVgsR0FDRSxXQUFXLE1BRGIsR0FFRSxVQUFVLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksU0FBUyxJQUFJLE1BQWIsR0FBc0IsR0FBbEMsQ0FBZCxDQUhoQixJQUlJLFFBTHdCLEdBTTVCLENBTkE7O0FBUVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0F6RUQ7O0FBMkVBOzs7Ozs7OztBQVFBLFFBQVEsdUNBQVIsR0FBa0QsVUFBUyxLQUFULEVBQWdCLE1BQWhCLEVBQXdCLElBQXhCLEVBQThCO0FBQzVFLFFBQ0ksSUFBSSxLQUFLLFNBQUwsS0FBbUIsQ0FEM0I7QUFBQSxRQUVwQixJQUFJLEtBQUssUUFBTCxLQUFrQixDQUZGO0FBQUEsUUFHcEIsVUFBVyxDQUFDLE1BQU0sS0FBTixHQUFjLENBQWYsSUFBb0IsZUFBckIsR0FBd0MsQ0FIOUI7QUFBQSxRQUlwQixXQUFXLE1BQU0sYUFBTixDQUFvQixLQUFLLElBQXpCLEVBQStCLEtBQUssR0FBcEMsSUFBMkMsQ0FKbEM7O0FBTUEsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFpQixJQUFJLENBQXJCLEVBQXdCLEtBQUssWUFBWSxPQUF6QyxFQUFrRDtBQUM5QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxZQUFZLGVBQXhDLEVBQXlEO0FBQ3JELGdCQUNJLE1BREosRUFFNUIsTUFGNEIsRUFHNUIsTUFINEI7O0FBS0EscUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxpQkFBdEIsQ0FBVDs7QUFHUixnQkFBSSxNQUFKLEVBQVk7O0FBR2hCLG9CQUNJLFlBQVksU0FBUyxJQUR6Qjs7QUFHUSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxRQUFYLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksUUFBWixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxRQUFaLElBQ0EsQ0FDSSxZQUFZLE1BQVosR0FDRSxVQUFXLFVBQVUsSUFBSSxNQUFmLEdBQTBCLElBQUksTUFBOUIsR0FBeUMsVUFBVSxJQUFJLE1BQUosR0FBYSxHQUF4QixHQUFnQyxJQUFJLE1BQUosR0FBYSxHQUE3QyxHQUFvRCxNQUF0RyxDQUZOLElBR0ksR0FKb0IsR0FLeEIsQ0FMQTs7QUFPSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosR0FDRSxVQUFXLFVBQVUsSUFBSSxNQUFmLEdBQTBCLElBQUksTUFBOUIsR0FBeUMsVUFBVSxJQUFJLE1BQUosR0FBYSxHQUF4QixHQUFnQyxJQUFJLE1BQUosR0FBYSxHQUE3QyxHQUFvRCxNQUF0RyxDQUZOLElBR0ksR0FKd0IsR0FLNUIsQ0FMQTs7QUFPSSx5QkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLENBQXRCLENBQVQ7O0FBRUEseUJBQVMsT0FBTyxJQUFQLENBQVksV0FBVyxDQUF2QixDQUFUOztBQUVKLHVCQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLElBQ0EsQ0FDSSxZQUFZLE1BQVosR0FDRSxVQUFXLFVBQVUsSUFBSSxNQUFmLEdBQTBCLElBQUksTUFBOUIsR0FBeUMsVUFBVSxJQUFJLE1BQUosR0FBYSxHQUF4QixHQUFnQyxJQUFJLE1BQUosR0FBYSxHQUE3QyxHQUFvRCxNQUF0RyxDQUZOLElBR0ksR0FKd0IsR0FLNUIsQ0FMQTtBQVNDO0FBRUk7QUFDSjtBQUNKLENBOUREOztBQWdFQTs7Ozs7O0FBTUEsUUFBUSw0Q0FBUixHQUF1RCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDakYsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0Qjs7QUFLQSxxQkFBWSxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFELEdBQTZDLE1BQU0sS0FBbkQsR0FBMkQsR0FBNUQsR0FBb0UsQ0FBOUU7O0FBR1IsZ0JBQUksTUFBSixFQUFZOztBQUdoQixvQkFDSSxZQUFZLFNBQVMsSUFEekI7O0FBR1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksWUFBWSxNQUFaLEdBQ0UsVUFBVyxVQUFVLElBQUksTUFBZixHQUEwQixJQUFJLE1BQTlCLEdBQXlDLFVBQVUsSUFBSSxNQUFKLEdBQWEsR0FBeEIsR0FBZ0MsSUFBSSxNQUFKLEdBQWEsR0FBN0MsR0FBb0QsTUFBdEcsQ0FGTixJQUdJLEdBSm9CLEdBS3hCLENBTEE7O0FBT0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksWUFBWSxNQUFaLEdBQ0UsVUFBVyxVQUFVLElBQUksTUFBZixHQUEwQixJQUFJLE1BQTlCLEdBQXlDLFVBQVUsSUFBSSxNQUFKLEdBQWEsR0FBeEIsR0FBZ0MsSUFBSSxNQUFKLEdBQWEsR0FBN0MsR0FBb0QsTUFBdEcsQ0FGTixJQUdJLEdBSndCLEdBSzVCLENBTEE7O0FBT0kseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksWUFBWSxNQUFaLEdBQ0UsVUFBVyxVQUFVLElBQUksTUFBZixHQUEwQixJQUFJLE1BQTlCLEdBQXlDLFVBQVUsSUFBSSxNQUFKLEdBQWEsR0FBeEIsR0FBZ0MsSUFBSSxNQUFKLEdBQWEsR0FBN0MsR0FBb0QsTUFBdEcsQ0FGTixJQUdJLEdBSndCLEdBSzVCLENBTEE7QUFTQztBQUVJO0FBQ0o7QUFDSixDQTlERDs7QUFnRUE7Ozs7Ozs7O0FBUUEsUUFBUSw0Q0FBUixHQUF1RCxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0IsSUFBeEIsRUFBOEI7QUFDakYsUUFDSSxJQUFJLEtBQUssU0FBTCxLQUFtQixDQUQzQjtBQUFBLFFBRXBCLElBQUksS0FBSyxRQUFMLEtBQWtCLENBRkY7QUFBQSxRQUdwQixVQUFXLENBQUMsTUFBTSxLQUFOLEdBQWMsQ0FBZixJQUFvQixlQUFyQixHQUF3QyxDQUg5QjtBQUFBLFFBSXBCLFdBQVcsTUFBTSxhQUFOLENBQW9CLEtBQUssSUFBekIsRUFBK0IsS0FBSyxHQUFwQyxJQUEyQyxDQUpsQzs7QUFNQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWlCLElBQUksQ0FBckIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksZUFBeEMsRUFBeUQ7QUFDckQsZ0JBQ0ksTUFESixFQUU1QixNQUY0QixFQUc1QixNQUg0QixFQUk1QixNQUo0Qjs7QUFNQSxxQkFBUyxNQUFNLElBQU4sQ0FBVyxXQUFXLGlCQUF0QixDQUFUOztBQUdSLGdCQUFJLE1BQUosRUFBWTtBQUNSLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLENBQVQ7O0FBR1Isb0JBQ0ksV0FBWSxTQUFTLE1BQVQsR0FBa0IsU0FBUyxNQUFULEdBQWtCLEdBQXJDLEdBQTRDLENBRDNEO0FBQUEsb0JBR0ksVUFBVyxTQUFTLE1BQVQsR0FBa0IsR0FBbkIsR0FBMEIsQ0FIeEM7QUFBQSxvQkFJSSxXQUFZLFVBQVUsU0FBUyxJQUFuQixJQUEyQixHQUE1QixHQUFtQyxDQUpsRDtBQUFBLG9CQUtJLFdBQVksQ0FBQyxTQUFTLElBQVYsSUFBa0IsTUFBbEIsR0FBMkIsR0FBNUIsR0FBbUMsQ0FMbEQ7O0FBT1EseUJBQVMsTUFBTSxJQUFOLENBQVcsUUFBWCxDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksUUFBWixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLEdBRUUsV0FBWSxVQUFVLElBQUksTUFBZixHQUEwQixJQUFJLE1BQTlCLEdBQXlDLFVBQVUsSUFBSSxNQUFKLEdBQWEsR0FBeEIsR0FBZ0MsSUFBSSxNQUFKLEdBQWEsR0FBN0MsR0FBb0QsTUFBdkcsQ0FITixJQUlJLFFBTG9CLEdBTXhCLENBTkE7O0FBUUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLEdBRUUsV0FBWSxVQUFVLElBQUksTUFBZixHQUEwQixJQUFJLE1BQTlCLEdBQXlDLFVBQVUsSUFBSSxNQUFKLEdBQWEsR0FBeEIsR0FBZ0MsSUFBSSxNQUFKLEdBQWEsR0FBN0MsR0FBb0QsTUFBdkcsQ0FITixJQUlJLFFBTHdCLEdBTTVCLENBTkE7O0FBUUkseUJBQVMsTUFBTSxJQUFOLENBQVcsV0FBVyxDQUF0QixDQUFUOztBQUVBLHlCQUFTLE9BQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsQ0FBVDs7QUFFSix1QkFBTyxJQUFQLENBQVksV0FBVyxDQUF2QixJQUNBLENBQ0ksV0FBVyxNQUFYLEdBQ0UsV0FBVyxNQURiLEdBRUUsV0FBWSxVQUFVLElBQUksTUFBZixHQUEwQixJQUFJLE1BQTlCLEdBQXlDLFVBQVUsSUFBSSxNQUFKLEdBQWEsR0FBeEIsR0FBZ0MsSUFBSSxNQUFKLEdBQWEsR0FBN0MsR0FBb0QsTUFBdkcsQ0FITixJQUlJLFFBTHdCLEdBTTVCLENBTkE7O0FBUVIsdUJBQU8sSUFBUCxDQUFZLFdBQVcsaUJBQXZCLElBQTRDLFFBQTVDO0FBSVM7QUFFSTtBQUNKO0FBQ0osQ0F6RUQ7O0FBMkVBOzs7Ozs7QUFNQSxRQUFRLGlEQUFSLEdBQTRELFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QixJQUF4QixFQUE4QjtBQUN0RixRQUNJLElBQUksS0FBSyxTQUFMLEtBQW1CLENBRDNCO0FBQUEsUUFFcEIsSUFBSSxLQUFLLFFBQUwsS0FBa0IsQ0FGRjtBQUFBLFFBR3BCLFVBQVcsQ0FBQyxNQUFNLEtBQU4sR0FBYyxDQUFmLElBQW9CLGVBQXJCLEdBQXdDLENBSDlCO0FBQUEsUUFJcEIsV0FBVyxNQUFNLGFBQU4sQ0FBb0IsS0FBSyxJQUF6QixFQUErQixLQUFLLEdBQXBDLElBQTJDLENBSmxDOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBaUIsSUFBSSxDQUFyQixFQUF3QixLQUFLLFlBQVksT0FBekMsRUFBa0Q7QUFDOUMsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxlQUF4QyxFQUF5RDtBQUNyRCxnQkFDSSxNQURKLEVBRTVCLE1BRjRCLEVBRzVCLE1BSDRCLEVBSTVCLE1BSjRCOztBQU1BLHFCQUFZLE1BQU0sSUFBTixDQUFXLFdBQVcsaUJBQXRCLENBQUQsR0FBNkMsTUFBTSxLQUFuRCxHQUEyRCxHQUE1RCxHQUFvRSxDQUE5RTs7QUFHUixnQkFBSSxNQUFKLEVBQVk7QUFDUix5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixDQUFUOztBQUdSLG9CQUNJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUQzRDtBQUFBLG9CQUdJLFVBQVcsU0FBUyxNQUFULEdBQWtCLEdBQW5CLEdBQTBCLENBSHhDO0FBQUEsb0JBSUksV0FBWSxVQUFVLFNBQVMsSUFBbkIsSUFBMkIsR0FBNUIsR0FBbUMsQ0FKbEQ7QUFBQSxvQkFLSSxXQUFZLENBQUMsU0FBUyxJQUFWLElBQWtCLE1BQWxCLEdBQTJCLEdBQTVCLEdBQW1DLENBTGxEOztBQU9RLHlCQUFTLE1BQU0sSUFBTixDQUFXLFFBQVgsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxRQUFaLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFFBQVosSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixHQUVFLFdBQVksVUFBVSxJQUFJLE1BQWYsR0FBMEIsSUFBSSxNQUE5QixHQUF5QyxVQUFVLElBQUksTUFBSixHQUFhLEdBQXhCLEdBQWdDLElBQUksTUFBSixHQUFhLEdBQTdDLEdBQW9ELE1BQXZHLENBSE4sSUFJSSxRQUxvQixHQU14QixDQU5BOztBQVFJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixHQUVFLFdBQVksVUFBVSxJQUFJLE1BQWYsR0FBMEIsSUFBSSxNQUE5QixHQUF5QyxVQUFVLElBQUksTUFBSixHQUFhLEdBQXhCLEdBQWdDLElBQUksTUFBSixHQUFhLEdBQTdDLEdBQW9ELE1BQXZHLENBSE4sSUFJSSxRQUx3QixHQU01QixDQU5BOztBQVFJLHlCQUFTLE1BQU0sSUFBTixDQUFXLFdBQVcsQ0FBdEIsQ0FBVDs7QUFFQSx5QkFBUyxPQUFPLElBQVAsQ0FBWSxXQUFXLENBQXZCLENBQVQ7O0FBRUosdUJBQU8sSUFBUCxDQUFZLFdBQVcsQ0FBdkIsSUFDQSxDQUNJLFdBQVcsTUFBWCxHQUNFLFdBQVcsTUFEYixHQUVFLFdBQVksVUFBVSxJQUFJLE1BQWYsR0FBMEIsSUFBSSxNQUE5QixHQUF5QyxVQUFVLElBQUksTUFBSixHQUFhLEdBQXhCLEdBQWdDLElBQUksTUFBSixHQUFhLEdBQTdDLEdBQW9ELE1BQXZHLENBSE4sSUFJSSxRQUx3QixHQU01QixDQU5BOztBQVFSLHVCQUFPLElBQVAsQ0FBWSxXQUFXLGlCQUF2QixJQUE0QyxRQUE1QztBQUlTO0FBRUk7QUFDSjtBQUNKLENBekVEOztBQTRFWixRQUFRLFNBQVIsR0FBb0IsQ0FBcEI7QUFDQSxRQUFRLFdBQVIsR0FBc0IsQ0FBdEI7QUFDQSxRQUFRLE1BQVIsR0FBaUIsQ0FBakI7QUFDQSxRQUFRLFNBQVIsR0FBb0IsQ0FBcEI7QUFDQSxRQUFRLFVBQVIsR0FBcUIsQ0FBckI7QUFDQSxRQUFRLFNBQVIsR0FBb0IsQ0FBcEI7QUFDQSxRQUFRLFdBQVIsR0FBc0IsQ0FBdEI7QUFDQSxRQUFRLFFBQVIsR0FBbUIsQ0FBbkI7QUFDQSxRQUFRLE9BQVIsR0FBa0IsQ0FBbEI7QUFDQSxRQUFRLFVBQVIsR0FBcUIsQ0FBckI7QUFDQSxRQUFRLFlBQVIsR0FBdUIsRUFBdkI7QUFDQSxRQUFRLFlBQVIsR0FBdUIsRUFBdkI7QUFDQSxRQUFRLGFBQVIsR0FBd0IsRUFBeEI7QUFDQSxRQUFRLGNBQVIsR0FBeUIsRUFBekI7QUFDQSxRQUFRLFdBQVIsR0FBc0IsRUFBdEI7O0FBRUo7Ozs7Ozs7O0FBUUEsUUFBUSxTQUFSLEdBQW9CLFVBQVUsTUFBVixFQUFrQixxQkFBbEIsRUFBeUMsS0FBekMsRUFBZ0QsSUFBaEQsRUFBc0Q7QUFDdEUsUUFBSSxNQUFNLEtBQU4sSUFBZSxDQUFuQixFQUFzQjtBQUNsQjtBQUNIOztBQUVELFFBQ0ksV0FBVyxpQkFBaUIsTUFBTSxTQUF2QixJQUFvQyxNQURuRDs7QUFHQSxRQUFJLE9BQU8sS0FBUCxHQUFlLEdBQW5CLEVBQXdCO0FBQ3BCLGNBQU0seUNBQU47QUFDSDs7QUFFRCxRQUFJLHFCQUFKLEVBQTJCO0FBQ3ZCLG9CQUFZLG1CQUFaO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsb0JBQVksY0FBWjtBQUNIOztBQUVELFFBQUksTUFBTSxLQUFOLElBQWUsR0FBbkIsRUFBd0I7QUFDcEIsb0JBQVksaUJBQVo7QUFDSCxLQUZELE1BRU87QUFDSCxvQkFBWSxzQkFBWjtBQUNIOztBQUVELFdBQU8sU0FBUCxHQUFtQixJQUFuQixDQUF3QixJQUF4Qjs7QUFFQSxTQUFLLFFBQUwsRUFBZSxLQUFmLEVBQXNCLE1BQXRCLEVBQThCLElBQTlCO0FBQ0gsQ0EzQkQ7QUE0QkEsU0FBUyxnQkFBVCxHQUE0QjtBQUN4QjtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixZQUNJLElBQUksSUFBSSxHQURaOztBQUdBLDJCQUFtQixDQUFuQixJQUF5QixDQUFDLElBQUksSUFBSSxDQUFULElBQWMsR0FBZixHQUFzQixDQUE5QztBQUNIOztBQUVEO0FBQ0EsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEdBQXBCLEVBQXlCLEdBQXpCLEVBQThCO0FBQzFCLFlBQ0ksSUFBSSxJQUFJLEdBRFo7O0FBR0EsK0JBQXVCLENBQXZCLElBQTZCLENBQUMsS0FBSyxJQUFMLENBQVUsQ0FBVixJQUFlLENBQWhCLElBQXFCLEdBQXRCLEdBQTZCLENBQXpEO0FBQ0g7QUFDSjtBQUNEOzs7Ozs7Ozs7a0JDdnNJd0IsVztBQXRCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQmUsU0FBUyxXQUFULENBQXFCLFVBQXJCLEVBQWlDO0FBQzVDO0FBQ0EsU0FBSyxJQUFJLFFBQVQsSUFBcUIsWUFBWSxRQUFqQyxFQUEyQztBQUN2QyxZQUFJLFlBQVksUUFBWixDQUFxQixjQUFyQixDQUFvQyxRQUFwQyxDQUFKLEVBQW1EO0FBQy9DLGlCQUFLLFFBQUwsSUFBaUIsWUFBWSxRQUFaLENBQXFCLFFBQXJCLENBQWpCO0FBQ0g7QUFDSjs7QUFFRCxTQUFLLElBQUksUUFBVCxJQUFxQixVQUFyQixFQUFpQztBQUM3QixZQUFJLFdBQVcsY0FBWCxDQUEwQixRQUExQixDQUFKLEVBQXlDO0FBQ3JDLGlCQUFLLFFBQUwsSUFBaUIsV0FBVyxRQUFYLENBQWpCO0FBQ0g7QUFDSjtBQUNKOztBQUVEO0FBQ0EsWUFBWSxXQUFaLEdBQTBCLENBQTFCO0FBQ0EsWUFBWSxPQUFaLEdBQXNCLENBQXRCO0FBQ0EsWUFBWSxTQUFaLEdBQXdCLENBQXhCOztBQUVBO0FBQ0EsWUFBWSxhQUFaLEdBQTRCLENBQTVCO0FBQ0EsWUFBWSxVQUFaLEdBQXlCLENBQXpCO0FBQ0EsWUFBWSxnQkFBWixHQUErQixDQUEvQjtBQUNBLFlBQVksY0FBWixHQUE2QixDQUE3QjtBQUNBLFlBQVksV0FBWixHQUEwQixDQUExQjs7QUFFQTtBQUNBLFlBQVksT0FBWixHQUFzQixDQUF0QjtBQUNBLFlBQVksT0FBWixHQUFzQixDQUF0QjtBQUNBLFlBQVksT0FBWixHQUFzQixDQUF0QjtBQUNBLFlBQVksTUFBWixHQUFxQixDQUFyQjtBQUNBLFlBQVksT0FBWixHQUFzQixDQUF0QjtBQUNBLFlBQVksTUFBWixHQUFxQixDQUFyQjtBQUNBLFlBQVksUUFBWixHQUF1QixDQUF2QjtBQUNBLFlBQVksS0FBWixHQUFvQixDQUFwQjs7QUFFQSxZQUFZLFFBQVosR0FBdUI7QUFDbkIsVUFBTSxLQURhLEVBQ04sWUFBWSxLQUROO0FBRW5CLGdCQUFZLENBRk8sRUFFSixTQUFTLENBRkw7O0FBSW5CLGtCQUFjLElBSks7QUFLbkIsbUJBQWUsS0FMSTtBQU1uQix3QkFBb0IsS0FORDs7QUFRbkIsVUFBTSxDQVJhLEVBUVYsV0FBVyxDQVJEO0FBU25CLGdCQUFZLFlBQVksV0FUTDtBQVVuQixXQUFPLEdBVlksRUFVUCxPQUFPLEdBVkE7O0FBWW5CLGFBQVMsR0FaVTs7QUFjbkI7QUFDQSxVQUFNLENBZmEsRUFlVixTQUFTLENBZkM7QUFnQm5CLFdBQU8sQ0FoQlksRUFnQlQsVUFBVSxDQWhCRDtBQWlCbkIsZ0JBQVksR0FqQk8sRUFpQkYsZUFBZSxDQWpCYjtBQWtCbkIsYUFBUyxHQWxCVSxFQWtCTCxZQUFZLENBbEJQO0FBbUJuQixXQUFPLEtBQUssRUFuQk8sRUFtQkgsVUFBVSxDQW5CUDs7QUFxQm5CLGVBQVc7QUFyQlEsQ0FBdkI7O0FBd0JBLFlBQVksU0FBWixDQUFzQixhQUF0QixHQUFzQyxVQUFTLFFBQVQsRUFBbUI7QUFDckQ7QUFDQSxRQUFJLEtBQUssWUFBTCxJQUFxQixLQUFLLFNBQUwsSUFBa0IsWUFBWSxRQUFuRCxJQUErRCxLQUFLLFNBQUwsSUFBa0IsWUFBWSxLQUFqRyxFQUF3RztBQUNwRyxhQUFLLE9BQUwsR0FBZSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsS0FBSyxJQUFMLEdBQVksUUFBMUIsQ0FBZjtBQUNILEtBRkQsTUFFTztBQUNILGFBQUssT0FBTCxHQUFlLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFLLElBQW5CLENBQWY7QUFDSDs7QUFFRDtBQUNBLFFBQUksS0FBSyxPQUFMLEdBQWUsRUFBbkIsRUFBdUI7QUFDbkIsYUFBSyxPQUFMLEdBQWUsS0FBSyxLQUFMLENBQVcsS0FBSyxPQUFoQixDQUFmO0FBQ0g7O0FBRUQsU0FBSyxRQUFMLEdBQWdCLEtBQUssYUFBTCxHQUFxQixLQUFLLEtBQUwsQ0FBVyxLQUFLLEtBQUwsR0FBYSxLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLEdBQW5CLENBQXhCLENBQXJCLEdBQXdFLEtBQUssS0FBN0Y7QUFDQSxTQUFLLFVBQUwsR0FBa0IsS0FBSyxPQUF2QjtBQUNBLFNBQUssUUFBTCxHQUFnQixLQUFLLEtBQXJCO0FBQ0EsU0FBSyxhQUFMLEdBQXFCLEtBQUssVUFBTCxHQUFrQixLQUFLLE9BQXZCLElBQWtDLEtBQUssa0JBQUwsR0FBMEIsUUFBMUIsR0FBcUMsR0FBdkUsQ0FBckI7QUFDSCxDQWpCRDs7QUFtQkEsWUFBWSxTQUFaLENBQXNCLEtBQXRCLEdBQThCLFlBQVc7QUFDckMsV0FBTyxJQUFJLFdBQUosQ0FBZ0IsSUFBaEIsQ0FBUDtBQUNILENBRkQ7Ozs7Ozs7OztrQkM5RXdCLGM7O0FBRnhCOzs7Ozs7QUFFZSxTQUFTLGNBQVQsR0FBMEI7QUFDckMsUUFDSSxjQUFjLEVBRGxCO0FBQUEsUUFFSSxnQkFBZ0IsR0FGcEI7QUFBQSxRQUdJLG1CQUFtQixHQUh2Qjs7QUFLQTs7Ozs7Ozs7O0FBU0EsUUFDSSxRQUFRLElBQUksVUFBSixDQUFlLGdCQUFnQixhQUEvQixDQURaO0FBQUEsUUFFSSxVQUFVLElBQUksVUFBSixDQUFlLG1CQUFtQixnQkFBbEMsQ0FGZDtBQUFBLFFBSUksYUFBYSxJQUpqQjtBQUFBLFFBS0ksU0FMSjtBQUFBLFFBS2UsWUFMZjtBQUFBLFFBSzZCLFVBTDdCO0FBQUEsUUFNSSxTQU5KO0FBQUEsUUFRSSxPQUFPLElBUlg7O0FBVUE7Ozs7O0FBS0EsYUFBUyxjQUFULENBQXdCLFNBQXhCLEVBQW1DLEVBQW5DLEVBQXVDLEVBQXZDLEVBQTJDO0FBQ3ZDLFlBQ0ksYUFBYSxTQUFTLFNBQVQsQ0FEakI7QUFBQSxZQUdJLFVBQVUsS0FBSyxJQUFMLENBQVUsVUFBVSxPQUFwQixDQUhkO0FBQUEsWUFJSSxZQUFZLEtBQUssSUFBTCxDQUFVLFVBQVUsT0FBcEIsSUFBK0IsQ0FKL0M7O0FBTUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFlBQVksU0FBaEMsRUFBMkMsR0FBM0MsRUFBZ0Q7QUFDNUMsb0JBQVEsQ0FBUixJQUFhLENBQWI7QUFDSDs7QUFFRCxZQUNJLGNBQWMsQ0FBQyxJQUFJLEVBQUwsS0FBWSxJQUFJLEVBQWhCLENBRGxCO0FBQUEsWUFFSSxXQUFXLE1BQU0sSUFBSSxFQUFWLENBRmY7QUFBQSxZQUdJLFFBQVEsS0FBSyxFQUhqQjtBQUFBLFlBSUksV0FBVyxDQUFDLElBQUksRUFBTCxJQUFXLEVBSjFCO0FBQUEsWUFNSSxXQUFXLENBTmY7QUFBQSxZQU9JLFdBQVcsQ0FQZjs7QUFTQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBcEIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDOUIsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFwQixFQUE2QixHQUE3QixFQUFrQztBQUM5QixvQkFDSSxhQUFhLFdBQVcsUUFBWCxDQURqQjs7QUFHQTs7OztBQUlBLHdCQUFRLFFBQVIsS0FBcUIsQ0FBQyxFQUFFLGFBQWEsV0FBZixDQUF0QjtBQUNBLHdCQUFRLFdBQVcsQ0FBbkIsS0FBeUIsQ0FBQyxFQUFFLGFBQWEsUUFBZixDQUExQjtBQUNBLHdCQUFRLFdBQVcsQ0FBWCxHQUFlLFNBQXZCLEtBQXFDLENBQUMsRUFBRSxhQUFhLEtBQWYsQ0FBdEM7QUFDQSx3QkFBUSxXQUFXLFNBQW5CLEtBQWlDLENBQUMsRUFBRSxhQUFhLFFBQWYsQ0FBbEM7O0FBRUE7QUFDQTtBQUNIO0FBQ0Qsd0JBQVksWUFBWSxPQUF4QjtBQUNIOztBQUVELGVBQU8sT0FBUDtBQUNIOztBQUVELGFBQVMsVUFBVCxDQUFvQixLQUFwQixFQUEyQixTQUEzQixFQUFzQztBQUNsQyxZQUNJLFVBQVUsS0FBSyxJQUFMLENBQVUsVUFBVSxPQUFwQixDQURkO0FBQUEsWUFHSSxTQUFTLFVBQVUsR0FIdkI7QUFBQSxZQUlJLFlBQWEsVUFBVSxPQUFWLEdBQW9CLENBQXJCLElBQTJCLFVBQVUsT0FBVixHQUFvQixDQUEvQyxDQUpoQjtBQUFBLFlBTUksVUFBVSxNQUFNLFVBQVUsVUFBVixHQUF1QixXQU4zQztBQUFBLFlBT0ksT0FBTyxLQUFLLEdBQUwsQ0FBUyxVQUFVLFFBQW5CLENBUFg7QUFBQSxZQVFJLE9BQU8sS0FBSyxHQUFMLENBQVMsVUFBVSxRQUFuQixDQVJYO0FBQUEsWUFVSSxTQUFTLENBVmI7O0FBWUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQXBCLEVBQTZCLEdBQTdCLEVBQWtDO0FBQzlCLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBcEIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDOUIsb0JBQ0ksSUFBSyxJQUFJLEdBQUosR0FBVSxNQURuQjtBQUFBLG9CQUVJLElBQUssSUFBSSxHQUFKLEdBQVUsTUFGbkI7QUFBQSxvQkFHSSxLQUFLLENBQUMsSUFBSSxJQUFKLEdBQVcsSUFBSSxJQUFoQixJQUF3QixPQUhqQztBQUFBLG9CQUlJLEtBQU0sSUFBSSxJQUFKLEdBQVcsSUFBSSxJQUp6QjtBQUFBLG9CQU1JLFVBQVUsS0FBSyxFQUFMLEdBQVUsS0FBSyxFQU43Qjs7QUFRQSxvQkFBSSxXQUFXLFNBQWYsRUFBMEI7QUFDdEIsMEJBQU0sUUFBTixJQUFrQixJQUFsQjtBQUNILGlCQUZELE1BRU87QUFDSCwwQkFBTSxRQUFOLElBQWtCLENBQWxCO0FBQ0g7QUFDSjtBQUNKOztBQUVELGVBQU8sS0FBUDtBQUNIOztBQUVELGFBQVMsWUFBVCxDQUFzQixLQUF0QixFQUE2QixTQUE3QixFQUF3QztBQUNwQyxZQUNJLFVBQVUsS0FBSyxJQUFMLENBQVUsVUFBVSxPQUFwQixDQURkO0FBQUEsWUFHSSxTQUFTLFVBQVUsR0FIdkI7QUFBQSxZQUlJLFlBQWEsVUFBVSxPQUFWLEdBQW9CLENBQXJCLElBQTJCLFVBQVUsT0FBVixHQUFvQixDQUEvQyxDQUpoQjtBQUFBLFlBS0ksaUJBQWtCLENBQUMsVUFBVSxPQUFWLEdBQW9CLENBQXJCLElBQTBCLENBQTNCLElBQWlDLENBQUMsVUFBVSxPQUFWLEdBQW9CLENBQXJCLElBQTBCLENBQTNELENBTHJCO0FBQUEsWUFNSSxpQkFBa0IsQ0FBQyxVQUFVLE9BQVYsR0FBb0IsQ0FBckIsSUFBMEIsQ0FBM0IsSUFBaUMsQ0FBQyxVQUFVLE9BQVYsR0FBb0IsQ0FBckIsSUFBMEIsQ0FBM0QsQ0FOckI7QUFBQSxZQVFJLFVBQVUsTUFBTSxVQUFVLFVBQVYsR0FBdUIsV0FSM0M7QUFBQSxZQVNJLE9BQU8sS0FBSyxHQUFMLENBQVMsVUFBVSxRQUFuQixDQVRYO0FBQUEsWUFVSSxPQUFPLEtBQUssR0FBTCxDQUFTLFVBQVUsUUFBbkIsQ0FWWDtBQUFBLFlBWUksU0FBUyxDQVpiOztBQWNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFwQixFQUE2QixHQUE3QixFQUFrQztBQUM5QixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQXBCLEVBQTZCLEdBQTdCLEVBQWtDO0FBQzlCLG9CQUNJLElBQUssSUFBSSxHQUFKLEdBQVUsTUFEbkI7QUFBQSxvQkFFSSxJQUFLLElBQUksR0FBSixHQUFVLE1BRm5CO0FBQUEsb0JBR0ksS0FBSyxDQUFDLElBQUksSUFBSixHQUFXLElBQUksSUFBaEIsSUFBd0IsT0FIakM7QUFBQSxvQkFJSSxLQUFNLElBQUksSUFBSixHQUFXLElBQUksSUFKekI7QUFBQSxvQkFNSSxVQUFVLEtBQUssRUFBTCxHQUFVLEtBQUssRUFON0I7O0FBUUEsb0JBQUksV0FBVyxjQUFmLEVBQStCO0FBQzNCLDBCQUFNLFFBQU4sSUFBa0IsSUFBbEI7QUFDSCxpQkFGRCxNQUVPLElBQUksVUFBVSxjQUFkLEVBQThCO0FBQ2pDLDBCQUFNLFFBQU4sSUFBa0IsQ0FBbEI7QUFDSCxpQkFGTSxNQUVBO0FBQ0gsd0JBQ0ksUUFBUSxDQURaOztBQUdBLHlCQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssQ0FBdEIsRUFBeUIsSUFBekIsRUFBK0I7QUFDM0IsNkJBQUssSUFBSSxLQUFLLENBQWQsRUFBaUIsS0FBSyxDQUF0QixFQUF5QixJQUF6QixFQUErQjtBQUMzQixnQ0FBSSxJQUFJLE1BQU0sTUFBTSxHQUFaLENBQUosR0FBdUIsTUFBM0I7QUFDQSxnQ0FBSSxJQUFJLE1BQU0sTUFBTSxHQUFaLENBQUosR0FBdUIsTUFBM0I7QUFDQSxpQ0FBSyxDQUFDLElBQUksSUFBSixHQUFXLElBQUksSUFBaEIsSUFBd0IsT0FBN0I7QUFDQSxpQ0FBTSxJQUFJLElBQUosR0FBVyxJQUFJLElBQXJCOztBQUVBLHNDQUFVLEtBQUssRUFBTCxHQUFVLEtBQUssRUFBekI7QUFDQSxnQ0FBSSxXQUFXLFNBQWYsRUFBMEI7QUFDdEIseUNBQVMsQ0FBVDtBQUNIO0FBQ0o7QUFDSjtBQUNELDBCQUFNLFFBQU4sSUFBa0IsS0FBSyxHQUFMLENBQVMsUUFBUSxFQUFqQixFQUFxQixHQUFyQixDQUFsQjtBQUNIO0FBQ0o7QUFDSjs7QUFFRCxlQUFPLEtBQVA7QUFDSDs7QUFFRCxhQUFTLGdCQUFULENBQTBCLEtBQTFCLEVBQWlDLFNBQWpDLEVBQTRDO0FBQ3hDLFlBQ0ksVUFBVSxLQUFLLElBQUwsQ0FBVSxVQUFVLE9BQXBCLENBRGQ7QUFBQSxZQUVJLFNBQVMsVUFBVSxHQUZ2QjtBQUFBLFlBSUksT0FBTyxVQUFVLE9BQVYsR0FBb0IsS0FBSyxHQUFMLENBQVMsS0FBSyxFQUFMLEdBQVUsQ0FBbkIsQ0FKL0I7QUFBQSxZQUtJLFFBQVMsT0FBTyxDQUFSLElBQWMsTUFBTSxVQUFVLFVBQVYsR0FBdUIsV0FBM0MsQ0FMWjtBQUFBLFlBTUksUUFBUyxPQUFPLENBTnBCO0FBQUEsWUFRSSxPQUFPLEtBQUssR0FBTCxDQUFTLFVBQVUsUUFBbkIsQ0FSWDtBQUFBLFlBU0ksT0FBTyxLQUFLLEdBQUwsQ0FBUyxVQUFVLFFBQW5CLENBVFg7QUFBQSxZQVdJLFNBQVMsQ0FYYjs7QUFhQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBcEIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDOUIsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFwQixFQUE2QixHQUE3QixFQUFrQztBQUM5QixvQkFDSSxJQUFLLElBQUksR0FBSixHQUFVLE1BRG5CO0FBQUEsb0JBRUksSUFBSyxJQUFJLEdBQUosR0FBVSxNQUZuQjtBQUFBLG9CQUdJLEtBQUssS0FBSyxHQUFMLENBQVMsSUFBSSxJQUFKLEdBQVcsSUFBSSxJQUF4QixDQUhUO0FBQUEsb0JBSUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxJQUFJLElBQUosR0FBVyxJQUFJLElBQXhCLENBSlQ7O0FBTUEsb0JBQUksTUFBTSxLQUFOLElBQWUsTUFBTSxLQUF6QixFQUFnQztBQUM1QiwwQkFBTSxRQUFOLElBQWtCLElBQWxCO0FBQ0gsaUJBRkQsTUFFTztBQUNILDBCQUFNLFFBQU4sSUFBa0IsQ0FBbEI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsZUFBTyxLQUFQO0FBQ0g7O0FBRUQsYUFBUyxrQkFBVCxDQUE0QixLQUE1QixFQUFtQyxTQUFuQyxFQUE4QztBQUMxQyxZQUNJLFVBQVUsS0FBSyxJQUFMLENBQVUsVUFBVSxPQUFwQixDQURkO0FBQUEsWUFFSSxTQUFTLFVBQVUsR0FGdkI7QUFBQSxZQUlJLE9BQU8sVUFBVSxPQUFWLEdBQW9CLEtBQUssR0FBTCxDQUFTLEtBQUssRUFBTCxHQUFVLENBQW5CLENBSi9CO0FBQUEsWUFLSSxRQUFTLE9BQU8sQ0FBUixJQUFjLE1BQU0sVUFBVSxVQUFWLEdBQXVCLFdBQTNDLENBTFo7QUFBQSxZQU1JLFFBQVMsT0FBTyxDQU5wQjtBQUFBLFlBUUksYUFBYSxRQUFRLENBUnpCO0FBQUEsWUFTSSxhQUFhLFFBQVEsQ0FUekI7QUFBQSxZQVdJLGFBQWEsUUFBUSxDQVh6QjtBQUFBLFlBWUksYUFBYSxRQUFRLENBWnpCO0FBQUEsWUFjSSxPQUFPLEtBQUssR0FBTCxDQUFTLFVBQVUsUUFBbkIsQ0FkWDtBQUFBLFlBZUksT0FBTyxLQUFLLEdBQUwsQ0FBUyxVQUFVLFFBQW5CLENBZlg7QUFBQSxZQWlCSSxTQUFTLENBakJiOztBQW1CQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBcEIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDOUIsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFwQixFQUE2QixHQUE3QixFQUFrQztBQUM5QixvQkFDSSxJQUFLLElBQUksR0FBSixHQUFVLE1BRG5CO0FBQUEsb0JBRUksSUFBSyxJQUFJLEdBQUosR0FBVSxNQUZuQjtBQUFBLG9CQUdJLEtBQUssS0FBSyxHQUFMLENBQVMsSUFBSSxJQUFKLEdBQVcsSUFBSSxJQUF4QixDQUhUO0FBQUEsb0JBSUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxJQUFJLElBQUosR0FBVyxJQUFJLElBQXhCLENBSlQ7O0FBTUEsb0JBQUksTUFBTSxVQUFOLElBQW9CLE1BQU0sVUFBOUIsRUFBMEM7QUFDdEMsMEJBQU0sUUFBTixJQUFrQixJQUFsQjtBQUNILGlCQUZELE1BRU8sSUFBSSxLQUFLLFVBQUwsSUFBbUIsS0FBSyxVQUE1QixFQUF3QztBQUMzQywwQkFBTSxRQUFOLElBQWtCLENBQWxCO0FBQ0gsaUJBRk0sTUFFQTtBQUNILHdCQUNJLFFBQVEsQ0FEWjs7QUFHQSx5QkFBSyxJQUFJLEtBQUssQ0FBZCxFQUFpQixLQUFLLENBQXRCLEVBQXlCLElBQXpCLEVBQStCO0FBQzNCLDZCQUFLLElBQUksS0FBSyxDQUFkLEVBQWlCLEtBQUssQ0FBdEIsRUFBeUIsSUFBekIsRUFBK0I7QUFDM0IsZ0NBQUksSUFBSSxNQUFNLE1BQU0sR0FBWixDQUFKLEdBQXVCLE1BQTNCO0FBQ0EsZ0NBQUksSUFBSSxNQUFNLE1BQU0sR0FBWixDQUFKLEdBQXVCLE1BQTNCO0FBQ0EsaUNBQUssS0FBSyxHQUFMLENBQVMsSUFBSSxJQUFKLEdBQVcsSUFBSSxJQUF4QixDQUFMO0FBQ0EsaUNBQUssS0FBSyxHQUFMLENBQVMsSUFBSSxJQUFKLEdBQVcsSUFBSSxJQUF4QixDQUFMOztBQUVBLGdDQUFJLE1BQU0sS0FBTixJQUFlLE1BQU0sS0FBekIsRUFBZ0M7QUFDNUI7QUFDSDtBQUNKO0FBQ0o7QUFDRCwwQkFBTSxRQUFOLElBQWtCLEtBQUssR0FBTCxDQUFTLFFBQVEsRUFBakIsRUFBcUIsR0FBckIsQ0FBbEI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsZUFBTyxLQUFQO0FBQ0g7O0FBRUQsYUFBUyxjQUFULENBQXdCLEtBQXhCLEVBQStCLFNBQS9CLEVBQTBDO0FBQ3RDLFlBQ0ksVUFBVSxLQUFLLElBQUwsQ0FBVSxVQUFVLE9BQXBCLENBRGQ7QUFBQSxZQUVJLFNBQVMsVUFBVSxHQUZ2QjtBQUFBLFlBR0ksWUFBYSxVQUFVLE9BQVYsR0FBb0IsQ0FBckIsSUFBMkIsVUFBVSxPQUFWLEdBQW9CLENBQS9DLENBSGhCO0FBQUEsWUFLSSxVQUFVLE1BQU0sVUFBVSxVQUFWLEdBQXVCLFdBTDNDO0FBQUEsWUFNSSxPQUFPLEtBQUssR0FBTCxDQUFTLFVBQVUsUUFBbkIsQ0FOWDtBQUFBLFlBT0ksT0FBTyxLQUFLLEdBQUwsQ0FBUyxVQUFVLFFBQW5CLENBUFg7QUFBQSxZQVNJLFNBQVMsQ0FUYjs7QUFXQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBcEIsRUFBNkIsR0FBN0IsRUFBa0M7QUFDOUIsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFwQixFQUE2QixHQUE3QixFQUFrQztBQUM5QixvQkFDSSxJQUFLLElBQUksR0FBSixHQUFVLE1BRG5CO0FBQUEsb0JBRUksSUFBSyxJQUFJLEdBQUosR0FBVSxNQUZuQjtBQUFBLG9CQUdJLEtBQUssQ0FBQyxJQUFJLElBQUosR0FBVyxJQUFJLElBQWhCLElBQXdCLE9BSGpDO0FBQUEsb0JBSUksS0FBTSxJQUFJLElBQUosR0FBVyxJQUFJLElBSnpCO0FBQUEsb0JBTUksVUFBVSxLQUFLLEVBQUwsR0FBVSxLQUFLLEVBTjdCOztBQVFBLG9CQUFJLFdBQVcsU0FBZixFQUEwQjtBQUN0QiwwQkFBTSxRQUFOLElBQWtCLENBQUMsRUFBRSxPQUFPLElBQUssVUFBVSxTQUF0QixDQUFGLENBQW5CO0FBQ0gsaUJBRkQsTUFFTztBQUNILDBCQUFNLFFBQU4sSUFBa0IsQ0FBbEI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsZUFBTyxLQUFQO0FBQ0g7O0FBRUQ7Ozs7O0FBS0EsYUFBUyxRQUFULENBQWtCLFNBQWxCLEVBQTZCO0FBQ3pCLFlBQUksY0FBYyxJQUFkLElBQXNCLFVBQVUsT0FBVixJQUFxQixTQUEzQyxJQUF3RCxVQUFVLFVBQVYsSUFBd0IsWUFBaEYsSUFDTyxVQUFVLFFBQVYsSUFBc0IsVUFEN0IsSUFDMkMsVUFBVSxJQUFWLElBQWtCLFNBRGpFLEVBQzRFO0FBQ3hFLG1CQUFPLFVBQVA7QUFDSDs7QUFFRCxnQkFBUSxVQUFVLElBQWxCO0FBQ0ksaUJBQUssc0JBQVksZ0JBQWpCO0FBQ0ksd0JBQVEsZUFBZSxLQUFmLEVBQXNCLFNBQXRCLENBQVI7QUFDSjtBQUNBLGlCQUFLLHNCQUFZLFVBQWpCO0FBQ0ksd0JBQVEsYUFBYSxLQUFiLEVBQW9CLFNBQXBCLENBQVI7QUFDSjtBQUNBLGlCQUFLLHNCQUFZLGFBQWpCO0FBQ0ksd0JBQVEsV0FBVyxLQUFYLEVBQWtCLFNBQWxCLENBQVI7QUFDSjtBQUNBLGlCQUFLLHNCQUFZLFdBQWpCO0FBQ0ksd0JBQVEsbUJBQW1CLEtBQW5CLEVBQTBCLFNBQTFCLENBQVI7QUFDSjtBQUNBLGlCQUFLLHNCQUFZLGNBQWpCO0FBQ0ksd0JBQVEsaUJBQWlCLEtBQWpCLEVBQXdCLFNBQXhCLENBQVI7QUFDSjtBQWZKOztBQWtCQSxxQkFBYSxLQUFiO0FBQ0Esb0JBQVksVUFBVSxPQUF0QjtBQUNBLG9CQUFZLFVBQVUsSUFBdEI7QUFDQSx1QkFBZSxVQUFVLFVBQXpCO0FBQ0EscUJBQWEsVUFBVSxRQUF2Qjs7QUFFQSxlQUFPLEtBQVA7QUFDSDs7QUFFRCxhQUFTLFlBQVQsQ0FBc0IsR0FBdEIsRUFBMkIsYUFBM0IsRUFBMEM7QUFDdEMsWUFDSSxTQUFTLEtBQUssS0FBTCxDQUFXLGdCQUFnQixHQUEzQixDQURiO0FBQUEsWUFFSSxVQUFVLEtBQUssT0FGbkI7QUFBQSxZQUlJLFdBQVcsSUFBSSxDQUFKLEdBQVEsUUFBUSxLQUovQjtBQUFBLFlBS0ksV0FBVyxJQUFJLENBQUosR0FBUSxRQUFRLE1BTC9CO0FBQUEsWUFPSSxXQUFXLENBUGY7QUFBQSxZQVFJLFVBUko7QUFBQSxZQVFnQixVQVJoQjs7QUFVQSxZQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUNkLHdCQUFZLFFBQVEsS0FBcEI7QUFDSDs7QUFFRCxZQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUNkLHdCQUFZLFFBQVEsTUFBcEI7QUFDSDs7QUFFRCxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksSUFBSSxNQUF4QixFQUFnQyxHQUFoQyxFQUFxQztBQUNqQyx5QkFBYSxXQUFXLFFBQVEsS0FBbkIsR0FBMkIsUUFBeEM7QUFDQSx5QkFBYSxXQUFXLFFBQVEsS0FBbkIsR0FBMkIsUUFBUSxLQUFoRDs7QUFFQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLElBQUksS0FBeEIsRUFBK0IsR0FBL0IsRUFBb0M7QUFDaEMsb0JBQ0ksYUFBYSxJQUFJLEtBQUosQ0FBVSxRQUFWLENBRGpCO0FBQUEsb0JBRUksZUFBZSxRQUFRLElBQVIsQ0FBYSxVQUFiLENBRm5COztBQUlBLG9CQUFJLEtBQUosQ0FBVSxRQUFWLElBQXNCLENBQUMsRUFBRSxjQUFlLGVBQWUsTUFBZixHQUF3QixHQUF6QixHQUFnQyxJQUE5QyxJQUFzRCxHQUF4RCxDQUF2Qjs7QUFFQTs7QUFFQTtBQUNBLG9CQUFJLGNBQWMsVUFBbEIsRUFBOEI7QUFDMUI7QUFDQSxrQ0FBYyxRQUFRLEtBQXRCO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLGdCQUFJLFlBQVksUUFBUSxNQUF4QixFQUFnQztBQUM1QiwyQkFBVyxDQUFYO0FBQ0g7QUFDSjtBQUNKOztBQUVEOzs7OztBQUtBLFNBQUssTUFBTCxHQUFjLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxTQUFmLEVBQTBCO0FBQ3BDLFlBQ0ksTUFBTTtBQUNGLG1CQUFPLFVBQVUsUUFEZjtBQUVGLG1CQUFPLEtBQUssSUFBTCxDQUFVLFVBQVUsT0FBcEIsQ0FGTDtBQUdGLG9CQUFRLEtBQUssSUFBTCxDQUFVLFVBQVUsT0FBcEI7QUFITixTQURWOztBQU9BO0FBQ0E7QUFDQSxZQUFJLFFBQVEsVUFBVSxJQUFWLElBQWtCLFVBQVUsSUFBVixJQUFrQixzQkFBWSxhQUE1RDs7QUFFQSxZQUFJLEtBQUosRUFBVztBQUNQLGdCQUFJLEtBQUo7QUFDQSxnQkFBSSxNQUFKO0FBQ0g7O0FBRUQsWUFDSSxLQUFLLElBQUksSUFBSSxLQUFKLEdBQVksR0FBaEIsR0FBc0IsR0FEL0I7QUFBQSxZQUVJLEtBQUssSUFBSSxJQUFJLE1BQUosR0FBYSxHQUFqQixHQUF1QixHQUZoQzs7QUFJQTtBQUNBLFlBQUksS0FBSyxDQUFULEVBQVk7QUFDUixrQkFBTSxDQUFOO0FBQ0g7QUFDRCxZQUFJLEtBQUssQ0FBVCxFQUFZO0FBQ1Isa0JBQU0sQ0FBTjtBQUNIOztBQUVELFlBQUksS0FBSixFQUFXO0FBQ1AsZ0JBQ0ksS0FBSyxLQUFLLEdBQUwsQ0FBUyxLQUFLLENBQUMsQ0FBQyxFQUFoQixDQURUO0FBQUEsZ0JBRUksS0FBSyxLQUFLLEdBQUwsQ0FBUyxLQUFLLENBQUMsQ0FBQyxFQUFoQixDQUZUOztBQUlBLGdCQUFJLEtBQUosR0FBWSxlQUFlLFNBQWYsRUFBMEIsRUFBMUIsRUFBOEIsRUFBOUIsQ0FBWjtBQUNILFNBTkQsTUFNTztBQUNILGdCQUFJLEtBQUosR0FBWSxTQUFTLFNBQVQsQ0FBWjtBQUNIOztBQUVELFlBQUksQ0FBSixHQUFRLENBQUMsQ0FBQyxFQUFWO0FBQ0EsWUFBSSxDQUFKLEdBQVEsQ0FBQyxDQUFDLEVBQVY7O0FBRUEsWUFBSSxVQUFVLE9BQVYsR0FBb0IsR0FBcEIsSUFBMkIsS0FBSyxPQUFMLElBQWdCLElBQS9DLEVBQXFEO0FBQ2pEO0FBQ0E7QUFDQSxnQkFBSSxJQUFJLEtBQUosSUFBYSxLQUFqQixFQUF3QjtBQUNwQix3QkFBUSxHQUFSLENBQVksS0FBWjtBQUNBLG9CQUFJLEtBQUosR0FBWSxPQUFaO0FBQ0g7QUFDRCx5QkFBYSxHQUFiLEVBQWtCLFVBQVUsT0FBNUI7QUFDSDs7QUFFRCxlQUFPLEdBQVA7QUFDSCxLQXJERDs7QUF1REEsU0FBSyxVQUFMLEdBQWtCLFVBQVMsT0FBVCxFQUFrQjtBQUNoQyxhQUFLLE9BQUwsR0FBZSxPQUFmO0FBQ0gsS0FGRDtBQUdILEMsQ0F0Y0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztrQkMyQndCLFc7O0FBTHhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUF6QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUEyQmUsU0FBUyxXQUFULEdBQXVCOztBQUVsQyxhQUFTLGFBQVQsQ0FBdUIsTUFBdkIsRUFBK0IsS0FBL0IsRUFBc0M7QUFDbEMsYUFBSyxPQUFMLEdBQWUsT0FBTyxTQUFQLEVBQWY7QUFDQSxhQUFLLEtBQUwsR0FBYSxPQUFPLFNBQVAsRUFBYjtBQUNBLGFBQUssTUFBTCxHQUFjLE9BQU8sU0FBUCxFQUFkO0FBQ0EsYUFBSyxRQUFMLEdBQWdCLE9BQU8sU0FBUCxFQUFoQjtBQUNIOztBQUVELGtCQUFjLG1CQUFkLEdBQW9DLElBQUksQ0FBeEM7O0FBRUEsYUFBUyxrQkFBVCxDQUE0QixNQUE1QixFQUFvQztBQUNoQyxZQUNJLFlBQVksSUFBSSxLQUFKLENBQVUsQ0FBVixDQURoQjs7QUFHQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxzQkFBVSxDQUFWLElBQWUsT0FBTyxZQUFQLENBQW9CLE9BQU8sUUFBUCxFQUFwQixDQUFmO0FBQ0g7O0FBRUQsYUFBSyxTQUFMLEdBQWlCLFVBQVUsSUFBVixDQUFlLEVBQWYsQ0FBakI7QUFDQSxhQUFLLFNBQUwsR0FBaUIsT0FBTyxTQUFQLEVBQWpCOztBQUVBLFlBQUksT0FBTyxHQUFYLEVBQWdCO0FBQ1osa0JBQU0saUJBQU47QUFDSDtBQUNKOztBQUVELGFBQVMsdUJBQVQsR0FBbUM7QUFDL0IsWUFDSSxhQURKLEVBRUksV0FGSjs7QUFJQSxhQUFLLGVBQUwsR0FBdUIsVUFBUyxNQUFULEVBQWlCO0FBQ3BDLDRCQUFnQixPQUFPLFNBQVAsRUFBaEI7O0FBRUEsaUJBQUssU0FBTCxHQUFpQixPQUFPLFNBQVAsRUFBakI7QUFDQSxpQkFBSyxLQUFMLEdBQWEsT0FBTyxTQUFQLEVBQWI7QUFDQSxpQkFBSyxPQUFMLEdBQWUsQ0FBQyxPQUFPLFNBQVAsS0FBcUIsQ0FBdEIsS0FBNEIsQ0FBM0M7O0FBRUEsMEJBQWMsT0FBTyxTQUFQLEVBQWQ7QUFDSCxTQVJEOztBQVVBOzs7O0FBSUEsYUFBSyxvQkFBTCxHQUE0QixZQUFXO0FBQ25DLG1CQUFPLGdCQUFnQix3QkFBd0IsbUJBQS9DO0FBQ0gsU0FGRDs7QUFJQSxhQUFLLGlCQUFMLEdBQXlCLFlBQVc7QUFDaEMsbUJBQU8sd0JBQXdCLG1CQUF4QixHQUE4QyxLQUFLLG9CQUFMLEVBQXJEO0FBQ0gsU0FGRDs7QUFJQSxhQUFLLGtCQUFMLEdBQTBCLFVBQVMsTUFBVCxFQUFpQjtBQUN2QyxpQkFBSyxJQUFMLEdBQVksT0FBTyxVQUFQLENBQWtCLFdBQWxCLENBQVo7O0FBRUE7QUFDQSxtQkFBTyxJQUFQLENBQVksZ0JBQWdCLFdBQWhCLEdBQThCLHdCQUF3QixtQkFBbEU7QUFDSCxTQUxEO0FBTUg7O0FBRUQ7QUFDQSw0QkFBd0IsbUJBQXhCLEdBQThDLElBQUksQ0FBbEQ7O0FBRUEsUUFDSSxZQUFZLFVBRGhCO0FBQUEsUUFHSSxpQkFBaUIsTUFIckI7QUFBQSxRQUlJLGtCQUFrQixNQUp0QjtBQUFBLFFBS0ksZ0JBQWdCLE1BTHBCO0FBQUEsUUFPSSxrQkFBa0IscUJBQVcsZUFQakM7QUFBQSxRQVFJLG9CQUFvQixxQkFBVyxpQkFSbkM7QUFBQSxRQVNJLGtCQUFrQixxQkFBVyxlQVRqQztBQUFBLFFBVUksb0JBQW9CLHFCQUFXLGlCQVZuQztBQUFBLFFBV0ksbUJBQW1CLHFCQUFXLGdCQVhsQzs7QUFhQSxhQUFTLGlCQUFULEdBQTZCO0FBQ3pCLFlBQ0ksU0FBUyxJQUFJLFVBQUosQ0FBZSxjQUFjLE1BQWQsR0FBdUIsQ0FBdEMsQ0FEYjtBQUFBLFlBRUksU0FBUyw4QkFBb0IsTUFBcEIsQ0FGYjs7QUFJQSxlQUFPLFdBQVAsQ0FBbUIsYUFBbkI7QUFDQSxlQUFPLFVBQVAsQ0FBa0IsQ0FBbEI7O0FBRUEsZUFBTyxPQUFPLGNBQVAsRUFBUDtBQUNIOztBQUVELGFBQVMsb0JBQVQsQ0FBOEIsT0FBOUIsRUFBdUM7QUFDbkMsWUFDSSxTQUFTLElBQUksVUFBSixDQUFlLGVBQWUsTUFBZixHQUF3QixJQUFJLENBQTNDLENBRGI7QUFBQSxZQUVJLFNBQVMsOEJBQW9CLE1BQXBCLENBRmI7O0FBSUEsZUFBTyxXQUFQLENBQW1CLGNBQW5CO0FBQ0EsZUFBTyxVQUFQLENBQWtCLEVBQWxCLEVBTm1DLENBTVo7O0FBRXZCLGVBQU8sVUFBUCxDQUFrQixDQUFsQixFQVJtQyxDQVFiO0FBQ3RCLGVBQU8sVUFBUCxDQUFrQixRQUFRLEtBQTFCO0FBQ0EsZUFBTyxVQUFQLENBQWtCLFFBQVEsTUFBMUI7QUFDQSxlQUFPLFVBQVAsQ0FBa0IsUUFBUSxhQUFSLEVBQWxCOztBQUVBLGVBQU8sT0FBTyxjQUFQLEVBQVA7QUFDSDs7QUFFRCxhQUFTLG1CQUFULENBQTZCLEtBQTdCLEVBQW9DO0FBQ2hDLFlBQ0ksWUFBWSxLQUFLLE1BQU0sSUFBTixDQUFXLE1BQWhCLEdBQXlCLE1BQU0sSUFBTixDQUFXLE1BRHBEO0FBQUEsWUFHSSxTQUFTLElBQUksVUFBSixDQUFlLGdCQUFnQixNQUFoQixHQUF5QixDQUF6QixHQUE2QixTQUE1QyxDQUhiO0FBQUEsWUFJSSxTQUFTLDhCQUFvQixNQUFwQixDQUpiO0FBQUEsWUFLSSxHQUxKOztBQU9BLGVBQU8sV0FBUCxDQUFtQixlQUFuQixFQVJnQyxDQVFLO0FBQ3JDLGVBQU8sVUFBUCxDQUFrQixTQUFsQixFQVRnQyxDQVNGOztBQUU5QixlQUFPLFVBQVAsQ0FBa0IsS0FBSyxNQUFNLElBQU4sQ0FBVyxNQUFsQyxFQVhnQyxDQVdXOztBQUUzQyxlQUFPLFVBQVAsQ0FBa0IsTUFBTSxTQUF4QjtBQUNBLGVBQU8sVUFBUCxDQUFrQixNQUFNLEtBQXhCO0FBQ0EsZUFBTyxVQUFQLENBQWtCLE1BQU0sT0FBTixHQUFnQixDQUFoQixHQUFvQixDQUF0QyxFQWZnQyxDQWVVOztBQUUxQyxlQUFPLFVBQVAsQ0FBa0IsTUFBTSxJQUFOLENBQVcsTUFBN0I7QUFDQSxlQUFPLFdBQVAsQ0FBbUIsTUFBTSxJQUF6Qjs7QUFFQTtBQUNBLGNBQU0sT0FBTyxHQUFiO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE1BQU0sSUFBTixDQUFXLE1BQS9CLEVBQXVDLEtBQUssZUFBNUMsRUFBNkQ7QUFDekQsbUJBQU8sS0FBUCxJQUFnQixNQUFNLElBQU4sQ0FBVyxJQUFJLGlCQUFmLENBQWhCO0FBQ0EsbUJBQU8sS0FBUCxJQUFnQixNQUFNLElBQU4sQ0FBVyxJQUFJLGVBQWYsQ0FBaEI7QUFDQSxtQkFBTyxLQUFQLElBQWdCLE1BQU0sSUFBTixDQUFXLElBQUksaUJBQWYsQ0FBaEI7QUFDQSxtQkFBTyxLQUFQLElBQWdCLE1BQU0sSUFBTixDQUFXLElBQUksZ0JBQWYsQ0FBaEI7QUFDSDs7QUFFRCxlQUFPLE1BQVA7QUFDSDs7QUFFRDs7O0FBR0EsU0FBSyxTQUFMLEdBQWlCLFVBQVMsT0FBVCxFQUFrQjtBQUMvQixlQUFPLElBQUksT0FBSixDQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUN6QyxnQkFDSSxXQUFXLElBQUksT0FBTyxJQUFQLENBQVksT0FBaEIsQ0FBd0I7QUFDL0IsdUJBQU87QUFEd0IsYUFBeEIsQ0FEZjtBQUFBLGdCQUlJLFlBQVksRUFKaEI7QUFBQSxnQkFLSSxRQUFRLElBQUksVUFBSixDQUFlLFVBQVUsTUFBekIsQ0FMWjs7QUFPQTtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxzQkFBTSxDQUFOLElBQVcsVUFBVSxVQUFWLENBQXFCLENBQXJCLENBQVg7QUFDSDtBQUNELHNCQUFVLElBQVYsQ0FBZSxLQUFmOztBQUVBO0FBQ0EscUJBQVMsSUFBVCxDQUFjLHFCQUFxQixPQUFyQixDQUFkLEVBQTZDLEtBQTdDOztBQUVBLGdCQUNJLFNBQVMsUUFBUSxTQUFSLEVBRGI7QUFBQSxnQkFFSSxJQUFJLENBRlI7O0FBSUE7O0FBRUEscUJBQVMsY0FBVCxHQUEwQjtBQUN0QixvQkFBSSxLQUFLLE9BQU8sTUFBaEIsRUFBd0I7QUFDcEIsNkJBQVMsSUFBVCxDQUFjLGtCQUFrQixPQUFsQixDQUFkLEVBQTBDLElBQTFDOztBQUVBLDhCQUFVLElBQVYsQ0FBZSxTQUFTLE1BQXhCOztBQUVBLDRCQUFRLElBQUksSUFBSixDQUFTLFNBQVQsRUFBb0IsRUFBQyxNQUFNLDBCQUFQLEVBQXBCLENBQVI7QUFDSCxpQkFORCxNQU1PO0FBQ0gsNkJBQVMsSUFBVCxDQUFjLG9CQUFvQixPQUFPLEdBQVAsQ0FBcEIsQ0FBZCxFQUFnRCxLQUFoRDs7QUFFQSwrQkFBVyxjQUFYLEVBQTJCLEVBQTNCO0FBQ0g7QUFDSjs7QUFFRCx1QkFBVyxjQUFYLEVBQTJCLEVBQTNCO0FBQ0gsU0F0Q00sQ0FBUDtBQXVDSCxLQXhDRDs7QUEwQ0EsYUFBUyxtQkFBVCxDQUE2QixLQUE3QixFQUFvQztBQUNoQyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBVSxNQUE5QixFQUFzQyxHQUF0QyxFQUEyQztBQUN2QyxnQkFBSSxNQUFNLENBQU4sS0FBWSxVQUFVLFVBQVYsQ0FBcUIsQ0FBckIsQ0FBaEIsRUFBeUM7QUFDckMsdUJBQU8sS0FBUDtBQUNIO0FBQ0o7O0FBRUQsZUFBTyxJQUFQO0FBQ0g7O0FBRUQ7Ozs7OztBQU1BLGFBQVMsYUFBVCxDQUF1QixHQUF2QixFQUE0QixHQUE1QixFQUFpQztBQUM3QixZQUFJLE9BQU8sSUFBUCxJQUFlLElBQUksTUFBSixJQUFjLENBQWpDLEVBQW9DO0FBQ2hDLG1CQUFPLEdBQVA7QUFDSDtBQUNELFlBQUksT0FBTyxJQUFQLElBQWUsSUFBSSxNQUFKLElBQWMsQ0FBakMsRUFBb0M7QUFDaEMsbUJBQU8sR0FBUDtBQUNIOztBQUVELFlBQ0ksU0FBUyxJQUFJLFVBQUosQ0FBZSxJQUFJLE1BQUosR0FBYSxJQUFJLE1BQWhDLENBRGI7O0FBR0EsZUFBTyxHQUFQLENBQVcsR0FBWCxFQUFnQixDQUFoQjtBQUNBLGVBQU8sR0FBUCxDQUFXLEdBQVgsRUFBZ0IsSUFBSSxNQUFwQjs7QUFFQSxlQUFPLE1BQVA7QUFDSDs7QUFFRDs7Ozs7QUFLQSxTQUFLLElBQUwsR0FBWSxVQUFTLFdBQVQsRUFBc0I7QUFDOUIsWUFDSSx1QkFBcUMsQ0FEekM7QUFBQSxZQUVJLDRCQUFxQyxDQUZ6QztBQUFBLFlBR0ksa0NBQXFDLENBSHpDO0FBQUEsWUFJSSxxQ0FBcUMsQ0FKekM7QUFBQSxZQUtJLHFCQUFxQyxDQUx6QztBQUFBLFlBTUksa0NBQXFDLENBTnpDO0FBQUEsWUFPSSxnQkFBcUMsQ0FQekM7QUFBQSxZQVFJLGNBQXFDLEVBUnpDOztBQVVBLFlBQ0ksT0FBTyxJQUFJLE9BQU8sSUFBUCxDQUFZLE9BQWhCLENBQXdCLEVBQXhCLENBRFg7QUFBQSxZQUVJLFFBQVEsb0JBRlo7QUFBQSxZQUdJLFVBQVUsSUFIZDtBQUFBLFlBSUksV0FKSjtBQUFBLFlBSWlCLEtBSmpCO0FBQUEsWUFLSSxjQUxKO0FBQUEsWUFLb0IsZUFMcEI7QUFBQSxZQUtxQyxTQUxyQztBQUFBLFlBTUksY0FBYyxJQU5sQjtBQUFBLFlBTXdCLFNBQVMsSUFOakM7QUFBQSxZQU9JLFFBQVEsSUFQWjtBQUFBLFlBUUksU0FBUyxJQVJiOztBQVVBOzs7Ozs7OztBQVFBLGlCQUFTLFlBQVQsQ0FBc0IsTUFBdEIsRUFBOEIsUUFBOUIsRUFBd0M7QUFDcEMsZ0JBQ0ksV0FBVyxpQkFBaUIsZUFEaEM7QUFBQSxnQkFFSSxzQkFBc0IsaUJBQWlCLFFBRjNDO0FBQUEsZ0JBR0ksWUFBWSxDQUhoQjs7O0FBS0k7QUFDQSx5QkFBYSxDQUNULGlCQURTLEVBQ1UsZUFEVixFQUMyQixpQkFEM0IsRUFDOEMsZ0JBRDlDLENBTmpCOztBQVVBO0FBQ0EsbUJBQU8sV0FBVyxlQUFYLElBQThCLFlBQVksT0FBTyxNQUF4RCxFQUFnRSxVQUFoRSxFQUE0RTtBQUN4RSx5QkFBUyxzQkFBc0IsV0FBVyxRQUFYLENBQS9CLElBQXVELE9BQU8sU0FBUCxDQUF2RDtBQUNBO0FBQ0E7QUFDSDs7QUFFRDtBQUNBLGdCQUNJLGNBQWMsS0FBSyxHQUFMLENBQVMsT0FBTyxNQUFQLEdBQWdCLFNBQXpCLEVBQW9DLGtCQUFrQixjQUF0RCxJQUF3RSxDQUQxRjtBQUFBLGdCQUVJLG1CQUFvQixjQUFjLGVBQWYsR0FBa0MsQ0FGekQ7QUFBQSxnQkFHSSxrQkFBa0IsY0FBYyxlQUhwQzs7QUFLQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLGdCQUFwQixFQUFzQyxHQUF0QyxFQUEyQztBQUN2Qyx5QkFBUyxpQkFBaUIsaUJBQTFCLElBQStDLE9BQU8sU0FBUCxDQUEvQztBQUNBLHlCQUFTLGlCQUFpQixlQUExQixJQUE2QyxPQUFPLFlBQVksQ0FBbkIsQ0FBN0M7QUFDQSx5QkFBUyxpQkFBaUIsaUJBQTFCLElBQStDLE9BQU8sWUFBWSxDQUFuQixDQUEvQztBQUNBLHlCQUFTLGlCQUFpQixnQkFBMUIsSUFBOEMsT0FBTyxZQUFZLENBQW5CLENBQTlDO0FBQ0Esa0NBQWtCLGVBQWxCO0FBQ0EsNkJBQWEsZUFBYjtBQUNIOztBQUVEO0FBQ0Esa0NBQXNCLGNBQXRCO0FBQ0EsaUJBQUssV0FBVyxDQUFoQixFQUFtQixXQUFXLGVBQTlCLEVBQStDLFVBQS9DLEVBQTJEO0FBQ3ZELHlCQUFTLHNCQUFzQixXQUFXLFFBQVgsQ0FBL0IsSUFBdUQsT0FBTyxTQUFQLENBQXZEO0FBQ0E7QUFDQTtBQUNIOztBQUVELGdCQUFJLFlBQVksT0FBTyxNQUF2QixFQUErQjtBQUMzQjtBQUNBLHVCQUFPLE9BQU8sUUFBUCxDQUFnQixTQUFoQixDQUFQO0FBQ0gsYUFIRCxNQUdPO0FBQ0g7QUFDQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFFRCxpQkFBUyxZQUFULENBQXNCLEtBQXRCLEVBQTZCO0FBQ3pCLGdCQUNJLE1BREo7O0FBR0E7QUFDQSxtQkFBTyxJQUFQLEVBQWE7QUFDVCx3QkFBUSxLQUFSO0FBQ0kseUJBQUssb0JBQUw7QUFDSSxpQ0FBUyxjQUFjLE1BQWQsRUFBc0IsS0FBdEIsQ0FBVDtBQUNBLGdDQUFRLElBQVI7O0FBRUE7QUFDQSw0QkFBSSxDQUFDLE1BQUQsSUFBVyxPQUFPLE1BQVAsR0FBZ0IsQ0FBL0IsRUFBa0M7QUFDOUI7QUFDSDs7QUFFRDtBQUNBLGlDQUFTLDhCQUFvQixNQUFwQixDQUFUO0FBQ0EsZ0NBQVEsSUFBSSxrQkFBSixDQUF1QixNQUF2QixDQUFSOztBQUVBO0FBQ0EsaUNBQVMsT0FBTyxRQUFQLENBQWdCLE9BQU8sR0FBdkIsQ0FBVDs7QUFFQSw0QkFBSSxXQUFKLEVBQWlCO0FBQ2IsZ0NBQUksTUFBTSxTQUFOLElBQW1CLGFBQXZCLEVBQXNDO0FBQ2xDLHdDQUFRLGFBQVI7QUFDQTtBQUNILDZCQUhELE1BR08sSUFBSSxNQUFNLFNBQU4sSUFBbUIsZUFBdkIsRUFBd0M7QUFDM0Msd0NBQVEsK0JBQVI7QUFDSCw2QkFGTSxNQUVBO0FBQ0gsd0NBQVEsR0FBUixDQUFZLHlCQUF5QixNQUFNLFNBQS9CLEdBQTJDLDBCQUF2RDs7QUFFQSx3Q0FBUSxNQUFSO0FBQ0EseUNBQVMsSUFBVDs7QUFFQSw0Q0FBWSxNQUFNLFNBQWxCO0FBQ0Esd0NBQVEsK0JBQVI7QUFDSDs7QUFFRDtBQUNILHlCQWpCRCxNQWlCTyxJQUFJLE1BQU0sU0FBTixJQUFtQixjQUF2QixFQUF1QztBQUMxQywwQ0FBYyxLQUFkOztBQUVBO0FBQ0Esb0NBQVEseUJBQVI7QUFDQTtBQUNILHlCQU5NLE1BTUE7QUFDSDtBQUNBLG9DQUFRLFdBQVI7QUFDSDtBQUNMO0FBQ0EseUJBQUsseUJBQUw7QUFDSSxpQ0FBUyxjQUFjLE1BQWQsRUFBc0IsS0FBdEIsQ0FBVDtBQUNBLGdDQUFRLElBQVI7O0FBRUE7QUFDQSw0QkFBSSxDQUFDLE1BQUQsSUFBVyxPQUFPLE1BQVAsR0FBZ0IsWUFBWSxTQUEzQyxFQUFzRDtBQUNsRDtBQUNIOztBQUVELGlDQUFTLDhCQUFvQixNQUFwQixDQUFUO0FBQ0EsaUNBQVMsSUFBSSxhQUFKLENBQWtCLE1BQWxCLEVBQTBCLFdBQTFCLENBQVQ7O0FBRUEsNEJBQUssT0FBTyxPQUFQLEtBQW1CLEVBQXBCLEdBQTBCLENBQTlCLEVBQWlDO0FBQzdCLG9DQUFRLFdBQVIsQ0FENkIsQ0FDUjtBQUNyQjtBQUNIOztBQUVELGtDQUFVLHdCQUFjLE9BQU8sS0FBckIsRUFBNEIsT0FBTyxNQUFuQyxDQUFWOztBQUVBLGdDQUFRLE1BQVI7QUFDQSxpQ0FBUyxJQUFUOztBQUVBLG9DQUFZLFlBQVksU0FBeEIsQ0F0QkosQ0FzQnVDO0FBQ25DLGdDQUFRLCtCQUFSO0FBQ0E7QUFDSjtBQUNBLHlCQUFLLCtCQUFMO0FBQ0ksaUNBQVMsY0FBYyxNQUFkLEVBQXNCLEtBQXRCLENBQVQ7QUFDQSxnQ0FBUSxJQUFSOztBQUVBO0FBQ0EsNEJBQUksQ0FBQyxNQUFELElBQVcsT0FBTyxNQUFQLEdBQWdCLHdCQUF3QixtQkFBdkQsRUFBNEU7QUFDeEU7QUFDSDs7QUFFRCxzQ0FBYyxJQUFJLHVCQUFKLEVBQWQ7O0FBRUEsaUNBQVMsOEJBQW9CLE1BQXBCLENBQVQ7QUFDQSxvQ0FBWSxlQUFaLENBQTRCLE1BQTVCOztBQUVBLGlDQUFTLE9BQU8sUUFBUCxDQUFnQixPQUFPLEdBQXZCLENBQVQ7O0FBRUEsZ0NBQVEsa0NBQVI7QUFDQTtBQUNKO0FBQ0EseUJBQUssa0NBQUw7QUFDSSxpQ0FBUyxjQUFjLE1BQWQsRUFBc0IsS0FBdEIsQ0FBVDtBQUNBLGdDQUFRLElBQVI7O0FBRUE7QUFDQSw0QkFBSSxDQUFDLE1BQUQsSUFBVyxPQUFPLE1BQVAsR0FBZ0IsWUFBWSxvQkFBWixFQUEvQixFQUFtRTtBQUMvRDtBQUNIOztBQUVELGlDQUFTLDhCQUFvQixNQUFwQixDQUFUO0FBQ0Esb0NBQVksa0JBQVosQ0FBK0IsTUFBL0I7O0FBRUEsaUNBQVMsT0FBTyxRQUFQLENBQWdCLE9BQU8sR0FBdkIsQ0FBVDs7QUFFQSxnQ0FBUSxzQkFBWSxPQUFPLEtBQW5CLEVBQTBCLE9BQU8sTUFBakMsRUFBeUMsWUFBWSxJQUFyRCxDQUFSO0FBQ0EsOEJBQU0sU0FBTixHQUFrQixZQUFZLFNBQTlCO0FBQ0EsOEJBQU0sS0FBTixHQUFjLFlBQVksS0FBMUI7QUFDQSw4QkFBTSxPQUFOLEdBQWdCLFlBQVksT0FBNUI7O0FBRUEseUNBQWlCLENBQWpCO0FBQ0EsMENBQWtCLE9BQU8sS0FBUCxHQUFlLE9BQU8sTUFBdEIsR0FBK0IsZUFBakQ7O0FBRUE7Ozs7QUFJQSxnQ0FBUSxNQUFSO0FBQ0EsaUNBQVMsSUFBVDs7QUFFQSxnQ0FBUSxrQkFBUjtBQUNBO0FBQ0o7QUFDQSx5QkFBSyxrQkFBTDtBQUNJOzs7OztBQUtBLDRCQUFJLFNBQVMsSUFBYixFQUFtQjtBQUNmLG9DQUFRLGFBQWEsS0FBYixFQUFvQixNQUFNLElBQTFCLENBQVI7O0FBRUEsZ0NBQUksa0JBQWtCLGVBQXRCLEVBQXVDO0FBQ25DLHdDQUFRLGNBQVIsQ0FBdUIsS0FBdkI7O0FBRUE7QUFDQSw0Q0FBWSxNQUFNLFNBQU4sR0FBa0IsWUFBWSxpQkFBWixFQUFsQixHQUFvRCxlQUFoRTtBQUNBLHdDQUFRLCtCQUFSO0FBQ0E7QUFDSDtBQUNKO0FBQ0w7QUFDQSx5QkFBSywrQkFBTDtBQUNJLDRCQUFJLEtBQUosRUFBVztBQUNQLGdDQUFJLFlBQVksTUFBTSxNQUF0QixFQUE4QjtBQUMxQix3Q0FBUSxNQUFNLFFBQU4sQ0FBZSxTQUFmLENBQVI7QUFDQSw0Q0FBWSxDQUFaO0FBQ0gsNkJBSEQsTUFHTztBQUNILDZDQUFhLE1BQU0sTUFBbkI7QUFDQSx3Q0FBUSxJQUFSO0FBQ0g7QUFDSjs7QUFFRCw0QkFBSSxhQUFhLENBQWpCLEVBQW9CO0FBQ2hCLG9DQUFRLG9CQUFSO0FBQ0E7QUFDSDtBQUNMO0FBNUpKOztBQStKQTtBQUNIO0FBQ0o7O0FBRUQsc0JBQWMsSUFBSSxVQUFKLENBQWUsV0FBZixDQUFkOztBQUVBLFlBQUksQ0FBQyxvQkFBb0IsV0FBcEIsQ0FBTCxFQUF1QztBQUNuQyxtQkFBTyxJQUFQLENBRG1DLENBQ3RCO0FBQ2hCOztBQUVEO0FBQ0Esc0JBQWMsWUFBWSxRQUFaLENBQXFCLFVBQVUsTUFBL0IsQ0FBZDs7QUFFQSxhQUFLLE1BQUwsR0FBYyxZQUFkOztBQUVBLGFBQUssS0FBTCxHQUFhLFVBQVMsTUFBVCxFQUFpQjtBQUMxQixnQkFBSSxXQUFXLENBQVgsSUFBZ0IsU0FBUyxhQUE3QixFQUE0QztBQUN4Qyx3QkFBUSxtQkFBUixDQUE0QixRQUFRLHNCQUFSLEVBQTVCOztBQUVBLHFCQUFLLE1BQUwsR0FBYyxPQUFkO0FBQ0gsYUFKRCxNQUlPO0FBQ0gsd0JBQVEsR0FBUixDQUFZLGdDQUFaOztBQUVBLHFCQUFLLE1BQUwsR0FBYyxJQUFkO0FBQ0g7QUFDSixTQVZEOztBQVlBO0FBQ0EsYUFBSyxJQUFMLENBQVUsV0FBVjs7QUFFQSxlQUFPLEtBQUssTUFBWjtBQUNILEtBblJEO0FBb1JIOzs7Ozs7Ozs7a0JDcmZ1QixNO0FBdEJ4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCZSxTQUFTLE1BQVQsQ0FBZ0IsR0FBaEIsRUFBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsRUFBMkI7QUFDdEMsU0FBSyxHQUFMLEdBQVcsR0FBWDs7QUFFQSxTQUFLLENBQUwsR0FBUyxDQUFUO0FBQ0EsU0FBSyxDQUFMLEdBQVMsQ0FBVDtBQUNIOzs7Ozs7Ozs7a0JDV3VCLFU7O0FBaEJ4Qjs7OztBQUNBOzs7Ozs7QUF2QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUF5QkEsU0FBUyxlQUFULENBQXlCLEtBQXpCLEVBQWdDLE1BQWhDLEVBQXdDO0FBQ3BDO0FBQ0EsUUFDSSxTQUFTLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQURiO0FBQUEsUUFFSSxVQUFVLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQUZkOztBQUlBLFdBQU8sUUFBUSxlQUFSLENBQXdCLEtBQXhCLEVBQStCLE1BQS9CLENBQVA7QUFDSDs7QUFFRDtBQUNBO0FBQ0E7O0FBRWUsU0FBUyxVQUFULENBQW9CLEtBQXBCLEVBQTJCLE1BQTNCLEVBQW1DO0FBQzlDLHVCQUFTLElBQVQsQ0FBYyxJQUFkLEVBQW9CLEtBQXBCLEVBQTJCLE1BQTNCOztBQUVBO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLGdCQUFnQixLQUFLLEtBQXJCLEVBQTRCLEtBQUssTUFBakMsQ0FBakI7O0FBRUE7QUFDQSxTQUFLLElBQUwsR0FBWSxLQUFLLFNBQUwsQ0FBZSxJQUEzQjtBQUNIOztBQUVELFdBQVcsU0FBWCxHQUF1QixPQUFPLE1BQVAsQ0FBYyxtQkFBUyxTQUF2QixDQUF2QjtBQUNBLFdBQVcsU0FBWCxDQUFxQixXQUFyQixHQUFtQyxVQUFuQzs7QUFFQSxXQUFXLGVBQVgsR0FBNkIsQ0FBN0I7QUFDQSxXQUFXLGVBQVgsR0FBNkIsQ0FBN0I7QUFDQSxXQUFXLGlCQUFYLEdBQStCLENBQS9CO0FBQ0EsV0FBVyxnQkFBWCxHQUE4QixDQUE5QjtBQUNBLFdBQVcsaUJBQVgsR0FBK0IsQ0FBL0I7O0FBRUE7QUFDQSxXQUFXLFNBQVgsQ0FBcUIsU0FBckIsR0FBaUMsVUFBUyxJQUFULEVBQWU7QUFDNUMsUUFDSSxTQUFTLElBQUksVUFBSixDQUFlLEtBQUssUUFBTCxFQUFmLEVBQWdDLEtBQUssU0FBTCxFQUFoQyxDQURiOztBQUdBLFdBQU8sY0FBUCxDQUFzQixJQUF0QixFQUE0QixDQUE1QixFQUErQixDQUEvQixFQUFrQyxJQUFsQzs7QUFFQSxXQUFPLE1BQVA7QUFDSCxDQVBEOztBQVNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBWCxDQUFxQixRQUFyQixHQUFnQyxVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDM0MsUUFBSSxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxHQUFMLENBQVMsS0FBSyxLQUFMLEdBQWEsQ0FBdEIsRUFBeUIsQ0FBekIsQ0FBWixDQUFKO0FBQ0EsUUFBSSxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxHQUFMLENBQVMsS0FBSyxNQUFMLEdBQWMsQ0FBdkIsRUFBMEIsQ0FBMUIsQ0FBWixDQUFKOztBQUVBLFFBQ0ksV0FBVyxLQUFLLGFBQUwsQ0FBbUIsQ0FBbkIsRUFBc0IsQ0FBdEIsQ0FEZjs7QUFHQSxXQUFRLEtBQUssSUFBTCxDQUFVLFdBQVcsV0FBVyxpQkFBaEMsS0FBc0QsRUFBdkQsR0FDQSxLQUFLLElBQUwsQ0FBVSxXQUFXLFdBQVcsZUFBaEMsS0FBdUQsRUFEdkQsR0FFQSxLQUFLLElBQUwsQ0FBVSxXQUFXLFdBQVcsaUJBQWhDLEtBQXVELENBRnZELEdBR0QsS0FBSyxJQUFMLENBQVUsV0FBVyxXQUFXLGdCQUFoQyxDQUhOO0FBSUgsQ0FYRDs7QUFhQTs7Ozs7QUFLQSxXQUFXLFNBQVgsQ0FBcUIsV0FBckIsR0FBbUMsVUFBUyxHQUFULEVBQWMsSUFBZCxFQUFvQjtBQUNuRCxXQUFPLEtBQUssU0FBTCxHQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFQOztBQUVBLFFBQ0ksSUFBSSxLQUFLLFFBQUwsRUFEUjtBQUFBLFFBRUksSUFBSSxLQUFLLFNBQUwsRUFGUjtBQUFBLFFBSUksU0FBUyxJQUFJLFVBQUosQ0FBZSxJQUFJLENBQUosR0FBUSxXQUFXLGVBQWxDLENBSmI7QUFBQSxRQU1JLGNBQWMsQ0FObEI7QUFBQSxRQU9JLFlBQVksS0FBSyxhQUFMLENBQW1CLEtBQUssSUFBeEIsRUFBOEIsS0FBSyxHQUFuQyxDQVBoQjtBQUFBLFFBUUksWUFBWSxJQUFJLGFBQUosQ0FBa0IsS0FBSyxJQUF2QixFQUE2QixLQUFLLEdBQWxDLENBUmhCO0FBQUEsUUFVSSxZQUFZLENBQUMsS0FBSyxLQUFMLEdBQWEsQ0FBZCxJQUFtQixXQUFXLGVBVjlDO0FBQUEsUUFXSSxZQUFZLENBQUMsSUFBSSxLQUFKLEdBQVksQ0FBYixJQUFrQixXQUFXLGVBWDdDO0FBQUEsUUFhSSxhQUFhLElBQUksV0FBVyxlQWJoQzs7QUFlQSxTQUFLLElBQUksSUFBSSxLQUFLLEdBQWxCLEVBQXVCLElBQUksS0FBSyxNQUFoQyxFQUF3QyxLQUFLLGFBQWEsU0FBbEIsRUFBNkIsYUFBYSxTQUFsRixFQUE2RjtBQUN6RixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksVUFBcEIsRUFBZ0MsS0FBSyxhQUFMLEVBQW9CLFdBQXBCLEVBQWlDLFdBQWpFLEVBQThFO0FBQzFFLG1CQUFPLFdBQVAsSUFBc0IsS0FBSyxJQUFMLENBQVUsU0FBVixJQUF1QixJQUFJLElBQUosQ0FBUyxTQUFULENBQTdDO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLE1BQVA7QUFDSCxDQXpCRDs7QUEyQkEsV0FBVyxTQUFYLENBQXFCLFVBQXJCLEdBQWtDLFVBQVMsTUFBVCxFQUFpQixJQUFqQixFQUF1QjtBQUNyRCxXQUFPLEtBQUssU0FBTCxHQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFQOztBQUVBLFFBQ0ksSUFBSSxLQUFLLFFBQUwsRUFEUjtBQUFBLFFBRUksSUFBSSxLQUFLLFNBQUwsRUFGUjtBQUFBLFFBSUksWUFBWSxLQUFLLGFBQUwsQ0FBbUIsS0FBSyxJQUF4QixFQUE4QixLQUFLLEdBQW5DLENBSmhCO0FBQUEsUUFLSSxjQUFjLENBTGxCO0FBQUEsUUFPSSxZQUFZLENBQUMsS0FBSyxLQUFMLEdBQWEsQ0FBZCxJQUFtQixXQUFXLGVBUDlDO0FBQUEsUUFTSSxhQUFhLElBQUksV0FBVyxlQVRoQzs7QUFXQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQXBCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLGlCQUFLLElBQUwsQ0FBVSxXQUFWLEtBQTBCLE9BQU8sYUFBUCxDQUExQjtBQUNIO0FBQ0QscUJBQWEsU0FBYjtBQUNIO0FBQ0osQ0FwQkQ7O0FBc0JBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBWCxDQUFxQixjQUFyQixHQUFzQyxVQUFTLEdBQVQsRUFBYyxPQUFkLEVBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCO0FBQy9ELFFBQ0ksYUFBYSxRQUFRLEtBQVIsRUFEakI7QUFBQSxRQUVJLFVBQVUscUJBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0IsQ0FBcEIsQ0FGZDs7QUFJQSxTQUFLLFNBQUwsR0FBaUIsY0FBakIsQ0FBZ0MsVUFBaEMsRUFBNEMsT0FBNUM7O0FBRUEsUUFDSSxhQUFhLENBQUMsSUFBSSxLQUFKLEdBQVksUUFBUSxRQUFSLEVBQWIsSUFBbUMsV0FBVyxlQUQvRDtBQUFBLFFBRUksYUFBYSxDQUFDLEtBQUssS0FBTCxHQUFhLFFBQVEsUUFBUixFQUFkLElBQW9DLFdBQVcsZUFGaEU7QUFBQSxRQUlJLFlBQVksSUFBSSxhQUFKLENBQWtCLFdBQVcsSUFBN0IsRUFBbUMsV0FBVyxHQUE5QyxDQUpoQjtBQUFBLFFBS0ksWUFBWSxLQUFLLGFBQUwsQ0FBbUIsUUFBUSxJQUEzQixFQUFpQyxRQUFRLEdBQXpDLENBTGhCOztBQU9BLFNBQUssSUFBSSxJQUFJLFFBQVEsR0FBckIsRUFBMEIsSUFBSSxRQUFRLE1BQXRDLEVBQThDLEtBQUssYUFBYSxVQUFsQixFQUE4QixhQUFhLFVBQXpGLEVBQXFHO0FBQ2pHLGFBQUssSUFBSSxJQUFJLFFBQVEsSUFBckIsRUFBMkIsSUFBSSxRQUFRLEtBQXZDLEVBQThDLEdBQTlDLEVBQW1EO0FBQy9DLGdCQUNJLFNBQVMsSUFBSSxJQUFKLENBQVMsWUFBWSxXQUFXLGlCQUFoQyxDQURiOztBQUdBLGdCQUFJLFVBQVUsQ0FBZCxFQUFpQjtBQUNiLDZCQUFhLFdBQVcsZUFBeEI7QUFDQSw2QkFBYSxXQUFXLGVBQXhCO0FBQ0E7QUFDSDs7QUFFRCxnQkFBSSxVQUFVLEdBQWQsRUFBbUI7QUFDZixxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQVcsZUFBL0IsRUFBZ0QsR0FBaEQsRUFBcUQ7QUFDakQseUJBQUssSUFBTCxDQUFVLFdBQVYsSUFBeUIsSUFBSSxJQUFKLENBQVMsV0FBVCxDQUF6QjtBQUNIO0FBQ0Q7QUFDSDs7QUFFRCxnQkFDSSxTQUFTLEtBQUssSUFBTCxDQUFVLFlBQVksV0FBVyxpQkFBakMsQ0FEYjtBQUFBLGdCQUVJLFdBQVksU0FBUyxNQUFULEdBQWtCLFNBQVMsTUFBVCxHQUFrQixHQUFyQyxHQUE0QyxDQUYzRDs7QUFJQSxnQkFBSSxXQUFXLENBQWYsRUFBa0I7QUFDZCxvQkFDSSxZQUFhLFNBQVMsR0FBVCxHQUFlLFFBQWhCLEdBQTRCLENBRDVDO0FBQUEsb0JBRUksV0FBVyxNQUFNLFNBRnJCOztBQUlBLHFCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsS0FBSyxXQUFMLEVBQWtCLFdBQXpDLEVBQXNEO0FBQ2xELHlCQUFLLElBQUwsQ0FBVSxTQUFWLElBQXdCLElBQUksSUFBSixDQUFTLFNBQVQsSUFBc0IsQ0FBQyxLQUFLLElBQUwsQ0FBVSxTQUFWLElBQXVCLFFBQXZCLEdBQWtDLElBQUksSUFBSixDQUFTLFNBQVQsSUFBc0IsUUFBekQsSUFBcUUsR0FBNUYsR0FBbUcsQ0FBMUg7QUFDSDtBQUNELHFCQUFLLElBQUwsQ0FBVSxXQUFWLElBQXlCLFFBQXpCO0FBQ0E7QUFDSCxhQVZELE1BVU87QUFDSCw2QkFBYSxXQUFXLGVBQXhCO0FBQ0EsNkJBQWEsV0FBVyxlQUF4QjtBQUNIO0FBQ0o7QUFDSjtBQUNKLENBcEREOztBQXNEQTs7O0FBR0EsV0FBVyxTQUFYLENBQXFCLGNBQXJCLEdBQXNDLFVBQVMsR0FBVCxFQUFjLElBQWQsRUFBb0IsSUFBcEIsRUFBMEIsT0FBMUIsRUFBbUM7QUFDckUsUUFDSSxVQUFVLFFBQVEsS0FBUixFQURkO0FBQUEsUUFFSSxVQUFVLHFCQUFXLElBQVgsRUFBaUIsSUFBakIsRUFBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsQ0FGZDs7QUFJQSxTQUFLLFNBQUwsR0FBaUIsY0FBakIsQ0FBZ0MsT0FBaEMsRUFBeUMsT0FBekM7O0FBRUEsUUFDSSxJQUFJLFFBQVEsUUFBUixLQUFxQixDQUQ3QjtBQUFBLFFBRUksSUFBSSxRQUFRLFNBQVIsS0FBc0IsQ0FGOUI7O0FBSUE7QUFDQSxRQUFJLFFBQVEsSUFBUixJQUFnQixDQUFoQixJQUFxQixRQUFRLEdBQVIsSUFBZSxDQUFwQyxJQUF5QyxLQUFLLEtBQUssS0FBbkQsSUFBNEQsS0FBSyxLQUFLLE1BQXRFLElBQWdGLEtBQUssSUFBSSxLQUF6RixJQUFrRyxLQUFLLElBQUksTUFBL0csRUFBdUg7QUFDbkgsYUFBSyxZQUFMLENBQWtCLEdBQWxCO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsWUFDSSxXQUFXLEtBQUssYUFBTCxDQUFtQixRQUFRLElBQTNCLEVBQWlDLFFBQVEsR0FBekMsQ0FEZjtBQUFBLFlBRUksV0FBVyxJQUFJLGFBQUosQ0FBa0IsUUFBUSxJQUExQixFQUFnQyxRQUFRLEdBQXhDLENBRmY7QUFBQSxZQUlJLFdBQVcsQ0FBQyxLQUFLLEtBQUwsR0FBYSxDQUFkLElBQW1CLFdBQVcsZUFKN0M7QUFBQSxZQUtJLFdBQVcsQ0FBQyxJQUFJLEtBQUosR0FBWSxDQUFiLElBQWtCLFdBQVcsZUFMNUM7O0FBT0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIscUJBQUssSUFBTCxDQUFVLFFBQVYsSUFBc0IsSUFBSSxJQUFKLENBQVMsUUFBVCxDQUF0QjtBQUNBLHFCQUFLLElBQUwsQ0FBVSxXQUFXLENBQXJCLElBQTBCLElBQUksSUFBSixDQUFTLFdBQVcsQ0FBcEIsQ0FBMUI7QUFDQSxxQkFBSyxJQUFMLENBQVUsV0FBVyxDQUFyQixJQUEwQixJQUFJLElBQUosQ0FBUyxXQUFXLENBQXBCLENBQTFCO0FBQ0EscUJBQUssSUFBTCxDQUFVLFdBQVcsQ0FBckIsSUFBMEIsSUFBSSxJQUFKLENBQVMsV0FBVyxDQUFwQixDQUExQjtBQUNBLDRCQUFZLENBQVo7QUFDQSw0QkFBWSxDQUFaO0FBQ0g7QUFDRCx3QkFBWSxRQUFaO0FBQ0Esd0JBQVksUUFBWjtBQUNIO0FBQ0o7QUFDSixDQW5DRDs7QUFxQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFYLENBQXFCLGFBQXJCLEdBQXFDLFVBQVMsR0FBVCxFQUFjLElBQWQsRUFBb0I7QUFDckQsV0FBTyxLQUFLLFNBQUwsR0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBUDs7QUFFQSxRQUNJLElBQUksS0FBSyxRQUFMLEVBRFI7QUFBQSxRQUVJLElBQUksS0FBSyxTQUFMLEVBRlI7QUFBQSxRQUlJLFdBQVcsS0FBSyxhQUFMLENBQW1CLEtBQUssSUFBeEIsRUFBOEIsS0FBSyxHQUFuQyxJQUEwQyxXQUFXLGlCQUpwRSxDQUlzRjtBQUp0RjtBQUFBLFFBS0ksUUFBUSxDQUFDLEtBQUssS0FBTCxHQUFhLENBQWQsSUFBbUIsV0FBVyxlQUwxQzs7QUFPQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGlCQUFLLElBQUwsQ0FBVSxRQUFWLElBQXNCLElBQUksSUFBSixDQUFTLFFBQVQsQ0FBdEI7QUFDQSx3QkFBWSxXQUFXLGVBQXZCO0FBQ0g7QUFDRCxvQkFBWSxLQUFaO0FBQ0g7QUFDSixDQWpCRDs7QUFtQkEsV0FBVyxTQUFYLENBQXFCLFlBQXJCLEdBQW9DLFVBQVMsR0FBVCxFQUFjO0FBQzlDLFFBQUksSUFBSSxLQUFKLElBQWEsS0FBSyxLQUFsQixJQUEyQixJQUFJLE1BQUosSUFBYyxLQUFLLE1BQWxELEVBQTBEO0FBQ3RELGFBQUssS0FBTCxHQUFhLElBQUksS0FBakI7QUFDQSxhQUFLLE1BQUwsR0FBYyxJQUFJLE1BQWxCOztBQUVBLGFBQUssU0FBTCxHQUFpQixnQkFBZ0IsS0FBSyxLQUFyQixFQUE0QixLQUFLLE1BQWpDLENBQWpCO0FBQ0EsYUFBSyxJQUFMLEdBQVksS0FBSyxTQUFMLENBQWUsSUFBM0I7QUFDSDs7QUFFRCxRQUFJLFNBQVMsS0FBSyxJQUFsQixFQUF3QjtBQUNwQixhQUFLLElBQUwsQ0FBVSxHQUFWLENBQWMsSUFBSSxJQUFsQjtBQUNILEtBRkQsTUFFTztBQUNIO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssSUFBTCxDQUFVLE1BQTlCLEVBQXNDLEdBQXRDLEVBQTJDO0FBQ3ZDLGlCQUFLLElBQUwsQ0FBVSxDQUFWLElBQWUsSUFBSSxJQUFKLENBQVMsQ0FBVCxDQUFmO0FBQ0g7QUFDSjtBQUNKLENBakJEOztBQW1CQTs7Ozs7O0FBTUEsV0FBVyxTQUFYLENBQXFCLFNBQXJCLEdBQWlDLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxLQUFmLEVBQXNCO0FBQ25ELFFBQUksQ0FBQyxLQUFLLFFBQUwsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLENBQUwsRUFBMEI7QUFDdEI7QUFDSDs7QUFFRCxRQUNJLFdBQVcsS0FBSyxRQUFMLENBQWMsQ0FBZCxFQUFpQixDQUFqQixDQURmO0FBQUEsUUFHSSxXQUFZLFlBQVksRUFBYixHQUFtQixJQUhsQztBQUFBLFFBSUksU0FBVSxZQUFZLEVBQWIsR0FBbUIsSUFKaEM7QUFBQSxRQUtJLFdBQVksWUFBWSxDQUFiLEdBQWtCLElBTGpDO0FBQUEsUUFNSSxVQUFVLFdBQVcsSUFOekI7QUFBQSxRQVFJLGFBQWMsU0FBUyxFQUFWLEdBQWdCLElBUmpDO0FBQUEsUUFTSSxXQUFZLFNBQVMsRUFBVixHQUFnQixJQVQvQjtBQUFBLFFBVUksYUFBYyxTQUFTLENBQVYsR0FBZSxJQVZoQztBQUFBLFFBV0ksWUFBWSxRQUFRLElBWHhCO0FBQUEsUUFhSSxRQUFRLEVBYlo7QUFBQSxRQWNJLE9BQU8sS0FBSyxTQUFMLEVBZFg7QUFBQSxRQWdCSSxPQUFPLEtBQUssSUFoQmhCOztBQWtCQTtBQUNBLFNBQUssSUFBTCxJQUFhLFdBQVcsZUFBeEI7QUFDQSxTQUFLLEtBQUwsSUFBYyxXQUFXLGVBQXpCOztBQUVBLFVBQU0sSUFBTixDQUFXLEVBQUMsSUFBSSxJQUFJLFdBQVcsZUFBcEIsRUFBcUMsSUFBSSxJQUFJLFdBQVcsZUFBeEQsRUFBeUUsR0FBRyxDQUE1RSxFQUErRSxJQUFJLENBQUMsQ0FBcEYsRUFBWDtBQUNBLFVBQU0sSUFBTixDQUFXLEVBQUMsSUFBSSxJQUFJLFdBQVcsZUFBcEIsRUFBcUMsSUFBSSxJQUFJLFdBQVcsZUFBeEQsRUFBeUUsR0FBRyxJQUFJLENBQWhGLEVBQW1GLElBQUksQ0FBdkYsRUFBWDs7QUFFQTs7Ozs7QUFLQSxRQUFJLFlBQVksQ0FBaEIsRUFBbUI7QUFDZixZQUFJLGNBQWMsQ0FBbEIsRUFBcUI7QUFDakI7QUFDSDs7QUFFRCxlQUFPLE1BQU0sTUFBTixHQUFlLENBQXRCLEVBQXlCO0FBQ3JCLGdCQUNJLE9BQU8sTUFBTSxHQUFOLEVBRFg7O0FBR0EsZ0JBQUksS0FBSyxDQUFMLEdBQVMsS0FBSyxHQUFkLElBQXFCLEtBQUssQ0FBTCxJQUFVLEtBQUssTUFBeEMsRUFBZ0Q7QUFDNUM7QUFDSDs7QUFFRCxnQkFDSSxhQUFhLEtBQUssYUFBTCxDQUFtQixDQUFuQixFQUFzQixLQUFLLENBQTNCLENBRGpCO0FBQUEsZ0JBR0ksT0FBTyxLQUFLLEVBSGhCO0FBQUEsZ0JBR29CLElBSHBCOztBQUtBLG1CQUNJLFFBQVEsS0FBSyxJQUFiLElBQ0csS0FBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxpQkFBcEMsS0FBMEQsQ0FGakUsRUFHRTtBQUNFLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGVBQXBDLElBQXVELFFBQXZEO0FBQ0EscUJBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsaUJBQXBDLElBQXlELFVBQXpEO0FBQ0EscUJBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsZ0JBQXBDLElBQXdELFNBQXhEO0FBQ0EscUJBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsaUJBQXBDLElBQXlELFVBQXpEOztBQUVBLHdCQUFRLFdBQVcsZUFBbkI7QUFDSDs7QUFFRCxnQkFBSSxRQUFRLEtBQUssRUFBakIsRUFBcUI7QUFDakIsdUJBQ0ksUUFBUSxLQUFLLEVBQWIsSUFDRyxLQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxLQUEwRCxRQUZqRSxFQUdFO0FBQ0UsNEJBQVEsV0FBVyxlQUFuQjtBQUNIO0FBQ0QsdUJBQU8sT0FBTyxXQUFXLGVBQXpCO0FBQ0Esb0JBQUksT0FBTyxLQUFLLEVBQWhCLEVBQW9CO0FBQ2hCO0FBQ0g7QUFDSixhQVhELE1BV087QUFDSCx3QkFBUSxXQUFXLGVBQW5CO0FBQ0Esb0JBQUksT0FBTyxLQUFLLEVBQWhCLEVBQW9CO0FBQ2hCLDBCQUFNLElBQU4sQ0FBVyxFQUFDLElBQUksSUFBTCxFQUFXLElBQUksS0FBSyxFQUFMLEdBQVUsV0FBVyxlQUFwQyxFQUFxRCxHQUFHLEtBQUssQ0FBTCxHQUFTLEtBQUssRUFBdEUsRUFBMEUsSUFBSSxDQUFDLEtBQUssRUFBcEYsRUFBWDtBQUNIO0FBQ0QsdUJBQU8sS0FBSyxFQUFMLEdBQVUsV0FBVyxlQUE1QjtBQUNIOztBQUVELGVBQUc7QUFDQyxxQkFBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxlQUFwQyxJQUF1RCxRQUF2RDtBQUNBLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxJQUF5RCxVQUF6RDtBQUNBLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGdCQUFwQyxJQUF3RCxTQUF4RDtBQUNBLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxJQUF5RCxVQUF6RDs7QUFFQSx1QkFDSSxPQUFPLEtBQUssS0FBWixJQUNHLEtBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsaUJBQXBDLEtBQTBELFFBRmpFLEVBR0U7QUFDRSx5QkFBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxlQUFwQyxJQUF1RCxRQUF2RDtBQUNBLHlCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxJQUF5RCxVQUF6RDtBQUNBLHlCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGdCQUFwQyxJQUF3RCxTQUF4RDtBQUNBLHlCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxJQUF5RCxVQUF6RDs7QUFFQSw0QkFBUSxXQUFXLGVBQW5CO0FBQ0g7QUFDRCxzQkFBTSxJQUFOLENBQVcsRUFBQyxJQUFJLElBQUwsRUFBVyxJQUFJLE9BQU8sV0FBVyxlQUFqQyxFQUFrRCxHQUFHLEtBQUssQ0FBTCxHQUFTLEtBQUssRUFBbkUsRUFBdUUsSUFBSSxLQUFLLEVBQWhGLEVBQVg7O0FBRUEsb0JBQUksT0FBTyxXQUFXLGVBQWxCLEdBQW9DLEtBQUssRUFBN0MsRUFBaUQ7QUFDN0MsMEJBQU0sSUFBTixDQUFXLEVBQUMsSUFBSSxLQUFLLEVBQUwsR0FBVSxXQUFXLGVBQTFCLEVBQTJDLElBQUksT0FBTyxXQUFXLGVBQWpFLEVBQWtGLEdBQUcsS0FBSyxDQUFMLEdBQVMsS0FBSyxFQUFuRyxFQUF1RyxJQUFJLENBQUMsS0FBSyxFQUFqSCxFQUFYO0FBQ0g7O0FBRUQsdUJBQU8sT0FBTyxXQUFXLGVBQXpCO0FBQ0EsdUJBQ0ksUUFBUSxLQUFLLEVBQWIsSUFBbUIsS0FBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxpQkFBcEMsS0FBMEQsUUFEakYsRUFFRTtBQUNFLDRCQUFRLFdBQVcsZUFBbkI7QUFDSDs7QUFFRCx1QkFBTyxPQUFPLFdBQVcsZUFBekI7QUFDSCxhQS9CRCxRQStCUyxRQUFRLEtBQUssRUEvQnRCO0FBZ0NIO0FBQ0osS0FsRkQsTUFrRk87QUFDSCxZQUFJLFNBQVMsUUFBYixFQUF1QjtBQUNuQjtBQUNIOztBQUVELGVBQU8sTUFBTSxNQUFOLEdBQWUsQ0FBdEIsRUFBeUI7QUFDckIsZ0JBQ0ksT0FBTyxNQUFNLEdBQU4sRUFEWDs7QUFHQSxnQkFBSSxLQUFLLENBQUwsR0FBUyxLQUFLLEdBQWQsSUFBcUIsS0FBSyxDQUFMLElBQVUsS0FBSyxNQUF4QyxFQUFnRDtBQUM1QztBQUNIOztBQUVELGdCQUNJLGFBQWEsS0FBSyxhQUFMLENBQW1CLENBQW5CLEVBQXNCLEtBQUssQ0FBM0IsQ0FEakI7QUFBQSxnQkFHSSxPQUFPLEtBQUssRUFIaEI7QUFBQSxnQkFHb0IsSUFIcEI7O0FBS0EsbUJBQ0ksUUFBUSxLQUFLLElBQWIsSUFDRyxLQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGVBQXBDLEtBQXdELE1BRDNELElBRUcsS0FBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxpQkFBcEMsS0FBMEQsUUFGN0QsSUFHRyxLQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGdCQUFwQyxLQUF5RCxPQUg1RCxJQUlHLEtBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsaUJBQXBDLEtBQTBELFFBTGpFLEVBTUU7QUFDRSxxQkFBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxlQUFwQyxJQUF1RCxRQUF2RDtBQUNBLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxJQUF5RCxVQUF6RDtBQUNBLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGdCQUFwQyxJQUF3RCxTQUF4RDtBQUNBLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxJQUF5RCxVQUF6RDs7QUFFQSx3QkFBUSxXQUFXLGVBQW5CO0FBQ0g7O0FBRUQsZ0JBQUksUUFBUSxLQUFLLEVBQWpCLEVBQXFCO0FBQ2pCLHVCQUNJLFFBQVEsS0FBSyxFQUFiLElBQ0csRUFDQyxLQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGVBQXBDLEtBQXdELE1BQXhELElBQ0csS0FBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxpQkFBcEMsS0FBMEQsUUFEN0QsSUFFRyxLQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGdCQUFwQyxLQUF5RCxPQUY1RCxJQUdHLEtBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsaUJBQXBDLEtBQTBELFFBSjlELENBRlAsRUFRRTtBQUNFLDRCQUFRLFdBQVcsZUFBbkI7QUFDSDtBQUNELHVCQUFPLE9BQU8sV0FBVyxlQUF6QjtBQUNBLG9CQUFJLE9BQU8sS0FBSyxFQUFoQixFQUFvQjtBQUNoQjtBQUNIO0FBQ0osYUFoQkQsTUFnQk87QUFDSCx3QkFBUSxXQUFXLGVBQW5CO0FBQ0Esb0JBQUksT0FBTyxLQUFLLEVBQWhCLEVBQW9CO0FBQ2hCLDBCQUFNLElBQU4sQ0FBVyxFQUFDLElBQUksSUFBTCxFQUFXLElBQUksS0FBSyxFQUFMLEdBQVUsV0FBVyxlQUFwQyxFQUFxRCxHQUFHLEtBQUssQ0FBTCxHQUFTLEtBQUssRUFBdEUsRUFBMEUsSUFBSSxDQUFDLEtBQUssRUFBcEYsRUFBWDtBQUNIO0FBQ0QsdUJBQU8sS0FBSyxFQUFMLEdBQVUsV0FBVyxlQUE1QjtBQUNIOztBQUVELGVBQUc7QUFDQyxxQkFBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxlQUFwQyxJQUF1RCxRQUF2RDtBQUNBLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxJQUF5RCxVQUF6RDtBQUNBLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGdCQUFwQyxJQUF3RCxTQUF4RDtBQUNBLHFCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxJQUF5RCxVQUF6RDs7QUFFQSx1QkFDSSxPQUFPLEtBQUssS0FBWixJQUNHLEtBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsZUFBcEMsS0FBd0QsTUFEM0QsSUFFRyxLQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxLQUEwRCxRQUY3RCxJQUdHLEtBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsZ0JBQXBDLEtBQXlELE9BSDVELElBSUcsS0FBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxpQkFBcEMsS0FBMEQsUUFMakUsRUFNRTtBQUNFLHlCQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGVBQXBDLElBQXVELFFBQXZEO0FBQ0EseUJBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsaUJBQXBDLElBQXlELFVBQXpEO0FBQ0EseUJBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsZ0JBQXBDLElBQXdELFNBQXhEO0FBQ0EseUJBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsaUJBQXBDLElBQXlELFVBQXpEOztBQUVBLDRCQUFRLFdBQVcsZUFBbkI7QUFDSDtBQUNELHNCQUFNLElBQU4sQ0FBVyxFQUFDLElBQUksSUFBTCxFQUFXLElBQUksT0FBTyxXQUFXLGVBQWpDLEVBQWtELEdBQUcsS0FBSyxDQUFMLEdBQVMsS0FBSyxFQUFuRSxFQUF1RSxJQUFJLEtBQUssRUFBaEYsRUFBWDs7QUFFQSxvQkFBSSxPQUFPLFdBQVcsZUFBbEIsR0FBb0MsS0FBSyxFQUE3QyxFQUFpRDtBQUM3QywwQkFBTSxJQUFOLENBQVcsRUFBQyxJQUFJLEtBQUssRUFBTCxHQUFVLFdBQVcsZUFBMUIsRUFBMkMsSUFBSSxPQUFPLFdBQVcsZUFBakUsRUFBa0YsR0FBRyxLQUFLLENBQUwsR0FBUyxLQUFLLEVBQW5HLEVBQXVHLElBQUksQ0FBQyxLQUFLLEVBQWpILEVBQVg7QUFDSDs7QUFFRCx1QkFBTyxPQUFPLFdBQVcsZUFBekI7QUFDQSx1QkFDSSxRQUFRLEtBQUssRUFBYixJQUFtQixFQUNmLEtBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsZUFBcEMsS0FBd0QsTUFBeEQsSUFDRyxLQUFLLE9BQU8sVUFBUCxHQUFvQixXQUFXLGlCQUFwQyxLQUEwRCxRQUQ3RCxJQUVHLEtBQUssT0FBTyxVQUFQLEdBQW9CLFdBQVcsZ0JBQXBDLEtBQXlELE9BRjVELElBR0csS0FBSyxPQUFPLFVBQVAsR0FBb0IsV0FBVyxpQkFBcEMsS0FBMEQsUUFKOUMsQ0FEdkIsRUFPRTtBQUNFLDRCQUFRLFdBQVcsZUFBbkI7QUFDSDs7QUFFRCx1QkFBTyxPQUFPLFdBQVcsZUFBekI7QUFDSCxhQXZDRCxRQXVDUyxRQUFRLEtBQUssRUF2Q3RCO0FBd0NIO0FBQ0o7QUFDSixDQXhORDs7QUEwTkE7Ozs7OztBQU1BLFNBQVMsYUFBVCxDQUF1QixNQUF2QixFQUErQixHQUEvQixFQUFvQztBQUNoQyxRQUNJLFdBQVcsQ0FEZjs7QUFHQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsWUFDSSxRQUFRLE9BQU8sV0FBVyxXQUFXLGlCQUE3QixDQURaOztBQUdBO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssVUFBNUIsRUFBd0M7QUFDcEMsbUJBQU8sUUFBUCxJQUFtQixLQUFLLEtBQUwsQ0FBVyxPQUFPLFFBQVAsSUFBbUIsS0FBbkIsR0FBMkIsR0FBdEMsQ0FBbkI7QUFDSDtBQUNELG1CQVIwQixDQVFkO0FBQ2Y7QUFDSjs7QUFFRDs7O0FBR0EsU0FBUyxhQUFULENBQXVCLE1BQXZCLEVBQStCLEdBQS9CLEVBQW9DO0FBQ2hDLFFBQ0ksV0FBVyxDQURmOztBQUdBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixZQUNJLFFBQVEsT0FBTyxXQUFXLFdBQVcsaUJBQTdCLENBRFo7O0FBR0EsWUFBSSxTQUFTLENBQWIsRUFBZ0I7QUFDWixnQkFDSSxXQUFXLE1BQU0sS0FEckI7O0FBR0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFVBQTVCLEVBQXdDO0FBQ3BDLHVCQUFPLFFBQVAsSUFBbUIsS0FBSyxHQUFMLENBQVMsS0FBSyxLQUFMLENBQVcsT0FBTyxRQUFQLElBQW1CLFFBQTlCLENBQVQsRUFBa0QsR0FBbEQsQ0FBbkI7QUFDSDtBQUNEO0FBQ0E7QUFDSCxTQVRELE1BU087QUFDSCx3QkFBWSxXQUFXLGVBQXZCO0FBQ0g7QUFDSjtBQUNKOztBQUVELFNBQVMsV0FBVCxDQUFxQixHQUFyQixFQUEwQixHQUExQixFQUErQixHQUEvQixFQUFvQyxNQUFwQyxFQUE0QztBQUN4QyxRQUNJLGNBQWMsQ0FEbEI7QUFBQSxRQUNxQixnQkFBZ0IsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLENBRHJDO0FBQUEsUUFFSSxRQUZKO0FBQUEsUUFFYyxRQUZkOztBQUlBLGVBQVcsQ0FBWDtBQUNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFKLElBQWMsSUFBSSxHQUFsQyxFQUF1QyxHQUF2QyxFQUE0QztBQUN4QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksV0FBVyxlQUEvQixFQUFnRCxHQUFoRCxFQUFxRDtBQUNqRCwwQkFBYyxDQUFkLEtBQW9CLElBQUksVUFBSixDQUFwQjtBQUNIO0FBQ0Q7QUFDSDs7QUFFRCxlQUFXLENBQVg7QUFDQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUI7QUFDQSxZQUFJLElBQUksTUFBSixHQUFhLEdBQWpCLEVBQXNCO0FBQ2xCLHVCQUFXLENBQUMsSUFBSSxNQUFMLElBQWUsV0FBVyxlQUFyQzs7QUFFQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQVcsZUFBL0IsRUFBZ0QsR0FBaEQsRUFBcUQ7QUFDakQsOEJBQWMsQ0FBZCxLQUFvQixJQUFJLFVBQUosQ0FBcEI7QUFDSDtBQUNEO0FBQ0g7O0FBRUQsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQVcsZUFBL0IsRUFBZ0QsR0FBaEQsRUFBcUQ7QUFDakQsZ0JBQUksVUFBSixJQUFrQixLQUFLLEtBQUwsQ0FBVyxjQUFjLENBQWQsSUFBbUIsV0FBOUIsQ0FBbEI7QUFDSDs7QUFFRDtBQUNBLFlBQUksSUFBSSxNQUFKLElBQWMsQ0FBbEIsRUFBcUI7QUFDakIsdUJBQVcsQ0FBQyxJQUFJLE1BQUwsSUFBZSxXQUFXLGVBQXJDOztBQUVBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksV0FBVyxlQUEvQixFQUFnRCxHQUFoRCxFQUFxRDtBQUNqRCw4QkFBYyxDQUFkLEtBQW9CLElBQUksVUFBSixDQUFwQjtBQUNIO0FBQ0Q7QUFDSDtBQUNKO0FBQ0o7O0FBRUQ7Ozs7Ozs7O0FBUUEsV0FBVyxTQUFYLENBQXFCLHNCQUFyQixHQUE4QyxVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWUsR0FBZixFQUFvQixNQUFwQixFQUE0QjtBQUN0RSxRQUNJLFFBQVEsQ0FBQyxLQUFLLEtBQUwsR0FBYSxDQUFkLElBQW1CLFdBQVcsZUFEMUM7QUFBQSxRQUVJLFlBQVksQ0FGaEI7QUFBQSxRQUdJLFlBQVksS0FBSyxhQUFMLENBQW1CLENBQW5CLEVBQXNCLENBQXRCLENBSGhCOztBQUtBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksV0FBVyxlQUEvQixFQUFnRCxHQUFoRCxFQUFxRDtBQUNqRCxtQkFBTyxXQUFQLElBQXNCLEtBQUssSUFBTCxDQUFVLFdBQVYsQ0FBdEI7QUFDSDs7QUFFRCxxQkFBYSxLQUFiO0FBQ0g7QUFDSixDQWJEOztBQWVBOzs7Ozs7OztBQVFBLFdBQVcsU0FBWCxDQUFxQixzQkFBckIsR0FBOEMsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlLEdBQWYsRUFBb0IsTUFBcEIsRUFBNEI7QUFDdEUsUUFDSSxRQUFRLENBQUMsS0FBSyxLQUFMLEdBQWEsQ0FBZCxJQUFtQixXQUFXLGVBRDFDO0FBQUEsUUFFSSxZQUFZLENBRmhCO0FBQUEsUUFHSSxZQUFZLEtBQUssYUFBTCxDQUFtQixDQUFuQixFQUFzQixDQUF0QixDQUhoQjs7QUFLQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQVcsZUFBL0IsRUFBZ0QsR0FBaEQsRUFBcUQ7QUFDakQsaUJBQUssSUFBTCxDQUFVLFdBQVYsSUFBeUIsT0FBTyxXQUFQLENBQXpCO0FBQ0g7O0FBRUQscUJBQWEsS0FBYjtBQUNIO0FBQ0osQ0FiRDs7QUFlQSxXQUFXLFNBQVgsQ0FBcUIsT0FBckIsR0FBK0IsVUFBUyxJQUFULEVBQWUsT0FBZixFQUF3QixPQUF4QixFQUFpQztBQUM1RCxXQUFPLEtBQUssU0FBTCxHQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFQOztBQUVBLFFBQ0ksWUFBWSxLQUFLLFFBQUwsRUFEaEI7QUFBQSxRQUVJLGlCQUFpQixZQUFZLFdBQVcsZUFGNUM7QUFBQSxRQUdJLGFBQWEsS0FBSyxTQUFMLEVBSGpCO0FBQUEsUUFJSSxhQUFhLEtBQUssR0FBTCxDQUFTLFNBQVQsRUFBb0IsVUFBcEIsQ0FKakI7QUFBQSxRQU1JLE1BQU0sSUFBSSxVQUFKLENBQWUsYUFBYSxXQUFXLGVBQXZDLENBTlY7QUFBQSxRQU9JLE1BQU0sSUFBSSxVQUFKLENBQWUsYUFBYSxXQUFXLGVBQXZDLENBUFY7O0FBU0EsU0FBSyxJQUFJLElBQUksS0FBSyxHQUFsQixFQUF1QixJQUFJLEtBQUssTUFBaEMsRUFBd0MsR0FBeEMsRUFBNkM7QUFDekMsWUFDSSxZQUFZLEtBQUssYUFBTCxDQUFtQixLQUFLLElBQXhCLEVBQThCLENBQTlCLENBRGhCOztBQUdBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxjQUFwQixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyxnQkFBSSxDQUFKLElBQVMsS0FBSyxJQUFMLENBQVUsV0FBVixDQUFUO0FBQ0g7O0FBRUQsc0JBQWMsR0FBZCxFQUFtQixTQUFuQjtBQUNBLG9CQUFZLEdBQVosRUFBaUIsR0FBakIsRUFBc0IsU0FBdEIsRUFBaUMsT0FBakM7O0FBRUEsb0JBQVksS0FBSyxhQUFMLENBQW1CLEtBQUssSUFBeEIsRUFBOEIsQ0FBOUIsQ0FBWjs7QUFFQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksY0FBcEIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsaUJBQUssSUFBTCxDQUFVLFdBQVYsSUFBeUIsSUFBSSxDQUFKLENBQXpCO0FBQ0g7QUFDSjs7QUFFRCxTQUFLLElBQUksSUFBSSxLQUFLLElBQWxCLEVBQXdCLElBQUksS0FBSyxLQUFqQyxFQUF3QyxHQUF4QyxFQUE2QztBQUN6QyxhQUFLLHNCQUFMLENBQTRCLENBQTVCLEVBQStCLEtBQUssR0FBcEMsRUFBeUMsVUFBekMsRUFBcUQsR0FBckQ7O0FBRUEsb0JBQVksR0FBWixFQUFpQixHQUFqQixFQUFzQixVQUF0QixFQUFrQyxPQUFsQztBQUNBLHNCQUFjLEdBQWQsRUFBbUIsVUFBbkI7O0FBRUEsYUFBSyxzQkFBTCxDQUE0QixDQUE1QixFQUErQixLQUFLLEdBQXBDLEVBQXlDLFVBQXpDLEVBQXFELEdBQXJEO0FBQ0g7QUFDSixDQXRDRDs7QUF3Q0EsV0FBVyxTQUFYLENBQXFCLGFBQXJCLEdBQXFDLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUNoRCxXQUFRLENBQUMsSUFBSSxLQUFLLEtBQVQsR0FBaUIsQ0FBbEIsSUFBdUIsV0FBVyxlQUFuQyxHQUFzRCxDQUE3RDtBQUNILENBRkQ7O0FBSUEsV0FBVyxTQUFYLENBQXFCLGFBQXJCLEdBQXFDLFlBQVc7QUFDNUMsV0FBTyxLQUFLLElBQUwsQ0FBVSxNQUFqQjtBQUNILENBRkQ7O0FBSUE7QUFDQSxXQUFXLFNBQVgsQ0FBcUIsYUFBckIsR0FBcUMsVUFBUyxLQUFULEVBQWdCO0FBQ2pELFFBQ0ksY0FBYyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FEbEI7QUFBQSxRQUVJLGVBQWUsWUFBWSxVQUFaLENBQXVCLElBQXZCLENBRm5COztBQUlBLGdCQUFZLEtBQVosR0FBb0IsTUFBTSxLQUExQjtBQUNBLGdCQUFZLE1BQVosR0FBcUIsTUFBTSxNQUEzQjs7QUFFQSxpQkFBYSx3QkFBYixHQUF3QyxNQUF4QztBQUNBLGlCQUFhLFNBQWIsQ0FBdUIsS0FBdkIsRUFBOEIsQ0FBOUIsRUFBaUMsQ0FBakM7O0FBRUEsU0FBSyxTQUFMLEdBQWlCLGFBQWEsWUFBYixDQUEwQixDQUExQixFQUE2QixDQUE3QixFQUFnQyxLQUFLLEtBQXJDLEVBQTRDLEtBQUssTUFBakQsQ0FBakI7QUFDQSxTQUFLLElBQUwsR0FBWSxLQUFLLFNBQUwsQ0FBZSxJQUEzQjtBQUNILENBYkQ7O0FBZUEsV0FBVyxTQUFYLENBQXFCLFlBQXJCLEdBQW9DLFlBQVc7QUFDM0MsV0FBTyxLQUFLLFNBQVo7QUFDSCxDQUZEOztBQUlBOzs7OztBQUtBLFdBQVcsU0FBWCxDQUFxQixZQUFyQixHQUFvQyxVQUFTLFNBQVQsRUFBb0I7QUFDcEQsU0FBSyxLQUFMLEdBQWEsVUFBVSxLQUF2QjtBQUNBLFNBQUssTUFBTCxHQUFjLFVBQVUsTUFBeEI7QUFDQSxTQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxTQUFLLElBQUwsR0FBWSxVQUFVLElBQXRCO0FBQ0gsQ0FMRDs7Ozs7Ozs7O2tCQzNxQndCLFM7O0FBRnhCOzs7Ozs7QUFFZSxTQUFTLFNBQVQsQ0FBbUIsS0FBbkIsRUFBMEIsTUFBMUIsRUFBa0MsUUFBbEMsRUFBNEM7O0FBRXZELHVCQUFTLElBQVQsQ0FBYyxJQUFkLEVBQW9CLEtBQXBCLEVBQTJCLE1BQTNCOztBQUVBLFNBQUssUUFBTCxHQUFnQixRQUFoQjs7QUFFQSxZQUFRLFFBQVI7QUFDSSxhQUFLLEVBQUw7QUFDSSxpQkFBSyxJQUFMLEdBQVksSUFBSSxXQUFKLENBQWdCLFFBQVEsTUFBeEIsQ0FBWjtBQUNKO0FBQ0EsYUFBSyxFQUFMO0FBQ0ksaUJBQUssSUFBTCxHQUFZLElBQUksV0FBSixDQUFnQixRQUFRLE1BQXhCLENBQVo7QUFDSjtBQUNBLGFBQUssQ0FBTDtBQUNBO0FBQ0ksaUJBQUssSUFBTCxHQUFZLElBQUksVUFBSixDQUFlLFFBQVEsTUFBdkIsQ0FBWjtBQVRSOztBQVlBLFNBQUssS0FBTCxHQUFhLFlBQVc7QUFDcEIsWUFDSSxTQUFTLElBQUksU0FBSixDQUFjLEtBQUssS0FBbkIsRUFBMEIsS0FBSyxNQUEvQixFQUF1QyxLQUFLLFFBQTVDLENBRGI7O0FBR0EsZUFBTyxJQUFQLENBQVksR0FBWixDQUFnQixLQUFLLElBQXJCOztBQUVBLGVBQU8sTUFBUDtBQUNILEtBUEQ7O0FBU0EsU0FBSyxRQUFMLEdBQWdCLFVBQVMsS0FBVCxFQUFnQjtBQUM1QixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUFMLENBQVUsTUFBOUIsRUFBc0MsR0FBdEMsRUFBMkM7QUFDdkMsaUJBQUssSUFBTCxDQUFVLENBQVYsSUFBZSxLQUFmO0FBQ0g7QUFDSixLQUpEOztBQU1BLFNBQUssU0FBTCxHQUFpQixVQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCO0FBQ25DLFlBQ0ksT0FBTyxLQUFLLFNBQUwsR0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FEWDtBQUFBLFlBRUksVUFBVSxLQUFLLEtBQUwsR0FBYSxLQUFLLFFBQUwsRUFGM0I7QUFBQSxZQUdJLFdBQVcsS0FBSyxhQUFMLENBQW1CLEtBQUssSUFBeEIsRUFBOEIsS0FBSyxHQUFuQyxDQUhmOztBQUtBLGFBQUssSUFBSSxJQUFJLEtBQUssR0FBbEIsRUFBdUIsSUFBSSxLQUFLLE1BQWhDLEVBQXdDLEtBQUssWUFBWSxPQUF6RCxFQUFrRTtBQUM5RCxpQkFBSyxJQUFJLElBQUksS0FBSyxJQUFsQixFQUF3QixJQUFJLEtBQUssS0FBakMsRUFBd0MsS0FBSyxVQUE3QyxFQUF5RDtBQUNyRCxxQkFBSyxJQUFMLENBQVUsUUFBVixJQUFzQixLQUF0QjtBQUNIO0FBQ0o7QUFDSixLQVhEOztBQWFBLFNBQUssa0JBQUwsR0FBMEIsWUFBVztBQUNqQyxZQUNJLFVBQVUsSUFBSSxVQUFKLENBQWUsUUFBUSxNQUF2QixDQURkOztBQUdBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFwQixFQUE0QixHQUE1QixFQUFpQztBQUM3QixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQXBCLEVBQTJCLEdBQTNCLEVBQWdDO0FBQzVCLHdCQUFRLElBQUksS0FBSixHQUFZLENBQXBCLElBQXlCLEtBQUssSUFBTCxDQUFVLElBQUksS0FBSixHQUFZLEtBQVosR0FBb0IsQ0FBcEIsR0FBd0IsQ0FBbEMsQ0FBekI7QUFDSDtBQUNKOztBQUVELGFBQUssSUFBTCxHQUFZLE9BQVo7QUFDSCxLQVhEOztBQWFBLFNBQUssUUFBTCxHQUFnQixVQUFTLEdBQVQsRUFBYztBQUMxQixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxJQUFMLENBQVUsTUFBOUIsRUFBc0MsR0FBdEMsRUFBMkM7QUFDdkMsaUJBQUssSUFBTCxDQUFVLENBQVYsSUFBZSxJQUFJLEtBQUosQ0FBVSxLQUFLLElBQUwsQ0FBVSxDQUFWLENBQVYsQ0FBZjtBQUNIO0FBQ0osS0FKRDs7QUFNQSxTQUFLLFFBQUwsR0FBZ0IsWUFBVztBQUN2QixZQUNJLFlBQVksS0FBSyxXQUFMLEVBRGhCO0FBQUEsWUFHSSxTQUFTLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUhiO0FBQUEsWUFJSSxVQUFVLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQUpkOztBQU1BLGVBQU8sS0FBUCxHQUFlLEtBQUssS0FBcEI7QUFDQSxlQUFPLE1BQVAsR0FBZ0IsS0FBSyxNQUFyQjs7QUFFQSxnQkFBUSxZQUFSLENBQXFCLFNBQXJCLEVBQWdDLENBQWhDLEVBQW1DLENBQW5DOztBQUVBLGVBQU8sTUFBUDtBQUNILEtBYkQ7O0FBZUEsU0FBSyxXQUFMLEdBQW1CLFlBQVc7QUFDMUIsWUFDSSxTQUFTLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQURiO0FBQUEsWUFFSSxVQUFVLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQUZkO0FBQUEsWUFHSSxZQUFZLFFBQVEsZUFBUixDQUF3QixLQUFLLEtBQTdCLEVBQW9DLEtBQUssTUFBekMsQ0FIaEI7QUFBQSxZQUtJLFdBQVcsQ0FMZjtBQUFBLFlBTUksV0FBVyxDQU5mOztBQVFBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLE1BQXpCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxLQUF6QixFQUFnQyxHQUFoQyxFQUFxQztBQUNqQywwQkFBVSxJQUFWLENBQWUsVUFBZixJQUE2QixLQUFLLElBQUwsQ0FBVSxRQUFWLENBQTdCO0FBQ0EsMEJBQVUsSUFBVixDQUFlLFVBQWYsSUFBNkIsS0FBSyxJQUFMLENBQVUsUUFBVixDQUE3QjtBQUNBLDBCQUFVLElBQVYsQ0FBZSxVQUFmLElBQTZCLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBN0I7QUFDQSwwQkFBVSxJQUFWLENBQWUsVUFBZixJQUE2QixJQUE3QjtBQUNBO0FBQ0g7QUFDSjs7QUFFRCxlQUFPLFNBQVA7QUFDSCxLQXBCRDtBQXFCSCxDLENBN0hEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0hBLFVBQVUsU0FBVixDQUFvQixhQUFwQixHQUFvQyxVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDL0MsV0FBTyxJQUFJLEtBQUssS0FBVCxHQUFpQixDQUF4QjtBQUNILENBRkQ7Ozs7Ozs7OztrQkNuR3dCLE87O0FBTnhCOzs7O0FBQ0E7Ozs7OztBQUVBOzs7QUF6QkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QmUsU0FBUyxPQUFULENBQWlCLEtBQWpCLEVBQXdCLE1BQXhCLEVBQWdDLElBQWhDLEVBQXNDO0FBQ2pEO0FBQ0EseUJBQVcsSUFBWCxDQUFnQixJQUFoQixFQUFzQixLQUF0QixFQUE2QixNQUE3Qjs7QUFFQSxTQUFLLElBQUwsR0FBWSxRQUFRLEVBQXBCOztBQUVBLFNBQUssS0FBTCxHQUFhLEdBQWI7QUFDQSxTQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsU0FBSyxTQUFMLEdBQWlCLGtCQUFRLFNBQXpCO0FBQ0g7O0FBRUQsUUFBUSxTQUFSLEdBQW9CLE9BQU8sTUFBUCxDQUFjLHFCQUFXLFNBQXpCLENBQXBCO0FBQ0EsUUFBUSxTQUFSLENBQWtCLFdBQWxCLEdBQWdDLE9BQWhDOztBQUVBLElBQ0ksa0JBQWtCLENBRHRCO0FBQUEsSUFHSSxvQkFBb0IsQ0FIeEI7O0FBS0EsUUFBUSxTQUFSLENBQWtCLFFBQWxCLEdBQTZCLFVBQVMsS0FBVCxFQUFnQjtBQUN6QyxRQUNJLElBQUssU0FBUyxFQUFWLEdBQWdCLElBRHhCO0FBQUEsUUFFSSxJQUFLLFNBQVMsRUFBVixHQUFnQixJQUZ4QjtBQUFBLFFBR0ksSUFBSyxTQUFTLENBQVYsR0FBZSxJQUh2QjtBQUFBLFFBSUksSUFBSSxRQUFRLElBSmhCOztBQU1BLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLEtBQUwsR0FBYSxLQUFLLE1BQWxCLEdBQTJCLGVBQS9DLEdBQWtFO0FBQzlELGFBQUssSUFBTCxDQUFVLEdBQVYsSUFBaUIsQ0FBakI7QUFDQSxhQUFLLElBQUwsQ0FBVSxHQUFWLElBQWlCLENBQWpCO0FBQ0EsYUFBSyxJQUFMLENBQVUsR0FBVixJQUFpQixDQUFqQjtBQUNBLGFBQUssSUFBTCxDQUFVLEdBQVYsSUFBaUIsQ0FBakI7QUFDSDtBQUNKLENBYkQ7O0FBZUEsUUFBUSxTQUFSLENBQWtCLFNBQWxCLEdBQThCLFVBQVMsSUFBVCxFQUFlLEtBQWYsRUFBc0I7QUFDaEQsUUFDSSxJQUFLLFNBQVMsRUFBVixHQUFnQixJQUR4QjtBQUFBLFFBRUksSUFBSyxTQUFTLEVBQVYsR0FBZ0IsSUFGeEI7QUFBQSxRQUdJLElBQUssU0FBUyxDQUFWLEdBQWUsSUFIdkI7QUFBQSxRQUlJLElBQUksUUFBUSxJQUpoQjs7QUFNQSxRQUNJLE9BQU8sS0FBSyxTQUFMLEdBQWlCLElBQWpCLENBQXNCLElBQXRCLENBRFg7QUFBQSxRQUVJLFVBQVUsQ0FBQyxLQUFLLEtBQUwsR0FBYSxLQUFLLFFBQUwsRUFBZCxJQUFpQyxlQUYvQztBQUFBLFFBSUksV0FBVyxLQUFLLGFBQUwsQ0FBbUIsS0FBSyxJQUF4QixFQUE4QixLQUFLLEdBQW5DLENBSmY7O0FBTUEsU0FBSyxJQUFJLElBQUksS0FBSyxHQUFsQixFQUF1QixJQUFJLEtBQUssTUFBaEMsRUFBd0MsS0FBSyxZQUFZLE9BQXpELEVBQWtFO0FBQzlELGFBQUssSUFBSSxJQUFJLEtBQUssSUFBbEIsRUFBd0IsSUFBSSxLQUFLLEtBQWpDLEVBQXdDLEdBQXhDLEVBQTZDO0FBQ3pDLGlCQUFLLElBQUwsQ0FBVSxVQUFWLElBQXdCLENBQXhCO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFVBQVYsSUFBd0IsQ0FBeEI7QUFDQSxpQkFBSyxJQUFMLENBQVUsVUFBVixJQUF3QixDQUF4QjtBQUNBLGlCQUFLLElBQUwsQ0FBVSxVQUFWLElBQXdCLENBQXhCO0FBQ0g7QUFDSjtBQUNKLENBckJEOztBQXVCQTs7OztBQUlBLFFBQVEsU0FBUixDQUFrQixlQUFsQixHQUFvQyxVQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCO0FBQ3ZELFdBQU8sS0FBSyxTQUFMLEdBQWlCLElBQWpCLENBQXNCLElBQXRCLENBQVA7O0FBRUEsU0FBSyxJQUFJLElBQUksS0FBSyxHQUFsQixFQUF1QixJQUFJLEtBQUssTUFBaEMsRUFBd0MsR0FBeEMsRUFBNkM7QUFDekMsWUFDSSxZQUFZLEtBQUssYUFBTCxDQUFtQixLQUFLLElBQXhCLEVBQThCLENBQTlCLENBRGhCO0FBQUEsWUFFSSxZQUFZLE9BQU8sYUFBUCxDQUFxQixLQUFLLEtBQUwsR0FBYSxDQUFsQyxFQUFxQyxDQUFyQyxDQUZoQjs7QUFJQSxhQUFLLElBQUksSUFBSSxLQUFLLElBQWxCLEVBQXdCLElBQUksS0FBSyxLQUFqQyxFQUF3QyxLQUFLLGFBQWEscUJBQVcsZUFBWCxHQUE2QixDQUF2RixFQUEwRjtBQUN0RixpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLHFCQUFXLGVBQS9CLEVBQWdELEdBQWhELEVBQXFEO0FBQ2pELHFCQUFLLElBQUwsQ0FBVSxXQUFWLElBQXlCLE9BQU8sSUFBUCxDQUFZLFdBQVosQ0FBekI7QUFDSDtBQUNKO0FBQ0o7QUFDSixDQWREOztBQWdCQTs7OztBQUlBLFFBQVEsU0FBUixDQUFrQixlQUFsQixHQUFvQyxVQUFTLElBQVQsRUFBZSxNQUFmLEVBQXVCO0FBQ3ZELFdBQU8sS0FBSyxTQUFMLEdBQWlCLElBQWpCLENBQXNCLElBQXRCLENBQVA7O0FBRUEsUUFDSSxhQUFhLEtBQUssUUFBTCxLQUFrQixxQkFBVyxlQUQ5Qzs7QUFHQSxTQUFLLElBQUksSUFBSSxLQUFLLEdBQWxCLEVBQXVCLElBQUksS0FBSyxNQUFoQyxFQUF3QyxHQUF4QyxFQUE2QztBQUN6QyxZQUNJLFlBQVksS0FBSyxhQUFMLENBQW1CLEtBQUssSUFBeEIsRUFBOEIsQ0FBOUIsQ0FEaEI7QUFBQSxZQUVJLFlBQVksT0FBTyxhQUFQLENBQXFCLEtBQUssSUFBMUIsRUFBZ0MsS0FBSyxNQUFMLEdBQWMsQ0FBZCxJQUFtQixJQUFJLEtBQUssR0FBNUIsQ0FBaEMsQ0FGaEI7O0FBSUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFVBQXBCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLGlCQUFLLElBQUwsQ0FBVSxXQUFWLElBQXlCLE9BQU8sSUFBUCxDQUFZLFdBQVosQ0FBekI7QUFDSDtBQUNKO0FBQ0osQ0FmRDs7QUFpQkE7OztBQUdBLFFBQVEsU0FBUixDQUFrQixhQUFsQixHQUFrQyxVQUFTLElBQVQsRUFBZTtBQUM3QyxXQUFPLEtBQUssU0FBTCxHQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFQOztBQUVBLFFBQ0ksS0FESjtBQUFBLFFBRUksVUFBVSxDQUFDLEtBQUssS0FBTCxHQUFhLEtBQUssUUFBTCxFQUFkLElBQWlDLHFCQUFXLGVBRjFEO0FBQUEsUUFJSSxXQUFXLEtBQUssYUFBTCxDQUFtQixLQUFLLElBQXhCLEVBQThCLEtBQUssR0FBbkMsQ0FKZjs7QUFNQSxTQUFLLElBQUksSUFBSSxLQUFLLEdBQWxCLEVBQXVCLElBQUksS0FBSyxNQUFoQyxFQUF3QyxLQUFLLFlBQVksT0FBekQsRUFBa0U7QUFDOUQsYUFBSyxJQUFJLElBQUksS0FBSyxJQUFsQixFQUF3QixJQUFJLEtBQUssS0FBakMsRUFBd0MsS0FBSyxZQUFZLHFCQUFXLGVBQXBFLEVBQXFGO0FBQ2pGLG9CQUFTLEtBQUssTUFBTCxLQUFnQixLQUFqQixHQUEwQixDQUFsQzs7QUFFQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxlQUFoQyxJQUFtRCxLQUFuRDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxLQUFyRDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGdCQUFoQyxJQUFvRCxLQUFwRDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxJQUFyRDtBQUNIO0FBQ0o7QUFDSixDQW5CRDs7QUFxQkE7Ozs7Ozs7O0FBUUEsUUFBUSxTQUFSLENBQWtCLG1CQUFsQixHQUF3QyxVQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCLEdBQXRCLEVBQTJCLGNBQTNCLEVBQTJDO0FBQy9FLFFBQ0ksWUFBWTtBQUNSLFdBQUksZUFBZSxDQUFmLEtBQXFCLEVBQXRCLEdBQTRCLElBRHZCO0FBRVIsV0FBSSxlQUFlLENBQWYsS0FBcUIsQ0FBdEIsR0FBMkIsSUFGdEI7QUFHUixXQUFHLGVBQWUsQ0FBZixJQUFvQixJQUhmO0FBSVIsV0FBSSxlQUFlLENBQWYsS0FBcUIsRUFBdEIsR0FBNEI7QUFKdkIsS0FEaEI7QUFBQSxRQU9JLFVBQVU7QUFDTixXQUFJLGVBQWUsQ0FBZixLQUFxQixFQUF0QixHQUE0QixJQUR6QjtBQUVOLFdBQUksZUFBZSxDQUFmLEtBQXFCLENBQXRCLEdBQTJCLElBRnhCO0FBR04sV0FBRyxlQUFlLENBQWYsSUFBb0IsSUFIakI7QUFJTixXQUFJLGVBQWUsQ0FBZixLQUFxQixFQUF0QixHQUE0QjtBQUp6QixLQVBkO0FBQUEsUUFjSSxVQUFVLENBQUMsS0FBSyxLQUFMLEdBQWEsS0FBSyxRQUFMLEVBQWQsSUFBaUMscUJBQVcsZUFkMUQ7QUFBQSxRQWVJLFdBQVcsS0FBSyxhQUFMLENBQW1CLEtBQUssSUFBeEIsRUFBOEIsS0FBSyxHQUFuQyxJQUEwQyxDQWZ6RDtBQUFBLFFBZ0JJLElBQUssS0FBSyxNQUFMLEdBQWMsS0FBSyxHQUFwQixHQUEyQixDQWhCbkM7O0FBa0JBLFFBQUksTUFBTSxLQUFWLEVBQWlCO0FBQ2IsWUFDSSxPQUFPLEdBRFg7QUFFQSxjQUFNLEtBQU47QUFDQSxnQkFBUSxJQUFSOztBQUVBLGVBQU8sU0FBUDtBQUNBLG9CQUFZLE9BQVo7QUFDQSxrQkFBVSxJQUFWO0FBQ0g7O0FBRUQsUUFDSSxnQkFBaUIsTUFBTSxLQUFQLEdBQWdCLENBRHBDO0FBQUEsUUFFSSxRQUFRLENBQUMsUUFBUSxDQUFSLEdBQVksVUFBVSxDQUF2QixJQUE0QixhQUZ4QztBQUFBLFFBR0ksUUFBUSxDQUFDLFFBQVEsQ0FBUixHQUFZLFVBQVUsQ0FBdkIsSUFBNEIsYUFIeEM7QUFBQSxRQUlJLFFBQVEsQ0FBQyxRQUFRLENBQVIsR0FBWSxVQUFVLENBQXZCLElBQTRCLGFBSnhDO0FBQUEsUUFLSSxRQUFRLENBQUMsUUFBUSxDQUFSLEdBQVksVUFBVSxDQUF2QixJQUE0QixhQUx4QztBQUFBLFFBT0ksT0FBTyxLQUFLLEdBQUwsQ0FBUyxLQUFLLElBQUwsR0FBWSxLQUFyQixFQUE0QixDQUE1QixDQVBYOztBQVNBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVksT0FBeEMsRUFBaUQ7QUFDN0M7QUFDQSxZQUNJLElBQUksS0FBSyxJQURiOztBQUdBLGFBQUssSUFBSSxPQUFPLEtBQUssR0FBTCxDQUFTLEtBQVQsRUFBZ0IsS0FBSyxLQUFyQixJQUE4QixDQUE5QyxFQUFpRCxJQUFJLElBQXJELEVBQTJELEtBQUssWUFBWSxxQkFBVyxlQUF2RixFQUF3RztBQUNwRyxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxlQUFoQyxJQUFtRCxVQUFVLENBQTdEO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsaUJBQWhDLElBQXFELFVBQVUsQ0FBL0Q7QUFDQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxnQkFBaEMsSUFBb0QsVUFBVSxDQUE5RDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxVQUFVLENBQS9EO0FBQ0g7O0FBRUQ7QUFDQSxZQUNJLElBQUksVUFBVSxDQUFWLEdBQWMsUUFBUSxJQUQ5QjtBQUFBLFlBRUksSUFBSSxVQUFVLENBQVYsR0FBYyxRQUFRLElBRjlCO0FBQUEsWUFHSSxJQUFJLFVBQVUsQ0FBVixHQUFjLFFBQVEsSUFIOUI7QUFBQSxZQUlJLElBQUksVUFBVSxDQUFWLEdBQWMsUUFBUSxJQUo5Qjs7QUFNQSxhQUFLLE9BQU8sS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLEtBQUssS0FBbkIsSUFBNEIsQ0FBeEMsRUFBMkMsSUFBSSxJQUEvQyxFQUFxRCxLQUFLLFlBQVkscUJBQVcsZUFBakYsRUFBa0c7QUFDOUYsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsZUFBaEMsSUFBbUQsQ0FBbkQ7QUFDQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxpQkFBaEMsSUFBcUQsQ0FBckQ7QUFDQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxnQkFBaEMsSUFBb0QsQ0FBcEQ7QUFDQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxpQkFBaEMsSUFBcUQsQ0FBckQ7O0FBRUEsaUJBQUssS0FBTDtBQUNBLGlCQUFLLEtBQUw7QUFDQSxpQkFBSyxLQUFMO0FBQ0EsaUJBQUssS0FBTDtBQUNIOztBQUVEO0FBQ0EsZUFBTyxJQUFJLEtBQUssS0FBaEIsRUFBdUIsS0FBSyxZQUFZLHFCQUFXLGVBQW5ELEVBQW9FO0FBQ2hFLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGVBQWhDLElBQW1ELFFBQVEsQ0FBM0Q7QUFDQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxpQkFBaEMsSUFBcUQsUUFBUSxDQUE3RDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGdCQUFoQyxJQUFvRCxRQUFRLENBQTVEO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsaUJBQWhDLElBQXFELFFBQVEsQ0FBN0Q7QUFDSDtBQUNKO0FBQ0osQ0E5RUQ7O0FBZ0ZBOzs7Ozs7OztBQVFBLFFBQVEsU0FBUixDQUFrQixtQkFBbEIsR0FBd0MsVUFBUyxJQUFULEVBQWUsS0FBZixFQUFzQixHQUF0QixFQUEyQixjQUEzQixFQUEyQztBQUMvRSxRQUNJLFlBQVk7QUFDUixXQUFJLGVBQWUsQ0FBZixLQUFxQixFQUF0QixHQUE0QixJQUR2QjtBQUVSLFdBQUksZUFBZSxDQUFmLEtBQXFCLENBQXRCLEdBQTJCLElBRnRCO0FBR1IsV0FBRyxlQUFlLENBQWYsSUFBb0IsSUFIZjtBQUlSLFdBQUksZUFBZSxDQUFmLEtBQXFCLEVBQXRCLEdBQTRCO0FBSnZCLEtBRGhCO0FBQUEsUUFPSSxVQUFVO0FBQ04sV0FBSSxlQUFlLENBQWYsS0FBcUIsRUFBdEIsR0FBNEIsSUFEekI7QUFFTixXQUFJLGVBQWUsQ0FBZixLQUFxQixDQUF0QixHQUEyQixJQUZ4QjtBQUdOLFdBQUcsZUFBZSxDQUFmLElBQW9CLElBSGpCO0FBSU4sV0FBSSxlQUFlLENBQWYsS0FBcUIsRUFBdEIsR0FBNEI7QUFKekIsS0FQZDtBQUFBLFFBY0ksVUFBVSxDQUFDLEtBQUssS0FBTCxHQUFhLEtBQUssUUFBTCxFQUFkLElBQWlDLHFCQUFXLGVBZDFEO0FBQUEsUUFlSSxXQUFXLEtBQUssYUFBTCxDQUFtQixLQUFLLElBQXhCLEVBQThCLEtBQUssR0FBbkMsSUFBMEMsQ0FmekQ7QUFBQSxRQWdCSSxJQUFLLEtBQUssS0FBTCxHQUFhLEtBQUssSUFBbkIsR0FBMkIsQ0FoQm5DOztBQWtCQSxRQUFJLE1BQU0sS0FBVixFQUFpQjtBQUNiLFlBQ0ksT0FBTyxHQURYO0FBRUEsY0FBTSxLQUFOO0FBQ0EsZ0JBQVEsSUFBUjs7QUFFQSxlQUFPLFNBQVA7QUFDQSxvQkFBWSxPQUFaO0FBQ0Esa0JBQVUsSUFBVjtBQUNIOztBQUVELFFBQ0ksSUFBSSxLQUFLLEdBRGI7O0FBR0E7QUFDQSxTQUFLLElBQUksT0FBTyxLQUFLLEdBQUwsQ0FBUyxLQUFLLE1BQWQsRUFBc0IsS0FBdEIsSUFBK0IsQ0FBL0MsRUFBa0QsSUFBSSxJQUF0RCxFQUE0RCxLQUFLLFlBQVksT0FBN0UsRUFBc0Y7QUFDbEYsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxxQkFBVyxlQUFuRCxFQUFvRTtBQUNoRSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxlQUFoQyxJQUFtRCxVQUFVLENBQTdEO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsaUJBQWhDLElBQXFELFVBQVUsQ0FBL0Q7QUFDQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxnQkFBaEMsSUFBb0QsVUFBVSxDQUE5RDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxVQUFVLENBQS9EO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLFFBQ0ksZ0JBQWlCLE1BQU0sS0FBUCxHQUFnQixDQURwQztBQUFBLFFBRUksUUFBUSxDQUFDLFFBQVEsQ0FBUixHQUFZLFVBQVUsQ0FBdkIsSUFBNEIsYUFGeEM7QUFBQSxRQUdJLFFBQVEsQ0FBQyxRQUFRLENBQVIsR0FBWSxVQUFVLENBQXZCLElBQTRCLGFBSHhDO0FBQUEsUUFJSSxRQUFRLENBQUMsUUFBUSxDQUFSLEdBQVksVUFBVSxDQUF2QixJQUE0QixhQUp4QztBQUFBLFFBS0ksUUFBUSxDQUFDLFFBQVEsQ0FBUixHQUFZLFVBQVUsQ0FBdkIsSUFBNEIsYUFMeEM7QUFBQSxRQU9JLE9BQU8sS0FBSyxHQUFMLENBQVMsSUFBSSxLQUFiLEVBQW9CLENBQXBCLENBUFg7QUFBQSxRQVFJLElBQUksVUFBVSxDQUFWLEdBQWMsUUFBUSxJQVI5QjtBQUFBLFFBU0ksSUFBSSxVQUFVLENBQVYsR0FBYyxRQUFRLElBVDlCO0FBQUEsUUFVSSxJQUFJLFVBQVUsQ0FBVixHQUFjLFFBQVEsSUFWOUI7QUFBQSxRQVdJLElBQUksVUFBVSxDQUFWLEdBQWMsUUFBUSxJQVg5Qjs7QUFhQSxTQUFLLElBQUksT0FBTyxLQUFLLEdBQUwsQ0FBUyxLQUFLLE1BQWQsRUFBc0IsR0FBdEIsSUFBNkIsQ0FBN0MsRUFBZ0QsSUFBSSxJQUFwRCxFQUEwRCxLQUFLLFlBQVksT0FBM0UsRUFBb0Y7QUFDaEYsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxxQkFBVyxlQUFuRCxFQUFvRTtBQUNoRSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxlQUFoQyxJQUFtRCxDQUFuRDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxDQUFyRDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGdCQUFoQyxJQUFvRCxDQUFwRDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxDQUFyRDtBQUNIOztBQUVELGFBQUssS0FBTDtBQUNBLGFBQUssS0FBTDtBQUNBLGFBQUssS0FBTDtBQUNBLGFBQUssS0FBTDtBQUNIOztBQUVEO0FBQ0EsV0FBTyxJQUFJLEtBQUssTUFBaEIsRUFBd0IsS0FBSyxZQUFZLE9BQXpDLEVBQWtEO0FBQzlDLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVkscUJBQVcsZUFBbkQsRUFBb0U7QUFDaEUsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsZUFBaEMsSUFBbUQsUUFBUSxDQUEzRDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxRQUFRLENBQTdEO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsZ0JBQWhDLElBQW9ELFFBQVEsQ0FBNUQ7QUFDQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxpQkFBaEMsSUFBcUQsUUFBUSxDQUE3RDtBQUNIO0FBQ0o7QUFDSixDQWhGRDs7QUFrRkE7Ozs7Ozs7Ozs7QUFVQSxRQUFRLFNBQVIsQ0FBa0IsZUFBbEIsR0FBb0MsVUFBUyxJQUFULEVBQWUsS0FBZixFQUFzQixLQUF0QixFQUE2QixHQUE3QixFQUFrQyxHQUFsQyxFQUF1QyxjQUF2QyxFQUF1RDtBQUN2RixRQUNJLFVBQVUsQ0FBQyxLQUFLLEtBQUwsR0FBYSxLQUFLLFFBQUwsRUFBZCxJQUFpQyxxQkFBVyxlQUQxRDtBQUFBLFFBRUksV0FBVyxLQUFLLGFBQUwsQ0FBbUIsS0FBSyxJQUF4QixFQUE4QixLQUFLLEdBQW5DLElBQTBDLENBRnpEO0FBQUEsUUFHSSxJQUFLLEtBQUssS0FBTCxHQUFhLEtBQUssSUFBbkIsR0FBMkIsQ0FIbkM7QUFBQSxRQUtJLFlBQVk7QUFDUixXQUFJLGVBQWUsQ0FBZixLQUFxQixFQUF0QixHQUE0QixJQUR2QjtBQUVSLFdBQUksZUFBZSxDQUFmLEtBQXFCLENBQXRCLEdBQTJCLElBRnRCO0FBR1IsV0FBRyxlQUFlLENBQWYsSUFBb0IsSUFIZjtBQUlSLFdBQUksZUFBZSxDQUFmLEtBQXFCLEVBQXRCLEdBQTRCO0FBSnZCLEtBTGhCO0FBQUEsUUFXSSxVQUFVO0FBQ04sV0FBSSxlQUFlLENBQWYsS0FBcUIsRUFBdEIsR0FBNEIsSUFEekI7QUFFTixXQUFJLGVBQWUsQ0FBZixLQUFxQixDQUF0QixHQUEyQixJQUZ4QjtBQUdOLFdBQUcsZUFBZSxDQUFmLElBQW9CLElBSGpCO0FBSU4sV0FBSSxlQUFlLENBQWYsS0FBcUIsRUFBdEIsR0FBNEI7QUFKekIsS0FYZDs7O0FBa0JBO0FBQ0ksZ0JBQWEsTUFBTSxLQUFQLEdBQWlCLENBQUMsTUFBTSxLQUFQLEtBQWlCLE1BQU0sS0FBdkIsQ0FBRCxJQUFtQyxNQUFNLEtBQXpDLENBbkJoQzs7QUFvQkE7QUFDSSxnQkFBYSxNQUFNLEtBQVAsR0FBaUIsQ0FBQyxNQUFNLEtBQVAsS0FBaUIsTUFBTSxLQUF2QixDQUFELElBQW1DLE1BQU0sS0FBekMsQ0FyQmhDO0FBQUEsUUFzQkksV0FBVyxJQUFJLFNBdEJuQjs7QUF3QkEsU0FBSyxJQUFJLElBQUksS0FBSyxHQUFsQixFQUF1QixJQUFJLEtBQUssTUFBaEMsRUFBd0MsS0FBSyxZQUFZLE9BQXpELEVBQWtFO0FBQzlEO0FBQ0E7QUFDSSxlQUFPLENBQUMsS0FBSyxJQUFMLEdBQVksS0FBYixJQUFzQixTQUF0QixHQUFrQyxDQUFDLElBQUksS0FBTCxJQUFjLFNBRjNEOztBQUlBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxDQUFwQixFQUF1QixLQUFLLFlBQVkscUJBQVcsZUFBbkQsRUFBb0U7QUFDaEUsZ0JBQ0ksY0FBYyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxJQUFULEVBQWUsR0FBZixDQUFULEVBQThCLEdBQTlCLENBRGxCO0FBQUEsZ0JBRUksaUJBQWlCLElBQUksV0FGekI7O0FBSUEsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsZUFBaEMsSUFBbUQsVUFBVSxDQUFWLEdBQWMsY0FBZCxHQUErQixRQUFRLENBQVIsR0FBWSxXQUE5RjtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxVQUFVLENBQVYsR0FBYyxjQUFkLEdBQStCLFFBQVEsQ0FBUixHQUFZLFdBQWhHO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsZ0JBQWhDLElBQW9ELFVBQVUsQ0FBVixHQUFjLGNBQWQsR0FBK0IsUUFBUSxDQUFSLEdBQVksV0FBL0Y7QUFDQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxpQkFBaEMsSUFBcUQsVUFBVSxDQUFWLEdBQWMsY0FBZCxHQUErQixRQUFRLENBQVIsR0FBWSxXQUFoRzs7QUFFQSxvQkFBUSxRQUFSO0FBQ0g7QUFDSjtBQUNKLENBM0NEOztBQTZDQTs7Ozs7Ozs7OztBQVVBLFFBQVEsU0FBUixDQUFrQixhQUFsQixHQUFrQyxVQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCLEtBQXRCLEVBQTZCLEdBQTdCLEVBQWtDLEdBQWxDLEVBQXVDLGNBQXZDLEVBQXVEO0FBQ3JGLFFBQ0ksVUFBVSxDQUFDLEtBQUssS0FBTCxHQUFhLEtBQUssUUFBTCxFQUFkLElBQWlDLHFCQUFXLGVBRDFEO0FBQUEsUUFFSSxXQUFXLEtBQUssYUFBTCxDQUFtQixLQUFLLElBQXhCLEVBQThCLEtBQUssR0FBbkMsSUFBMEMsQ0FGekQ7QUFBQSxRQUdJLElBQUssS0FBSyxLQUFMLEdBQWEsS0FBSyxJQUFuQixHQUEyQixDQUhuQztBQUFBLFFBS0ksWUFBWTtBQUNSLFdBQUksZUFBZSxDQUFmLEtBQXFCLEVBQXRCLEdBQTRCLElBRHZCO0FBRVIsV0FBSSxlQUFlLENBQWYsS0FBcUIsQ0FBdEIsR0FBMkIsSUFGdEI7QUFHUixXQUFHLGVBQWUsQ0FBZixJQUFvQixJQUhmO0FBSVIsV0FBSSxlQUFlLENBQWYsS0FBcUIsRUFBdEIsR0FBNEI7QUFKdkIsS0FMaEI7QUFBQSxRQVdJLFVBQVU7QUFDTixXQUFJLGVBQWUsQ0FBZixLQUFxQixFQUF0QixHQUE0QixJQUR6QjtBQUVOLFdBQUksZUFBZSxDQUFmLEtBQXFCLENBQXRCLEdBQTJCLElBRnhCO0FBR04sV0FBRyxlQUFlLENBQWYsSUFBb0IsSUFIakI7QUFJTixXQUFJLGVBQWUsQ0FBZixLQUFxQixFQUF0QixHQUE0QjtBQUp6QixLQVhkOzs7QUFrQkE7QUFDSSxnQkFBYSxNQUFNLEtBQVAsR0FBaUIsQ0FBQyxNQUFNLEtBQVAsS0FBaUIsTUFBTSxLQUF2QixDQUFELElBQW1DLE1BQU0sS0FBekMsQ0FuQmhDOztBQW9CQTtBQUNJLGdCQUFhLE1BQU0sS0FBUCxHQUFpQixDQUFDLE1BQU0sS0FBUCxLQUFpQixNQUFNLEtBQXZCLENBQUQsSUFBbUMsTUFBTSxLQUF6QyxDQXJCaEM7QUFBQSxRQXNCSSxXQUFXLElBQUksU0F0Qm5COztBQXdCQSxTQUFLLElBQUksSUFBSSxLQUFLLEdBQWxCLEVBQXVCLElBQUksS0FBSyxNQUFoQyxFQUF3QyxLQUFLLFlBQVksT0FBekQsRUFBa0U7QUFDOUQ7QUFDQTtBQUNJLGVBQU8sQ0FBQyxLQUFLLElBQUwsR0FBWSxLQUFiLElBQXNCLFNBQXRCLEdBQWtDLENBQUMsSUFBSSxLQUFMLElBQWMsU0FGM0Q7O0FBSUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEtBQUssWUFBWSxxQkFBVyxlQUFuRCxFQUFvRTtBQUNoRSxnQkFDSSxjQUFjLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLElBQVQsRUFBZSxHQUFmLENBQVQsRUFBOEIsR0FBOUIsQ0FEbEI7QUFBQSxnQkFFSSxpQkFBaUIsSUFBSSxXQUZ6Qjs7O0FBSUk7QUFDQSxnQkFBSSxVQUFVLENBQVYsR0FBYyxjQUFkLEdBQStCLFFBQVEsQ0FBUixHQUFZLFdBTG5EO0FBQUEsZ0JBTUksSUFBSSxVQUFVLENBQVYsR0FBYyxjQUFkLEdBQStCLFFBQVEsQ0FBUixHQUFZLFdBTm5EO0FBQUEsZ0JBT0ksSUFBSSxVQUFVLENBQVYsR0FBYyxjQUFkLEdBQStCLFFBQVEsQ0FBUixHQUFZLFdBUG5EO0FBQUEsZ0JBUUksSUFBSSxVQUFVLENBQVYsR0FBYyxjQUFkLEdBQStCLFFBQVEsQ0FBUixHQUFZLFdBUm5EO0FBQUEsZ0JBVUksU0FBUyxLQUFLLElBQUwsQ0FBVSxXQUFXLGlCQUFyQixDQVZiO0FBQUEsZ0JBV0ksV0FBWSxJQUFJLE1BQUosR0FBYSxJQUFJLE1BQUosR0FBYSxHQUEzQixHQUFrQyxDQVhqRDs7QUFhQSxnQkFBSSxXQUFXLENBQWYsRUFBa0I7QUFDZCxvQkFDSSxZQUFhLElBQUksR0FBSixHQUFVLFFBQVgsR0FBdUIsQ0FEdkM7QUFBQSxvQkFFSSxXQUFXLE1BQU0sU0FGckI7O0FBSUEscUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsZUFBaEMsSUFBc0QsQ0FBQyxJQUFJLFNBQUosR0FBZ0IsS0FBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxlQUFoQyxJQUFtRCxRQUFwRSxJQUFnRixHQUFqRixHQUF3RixDQUE3STtBQUNBLHFCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFzRCxDQUFDLElBQUksU0FBSixHQUFnQixLQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxRQUF0RSxJQUFrRixHQUFuRixHQUEwRixDQUEvSTtBQUNBLHFCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGdCQUFoQyxJQUFzRCxDQUFDLElBQUksU0FBSixHQUFnQixLQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGdCQUFoQyxJQUFvRCxRQUFyRSxJQUFpRixHQUFsRixHQUF5RixDQUE5STtBQUNBLHFCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxJQUFxRCxRQUFyRDtBQUNIOztBQUVELG9CQUFRLFFBQVI7QUFDSDtBQUNKO0FBQ0osQ0ExREQ7O0FBNERBOzs7Ozs7OztBQVFBLFFBQVEsU0FBUixDQUFrQixRQUFsQixHQUE2QixVQUFTLElBQVQsRUFBZSxLQUFmLEVBQXNCLEtBQXRCLEVBQTZCLEdBQTdCLEVBQWtDLEdBQWxDLEVBQXVDLGNBQXZDLEVBQXVELE9BQXZELEVBQWdFO0FBQ3pGLFdBQU8sS0FBSyxTQUFMLEdBQWlCLElBQWpCLENBQXNCLElBQXRCLENBQVA7O0FBRUE7QUFDQSxRQUFJLFNBQVMsR0FBVCxJQUFnQixTQUFTLEdBQTdCLEVBQWtDO0FBQzlCO0FBQ0g7O0FBRUQ7QUFDQSxRQUFJLFdBQVcsZUFBZSxDQUFmLE1BQXNCLEVBQXRCLElBQTRCLEdBQTVCLElBQW1DLGVBQWUsQ0FBZixNQUFzQixFQUF0QixJQUE0QixHQUE5RSxFQUFtRjtBQUMvRSxZQUFJLFNBQVMsR0FBYixFQUFrQjtBQUNkLGlCQUFLLG1CQUFMLENBQXlCLElBQXpCLEVBQStCLEtBQS9CLEVBQXNDLEdBQXRDLEVBQTJDLGNBQTNDO0FBQ0gsU0FGRCxNQUVPLElBQUksU0FBUyxHQUFiLEVBQWtCO0FBQ3JCLGlCQUFLLG1CQUFMLENBQXlCLElBQXpCLEVBQStCLEtBQS9CLEVBQXNDLEdBQXRDLEVBQTJDLGNBQTNDO0FBQ0gsU0FGTSxNQUVBO0FBQ0gsaUJBQUssZUFBTCxDQUFxQixJQUFyQixFQUEyQixLQUEzQixFQUFrQyxLQUFsQyxFQUF5QyxHQUF6QyxFQUE4QyxHQUE5QyxFQUFtRCxjQUFuRDtBQUNIO0FBQ0osS0FSRCxNQVFPO0FBQ0gsYUFBSyxhQUFMLENBQW1CLElBQW5CLEVBQXlCLEtBQXpCLEVBQWdDLEtBQWhDLEVBQXVDLEdBQXZDLEVBQTRDLEdBQTVDLEVBQWlELGNBQWpEO0FBQ0g7QUFDSixDQXBCRDs7QUFzQkE7OztBQUdBLFFBQVEsU0FBUixDQUFrQixrQkFBbEIsR0FBdUMsVUFBUyxJQUFULEVBQWU7QUFDbEQsV0FBTyxLQUFLLFNBQUwsR0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBUDs7QUFFQSxRQUNJLEtBREo7QUFBQSxRQUVJLFVBQVUsQ0FBQyxLQUFLLEtBQUwsR0FBYSxLQUFLLFFBQUwsRUFBZCxJQUFpQyxxQkFBVyxlQUYxRDtBQUFBLFFBSUksV0FBVyxLQUFLLGFBQUwsQ0FBbUIsS0FBSyxJQUF4QixFQUE4QixLQUFLLEdBQW5DLENBSmY7O0FBTUEsU0FBSyxJQUFJLElBQUksS0FBSyxHQUFsQixFQUF1QixJQUFJLEtBQUssTUFBaEMsRUFBd0MsS0FBSyxZQUFZLE9BQXpELEVBQWtFO0FBQzlELGFBQUssSUFBSSxJQUFJLEtBQUssSUFBbEIsRUFBd0IsSUFBSSxLQUFLLEtBQWpDLEVBQXdDLEtBQUssWUFBWSxxQkFBVyxlQUFwRSxFQUFxRjtBQUNqRixvQkFBUyxLQUFLLE1BQUwsS0FBZ0IsU0FBakIsR0FBOEIsQ0FBdEM7O0FBRUEsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsZUFBaEMsSUFBb0QsU0FBUyxFQUFWLEdBQWdCLElBQW5FO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsaUJBQWhDLElBQXNELFNBQVMsQ0FBVixHQUFlLElBQXBFO0FBQ0EsaUJBQUssSUFBTCxDQUFVLFdBQVcscUJBQVcsZ0JBQWhDLElBQW9ELFFBQVEsSUFBNUQ7QUFDQSxpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxpQkFBaEMsSUFBcUQsSUFBckQ7QUFDSDtBQUNKO0FBQ0osQ0FuQkQ7O0FBcUJBOzs7QUFHQSxRQUFRLFNBQVIsQ0FBa0IsTUFBbEIsR0FBMkIsVUFBUyxJQUFULEVBQWU7QUFDdEMsV0FBTyxLQUFLLFNBQUwsR0FBaUIsSUFBakIsQ0FBc0IsSUFBdEIsQ0FBUDs7QUFFQSxRQUNJLFVBQVUsQ0FBQyxLQUFLLEtBQUwsR0FBYSxLQUFLLFFBQUwsRUFBZCxJQUFpQyxxQkFBVyxlQUQxRDtBQUFBLFFBR0ksV0FBVyxLQUFLLGFBQUwsQ0FBbUIsS0FBSyxJQUF4QixFQUE4QixLQUFLLEdBQW5DLENBSGY7O0FBS0EsU0FBSyxJQUFJLElBQUksS0FBSyxHQUFsQixFQUF1QixJQUFJLEtBQUssTUFBaEMsRUFBd0MsS0FBSyxZQUFZLE9BQXpELEVBQWtFO0FBQzlELGFBQUssSUFBSSxJQUFJLEtBQUssSUFBbEIsRUFBd0IsSUFBSSxLQUFLLEtBQWpDLEVBQXdDLEtBQUssWUFBWSxxQkFBVyxlQUFwRSxFQUFxRjtBQUNqRixpQkFBSyxJQUFMLENBQVUsV0FBVyxxQkFBVyxlQUFoQyxLQUFvRCxJQUFwRDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGlCQUFoQyxLQUFzRCxJQUF0RDtBQUNBLGlCQUFLLElBQUwsQ0FBVSxXQUFXLHFCQUFXLGdCQUFoQyxLQUFxRCxJQUFyRDtBQUNIO0FBQ0o7QUFDSixDQWZEOztBQWlCQSxRQUFRLFNBQVIsQ0FBa0IsUUFBbEIsR0FBNkIsWUFBVztBQUNwQyxXQUFPLEtBQUssS0FBWjtBQUNILENBRkQ7O0FBSUEsUUFBUSxTQUFSLENBQWtCLFlBQWxCLEdBQWlDLFlBQVc7QUFDeEMsV0FBTyxLQUFLLFNBQVo7QUFDSCxDQUZEOztBQUlBLFFBQVEsU0FBUixDQUFrQixLQUFsQixHQUEwQixZQUFXO0FBQ2pDLFFBQ0ksU0FBUyxJQUFJLE9BQUosQ0FBWSxLQUFLLEtBQWpCLEVBQXdCLEtBQUssTUFBN0IsRUFBcUMsRUFBckMsQ0FEYjs7QUFHQSxXQUFPLFFBQVAsQ0FBZ0IsSUFBaEI7O0FBRUEsV0FBTyxNQUFQO0FBQ0gsQ0FQRDs7QUFTQSxRQUFRLFNBQVIsQ0FBa0IsUUFBbEIsR0FBNkIsVUFBUyxLQUFULEVBQWdCO0FBQ3pDLFNBQUssSUFBTCxHQUFZLE1BQU0sSUFBbEI7QUFDQSxTQUFLLFNBQUwsR0FBaUIsTUFBTSxTQUF2QjtBQUNBLFNBQUssS0FBTCxHQUFhLE1BQU0sS0FBbkI7QUFDQSxTQUFLLE9BQUwsR0FBZSxNQUFNLE9BQXJCOztBQUVBLFNBQUssWUFBTCxDQUFrQixLQUFsQjtBQUNILENBUEQ7O0FBU0E7QUFDQSxRQUFRLFNBQVIsQ0FBa0IsUUFBbEIsR0FBNkIsWUFBVztBQUNwQyxRQUFJLEtBQUssS0FBTCxJQUFjLEdBQWxCLEVBQXVCO0FBQ25CLGVBQU8sSUFBUDtBQUNIOztBQUVELFFBQ0ksV0FBVyxpQkFEZjs7QUFHQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksTUFBcEIsRUFBNEIsR0FBNUIsRUFBaUM7QUFDN0IsWUFDSSxhQUFhLElBRGpCOztBQUdBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxLQUFLLEtBQXpCLEVBQWdDLEtBQUssWUFBWSxlQUFqRCxFQUFrRTtBQUM5RCwwQkFBYyxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQWQ7QUFDSDs7QUFFRDtBQUNBLFlBQUksY0FBYyxJQUFsQixFQUF3QjtBQUNwQixtQkFBTyxJQUFQO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLEtBQVA7QUFDSCxDQXZCRDs7QUF5QkE7QUFDQSxRQUFRLFNBQVIsQ0FBa0IsY0FBbEIsR0FBbUMsVUFBUyxJQUFULEVBQWU7QUFDOUMsUUFBSSxLQUFLLEtBQUwsSUFBYyxHQUFsQixFQUF1QjtBQUNuQixlQUFPLElBQVA7QUFDSDs7QUFFRCxXQUFPLEtBQUssU0FBTCxHQUFpQixJQUFqQixDQUFzQixJQUF0QixDQUFQOztBQUVBLFFBQ0ksVUFBVSxDQUFDLEtBQUssS0FBTCxHQUFhLEtBQUssUUFBTCxFQUFkLElBQWlDLGVBRC9DO0FBQUEsUUFFSSxXQUFXLEtBQUssYUFBTCxDQUFtQixLQUFLLElBQXhCLEVBQThCLEtBQUssR0FBbkMsSUFBMEMsaUJBRnpEOztBQUlBLFNBQUssSUFBSSxJQUFJLEtBQUssR0FBbEIsRUFBdUIsSUFBSSxLQUFLLE1BQWhDLEVBQXdDLEtBQUssWUFBWSxPQUF6RCxFQUFrRTtBQUM5RCxZQUNJLGFBQWEsSUFEakI7O0FBR0EsYUFBSyxJQUFJLElBQUksS0FBSyxJQUFsQixFQUF3QixJQUFJLEtBQUssS0FBakMsRUFBd0MsS0FBSyxZQUFZLGVBQXpELEVBQTBFO0FBQ3RFLDBCQUFjLEtBQUssSUFBTCxDQUFVLFFBQVYsQ0FBZDtBQUNIOztBQUVEO0FBQ0EsWUFBSSxjQUFjLElBQWxCLEVBQXdCO0FBQ3BCLG1CQUFPLElBQVA7QUFDSDtBQUNKOztBQUVELFdBQU8sS0FBUDtBQUNILENBMUJEOztBQTRCQTs7Ozs7Ozs7QUFRQSxRQUFRLFNBQVIsQ0FBa0IsdUJBQWxCLEdBQTRDLFVBQVMsYUFBVCxFQUF3QjtBQUNoRSxRQUNJLFFBREo7QUFBQSxRQUVJLFNBQVMsY0FBYyxLQUFkLEVBRmI7QUFBQSxRQUdJLENBSEo7QUFBQSxRQUdPLENBSFA7QUFBQSxRQUlJLFNBSko7QUFBQSxRQUtJLE9BTEo7O0FBT0E7QUFDQSxjQUFVLENBQUMsS0FBSyxLQUFMLEdBQWEsT0FBTyxRQUFQLEVBQWQsSUFBbUMsZUFBN0M7QUFDQSxlQUFXLEtBQUssYUFBTCxDQUFtQixPQUFPLElBQTFCLEVBQWdDLE9BQU8sR0FBdkMsSUFBOEMsaUJBQXpEOztBQUVBLFNBQUssSUFBSSxPQUFPLEdBQWhCLEVBQXFCLElBQUksT0FBTyxNQUFoQyxFQUF3QyxLQUFLLFlBQVksT0FBekQsRUFBa0U7QUFDOUQsb0JBQVksSUFBWjs7QUFFQSxhQUFLLElBQUksSUFBSSxPQUFPLElBQXBCLEVBQTBCLElBQUksT0FBTyxLQUFyQyxFQUE0QyxLQUFLLFlBQVksZUFBN0QsRUFBOEU7QUFDMUUseUJBQWEsS0FBSyxJQUFMLENBQVUsUUFBVixDQUFiO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJLGFBQWEsSUFBakIsRUFBdUI7QUFDbkI7QUFDSDtBQUNKOztBQUVELFdBQU8sR0FBUCxHQUFhLENBQWI7O0FBRUEsUUFBSSxPQUFPLEdBQVAsSUFBYyxPQUFPLE1BQXpCLEVBQWlDO0FBQzdCO0FBQ0EsZUFBTyxNQUFQO0FBQ0g7O0FBRUQ7QUFDQSxlQUFXLEtBQUssYUFBTCxDQUFtQixPQUFPLEtBQVAsR0FBZSxDQUFsQyxFQUFxQyxPQUFPLE1BQVAsR0FBZ0IsQ0FBckQsSUFBMEQsaUJBQXJFO0FBQ0EsU0FBSyxJQUFJLE9BQU8sTUFBUCxHQUFnQixDQUF6QixFQUE0QixLQUFLLE9BQU8sR0FBeEMsRUFBNkMsS0FBSyxZQUFZLE9BQTlELEVBQXVFO0FBQ25FLG9CQUFZLElBQVo7O0FBRUEsYUFBSyxJQUFJLElBQUksT0FBTyxLQUFQLEdBQWUsQ0FBNUIsRUFBK0IsS0FBSyxPQUFPLElBQTNDLEVBQWlELEtBQUssWUFBWSxlQUFsRSxFQUFtRjtBQUMvRSx5QkFBYSxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQWI7QUFDSDs7QUFFRDtBQUNBLFlBQUksYUFBYSxJQUFqQixFQUF1QjtBQUNuQjtBQUNIO0FBQ0o7O0FBRUQsV0FBTyxNQUFQLEdBQWdCLElBQUksQ0FBcEIsQ0EvQ2dFLENBK0N6Qzs7QUFFdkI7QUFDQSxjQUFVLGtCQUFrQixLQUFLLEtBQWpDO0FBQ0EsU0FBSyxJQUFJLE9BQU8sSUFBaEIsRUFBc0IsSUFBSSxPQUFPLEtBQWpDLEVBQXdDLEdBQXhDLEVBQTZDO0FBQ3pDLG1CQUFXLEtBQUssYUFBTCxDQUFtQixDQUFuQixFQUFzQixPQUFPLEdBQTdCLElBQW9DLGlCQUEvQztBQUNBLG9CQUFZLElBQVo7O0FBRUEsYUFBSyxJQUFJLE9BQU8sR0FBaEIsRUFBcUIsSUFBSSxPQUFPLE1BQWhDLEVBQXdDLEtBQUssWUFBWSxPQUF6RCxFQUFrRTtBQUM5RCx5QkFBYSxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQWI7QUFDSDs7QUFFRCxZQUFJLGFBQWEsSUFBakIsRUFBdUI7QUFDbkI7QUFDSDtBQUNKOztBQUVELFdBQU8sSUFBUCxHQUFjLENBQWQ7O0FBRUE7QUFDQSxTQUFLLElBQUksT0FBTyxLQUFQLEdBQWUsQ0FBeEIsRUFBMkIsS0FBSyxPQUFPLElBQXZDLEVBQTZDLEdBQTdDLEVBQWtEO0FBQzlDLG1CQUFXLEtBQUssYUFBTCxDQUFtQixDQUFuQixFQUFzQixPQUFPLEdBQTdCLElBQW9DLGlCQUEvQztBQUNBLG9CQUFZLElBQVo7O0FBRUEsYUFBSyxJQUFJLE9BQU8sR0FBaEIsRUFBcUIsSUFBSSxPQUFPLE1BQWhDLEVBQXdDLEtBQUssWUFBWSxPQUF6RCxFQUFrRTtBQUM5RCx5QkFBYSxLQUFLLElBQUwsQ0FBVSxRQUFWLENBQWI7QUFDSDs7QUFFRCxZQUFJLGFBQWEsSUFBakIsRUFBdUI7QUFDbkI7QUFDSDtBQUNKOztBQUVELFdBQU8sS0FBUCxHQUFlLElBQUksQ0FBbkI7O0FBRUEsV0FBTyxNQUFQO0FBQ0gsQ0FuRkQ7O0FBcUZBLFFBQVEsU0FBUixDQUFrQixRQUFsQixHQUE2QixVQUFTLEtBQVQsRUFBZ0I7QUFDekMsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNILENBRkQ7O0FBSUEsUUFBUSxTQUFSLENBQWtCLFlBQWxCLEdBQWlDLFVBQVMsU0FBVCxFQUFvQjtBQUNqRCxTQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDSCxDQUZEOztBQUlBLFFBQVEsU0FBUixDQUFrQixRQUFsQixHQUE2QixZQUFXO0FBQ3BDLFdBQU8sS0FBSyxLQUFaO0FBQ0gsQ0FGRDs7QUFJQSxRQUFRLFNBQVIsQ0FBa0IsWUFBbEIsR0FBaUMsWUFBVztBQUN4QyxXQUFPLEtBQUssU0FBWjtBQUNILENBRkQ7O0FBSUE7Ozs7O0FBS0EsU0FBUyxnQkFBVCxDQUEwQixNQUExQixFQUFrQyxRQUFsQyxFQUE0QztBQUN4QyxlQUFXLFdBQVcsQ0FBdEI7O0FBRUEsUUFBSSxZQUFZLENBQWhCLEVBQW1CO0FBQ2YsZUFBTyxNQUFQO0FBQ0g7O0FBRUQsUUFDSSxnQkFBZ0IsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBRHBCO0FBQUEsUUFFSSx1QkFBdUIsY0FBYyxVQUFkLENBQXlCLElBQXpCLENBRjNCOztBQUlBLFFBQUksV0FBVyxDQUFYLElBQWdCLENBQXBCLEVBQXVCO0FBQ25CLHNCQUFjLEtBQWQsR0FBc0IsT0FBTyxLQUE3QjtBQUNBLHNCQUFjLE1BQWQsR0FBdUIsT0FBTyxNQUE5QjtBQUNILEtBSEQsTUFHTztBQUNILHNCQUFjLEtBQWQsR0FBc0IsT0FBTyxNQUE3QjtBQUNBLHNCQUFjLE1BQWQsR0FBdUIsT0FBTyxLQUE5QjtBQUNIOztBQUVELFlBQVEsUUFBUjtBQUNJLGFBQUssQ0FBTDtBQUNJO0FBQ0EsaUNBQXFCLE1BQXJCLENBQTRCLEtBQUssRUFBTCxHQUFVLENBQXRDO0FBQ0EsaUNBQXFCLFNBQXJCLENBQStCLE1BQS9CLEVBQXVDLENBQXZDLEVBQTBDLENBQUMsT0FBTyxNQUFsRDtBQUNBO0FBQ0osYUFBSyxDQUFMO0FBQ0ksaUNBQXFCLE1BQXJCLENBQTRCLEtBQUssRUFBakM7QUFDQSxpQ0FBcUIsU0FBckIsQ0FBK0IsTUFBL0IsRUFBdUMsQ0FBQyxPQUFPLEtBQS9DLEVBQXNELENBQUMsT0FBTyxNQUE5RDtBQUNBO0FBQ0osYUFBSyxDQUFMO0FBQ0k7QUFDQSxpQ0FBcUIsTUFBckIsQ0FBNEIsQ0FBQyxLQUFLLEVBQU4sR0FBVyxDQUF2QztBQUNBLGlDQUFxQixTQUFyQixDQUErQixNQUEvQixFQUF1QyxDQUFDLE9BQU8sS0FBL0MsRUFBc0QsQ0FBdEQ7QUFDQTtBQUNKLGFBQUssQ0FBTDtBQUNBO0FBQ0ksbUJBQU8sTUFBUDtBQWpCUjs7QUFvQkEsV0FBTyxhQUFQO0FBQ0g7O0FBRUQsU0FBUyxzQkFBVCxDQUFnQyxHQUFoQyxFQUFxQztBQUNqQyxRQUFJLE9BQU8sR0FBUCxLQUFlLFFBQWYsSUFBMkIsQ0FBQyxJQUFJLEtBQUosQ0FBVSwyQkFBVixDQUFoQyxFQUF3RTtBQUNwRSxlQUFPLEtBQVA7QUFDSDs7QUFFRCxXQUFPLE9BQU8sSUFBUCxDQUFZLElBQUksU0FBSixDQUFjLDBCQUEwQixNQUF4QyxDQUFaLENBQVA7QUFDSDs7QUFFRDs7Ozs7O0FBTUEsUUFBUSxTQUFSLENBQWtCLFFBQWxCLEdBQTZCLFVBQVMsUUFBVCxFQUFtQjtBQUM1QyxRQUNJLFNBQVMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBRGI7QUFBQSxRQUVJLGdCQUFnQixPQUFPLFVBQVAsQ0FBa0IsSUFBbEIsQ0FGcEI7O0FBSUE7QUFDQSxXQUFPLEtBQVAsR0FBZSxLQUFLLFNBQUwsQ0FBZSxLQUE5QjtBQUNBLFdBQU8sTUFBUCxHQUFnQixLQUFLLFNBQUwsQ0FBZSxNQUEvQjs7QUFFQSxrQkFBYyxZQUFkLENBQTJCLEtBQUssU0FBaEMsRUFBMkMsQ0FBM0MsRUFBOEMsQ0FBOUM7O0FBRUE7QUFDQSxhQUFTLGlCQUFpQixNQUFqQixFQUF5QixZQUFZLENBQXJDLENBQVQ7O0FBRUEsV0FBTyx1QkFBdUIsT0FBTyxTQUFQLENBQWlCLFdBQWpCLENBQXZCLENBQVA7QUFDSCxDQWZEOzs7Ozs7Ozs7a0JDcHZCd0IsYTtBQXRCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQmUsU0FBUyxhQUFULEdBQXlCO0FBQ3BDLFNBQUssS0FBTCxHQUFhLElBQUksVUFBSixDQUFlLEdBQWYsQ0FBYjs7QUFFQSxTQUFLLFlBQUwsR0FBb0IsWUFBVztBQUMzQixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsaUJBQUssS0FBTCxDQUFXLENBQVgsSUFBZ0IsQ0FBaEI7QUFDSDtBQUNKLEtBSkQ7O0FBTUEsU0FBSyxzQkFBTCxHQUE4QixVQUFTLFVBQVQsRUFBcUIsUUFBckIsRUFBK0I7QUFDekQsWUFDSSxRQUFRLFdBQVcsR0FBWCxHQUFrQixPQUFPLFNBQVMsUUFBaEIsQ0FBbEIsR0FBOEMsTUFBTSxRQURoRTtBQUFBLFlBRUksU0FBUyxNQUFNLFFBQVEsR0FBZCxHQUFvQixVQUZqQzs7QUFJQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksR0FBcEIsRUFBeUIsR0FBekIsRUFBOEI7QUFDMUIsZ0JBQ0ksSUFBSSxJQUFJLEtBRFo7QUFBQSxnQkFFSSxJQUFJLElBQUksS0FBSixHQUFZLE1BRnBCOztBQUlBLGlCQUFLLEtBQUwsQ0FBVyxDQUFYLElBQWdCLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFLLEdBQUwsQ0FBUyxDQUFDLEVBQUUsSUFBSSxLQUFOLENBQVYsRUFBd0IsQ0FBeEIsQ0FBZCxDQUFoQjtBQUNIO0FBQ0osS0FaRDs7QUFjQSxTQUFLLE1BQUwsR0FBYyxZQUFXO0FBQ3JCLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxHQUFwQixFQUF5QixHQUF6QixFQUE4QjtBQUMxQixpQkFBSyxLQUFMLENBQVcsQ0FBWCxJQUFnQixNQUFNLEtBQUssS0FBTCxDQUFXLENBQVgsQ0FBdEI7QUFDSDtBQUNKLEtBSkQ7QUFLSDs7Ozs7Ozs7O2tCQ3RDdUIsZ0I7O0FBWnhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFQTs7Ozs7OztBQU9lLFNBQVMsZ0JBQVQsQ0FBMEIsT0FBMUIsRUFBbUM7QUFDOUMsUUFDSSxZQUFZLEVBRGhCO0FBQUEsUUFFSSxZQUFZLEVBRmhCO0FBQUEsUUFHSSxPQUFPLElBSFg7O0FBS0EsUUFBSSxRQUFRLGdCQUFSLElBQTRCLENBQUMsS0FBSyxRQUFRLGdCQUFkLEVBQWdDLE1BQWhDLEdBQXlDLENBQXpFLEVBQTRFO0FBQ3hFLGtCQUFVLElBQVYsQ0FBZTtBQUNYLGlCQUFLLFFBQVEsZ0JBREY7QUFFWCxzQkFBVSxnQkFGQztBQUdYLGtCQUFNLFFBSEs7QUFJWCxzQkFBVTtBQUpDLFNBQWY7QUFNSCxLQVBELE1BT087QUFDSCxZQUFJLFFBQVEsWUFBUixJQUF3QixDQUFDLEtBQUssUUFBUSxZQUFkLEVBQTRCLE1BQTVCLEdBQXFDLENBQWpFLEVBQW9FO0FBQ2hFLHNCQUFVLElBQVYsQ0FBZTtBQUNYLHFCQUFLLFFBQVEsWUFERjtBQUVYLDBCQUFVLFNBRkM7QUFHWCxzQkFBTSxNQUhLO0FBSVgsMEJBQVU7QUFKQyxhQUFmO0FBTUg7QUFDSjs7QUFFRCxRQUFJLFFBQVEsZUFBWixFQUE2QjtBQUN6QixrQkFBVSxJQUFWLENBQWU7QUFDWCxpQkFBSyxRQUFRLGVBREY7QUFFWCxzQkFBVSxnQkFGQztBQUdYLGtCQUFNLFVBSEs7QUFJWCxzQkFBVSxLQUpDO0FBS1gsd0JBQVksSUFMRCxDQUtNO0FBTE4sU0FBZjtBQU9IOztBQUVELGFBQVMsY0FBVCxDQUF3QixRQUF4QixFQUFrQyxZQUFsQyxFQUFnRDtBQUM1QyxlQUFPLElBQUksT0FBSixDQUFZLFVBQVMsT0FBVCxFQUFrQixNQUFsQixFQUEwQjtBQUN6QyxvQkFBUSxTQUFTLElBQWpCO0FBQ0kscUJBQUssTUFBTDtBQUNJLHdCQUNJLE9BQU8sSUFBSSxJQUFKLENBQVMsQ0FBQyxZQUFELENBQVQsRUFBeUIsRUFBQyxNQUFNLFdBQVAsRUFBekIsQ0FEWDtBQUFBLHdCQUVJLFdBQVcsT0FBTyxHQUFQLENBQVcsZUFBWCxDQUEyQixJQUEzQixDQUZmOztBQUlBLHdCQUFJLFFBQUosRUFBYztBQUNWLDRCQUNJLFFBQVEsSUFBSSxLQUFKLEVBRFo7O0FBR0EsOEJBQU0sTUFBTixHQUFlLFlBQVc7QUFDdEIsZ0NBQ0ksVUFBVSx3QkFBYyxLQUFLLEtBQW5CLEVBQTBCLEtBQUssTUFBL0IsQ0FEZDtBQUFBLGdDQUVJLFFBQVEsc0JBQVksS0FBSyxLQUFqQixFQUF3QixLQUFLLE1BQTdCLEVBQXFDLFNBQXJDLENBRlo7O0FBSUEsa0NBQU0sYUFBTixDQUFvQixLQUFwQjtBQUNBLG9DQUFRLGNBQVIsQ0FBdUIsS0FBdkI7O0FBRUEsb0NBQVEsSUFBUjtBQUNBLG1DQUFPLEdBQVAsQ0FBVyxlQUFYLENBQTJCLFFBQTNCOztBQUVBLG9DQUFRLE9BQVI7QUFDSCx5QkFaRDs7QUFjQSw4QkFBTSxHQUFOLEdBQVksUUFBWjtBQUNILHFCQW5CRCxNQW1CTztBQUNILGdDQUFRLElBQVI7QUFDSDtBQUNMO0FBQ0EscUJBQUssVUFBTDtBQUNJLHdCQUNJLFNBQVMsK0JBRGI7QUFBQSx3QkFFSSxTQUFTLE9BQU8sSUFBUCxDQUFZLFlBQVosQ0FGYjs7QUFJQSw0QkFBUSxNQUFSO0FBQ0o7QUFDQSxxQkFBSyxRQUFMO0FBQ0ksd0JBQ0ksU0FBUywyQkFEYjtBQUFBLHdCQUVJLFVBQVUsT0FBTyxJQUFQLENBQVksWUFBWixDQUZkOztBQUlBLDRCQUFRLE9BQVI7QUFDSjtBQUNBO0FBQ0ksNEJBQVEsSUFBUjtBQUNKO0FBN0NKO0FBK0NILFNBaERNLENBQVA7QUFpREg7O0FBRUQsYUFBUyxjQUFULENBQXdCLFFBQXhCLEVBQWtDLFFBQWxDLEVBQTRDO0FBQ3hDLFlBQUksYUFBYSxJQUFqQixFQUF1QjtBQUNuQixpQkFBSyxTQUFMLENBQWUsaUJBQWYsRUFBa0MsQ0FBQyxHQUFELEVBQU0sa0JBQWtCLFNBQVMsUUFBM0IsR0FBc0MsS0FBNUMsQ0FBbEM7QUFDSCxTQUZELE1BRU87QUFDSCxpQkFBSyxTQUFMLENBQWUsaUJBQWYsRUFBa0MsQ0FBQyxRQUFELEVBQVcsa0JBQWtCLFNBQVMsUUFBM0IsR0FBc0MsSUFBdEMsR0FBNkMsS0FBSyxLQUFMLENBQVcsV0FBVyxHQUF0QixDQUE3QyxHQUEwRSxPQUFyRixDQUFsQztBQUNIO0FBQ0o7O0FBRUQsU0FBSyxJQUFMLEdBQVksWUFBVztBQUNuQixZQUFJLFVBQVUsTUFBVixJQUFvQixDQUF4QixFQUEyQjtBQUN2QixpQkFBSyxTQUFMLENBQWUsaUJBQWYsRUFBa0MsQ0FBQyxTQUFELENBQWxDO0FBQ0E7QUFDSDs7QUFFRCxZQUNJLFdBQVcsVUFBVSxLQUFWLEVBRGY7QUFBQSxZQUVJLE1BQU0sSUFBSSxjQUFKLEVBRlY7O0FBSUEsWUFBSSxnQkFBSixDQUFxQixVQUFyQixFQUFpQyxVQUFTLEdBQVQsRUFBYztBQUMzQyxnQkFDSSxRQURKOztBQUdBLGdCQUFJLElBQUksZ0JBQUosSUFBd0IsQ0FBQyxTQUFTLFVBQXRDLEVBQWtEO0FBQzlDLDJCQUFXLElBQUksTUFBSixHQUFhLElBQUksS0FBNUI7QUFDSCxhQUZELE1BRU87QUFDSCwyQkFBVyxJQUFYO0FBQ0g7O0FBRUQsMkJBQWUsUUFBZixFQUF5QixRQUF6QjtBQUNILFNBWEQsRUFXRyxLQVhIOztBQWFBLGlCQUFTLFdBQVQsR0FBdUI7QUFDbkIsZ0JBQUksU0FBUyxRQUFiLEVBQXVCO0FBQ25CLHFCQUFLLFNBQUwsQ0FBZSxnQkFBZixFQUFpQyxDQUFDLHlCQUF5QixTQUFTLFFBQWxDLEdBQTZDLDJCQUE5QyxDQUFqQztBQUNILGFBRkQsTUFFTztBQUNIO0FBQ0EscUJBQUssSUFBTDtBQUNIO0FBQ0o7O0FBRUQsWUFBSSxnQkFBSixDQUFxQixNQUFyQixFQUE2QixVQUFTLEdBQVQsRUFBYztBQUN2QyxnQkFBSSxLQUFLLE1BQUwsSUFBZSxHQUFuQixFQUF3QjtBQUNwQixvQkFDSSxXQUFXLEtBQUssUUFEcEI7O0FBR0EscUJBQUssU0FBTCxDQUFlLGlCQUFmLEVBQWtDLENBQUMsR0FBRCxFQUFNLDBCQUFOLENBQWxDOztBQUVBO0FBQ0EsMkJBQ0ksWUFBVztBQUNQLG1DQUFlLFFBQWYsRUFBeUIsUUFBekIsRUFBbUMsSUFBbkMsQ0FBd0MsVUFBUyxPQUFULEVBQWtCO0FBQ3RELDRCQUFJLE9BQUosRUFBYTtBQUNULHNDQUFVLFNBQVMsSUFBbkIsSUFBMkIsT0FBM0I7O0FBRUE7QUFDQSxpQ0FBSyxJQUFMO0FBQ0gseUJBTEQsTUFLTztBQUNILGlDQUFLLFNBQUwsQ0FBZSxnQkFBZixFQUFpQyxDQUFDLHlCQUF5QixTQUFTLFFBQW5DLENBQWpDO0FBQ0g7QUFDSixxQkFURDtBQVVILGlCQVpMLEVBYUksQ0FiSjtBQWVILGFBdEJELE1Bc0JPO0FBQ0g7QUFDSDtBQUNKLFNBMUJELEVBMEJHLEtBMUJIOztBQTRCQSxZQUFJLGdCQUFKLENBQXFCLE9BQXJCLEVBQThCLFdBQTlCOztBQUVBLHVCQUFlLFFBQWYsRUFBeUIsU0FBUyxVQUFULEdBQXNCLElBQXRCLEdBQTZCLEdBQXREOztBQUVBLFlBQUksSUFBSixDQUFTLEtBQVQsRUFBZ0IsU0FBUyxHQUF6QixFQUE4QixJQUE5Qjs7QUFFQSxZQUFJLFlBQUosR0FBbUIsYUFBbkI7O0FBRUEsWUFBSSxJQUFKO0FBQ0gsS0FyRUQ7QUFzRUg7O0FBRUQsaUJBQWlCLFNBQWpCLEdBQTZCLE9BQU8sTUFBUCxDQUFjLGFBQWEsU0FBM0IsQ0FBN0I7QUFDQSxpQkFBaUIsU0FBakIsQ0FBMkIsV0FBM0IsR0FBeUMsZ0JBQXpDOzs7Ozs7Ozs7UUMzS2dCLHVCLEdBQUEsdUI7a0JBb0JRLGU7O0FBNUJ4Qjs7OztBQUNBOzs7O0FBQ0E7Ozs7OztBQUVBOzs7O0FBSU8sU0FBUyx1QkFBVCxDQUFpQyxDQUFqQyxFQUFvQztBQUN2QyxRQUNJLFNBQVMsSUFBSSxVQUFKLENBQWUsRUFBRSxNQUFqQixDQURiOztBQUdBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxFQUFFLE1BQXRCLEVBQThCLEdBQTlCLEVBQW1DO0FBQy9CLGVBQU8sQ0FBUCxJQUFZLEVBQUUsVUFBRixDQUFhLENBQWIsQ0FBWjtBQUNIOztBQUVELFdBQU8sTUFBUDtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTZSxTQUFTLGVBQVQsQ0FBeUIsT0FBekIsRUFBa0M7QUFDN0MsUUFDSSxPQUFPLElBRFg7QUFBQSxRQUdJLFlBQVksS0FIaEI7O0FBS0EsWUFBUSxRQUFSLEdBQW1CLFFBQVEsUUFBUixJQUFvQixDQUF2Qzs7QUFFQSxhQUFTLGNBQVQsQ0FBd0IsUUFBeEIsRUFBa0M7QUFDOUIsWUFBSSxhQUFhLElBQWpCLEVBQXVCO0FBQ25CLGlCQUFLLFNBQUwsQ0FBZSxnQkFBZixFQUFpQyxDQUFDLEdBQUQsRUFBTSxzQ0FBTixDQUFqQztBQUNILFNBRkQsTUFFTztBQUNILGlCQUFLLFNBQUwsQ0FBZSxnQkFBZixFQUFpQyxDQUFDLFFBQUQsRUFBVyw0Q0FBNEMsS0FBSyxLQUFMLENBQVcsV0FBVyxHQUF0QixDQUE1QyxHQUF5RSxJQUFwRixDQUFqQztBQUNIO0FBQ0o7O0FBRUQsYUFBUyxXQUFULENBQXFCLGFBQXJCLEVBQW9DO0FBQ2hDLGFBQUssU0FBTCxDQUFlLGVBQWYsRUFBZ0MsQ0FBQyxhQUFELENBQWhDO0FBQ0g7O0FBRUQsYUFBUyxXQUFULENBQXFCLFFBQXJCLEVBQStCO0FBQzNCLFlBQ0ksTUFBTSxJQUFJLGNBQUosRUFEVjs7QUFHQSxZQUFJLE1BQUosQ0FBVyxnQkFBWCxDQUE0QixVQUE1QixFQUF3QyxVQUFTLEdBQVQsRUFBYztBQUNsRCxnQkFDSSxRQURKOztBQUdBLGdCQUFJLElBQUksZ0JBQVIsRUFBMEI7QUFDdEIsMkJBQVcsSUFBSSxNQUFKLEdBQWEsSUFBSSxLQUE1QjtBQUNILGFBRkQsTUFFTztBQUNILDJCQUFXLElBQVg7QUFDSDs7QUFFRCwyQkFBZSxRQUFmO0FBQ0gsU0FYRCxFQVdHLEtBWEg7O0FBYUEsWUFBSSxnQkFBSixDQUFxQixNQUFyQixFQUE2QixVQUFTLEdBQVQsRUFBYztBQUN2QywyQkFBZSxHQUFmOztBQUVBLGdCQUFJLEtBQUssTUFBTCxJQUFlLEdBQWYsSUFBc0IsV0FBVyxJQUFYLENBQWdCLEtBQUssUUFBckIsQ0FBMUIsRUFBMEQ7QUFDdEQscUJBQUssU0FBTCxDQUFlLGdCQUFmO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsNEJBQVksS0FBSyxRQUFqQjtBQUNIO0FBQ0osU0FSRCxFQVFHLEtBUkg7O0FBVUEsWUFBSSxnQkFBSixDQUFxQixPQUFyQixFQUE4QixZQUFXO0FBQ3JDLHdCQUFZLEtBQUssUUFBakI7QUFDSCxTQUZELEVBRUcsS0FGSDs7QUFJQSx1QkFBZSxDQUFmOztBQUVBLFlBQUksSUFBSixDQUFTLE1BQVQsRUFBaUIsUUFBUSxHQUF6QixFQUE4QixJQUE5Qjs7QUFFQSxZQUFJLFlBQUosR0FBbUIsTUFBbkI7O0FBRUEsWUFBSSxJQUFKLENBQVMsUUFBVDtBQUNIOztBQUVEOzs7Ozs7Ozs7QUFTQSxTQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLFlBQ0ksSUFESixFQUVJLFFBRkosRUFHSSxZQUhKOztBQUtBLGVBQU8sd0JBQXdCLFFBQVEsT0FBUixDQUFnQixVQUFoQixDQUEyQixRQUFRLFFBQW5DLENBQXhCLENBQVA7QUFDQSxtQkFBVyxJQUFJLElBQUosQ0FBUyxDQUFDLElBQUQsQ0FBVCxFQUFpQixFQUFDLE1BQU0sV0FBUCxFQUFqQixDQUFYO0FBQ0EsZUFBTyxJQUFQLENBUm1CLENBUU47O0FBRWIsWUFDSSxlQURKOztBQUdBLFlBQUksUUFBUSxPQUFSLENBQWdCLGVBQWhCLEVBQUosRUFBdUM7QUFDbkMsOEJBQWtCLFFBQVEsT0FBUixDQUFnQixJQUFoQixDQUFsQjtBQUNILFNBRkQsTUFFTztBQUNILDhCQUFtQiwyQkFBRCxDQUFvQixTQUFwQixDQUE4QixRQUFRLE9BQXRDLENBQWxCO0FBQ0g7O0FBRUQsd0JBQWdCLElBQWhCLENBQXFCLFVBQVMsU0FBVCxFQUFvQjtBQUNyQyxnQkFBSSxTQUFKLEVBQWU7QUFDWCxxQkFBSyxTQUFMLENBQWUsZUFBZjtBQUNBO0FBQ0g7O0FBRUQsZ0JBQUksUUFBUSxRQUFaLEVBQXNCO0FBQ2xCLG9CQUNJLE1BQU0sK0JBRFY7O0FBR0EsK0JBQWUsSUFBSSxJQUFKLENBQVMsQ0FBQyxJQUFJLEtBQUosQ0FBVSxRQUFRLFFBQWxCLENBQUQsQ0FBVCxFQUF3QyxFQUFDLE1BQU0sMEJBQVAsRUFBeEMsQ0FBZjtBQUNILGFBTEQsTUFLTztBQUNILCtCQUFlLElBQWY7QUFDSDs7QUFFRCxnQkFBSSxRQUFRLEdBQVosRUFBaUI7QUFDYixvQkFDSSxTQUFTLGlEQURiO0FBQUEsb0JBRUksV0FBVyxJQUFJLFFBQUosRUFGZjs7QUFJQSx5QkFBUyxNQUFULENBQWdCLGFBQWhCLEVBQStCLE1BQS9COztBQUVaLHlCQUFTLE1BQVQsQ0FBZ0IsU0FBaEIsRUFBMkIsbUJBQTNCOztBQUVBLHlCQUFTLE1BQVQsQ0FBZ0IsU0FBaEIsRUFBMkIsUUFBM0I7QUFDWSwyQkFBVyxJQUFYOztBQUVBLG9CQUFJLFNBQUosRUFBZTtBQUMxQiw2QkFBUyxNQUFULENBQWdCLGlCQUFoQixFQUFtQyxtQkFBbkM7QUFDQSw2QkFBUyxNQUFULENBQWdCLFdBQWhCLEVBQTZCLFNBQTdCO0FBQ2UsZ0NBQVksSUFBWjs7QUFFQTtBQUNBLDZCQUFTLE1BQVQsQ0FBZ0IsVUFBaEIsRUFBNEIsS0FBSyxRQUFRLFFBQXpDO0FBQ0gsaUJBUEQsTUFPTztBQUNIOzs7O0FBSUEsNkJBQVMsTUFBVCxDQUFnQixVQUFoQixFQUE0QixHQUE1QjtBQUNIOztBQUVELG9CQUFJLFlBQUosRUFBa0I7QUFDZCw2QkFBUyxNQUFULENBQWdCLFVBQWhCLEVBQTRCLFlBQTVCO0FBQ0EsbUNBQWUsSUFBZjtBQUNIOztBQUVELHlCQUFTLE1BQVQsQ0FBZ0IsV0FBaEIsRUFBNkIsTUFBN0I7O0FBRUEsNEJBQVksUUFBWjtBQUNILGFBbkNELE1BbUNPO0FBQ0gsdUJBQU8sTUFBUCxDQUFjLFFBQWQsRUFBd0IsWUFBeEI7O0FBRUEsb0JBQUksU0FBSixFQUFlO0FBQ1gsMkJBQU8sTUFBUCxDQUFjLFNBQWQsRUFBeUIsWUFBekI7QUFDSDtBQUNELG9CQUFJLFlBQUosRUFBa0I7QUFDZCwyQkFBTyxNQUFQLENBQWMsWUFBZCxFQUE0QixZQUE1QjtBQUNIO0FBQ0o7QUFDSixTQTVERDtBQTZESCxLQWhGRDs7QUFrRkEsU0FBSyxNQUFMLEdBQWMsWUFBVztBQUNyQixvQkFBWSxJQUFaO0FBQ0gsS0FGRDtBQUdIOztBQUVELGdCQUFnQixTQUFoQixHQUE0QixPQUFPLE1BQVAsQ0FBYyxhQUFhLFNBQTNCLENBQTVCO0FBQ0EsZ0JBQWdCLFNBQWhCLENBQTBCLFdBQTFCLEdBQXdDLGVBQXhDOzs7Ozs7OztrQkNuS3dCLE07QUF0QnhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JlLFNBQVMsTUFBVCxHQUFrQixDQUNoQzs7QUFFRDs7Ozs7O0FBTUEsT0FBTyxTQUFQLENBQWlCLEtBQWpCLEdBQXlCLFVBQVMsSUFBVCxFQUFlO0FBQ3BDLFdBQU8sS0FBUDtBQUNILENBRkQ7O0FBSUE7Ozs7O0FBS0EsT0FBTyxTQUFQLENBQWlCLFFBQWpCLEdBQTRCLFlBQVc7QUFDbkMsV0FBTyxLQUFQO0FBQ0gsQ0FGRDs7QUFJQTs7Ozs7OztBQU9BLE9BQU8sU0FBUCxDQUFpQixhQUFqQixHQUFpQyxVQUFTLE1BQVQsRUFBaUIsS0FBakIsRUFBd0I7QUFDckQsV0FBTyxDQUFQO0FBQ0gsQ0FGRDs7QUFJQTs7O0FBR0EsT0FBTyxTQUFQLENBQWlCLE9BQWpCLEdBQTJCLFlBQVcsQ0FDckMsQ0FERDs7Ozs7Ozs7O2tCQ3BDd0IsYTtBQXRCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQmUsU0FBUyxhQUFULENBQXVCLE1BQXZCLEVBQStCO0FBQzFDLFFBQ0ksU0FDSSxpck1BRlI7O0FBK0dBO0FBQ0EsV0FBTyxFQUFQLENBQVUsaUJBQVYsRUFBNkIsVUFBUyxDQUFULEVBQVk7QUFDckMsZUFBTyxNQUFQO0FBQ0gsS0FGRDs7QUFJQSxXQUFPLEtBQVAsQ0FBYTtBQUNULGNBQU07QUFERyxLQUFiOztBQUlBO0FBQ0EsV0FBTyxJQUFQLENBQVksVUFBWixFQUF3QixLQUF4QixHQUFnQyxFQUFFLE1BQUYsQ0FBaEM7O0FBRUEsV0FBTyxXQUFQLENBQW1CLE9BQU8sQ0FBUCxDQUFuQjs7QUFFQSxTQUFLLElBQUwsR0FBWSxZQUFXO0FBQ25CLGVBQU8sS0FBUCxDQUFhLE1BQWI7QUFDSCxLQUZEO0FBR0g7Ozs7Ozs7OztrQkNqSXVCLGU7QUF0QnhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JlLFNBQVMsZUFBVCxDQUF5QixNQUF6QixFQUFpQyxVQUFqQyxFQUE2QztBQUN4RCxRQUNJLFNBQ0ksNHNEQUZSO0FBQUEsUUFnQ0ksaUJBQWlCLEVBQUUsMkJBQUYsRUFBK0IsTUFBL0IsQ0FoQ3JCO0FBQUEsUUFpQ0kscUJBQXFCLEVBQUUsK0JBQUYsRUFBbUMsTUFBbkMsQ0FqQ3pCO0FBQUEsUUFrQ0ksY0FBYyxFQUFFLDhCQUFGLEVBQWtDLE1BQWxDLENBbENsQjs7QUFvQ0EsU0FBSyxJQUFMLEdBQVksWUFBVztBQUNuQixlQUFPLEtBQVAsQ0FBYSxNQUFiO0FBQ0gsS0FGRDs7QUFJQSxnQkFBWSxLQUFaLENBQWtCLFVBQVMsQ0FBVCxFQUFZO0FBQzFCLFlBQ0ksT0FBTyxLQUFLLEdBQUwsQ0FBUyxTQUFTLGVBQWUsR0FBZixFQUFULEVBQStCLEVBQS9CLENBQVQsRUFBNkMsQ0FBN0MsQ0FEWDtBQUFBLFlBRUksYUFBYSxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxTQUFTLG1CQUFtQixHQUFuQixFQUFULEVBQW1DLEVBQW5DLENBQVQsRUFBaUQsQ0FBakQsQ0FBVCxFQUE4RCxDQUE5RCxDQUZqQjs7QUFJQSxtQkFBVyxVQUFYLEdBQXdCLE9BQXhCLENBQWdDLElBQWhDLEVBQXNDLElBQXRDLEVBQTRDLFVBQTVDO0FBQ0gsS0FORDs7QUFRQSxXQUNLLEtBREwsQ0FDVztBQUNILGNBQU07QUFESCxLQURYLEVBSUssRUFKTCxDQUlRLGdCQUpSLEVBSTBCLFlBQVc7QUFDN0IsdUJBQWUsS0FBZjtBQUNILEtBTkwsRUFPSyxFQVBMLENBT1EsVUFQUixFQU9vQixVQUFTLENBQVQsRUFBWTtBQUN4QixZQUFJLEVBQUUsT0FBRixJQUFhLEVBQWpCLEVBQXFCO0FBQ2pCLHdCQUFZLEtBQVo7QUFDSDtBQUNKLEtBWEw7O0FBYUE7QUFDQSxXQUFPLElBQVAsQ0FBWSxVQUFaLEVBQXdCLEtBQXhCLEdBQWdDLEVBQUUsTUFBRixDQUFoQzs7QUFFQSxXQUFPLFdBQVAsQ0FBbUIsT0FBTyxDQUFQLENBQW5COztBQUVBOzs7Ozs7O0FBT0g7Ozs7Ozs7OztrQkNRdUIsYzs7QUFsRnhCOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7QUFFQTs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFFQSxTQUFTLG1CQUFULENBQTZCLFFBQTdCLEVBQXVDLE1BQXZDLEVBQStDO0FBQzNDLFFBQ0ksUUFBUSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FEWjs7QUFHQSxVQUFNLFNBQU4sR0FBa0Isb0NBQWxCOztBQUVBLFVBQU0sV0FBTixDQUFrQixTQUFTLFVBQVQsRUFBbEI7QUFDQSxVQUFNLFdBQU4sQ0FBa0IsT0FBTyxVQUFQLEVBQWxCOztBQUVBLFdBQU8sS0FBUDtBQUNILEMsQ0E3Q0Q7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUErQ0EsU0FBUyxZQUFULENBQXNCLEtBQXRCLEVBQTZCLFdBQTdCLEVBQTBDO0FBQ3RDLFNBQUssSUFBSSxHQUFULElBQWdCLFdBQWhCLEVBQTZCO0FBQ3pCLFlBQ0ksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FEYjs7QUFHQSxlQUFPLFdBQVAsQ0FBbUIsU0FBUyxjQUFULENBQXdCLFlBQVksR0FBWixDQUF4QixDQUFuQjtBQUNBLGVBQU8sS0FBUCxHQUFlLEdBQWY7O0FBRUEsY0FBTSxXQUFOLENBQWtCLE1BQWxCO0FBQ0g7QUFDSjs7QUFFRCxTQUFTLGlCQUFULENBQTJCLFVBQTNCLEVBQXVDO0FBQ25DLFFBQ0ksT0FBTyxJQURYO0FBQUEsUUFHSSxJQUFJLEdBSFI7QUFBQSxRQUdhLElBQUksRUFIakI7QUFBQSxRQUtJLFNBQVMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBTGI7QUFBQSxRQU1JLGdCQUFnQixPQUFPLFVBQVAsQ0FBa0IsSUFBbEIsQ0FOcEI7QUFBQSxRQVFJLGVBQWUsMkNBQTBCLGFBQTFCLENBUm5CO0FBQUEsUUFVSSxRQUFRLHNCQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCLEVBQWxCLENBVlo7QUFBQSxRQVdJLGNBQWMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBWGxCO0FBQUEsUUFZSSxxQkFBcUIsWUFBWSxVQUFaLENBQXVCLElBQXZCLENBWnpCO0FBQUEsUUFjSSxXQUFXLFdBQVcsY0FBWCxFQWRmOztBQWdCQSxhQUFTLEtBQVQsR0FBaUI7QUFDYixjQUFNLFFBQU4sQ0FBZSxNQUFNLFNBQU4sRUFBZixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQyxFQUF3QyxNQUFNLEtBQTlDLEVBQXFELENBQXJELEVBQXdELFFBQXhELEVBQWtFLElBQWxFO0FBQ0EsMkJBQW1CLFlBQW5CLENBQWdDLE1BQU0sU0FBdEMsRUFBaUQsQ0FBakQsRUFBb0QsQ0FBcEQsRUFBdUQsQ0FBdkQsRUFBMEQsQ0FBMUQsRUFBNkQsQ0FBN0QsRUFBZ0UsQ0FBaEU7O0FBRUEsc0JBQWMsUUFBZCxDQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixPQUFPLEtBQXBDLEVBQTJDLE9BQU8sTUFBbEQ7QUFDQSxzQkFBYyxTQUFkLENBQXdCLFdBQXhCLEVBQXFDLENBQXJDLEVBQXdDLENBQXhDO0FBQ0g7O0FBRUQsU0FBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsZUFBTyxNQUFQO0FBQ0gsS0FGRDs7QUFJQSxlQUFXLEVBQVgsQ0FBYyxnQkFBZCxFQUFnQyxVQUFTLFNBQVQsRUFBb0I7QUFDaEQsbUJBQVcsU0FBWDs7QUFFQTtBQUNILEtBSkQ7O0FBTUEsV0FBTyxLQUFQLEdBQWUsWUFBWSxLQUFaLEdBQW9CLENBQW5DO0FBQ0EsV0FBTyxNQUFQLEdBQWdCLFlBQVksTUFBWixHQUFxQixDQUFyQzs7QUFFQSxXQUFPLFNBQVAsR0FBbUIsK0JBQW5COztBQUVBLGtCQUFjLFNBQWQsR0FBMEIsWUFBMUI7O0FBRUE7QUFDSDs7QUFFYyxTQUFTLGNBQVQsQ0FBd0IsVUFBeEIsRUFBb0M7QUFDL0Msd0JBQVUsSUFBVixDQUFlLElBQWYsRUFBcUIsVUFBckIsRUFBaUMsT0FBakMsRUFBMEMsY0FBMUM7O0FBRUEsUUFDSSxhQUFhLElBQUksWUFBSixDQUFpQixVQUFqQixDQURqQjtBQUFBLFFBRUksZ0JBQWdCLElBQUksZUFBSixDQUFvQixVQUFwQixDQUZwQjtBQUFBLFFBR0ksaUJBQWlCLElBQUksZ0JBQUosQ0FBcUIsVUFBckIsQ0FIckI7QUFBQSxRQUtJLE9BQU8sS0FBSyxjQUFMLEVBTFg7O0FBT0EsU0FBSyxXQUFMLENBQWlCLFdBQVcsVUFBWCxFQUFqQjtBQUNBLFNBQUssV0FBTCxDQUFpQixjQUFjLFVBQWQsRUFBakI7QUFDQSxTQUFLLFdBQUwsQ0FBaUIsZUFBZSxVQUFmLEVBQWpCOztBQUVBLGVBQVcsRUFBWCxDQUFjLFlBQWQsRUFBNEIsVUFBUyxJQUFULEVBQWU7QUFDdkMsbUJBQVcsVUFBWCxHQUF3QixLQUF4QixDQUE4QixPQUE5QixHQUF3QyxNQUF4QztBQUNBLHNCQUFjLFVBQWQsR0FBMkIsS0FBM0IsQ0FBaUMsT0FBakMsR0FBMkMsTUFBM0M7QUFDQSx1QkFBZSxVQUFmLEdBQTRCLEtBQTVCLENBQWtDLE9BQWxDLEdBQTRDLE1BQTVDOztBQUVBLGdCQUFRLElBQVI7QUFDSSxpQkFBSyx1QkFBYSxjQUFsQjtBQUNJLDhCQUFjLFVBQWQsR0FBMkIsS0FBM0IsQ0FBaUMsT0FBakMsR0FBMkMsT0FBM0M7QUFDSjtBQUNBLGlCQUFLLHVCQUFhLFdBQWxCO0FBQ0ksK0JBQWUsVUFBZixHQUE0QixLQUE1QixDQUFrQyxPQUFsQyxHQUE0QyxPQUE1QztBQUNKO0FBQ0E7QUFDSSwyQkFBVyxVQUFYLEdBQXdCLEtBQXhCLENBQThCLE9BQTlCLEdBQXdDLE9BQXhDO0FBQ0o7QUFUSjtBQVdILEtBaEJEO0FBaUJIOztBQUVELGVBQWUsU0FBZixHQUEyQixPQUFPLE1BQVAsQ0FBYyxvQkFBVSxTQUF4QixDQUEzQjtBQUNBLGVBQWUsU0FBZixDQUF5QixXQUF6QixHQUF1QyxjQUF2Qzs7QUFFQSxTQUFTLFlBQVQsQ0FBc0IsVUFBdEIsRUFBa0M7QUFDOUIsUUFDSSxZQUFZLENBQUMsaUJBQUQsRUFBb0IsaUJBQXBCLEVBQXVDLFlBQXZDLEVBQXFELGtCQUFyRCxFQUF5RSxrQkFBekUsQ0FEaEI7QUFBQSxRQUVJLGNBQWMsQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLENBQVAsRUFBVSxDQUFWLEVBQWEsQ0FBYixFQUFnQixDQUFoQixFQUFtQixDQUFuQixFQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixFQUE1QixFQUFnQyxFQUFoQyxFQUFvQyxFQUFwQyxFQUF3QyxFQUF4QyxFQUE0QyxFQUE1QyxFQUFnRCxFQUFoRCxFQUFvRCxFQUFwRCxFQUF3RCxFQUF4RCxFQUE0RCxFQUE1RCxFQUFnRSxFQUFoRSxFQUFvRSxFQUFwRSxFQUF3RSxFQUF4RSxFQUE0RSxFQUE1RSxFQUFnRixHQUFoRixFQUFxRixHQUFyRixFQUEwRixHQUExRixFQUErRixHQUEvRixFQUFvRyxHQUFwRyxDQUZsQjs7QUFJQSxRQUNJLFFBQVEsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRFo7QUFBQSxRQUdJLFdBQVcsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBSGY7QUFBQSxRQUtJLFVBQVUseUJBQWUsS0FBZixFQUFzQix5Q0FBdEIsQ0FMZDtBQUFBLFFBTUksY0FBYyx1QkFBYSxDQUFiLEVBQWdCLEdBQWhCLENBTmxCO0FBQUEsUUFRSSxTQUFTLHlCQUFlLElBQWYsRUFBcUIsc0NBQXJCLENBUmI7QUFBQSxRQVNJLGFBQWEsdUJBQWEsQ0FBYixFQUFnQixHQUFoQixFQUFxQixLQUFyQixFQUE0QixJQUE1QixDQVRqQjtBQUFBLFFBV0ksZUFBZ0IseUJBQWUsS0FBZixFQUFzQiw0Q0FBdEIsQ0FYcEI7QUFBQSxRQVlJLG1CQUFtQix1QkFBYSxDQUFiLEVBQWdCLElBQWhCLEVBQXNCLEtBQXRCLEVBQTZCLElBQTdCLENBWnZCO0FBQUEsUUFjSSxjQUFjLHVCQUFhLENBQWIsRUFBZ0IsR0FBaEIsRUFBcUIsS0FBckIsRUFBNEIsSUFBNUIsQ0FkbEI7QUFBQSxRQWVJLGNBQWMsdUJBQWEsQ0FBYixFQUFnQixHQUFoQixFQUFxQixLQUFyQixFQUE0QixJQUE1QixDQWZsQjtBQUFBLFFBZ0JJLGdCQUFnQix1QkFBYSxDQUFiLEVBQWdCLEdBQWhCLEVBQXFCLEtBQXJCLEVBQTRCLElBQTVCLENBaEJwQjtBQUFBLFFBaUJJLGtCQUFrQix1QkFBYSxDQUFiLEVBQWdCLEdBQWhCLEVBQXFCLEtBQXJCLEVBQTRCLElBQTVCLENBakJ0QjtBQUFBLFFBbUJJLGVBQWUsSUFBSSxlQUFlLGNBQW5CLENBQWtDLFVBQWxDLENBbkJuQjs7QUFxQkEsYUFBUyxxQkFBVCxHQUFpQztBQUM3QixnQkFBUSxRQUFSLENBQWlCLFdBQVcsWUFBWCxHQUEwQixhQUEzQztBQUNBLG9CQUFZLFFBQVosQ0FBcUIsV0FBVyxRQUFYLEVBQXJCOztBQUVBLGVBQU8sUUFBUCxDQUFnQixXQUFXLFlBQVgsR0FBMEIsWUFBMUM7QUFDQSxtQkFBVyxRQUFYLENBQW9CLFdBQVcsWUFBWCxFQUFwQjs7QUFFQSxxQkFBYSxRQUFiLENBQXNCLFdBQVcsWUFBWCxHQUEwQixrQkFBaEQ7QUFDQSx5QkFBaUIsUUFBakIsQ0FBMEIsQ0FBQyxFQUFFLFdBQVcsWUFBWCxHQUEwQixVQUExQixHQUF1QyxHQUF6QyxDQUEzQjs7QUFFQSxpQkFBUyxLQUFULEdBQWlCLFdBQVcsWUFBWCxHQUEwQixJQUEzQzs7QUFFQSxvQkFBWSxRQUFaLENBQXFCLENBQUMsRUFBRSxXQUFXLFlBQVgsR0FBMEIsS0FBMUIsR0FBa0MsR0FBcEMsQ0FBdEI7QUFDQSxvQkFBWSxRQUFaLENBQXFCLENBQUMsRUFBRSxXQUFXLFlBQVgsR0FBMEIsS0FBMUIsR0FBa0MsR0FBcEMsQ0FBdEI7QUFDQSxzQkFBYyxRQUFkLENBQXVCLENBQUMsRUFBRSxXQUFXLFlBQVgsR0FBMEIsT0FBMUIsR0FBb0MsR0FBdEMsQ0FBeEI7QUFDQSx3QkFBZ0IsUUFBaEIsQ0FBeUIsQ0FBQyxFQUFFLFdBQVcsWUFBWCxHQUEwQixTQUExQixHQUFzQyxHQUF4QyxDQUExQjtBQUNIOztBQUVELFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLGVBQU8sS0FBUDtBQUNILEtBRkQ7O0FBSUEsZ0JBQVksS0FBWixHQUFvQixVQUFVLEtBQVYsRUFBaUI7QUFDakMsZUFBTyxjQUFjLEtBQXJCO0FBQ0gsS0FGRDs7QUFJQSxnQkFBWSxFQUFaLENBQWUsYUFBZixFQUE4QixVQUFVLEtBQVYsRUFBaUI7QUFDM0MsbUJBQVcsUUFBWCxDQUFvQixLQUFwQjtBQUNILEtBRkQ7O0FBSUEsZUFBVyxLQUFYLEdBQW1CLFVBQVUsS0FBVixFQUFpQjtBQUNoQyxlQUFPLGlCQUFpQixLQUF4QjtBQUNILEtBRkQ7O0FBSUEsZUFBVyxFQUFYLENBQWMsYUFBZCxFQUE2QixVQUFVLEtBQVYsRUFBaUI7QUFDMUMsbUJBQVcsWUFBWCxDQUF3QixLQUF4QjtBQUNILEtBRkQ7O0FBSUEsZ0JBQVksS0FBWixHQUFvQixVQUFVLEtBQVYsRUFBaUI7QUFDakMsZUFBTyxZQUFZLEtBQVosR0FBb0IsR0FBM0I7QUFDSCxLQUZEOztBQUlBLGdCQUFZLEVBQVosQ0FBZSxhQUFmLEVBQThCLFVBQVUsS0FBVixFQUFpQjtBQUMzQyxtQkFBVyxZQUFYLEdBQTBCLEtBQTFCLEdBQWtDLFFBQVEsS0FBMUM7QUFDQSxtQkFBVyxpQkFBWDtBQUNILEtBSEQ7O0FBS0EsZ0JBQVksS0FBWixHQUFvQixVQUFVLEtBQVYsRUFBaUI7QUFDakMsZUFBTyxZQUFZLEtBQVosR0FBb0IsR0FBM0I7QUFDSCxLQUZEOztBQUlBLGdCQUFZLEVBQVosQ0FBZSxhQUFmLEVBQThCLFVBQVUsS0FBVixFQUFpQjtBQUMzQyxtQkFBVyxZQUFYLEdBQTBCLEtBQTFCLEdBQWtDLFFBQVEsS0FBMUM7QUFDQSxtQkFBVyxpQkFBWDtBQUNILEtBSEQ7O0FBS0Esa0JBQWMsS0FBZCxHQUFzQixVQUFVLEtBQVYsRUFBaUI7QUFDbkMsZUFBTyxjQUFjLEtBQWQsR0FBc0IsR0FBN0I7QUFDSCxLQUZEOztBQUlBLGtCQUFjLEVBQWQsQ0FBaUIsYUFBakIsRUFBZ0MsVUFBVSxLQUFWLEVBQWlCO0FBQzdDLG1CQUFXLFlBQVgsR0FBMEIsT0FBMUIsR0FBb0MsUUFBUSxLQUE1QztBQUNBLG1CQUFXLGlCQUFYO0FBQ0gsS0FIRDs7QUFLQSxxQkFBaUIsS0FBakIsR0FBeUIsVUFBVSxLQUFWLEVBQWlCO0FBQ3RDLGVBQU8saUJBQWlCLEtBQWpCLEdBQXlCLEdBQWhDO0FBQ0gsS0FGRDs7QUFJQSxxQkFBaUIsRUFBakIsQ0FBb0IsYUFBcEIsRUFBbUMsVUFBVSxLQUFWLEVBQWlCO0FBQ2hELG1CQUFXLFlBQVgsR0FBMEIsVUFBMUIsR0FBdUMsUUFBUSxLQUEvQztBQUNBLG1CQUFXLGlCQUFYO0FBQ0gsS0FIRDs7QUFLQSxvQkFBZ0IsS0FBaEIsR0FBd0IsVUFBVSxLQUFWLEVBQWlCO0FBQ3JDLGVBQU8sZ0JBQWdCLEtBQWhCLEdBQXdCLEdBQS9CO0FBQ0gsS0FGRDs7QUFJQSxvQkFBZ0IsRUFBaEIsQ0FBbUIsYUFBbkIsRUFBa0MsVUFBVSxLQUFWLEVBQWlCO0FBQy9DLG1CQUFXLFlBQVgsR0FBMEIsU0FBMUIsR0FBc0MsUUFBUSxLQUE5QztBQUNBLG1CQUFXLGlCQUFYO0FBQ0gsS0FIRDs7QUFLQSxpQkFBYSxFQUFiLENBQWdCLGFBQWhCLEVBQStCLFVBQVUsS0FBVixFQUFpQjtBQUM1QyxtQkFBVyxZQUFYLEdBQTBCLGtCQUExQixHQUErQyxLQUEvQztBQUNBLG1CQUFXLGlCQUFYO0FBQ0gsS0FIRDs7QUFLQSxZQUFRLEVBQVIsQ0FBVyxhQUFYLEVBQTBCLFVBQVUsS0FBVixFQUFpQjtBQUN2QyxtQkFBVyxZQUFYLEdBQTBCLGFBQTFCLEdBQTBDLEtBQTFDO0FBQ0EsbUJBQVcsaUJBQVg7QUFDSCxLQUhEOztBQUtBLFdBQU8sRUFBUCxDQUFVLGFBQVYsRUFBeUIsVUFBVSxLQUFWLEVBQWlCO0FBQ3RDLG1CQUFXLFlBQVgsR0FBMEIsWUFBMUIsR0FBeUMsS0FBekM7QUFDQSxtQkFBVyxpQkFBWDtBQUNILEtBSEQ7O0FBS0EsYUFBUyxnQkFBVCxDQUEwQixRQUExQixFQUFvQyxVQUFTLENBQVQsRUFBWTtBQUM1QyxtQkFBVyxZQUFYLEdBQTBCLElBQTFCLEdBQWlDLFNBQVMsU0FBUyxLQUFsQixFQUF5QixFQUF6QixDQUFqQztBQUNILEtBRkQ7O0FBSUEsYUFBUyxTQUFULEdBQXFCLGNBQXJCO0FBQ0EsaUJBQWEsUUFBYixFQUF1QixTQUF2Qjs7QUFFQSxVQUFNLFdBQU4sQ0FBa0IsUUFBbEI7O0FBRUEsVUFBTSxXQUFOLENBQWtCLGFBQWEsVUFBYixFQUFsQjs7QUFFQSxVQUFNLFdBQU4sQ0FBa0Isb0JBQW9CLE1BQXBCLEVBQTRCLFVBQTVCLENBQWxCO0FBQ0EsVUFBTSxXQUFOLENBQWtCLG9CQUFvQixPQUFwQixFQUE2QixXQUE3QixDQUFsQjtBQUNBLFVBQU0sV0FBTixDQUFrQixZQUFZLFVBQVosRUFBbEI7QUFDQSxVQUFNLFdBQU4sQ0FBa0IsWUFBWSxVQUFaLEVBQWxCO0FBQ0EsVUFBTSxXQUFOLENBQWtCLGNBQWMsVUFBZCxFQUFsQjtBQUNBLFVBQU0sV0FBTixDQUFrQixvQkFBb0IsWUFBcEIsRUFBa0MsZ0JBQWxDLENBQWxCO0FBQ0EsVUFBTSxXQUFOLENBQWtCLGdCQUFnQixVQUFoQixFQUFsQjs7QUFFQTs7QUFFQSxlQUFXLEVBQVgsQ0FBYyxZQUFkLEVBQTRCLFVBQVMsSUFBVCxFQUFlLFFBQWYsRUFBeUI7QUFDakQsb0JBQVksUUFBWixDQUFxQixTQUFTLEtBQTlCO0FBQ0EsbUJBQVcsUUFBWCxDQUFvQixTQUFTLElBQTdCO0FBQ0EsZUFBTyxRQUFQLENBQWdCLFNBQVMsWUFBekI7QUFDQSxnQkFBUSxRQUFSLENBQWlCLFNBQVMsYUFBMUI7QUFDQSxpQkFBUyxLQUFULEdBQWlCLFNBQVMsSUFBMUI7QUFDQSxxQkFBYSxRQUFiLENBQXNCLFNBQVMsa0JBQS9COztBQUVBLFlBQUksQ0FBQyxFQUFFLFNBQVMsS0FBVCxHQUFpQixLQUFuQixDQUFELElBQThCLFlBQVksS0FBOUMsRUFBcUQ7QUFDakQsd0JBQVksUUFBWixDQUFxQixDQUFDLEVBQUUsU0FBUyxLQUFULEdBQWlCLEtBQW5CLENBQXRCO0FBQ0g7O0FBRUQsWUFBSSxDQUFDLEVBQUUsU0FBUyxLQUFULEdBQWlCLEtBQW5CLENBQUQsSUFBOEIsWUFBWSxLQUE5QyxFQUFxRDtBQUNqRCx3QkFBWSxRQUFaLENBQXFCLENBQUMsRUFBRSxTQUFTLEtBQVQsR0FBaUIsS0FBbkIsQ0FBdEI7QUFDSDs7QUFFRCxZQUFJLENBQUMsRUFBRSxTQUFTLE9BQVQsR0FBbUIsS0FBckIsQ0FBRCxJQUFnQyxjQUFjLEtBQWxELEVBQXlEO0FBQ3JELDBCQUFjLFFBQWQsQ0FBdUIsQ0FBQyxFQUFFLFNBQVMsT0FBVCxHQUFtQixLQUFyQixDQUF4QjtBQUNIOztBQUVELFlBQUksQ0FBQyxFQUFFLFNBQVMsVUFBVCxHQUFzQixLQUF4QixDQUFELElBQW1DLGlCQUFpQixLQUF4RCxFQUErRDtBQUMzRCw2QkFBaUIsUUFBakIsQ0FBMEIsQ0FBQyxFQUFFLFNBQVMsVUFBVCxHQUFzQixLQUF4QixDQUEzQjtBQUNIOztBQUVELFlBQUksQ0FBQyxFQUFFLFNBQVMsU0FBVCxHQUFxQixLQUF2QixDQUFELElBQWtDLGdCQUFnQixLQUF0RCxFQUE2RDtBQUN6RCw0QkFBZ0IsUUFBaEIsQ0FBeUIsQ0FBQyxFQUFFLFNBQVMsU0FBVCxHQUFxQixLQUF2QixDQUExQjtBQUNIO0FBQ0osS0EzQkQ7O0FBNkJBLFFBQUkscUJBQUosRUFBMkIsVUFBUyxLQUFULEVBQWdCLE9BQWhCLEVBQXlCO0FBQ2hELFlBQ0ksV0FBVyxTQUFTLFFBQVEsUUFBakIsRUFBMkIsRUFBM0IsQ0FEZjs7QUFHQSxZQUFJLFlBQVksQ0FBaEIsRUFBbUI7QUFDZix1QkFBVyxFQUFYO0FBQ0g7O0FBRUQsbUJBQVcsUUFBWCxDQUFvQixLQUFLLEtBQUwsQ0FBVyxXQUFXLEVBQVgsR0FBZ0IsR0FBM0IsQ0FBcEI7QUFDSCxLQVREOztBQVdBLFFBQUksS0FBSixFQUFXLFlBQVc7QUFDbEIsWUFDSSxPQUFPLFdBQVcsWUFBWCxFQURYOztBQUdBLGFBQUssSUFBSSxJQUFJLFlBQVksTUFBWixHQUFxQixDQUFsQyxFQUFxQyxLQUFLLENBQTFDLEVBQTZDLEdBQTdDLEVBQWtEO0FBQzlDLGdCQUFJLE9BQU8sWUFBWSxDQUFaLENBQVgsRUFBMkI7QUFDdkIsMkJBQVcsWUFBWCxDQUF3QixZQUFZLENBQVosQ0FBeEI7QUFDQTtBQUNIO0FBQ0o7QUFDSixLQVZEOztBQVlBLFFBQUksS0FBSixFQUFXLFlBQVc7QUFDbEIsWUFDSSxPQUFPLFdBQVcsWUFBWCxFQURYOztBQUdBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxZQUFZLE1BQWhDLEVBQXdDLEdBQXhDLEVBQTZDO0FBQ3pDLGdCQUFJLE9BQU8sWUFBWSxDQUFaLENBQVgsRUFBMkI7QUFDdkIsMkJBQVcsWUFBWCxDQUF3QixZQUFZLENBQVosQ0FBeEI7QUFDQTtBQUNIO0FBQ0o7QUFDSixLQVZEO0FBV0g7O0FBRUQsZUFBZSxjQUFmLEdBQWdDLFVBQVMsVUFBVCxFQUFxQjtBQUNqRCxRQUNJLE9BQU8sRUFEWDtBQUFBLFFBR0ksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FIYjtBQUFBLFFBSUksZ0JBQWdCLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQUpwQjtBQUFBLFFBTUksZ0JBQWdCLEtBTnBCOztBQVFBLGFBQVMsS0FBVCxHQUFpQjtBQUNiLHNCQUFjLFNBQWQsQ0FBd0IsQ0FBeEIsRUFBMkIsQ0FBM0IsRUFBOEIsT0FBTyxLQUFyQyxFQUE0QyxPQUFPLE1BQW5EOztBQUVBLHNCQUFjLFNBQWQ7QUFDQSxzQkFBYyxHQUFkLENBQWtCLE9BQU8sS0FBUCxHQUFlLENBQWpDLEVBQW9DLE9BQU8sTUFBUCxHQUFnQixDQUFwRCxFQUF1RCxPQUFPLENBQVAsR0FBVyxPQUFPLGdCQUF6RSxFQUEyRixDQUEzRixFQUE4RixLQUFLLEVBQUwsR0FBVSxDQUF4RztBQUNBLHNCQUFjLE1BQWQ7QUFDSDs7QUFFRCxhQUFTLGVBQVQsQ0FBeUIsQ0FBekIsRUFBNEI7QUFDeEIsWUFDSSxTQUFTLEVBQUUsTUFBRixFQUFVLE1BQVYsRUFEYjtBQUFBLFlBR0ksS0FBSyxFQUFDLEdBQUcsRUFBRSxLQUFGLEdBQVUsT0FBTyxJQUFyQixFQUEyQixHQUFHLEVBQUUsS0FBRixHQUFVLE9BQU8sR0FBL0MsRUFIVDtBQUFBLFlBS0ksSUFBSSxHQUFHLENBQUgsR0FBTyxFQUFFLE1BQUYsRUFBVSxLQUFWLEtBQW9CLENBTG5DO0FBQUEsWUFNSSxJQUFJLEdBQUcsQ0FBSCxHQUFPLEVBQUUsTUFBRixFQUFVLE1BQVYsS0FBcUIsQ0FOcEM7QUFBQSxZQVFJLFVBQVUsS0FBSyxLQUFMLENBQVcsS0FBSyxJQUFMLENBQVUsSUFBSSxDQUFKLEdBQVEsSUFBSSxDQUF0QixJQUEyQixDQUF0QyxDQVJkOztBQVVBLGVBQU8sS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxPQUFkLENBQVosQ0FBUDs7QUFFQTtBQUNBLG1CQUFXLFlBQVgsQ0FBd0IsSUFBeEI7QUFDSDs7QUFFRCxhQUFTLGFBQVQsQ0FBdUIsQ0FBdkIsRUFBMEI7QUFDdEIsWUFBSSxhQUFKLEVBQW1CO0FBQ2YsNEJBQWdCLEtBQWhCO0FBQ0EsbUJBQU8sbUJBQVAsQ0FBMkIsU0FBM0IsRUFBc0MsYUFBdEM7QUFDQSxtQkFBTyxtQkFBUCxDQUEyQixXQUEzQixFQUF3QyxlQUF4QztBQUNIO0FBQ0o7O0FBRUQsU0FBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsZUFBTyxNQUFQO0FBQ0gsS0FGRDs7QUFJQSxXQUFPLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLFVBQVMsQ0FBVCxFQUFZO0FBQzdDLFlBQUksQ0FBQyxhQUFMLEVBQW9CO0FBQ2hCLDRCQUFnQixJQUFoQjs7QUFFQSxtQkFBTyxnQkFBUCxDQUF3QixTQUF4QixFQUFtQyxhQUFuQztBQUNBLG1CQUFPLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLGVBQXJDOztBQUVBLDRCQUFnQixDQUFoQjtBQUNIO0FBQ0osS0FURDs7QUFXQSxlQUFXLEVBQVgsQ0FBYyxZQUFkLEVBQTRCLFVBQVMsSUFBVCxFQUFlLFFBQWYsRUFBeUI7QUFDakQsWUFBSSxTQUFTLElBQVQsSUFBaUIsSUFBckIsRUFBMkI7QUFDdkIsbUJBQU8sU0FBUyxJQUFoQjtBQUNBO0FBQ0g7QUFDSixLQUxEOztBQU9BLFdBQU8sS0FBUCxHQUFlLEVBQWY7QUFDQSxXQUFPLE1BQVAsR0FBZ0IsRUFBaEI7O0FBRUEsUUFBSSxPQUFPLGdCQUFQLEdBQTBCLENBQTlCLEVBQWlDO0FBQzdCLGVBQU8sS0FBUCxDQUFhLEtBQWIsR0FBcUIsT0FBTyxLQUFQLEdBQWUsSUFBcEM7QUFDQSxlQUFPLEtBQVAsQ0FBYSxNQUFiLEdBQXNCLE9BQU8sTUFBUCxHQUFnQixJQUF0Qzs7QUFFQSxlQUFPLEtBQVAsR0FBZSxPQUFPLEtBQVAsR0FBZSxPQUFPLGdCQUFyQztBQUNBLGVBQU8sTUFBUCxHQUFnQixPQUFPLE1BQVAsR0FBZ0IsT0FBTyxnQkFBdkM7QUFDSDs7QUFFRCxXQUFPLFNBQVAsR0FBbUIsNEJBQW5COztBQUVBLGtCQUFjLFdBQWQsR0FBNEIsT0FBNUI7QUFDQSxrQkFBYyxTQUFkLEdBQTBCLE1BQU0sT0FBTyxnQkFBdkM7O0FBRUE7QUFDSCxDQWpGRDs7QUFtRkEsU0FBUyxlQUFULENBQXlCLFVBQXpCLEVBQXFDO0FBQ2pDLFFBQ0ksZ0JBQWdCLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQURwQjtBQUFBLFFBR0ksa0JBQWtCLElBQUksaUJBQUosQ0FBc0IsVUFBdEIsQ0FIdEI7QUFBQSxRQUtJLHNCQUFzQiw0QkFBa0Isc0JBQVksV0FBVyxjQUFYLEdBQTRCLENBQTVCLElBQWlDLFFBQTdDLENBQWxCLENBTDFCO0FBQUEsUUFNSSxvQkFBb0IsNEJBQWtCLHNCQUFZLFdBQVcsY0FBWCxHQUE0QixDQUE1QixJQUFpQyxRQUE3QyxDQUFsQixDQU54Qjs7QUFRQSxhQUFTLGNBQVQsR0FBMEI7QUFDdEIsWUFDSSxXQUFXLElBQUksS0FBSixDQUFVLENBQVYsQ0FEZjs7QUFHQSxpQkFBUyxDQUFULElBQWUsb0JBQW9CLFFBQXBCLE1BQWtDLEVBQW5DLEdBQXlDLG9CQUFvQixXQUFwQixFQUF2RDtBQUNBLGlCQUFTLENBQVQsSUFBZSxrQkFBa0IsUUFBbEIsTUFBZ0MsRUFBakMsR0FBd0Msa0JBQWtCLFdBQWxCLEVBQXREOztBQUVBLG1CQUFXLGNBQVgsQ0FBMEIsUUFBMUI7QUFDSDs7QUFFRCxTQUFLLFVBQUwsR0FBa0IsWUFBVztBQUN6QixlQUFPLGFBQVA7QUFDSCxLQUZEOztBQUlBLGtCQUFjLFNBQWQsR0FBMEIsNkJBQTFCO0FBQ0Esa0JBQWMsS0FBZCxDQUFvQixPQUFwQixHQUE4QixNQUE5Qjs7QUFFQSx3QkFBb0IsRUFBcEIsQ0FBdUIsYUFBdkIsRUFBc0MsY0FBdEM7QUFDQSx3QkFBb0IsRUFBcEIsQ0FBdUIsYUFBdkIsRUFBc0MsY0FBdEM7QUFDQSxzQkFBa0IsRUFBbEIsQ0FBcUIsYUFBckIsRUFBb0MsY0FBcEM7QUFDQSxzQkFBa0IsRUFBbEIsQ0FBcUIsYUFBckIsRUFBb0MsY0FBcEM7O0FBRUEsUUFDSSxLQURKLEVBQ1csV0FEWCxFQUN3QixVQUR4Qjs7QUFHQSxZQUFRLFNBQVMsYUFBVCxDQUF1QixHQUF2QixDQUFSO0FBQ0EsVUFBTSxTQUFOLEdBQWtCLFVBQWxCOztBQUVBLGtCQUFjLFdBQWQsQ0FBMEIsS0FBMUI7QUFDQSxrQkFBYyxXQUFkLENBQTBCLGdCQUFnQixVQUFoQixFQUExQjs7QUFFQSxrQkFBYyxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FBZDtBQUNBLGdCQUFZLFNBQVosR0FBd0IsOEJBQXhCOztBQUVBLGlCQUFhLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFiO0FBQ0EsZUFBVyxTQUFYLEdBQXVCLG1DQUF2Qjs7QUFFQSxlQUFXLFdBQVgsQ0FBdUIsb0JBQW9CLFVBQXBCLEVBQXZCOztBQUVBLGdCQUFZLFdBQVosQ0FBd0IsVUFBeEI7O0FBRUEsaUJBQWEsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWI7QUFDQSxlQUFXLFNBQVgsR0FBdUIsaUNBQXZCOztBQUVBLGVBQVcsV0FBWCxDQUF1QixrQkFBa0IsVUFBbEIsRUFBdkI7O0FBRUEsZ0JBQVksV0FBWixDQUF3QixVQUF4Qjs7QUFFQSxrQkFBYyxXQUFkLENBQTBCLFdBQTFCO0FBQ0g7O0FBRUQsU0FBUyxnQkFBVCxDQUEwQixVQUExQixFQUFzQztBQUNsQyxRQUNJLDBCQUEwQixFQUFDLFFBQVEsUUFBVCxFQUFtQixPQUFPLE9BQTFCLEVBRDlCOztBQUdBLFFBQ0ksUUFBUSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FEWjtBQUFBLFFBR0ksZUFBZSxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FIbkI7QUFBQSxRQUlJLGVBQWUsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBSm5CO0FBQUEsUUFLSSxjQUFjLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUxsQjs7QUFPQSxTQUFLLFVBQUwsR0FBa0IsWUFBVztBQUN6QixlQUFPLEtBQVA7QUFDSCxLQUZEOztBQUlBLFVBQU0sU0FBTixHQUFrQiw4QkFBbEI7QUFDQSxVQUFNLEtBQU4sQ0FBWSxPQUFaLEdBQXNCLE1BQXRCOztBQUVBLGlCQUFhLElBQWIsR0FBb0IsUUFBcEI7QUFDQSxpQkFBYSxJQUFiLEdBQW9CLFFBQXBCOztBQUVBLGlCQUFhLFNBQWIsR0FBeUIsMkJBQXpCO0FBQ0EsaUJBQWEsU0FBYixHQUF5QiwyQkFBekI7O0FBRUEsaUJBQWEsU0FBYixHQUF5QixpQkFBekI7QUFDQSxpQkFBYSxTQUFiLEdBQXlCLFFBQXpCOztBQUVBLGdCQUFZLGdCQUFaLENBQTZCLFFBQTdCLEVBQXVDLFVBQVMsQ0FBVCxFQUFZO0FBQy9DLG1CQUFXLHlCQUFYLENBQXFDLEtBQUssS0FBMUM7QUFDSCxLQUZEOztBQUlBLGdCQUFZLFNBQVosR0FBd0IsbURBQXhCO0FBQ0EsaUJBQWEsV0FBYixFQUEwQix1QkFBMUI7O0FBRUEsUUFBSSxpREFBSixFQUFzQztBQUNsQyxZQUNJLGNBQWMsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRGxCO0FBQUEsWUFFSSxjQUFjLFNBQVMsYUFBVCxDQUF1QixPQUF2QixDQUZsQjs7QUFJQSxvQkFBWSxTQUFaLEdBQXdCLGlCQUF4Qjs7QUFFQSxvQkFBWSxTQUFaLEdBQXdCLFlBQXhCO0FBQ0Esb0JBQVksV0FBWixDQUF3QixXQUF4QjtBQUNBLG9CQUFZLFdBQVosQ0FBd0IsV0FBeEI7O0FBRUEsY0FBTSxXQUFOLENBQWtCLFdBQWxCO0FBQ0g7O0FBRUQsUUFDSSxjQUFjLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQURsQjs7QUFHQSxnQkFBWSxXQUFaLENBQXdCLFlBQXhCO0FBQ0EsZ0JBQVksV0FBWixDQUF3QixZQUF4Qjs7QUFFQSxnQkFBWSxTQUFaLEdBQXdCLFlBQXhCOztBQUVBLFVBQU0sV0FBTixDQUFrQixXQUFsQjs7QUFFQSxpQkFBYSxnQkFBYixDQUE4QixPQUE5QixFQUF1QyxVQUFTLENBQVQsRUFBWTtBQUMvQyxtQkFBVyxlQUFYLENBQTJCLEVBQUMsUUFBUSxtQkFBVCxFQUEzQjtBQUNBLFVBQUUsY0FBRjtBQUNILEtBSEQ7O0FBS0EsaUJBQWEsZ0JBQWIsQ0FBOEIsT0FBOUIsRUFBdUMsVUFBUyxDQUFULEVBQVk7QUFDL0MsbUJBQVcsZUFBWCxDQUEyQixFQUFDLFFBQVEsbUJBQVQsRUFBM0I7QUFDQSxVQUFFLGNBQUY7QUFDSCxLQUhEO0FBSUg7Ozs7Ozs7OztrQkMxWHVCLFE7O0FBaEt4Qjs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOztBQUNBOzs7O0FBQ0E7O0FBRUE7Ozs7QUFFQTs7OztBQUVBOztBQUNBOzs7O0FBQ0E7Ozs7OztBQXBDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNDQSxTQUFTLFdBQVQsR0FBdUI7QUFDbkIsU0FBSyxLQUFMLEdBQWEsRUFBYjtBQUNIOztBQUVEOzs7QUFHQSxZQUFZLGtCQUFaLEdBQWlDLENBQWpDO0FBQ0EsWUFBWSxlQUFaLEdBQThCLENBQTlCOztBQUVBLFlBQVksU0FBWixDQUFzQixPQUF0QixHQUFnQyxVQUFTLEtBQVQsRUFBZ0IsT0FBaEIsRUFBeUI7QUFDckQsUUFDSSxVQUFVLEtBQUssS0FBTCxDQUFXLEtBQVgsQ0FEZDs7QUFHQSxRQUFJLFdBQVcsT0FBZixFQUF3QjtBQUNwQjtBQUNIOztBQUVELFFBQUksT0FBSixFQUFhO0FBQ1QsZ0JBQVEsS0FBUjtBQUNIOztBQUVELFNBQUssS0FBTCxDQUFXLEtBQVgsSUFBb0IsT0FBcEI7QUFDQSxZQUFRLEtBQVI7QUFDSCxDQWREOztBQWdCQSxZQUFZLFNBQVosQ0FBc0IsY0FBdEIsR0FBdUMsVUFBUyxPQUFULEVBQWtCO0FBQ3JELFlBQVEsU0FBUixHQUFvQixLQUFwQjtBQUNBLFlBQVEsT0FBUixHQUFrQixLQUFsQjs7QUFFQSxTQUFLLE9BQUwsQ0FBYSxZQUFZLGtCQUF6QixFQUE2QyxPQUE3QztBQUNILENBTEQ7O0FBT0EsWUFBWSxTQUFaLENBQXNCLFdBQXRCLEdBQW9DLFVBQVMsT0FBVCxFQUFrQjtBQUNsRDtBQUNBLFNBQUssSUFBSSxJQUFJLEtBQUssS0FBTCxDQUFXLE1BQVgsR0FBb0IsQ0FBakMsRUFBb0MsSUFBSSxZQUFZLGVBQXBELEVBQXFFLEdBQXJFLEVBQTBFO0FBQ3RFLGFBQUssS0FBTCxDQUFXLENBQVgsRUFBYyxLQUFkO0FBQ0EsYUFBSyxLQUFMLENBQVcsTUFBWCxDQUFrQixDQUFsQixFQUFxQixDQUFyQjtBQUNIOztBQUVELFlBQVEsU0FBUixHQUFvQixLQUFwQjtBQUNBLFlBQVEsT0FBUixHQUFrQixLQUFsQjs7QUFFQSxTQUFLLE9BQUwsQ0FBYSxZQUFZLGVBQXpCLEVBQTBDLE9BQTFDO0FBQ0gsQ0FYRDs7QUFhQTs7Ozs7OztBQU9BLFlBQVksU0FBWixDQUFzQixZQUF0QixHQUFxQyxVQUFTLEtBQVQsRUFBZ0IsTUFBaEIsRUFBd0I7QUFDekQsU0FBSyxJQUFJLElBQUksS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixDQUFqQyxFQUFvQyxLQUFLLENBQXpDLEVBQTRDLEdBQTVDLEVBQWlEO0FBQzdDLFlBQ0ksT0FBTyxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBRFg7O0FBR0EsWUFBSSxLQUFLLEtBQUwsRUFBWSxLQUFaLENBQWtCLElBQWxCLEVBQXdCLE1BQXhCLEtBQW1DLEtBQUssT0FBTCxJQUFnQixTQUFTLE9BQWhFLEVBQXlFO0FBQ3JFO0FBQ0EsbUJBQU8sSUFBUDtBQUNIO0FBQ0o7O0FBRUQsV0FBTyxLQUFQO0FBQ0gsQ0FaRDs7QUFjQTtXQUNzQixDQUFDLFdBQUQsRUFBYyxTQUFkLEM7OztBQUFqQixRQUFJLG9CQUFKO0FBQ0QsZ0JBQVksU0FBWixDQUFzQixTQUF0QixJQUFtQyxVQUFVLENBQVYsRUFBYSxNQUFiLEVBQXFCLFFBQXJCLEVBQStCO0FBQzlELGFBQUssWUFBTCxDQUFrQixTQUFsQixFQUE2QixDQUFDLENBQUQsRUFBSSxNQUFKLEVBQVksUUFBWixDQUE3QjtBQUNILEtBRkQ7OztBQURKLHlDQUFnRDtBQUFBO0FBSS9DOztZQUVxQixDQUFDLFdBQUQsRUFBYyxXQUFkLEM7OztBQUFqQixRQUFJLHNCQUFKO0FBQ0QsZ0JBQVksU0FBWixDQUFzQixTQUF0QixJQUFtQyxVQUFVLENBQVYsRUFBYSxRQUFiLEVBQXVCO0FBQ3RELGFBQUssWUFBTCxDQUFrQixTQUFsQixFQUE2QixDQUFDLENBQUQsRUFBSSxRQUFKLENBQTdCO0FBQ0gsS0FGRDs7O0FBREosNkNBQWtEO0FBQUE7QUFJakQ7O1lBRXFCLENBQUMsU0FBRCxFQUFZLE9BQVosQzs7O0FBQWpCLFFBQUksc0JBQUo7QUFDRCxnQkFBWSxTQUFaLENBQXNCLFNBQXRCLElBQW1DLFVBQVUsQ0FBVixFQUFhO0FBQzVDLFlBQUksS0FBSyxZQUFMLENBQWtCLFNBQWxCLEVBQTZCLENBQUMsQ0FBRCxDQUE3QixDQUFKLEVBQXVDO0FBQ25DO0FBQ0EsY0FBRSxjQUFGO0FBQ0g7QUFDSixLQUxEOzs7QUFESiw2Q0FBNEM7QUFBQTtBQU8zQzs7QUFFRCxZQUFZLFNBQVosQ0FBc0IsS0FBdEIsR0FBOEIsVUFBUyxPQUFULEVBQWtCO0FBQzVDLFNBQUssWUFBTCxDQUFrQixPQUFsQixFQUEyQixDQUFDLE9BQUQsQ0FBM0I7QUFDSCxDQUZEOztBQUlBOzs7Ozs7QUFNQSxZQUFZLFNBQVosQ0FBc0IsSUFBdEIsR0FBNkIsVUFBUyxJQUFULEVBQWUsU0FBZixFQUEwQjtBQUNuRCxRQUNJLGNBQWMsS0FBSyxJQUFMLEVBRGxCOztBQUdBLFFBQUksV0FBSixFQUFpQjtBQUNiLG9CQUFZLE9BQVo7QUFDSDs7QUFFRCxTQUFLLFNBQUwsR0FBaUIsU0FBakI7QUFDQSxTQUFLLE9BQUwsR0FBZSxLQUFmOztBQUVBLFNBQUssS0FBTDs7QUFFQSxTQUFLLEtBQUwsQ0FBVyxJQUFYLENBQWdCLElBQWhCO0FBQ0gsQ0FkRDs7QUFnQkEsWUFBWSxTQUFaLENBQXNCLElBQXRCLEdBQTZCLFlBQVc7QUFDcEMsUUFBSSxLQUFLLEtBQUwsQ0FBVyxNQUFYLEdBQW9CLENBQXhCLEVBQTJCO0FBQ3ZCLGVBQU8sS0FBSyxLQUFMLENBQVcsS0FBSyxLQUFMLENBQVcsTUFBWCxHQUFvQixDQUEvQixDQUFQO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsZUFBTyxJQUFQO0FBQ0g7QUFDSixDQU5EOztBQVFBOzs7OztBQUtBLFlBQVksU0FBWixDQUFzQixHQUF0QixHQUE0QixZQUFXO0FBQ25DLFFBQ0ksZUFBZSxLQUFLLEtBQUwsQ0FBVyxHQUFYLEVBRG5CO0FBQUEsUUFFSSxTQUFTLEtBQUssSUFBTCxFQUZiOztBQUlBLFFBQUksWUFBSixFQUFrQjtBQUNkLHFCQUFhLEtBQWI7QUFDSDs7QUFFRCxRQUFJLE1BQUosRUFBWTtBQUNSLGVBQU8sTUFBUDtBQUNIOztBQUVELFdBQU8sTUFBUDtBQUNILENBZEQ7O0FBZ0JlLFNBQVMsUUFBVCxDQUFrQixVQUFsQixFQUE4QjtBQUN6QyxRQUNJLGlCQUFpQixDQURyQjtBQUFBLFFBRUksZUFBZSxDQUZuQjtBQUFBLFFBR0ksbUJBQW1CLENBSHZCO0FBQUEsUUFLSSxXQUFXLElBTGY7QUFBQSxRQU1JLFdBQVcsSUFOZjtBQUFBLFFBUUksaUJBQWlCLFNBUnJCO0FBQUEsUUFRZ0Msa0JBQWtCLE1BUmxEO0FBQUEsUUFRMEQsaUJBQWlCLFVBUjNFO0FBQUEsUUFRdUYsbUJBQW1CLFdBUjFHO0FBQUEsUUFTSSxjQUFjLE1BVGxCO0FBQUEsUUFTMEIscUJBQXFCLGFBVC9DO0FBQUEsUUFTOEQscUJBQXFCLGFBVG5GO0FBQUEsUUFVSSxtQkFBbUIsV0FWdkI7QUFBQSxRQVVvQyxtQkFBbUIsV0FWdkQ7O0FBWUEsUUFDSSxPQUFPLElBRFg7QUFBQSxRQUdJLGtCQUFrQixTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FIdEI7QUFBQSxRQUlJLHFCQUFxQixTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FKekI7QUFBQSxRQUtJLHdCQUF3QixTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FMNUI7OztBQU9JO0FBQ0EsYUFBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FSYjtBQUFBLFFBU0ksZ0JBQWdCLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQVRwQjs7O0FBV0k7QUFDQSxvQkFBZ0IsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBWnBCO0FBQUEsUUFhSSx1QkFBdUIsY0FBYyxVQUFkLENBQXlCLElBQXpCLENBYjNCO0FBQUEsUUFlSSxzQkFBc0IsMkNBQTBCLGFBQTFCLENBZjFCO0FBQUEsUUFpQkksVUFBVSxXQUFXLFVBQVgsRUFqQmQ7OztBQW1CSTtBQUNBLFdBQU8sQ0FwQlg7QUFBQSxRQXFCSSxVQUFVLENBckJkO0FBQUEsUUFxQmlCLFVBQVUsQ0FyQjNCO0FBQUEsUUFzQkksaUJBQWlCLEdBdEJyQjtBQUFBLFFBdUJJLFlBQVksMkJBdkJoQjtBQUFBLFFBd0JJLGdCQUFnQixLQXhCcEI7OztBQTBCSTtBQUNBLGVBQVcsS0EzQmY7QUFBQSxRQTRCSSxXQUFXLEVBNUJmO0FBQUEsUUE4QkksU0FBUyxDQTlCYjtBQUFBLFFBOEJnQixTQUFTLENBOUJ6QjtBQUFBLFFBZ0NJLFVBQVUsS0FoQ2Q7QUFBQSxRQWdDcUIsWUFBWSxDQUFDLEtBQUQsRUFBUSxLQUFSLEVBQWUsS0FBZixDQWhDakMsQ0FnQ3VELHFDQWhDdkQ7QUFBQSxRQWdDOEYsZUFBZSxLQWhDN0c7OztBQWtDSTs7Ozs7QUFLQSwwQkFBc0IscUJBQVcsQ0FBWCxFQUFjLENBQWQsRUFBaUIsUUFBUSxLQUF6QixFQUFnQyxRQUFRLE1BQXhDLENBdkMxQjs7O0FBeUNJOzs7O0FBSUEsb0JBQWdCLHFCQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLENBQWpCLEVBQW9CLENBQXBCLENBN0NwQjtBQUFBLFFBOENJLG1CQUFtQixLQTlDdkI7OztBQWdESTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQXJESjtBQUFBLFFBc0RJLGVBdERKO0FBQUEsUUF1REksT0F2REo7QUFBQSxRQXdESSxnQkF4REo7QUFBQSxRQXlESSxhQXpESjtBQUFBLFFBMERJLGdCQTFESjtBQUFBLFFBMkRJLGlCQTNESjtBQUFBLFFBNERJLFlBNURKO0FBQUEsUUE2REksYUE3REo7OztBQStESTtBQUNBLG1CQUFlLEVBaEVuQjtBQUFBLFFBa0VJLFlBQVksSUFBSSxXQUFKLEVBbEVoQjtBQUFBLFFBb0VJLFdBcEVKO0FBQUEsUUFvRWlCLGVBcEVqQjtBQUFBLFFBc0VJLGFBQWEsMEJBQWdCLEtBQWhCLENBdEVqQjtBQUFBLFFBdUVJLGFBQWEsMEJBQWdCLElBQWhCLENBdkVqQjtBQUFBLFFBeUVJLFNBQVMsd0JBQWMsTUFBZCxFQXpFYjs7QUEyRUEsU0FBSyxJQUFMLEdBQVksS0FBSyxJQUFMLElBQWEsVUFBUyxDQUFULEVBQVk7QUFDakMsWUFBSSxDQUFDLENBQUwsQ0FEaUMsQ0FDekI7QUFDUixZQUFJLE1BQU0sQ0FBTixJQUFXLE1BQU0sQ0FBTixDQUFmLEVBQXlCO0FBQ3JCLG1CQUFPLENBQVA7QUFDSDtBQUNELGVBQU8sSUFBSSxDQUFKLEdBQVEsQ0FBUixHQUFZLENBQUMsQ0FBcEI7QUFDSCxLQU5EOztBQVFBO0FBQ0EsYUFBUyxNQUFULEdBQWtCLENBQ2pCOztBQUVKOzs7OztBQUtHLFdBQU8sU0FBUCxDQUFpQixTQUFqQixHQUE2QixLQUE3Qjs7QUFFSDs7Ozs7OztBQU9HLFdBQU8sU0FBUCxDQUFpQixPQUFqQixHQUEyQixLQUEzQjs7QUFFQSxXQUFPLFNBQVAsQ0FBaUIsS0FBakIsR0FBeUIsWUFBVztBQUNoQyxrQkFBVSxjQUFWO0FBQ0gsS0FGRDs7QUFJQSxXQUFPLFNBQVAsQ0FBaUIsS0FBakIsR0FBeUIsWUFBVztBQUNoQyxhQUFLLE9BQUwsR0FBZSxLQUFmO0FBQ0gsS0FGRDs7QUFJQSxXQUFPLFNBQVAsQ0FBaUIsU0FBakIsR0FBNkIsT0FBTyxTQUFQLENBQWlCLEtBQWpCLEdBQXlCLE9BQU8sU0FBUCxDQUFpQixTQUFqQixHQUNoRCxPQUFPLFNBQVAsQ0FBaUIsU0FBakIsR0FBNkIsT0FBTyxTQUFQLENBQWlCLE9BQWpCLEdBQTJCLE9BQU8sU0FBUCxDQUFpQixPQUFqQixHQUN4RCxPQUFPLFNBQVAsQ0FBaUIsT0FBakIsR0FBMkIsT0FBTyxTQUFQLENBQWlCLE1BQWpCLEdBQTBCLE9BQU8sU0FBUCxDQUFpQixLQUFqQixHQUF5QixZQUFXLENBQUUsQ0FGakc7O0FBSUE7QUFDQTtBQUNBOztBQUVBLGFBQVMsYUFBVCxHQUF5QixDQUN4Qjs7QUFFRCxrQkFBYyxTQUFkLEdBQTBCLE9BQU8sTUFBUCxDQUFjLE9BQU8sU0FBckIsQ0FBMUI7QUFDQSxrQkFBYyxTQUFkLENBQXdCLFdBQXhCLEdBQXNDLGFBQXRDOztBQUVBLGtCQUFjLFNBQWQsQ0FBd0IsU0FBeEIsR0FBb0MsVUFBUyxDQUFULEVBQVksTUFBWixFQUFvQixRQUFwQixFQUE4QjtBQUM5RCxZQUNJLGVBQWUsSUFBSSxTQUFKLENBQWMsT0FBZCxDQURuQjs7QUFHQSxZQUFJLENBQUMsWUFBRCxLQUNRLFVBQVUsZ0JBQVYsSUFBOEIsVUFBVSxjQUFWLElBQTRCLEVBQUUsTUFEcEUsQ0FBSixFQUNpRjtBQUM3RSxzQkFBVSxJQUFWLENBQWUsZUFBZixFQUFnQyxJQUFoQztBQUNBO0FBQ0Esc0JBQVUsSUFBVixHQUFpQixTQUFqQixDQUEyQixDQUEzQixFQUE4QixNQUE5QixFQUFzQyxRQUF0QztBQUNILFNBTEQsTUFLTyxJQUFJLFVBQVUsWUFBVixJQUEwQixnQkFBZ0IsVUFBVSxjQUF4RCxFQUF3RTtBQUMzRSxnQkFBSSxFQUFFLE1BQU4sRUFBYztBQUNWLDBCQUFVLElBQVYsQ0FBZSxnQkFBZixFQUFpQyxJQUFqQztBQUNBLDBCQUFVLElBQVYsR0FBaUIsU0FBakIsQ0FBMkIsQ0FBM0IsRUFBOEIsTUFBOUIsRUFBc0MsUUFBdEM7QUFDSCxhQUhELE1BR087QUFDSCwwQkFBVSxJQUFWLENBQWUsT0FBZixFQUF3QixJQUF4QjtBQUNBLDBCQUFVLElBQVYsR0FBaUIsU0FBakIsQ0FBMkIsQ0FBM0IsRUFBOEIsTUFBOUIsRUFBc0MsUUFBdEM7QUFDSDtBQUNKO0FBQ0osS0FsQkQ7O0FBb0JBLGtCQUFjLFNBQWQsQ0FBd0IsT0FBeEIsR0FBa0MsVUFBUyxDQUFULEVBQVk7QUFDMUMsWUFBSSxFQUFFLE9BQUYsSUFBYSxFQUFqQixDQUFvQixXQUFwQixFQUFpQztBQUM3QixvQkFBSSxFQUFFLE1BQU4sRUFBYztBQUNWLDhCQUFVLElBQVYsQ0FBZSxnQkFBZixFQUFpQyxJQUFqQztBQUNBLDhCQUFVLElBQVYsR0FBaUIsT0FBakIsQ0FBeUIsQ0FBekI7QUFDSCxpQkFIRCxNQUdPO0FBQ0g7QUFDQSw4QkFBVSxJQUFWLENBQWUsT0FBZixFQUF3QixJQUF4QjtBQUNBLDhCQUFVLElBQVYsR0FBaUIsT0FBakIsQ0FBeUIsQ0FBekI7QUFDSDtBQUNELHVCQUFPLElBQVA7QUFDSDtBQUNKLEtBWkQ7O0FBY0g7Ozs7O0FBS0csYUFBUyxhQUFULEdBQXlCO0FBQ3JCLGFBQUssdUJBQUwsR0FBK0IsS0FBL0I7O0FBRUE7QUFDQSxhQUFLLGNBQUwsR0FBc0IsSUFBdEI7QUFDSDs7QUFFRCxrQkFBYyxTQUFkLEdBQTBCLE9BQU8sTUFBUCxDQUFjLE9BQU8sU0FBckIsQ0FBMUI7QUFDQSxrQkFBYyxTQUFkLENBQXdCLFdBQXhCLEdBQXNDLGFBQXRDOztBQUVBOzs7QUFHQSxrQkFBYyxTQUFkLENBQXdCLG1CQUF4QixHQUE4QyxZQUFXO0FBQ3JELFlBQ0ksWUFBWSxXQUFXLFlBQVgsS0FBNEIsSUFENUM7O0FBR0EsZUFBTyxxQkFDSCxTQUFTLFlBQVksQ0FEbEIsRUFFSCxTQUFTLFlBQVksQ0FGbEIsRUFHSCxTQUFTLFlBQVksQ0FIbEIsRUFJSCxTQUFTLFlBQVksQ0FKbEIsQ0FBUDtBQU1ILEtBVkQ7O0FBWUE7OztBQUdBLGtCQUFjLFNBQWQsQ0FBd0IsaUJBQXhCLEdBQTRDLFlBQVc7QUFDbkQ7OztBQUdBLFlBQUksVUFBVSxJQUFWLE1BQW9CLElBQXhCLEVBQThCO0FBQzFCO0FBQ0g7O0FBRUQsYUFBSyx1QkFBTCxHQUErQixJQUEvQjs7QUFFQSxZQUNJLE9BQU8sS0FBSyxtQkFBTCxFQURYOztBQUdBLGFBQUssSUFBTCxDQUFVLENBQVYsRUFBYSxDQUFiOztBQUVBO0FBQ0EsWUFBSSxLQUFLLGNBQUwsSUFBdUIsSUFBM0IsRUFBaUM7QUFDN0IsaUJBQUssS0FBTCxDQUFXLEtBQUssY0FBaEI7QUFDQSxpQkFBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0g7O0FBRUQsb0JBQVksSUFBWjtBQUNILEtBdEJEOztBQXdCSDs7O0FBR0csa0JBQWMsU0FBZCxDQUF3QixpQkFBeEIsR0FBNEMsWUFBVztBQUNuRCxhQUFLLHVCQUFMLEdBQStCLEtBQS9COztBQUVBLFlBQUksS0FBSyxjQUFMLElBQXVCLElBQTNCLEVBQWlDO0FBQzdCLHdCQUFZLEtBQUssY0FBakI7QUFDQSxpQkFBSyxjQUFMLEdBQXNCLElBQXRCO0FBQ0g7QUFDSixLQVBEOztBQVNBLGtCQUFjLFNBQWQsQ0FBd0IsU0FBeEIsR0FBb0MsVUFBUyxDQUFULEVBQVksUUFBWixFQUFzQjtBQUN0RCxhQUFLLGlCQUFMO0FBQ0gsS0FGRDs7QUFJQSxrQkFBYyxTQUFkLENBQXdCLEtBQXhCLEdBQWdDLFlBQVc7QUFDdkMsZUFBTyxTQUFQLENBQWlCLEtBQWpCLENBQXVCLElBQXZCLENBQTRCLElBQTVCOztBQUVBLFlBQUksT0FBSixFQUFhO0FBQ1QsaUJBQUssaUJBQUw7QUFDSDtBQUNKLEtBTkQ7O0FBUUEsa0JBQWMsU0FBZCxDQUF3QixLQUF4QixHQUFnQyxZQUFXO0FBQ3ZDLGVBQU8sU0FBUCxDQUFpQixLQUFqQixDQUF1QixJQUF2QixDQUE0QixJQUE1QjtBQUNBLGFBQUssaUJBQUw7QUFDSCxLQUhEOztBQUtBLGtCQUFjLFNBQWQsQ0FBd0IsT0FBeEIsR0FBa0MsY0FBYyxTQUFkLENBQXdCLEtBQTFEO0FBQ0Esa0JBQWMsU0FBZCxDQUF3QixNQUF4QixHQUFpQyxjQUFjLFNBQWQsQ0FBd0IsS0FBekQ7O0FBRUEsa0JBQWMsU0FBZCxDQUF3QixLQUF4QixHQUFnQyxZQUFXO0FBQ3ZDLFlBQUksS0FBSyx1QkFBVCxFQUFrQztBQUM5QixpQkFBSyx1QkFBTCxHQUErQixLQUEvQjs7QUFFQSxnQkFDSSxJQUFJLEtBQUssbUJBQUwsRUFEUjs7QUFHQSwwQkFBYyxTQUFkOztBQUVBLDBCQUFjLEdBQWQsQ0FDSSxDQUFDLEVBQUUsSUFBRixHQUFTLEVBQUUsS0FBWixJQUFxQixDQUR6QixFQUVJLENBQUMsRUFBRSxHQUFGLEdBQVEsRUFBRSxNQUFYLElBQXFCLENBRnpCLEVBR0ksRUFBRSxRQUFGLEtBQWUsQ0FIbkIsRUFJSSxDQUpKLEVBS0ksS0FBSyxFQUFMLEdBQVUsQ0FMZDs7QUFRQSwwQkFBYyxNQUFkOztBQUVBLGNBQUUsSUFBRixDQUFPLENBQVAsRUFBVSxDQUFWOztBQUVBLGdCQUFJLEtBQUssY0FBTCxJQUF1QixJQUEzQixFQUFpQztBQUM3QixxQkFBSyxjQUFMLEdBQXNCLENBQXRCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gscUJBQUssY0FBTCxDQUFvQixLQUFwQixDQUEwQixDQUExQjtBQUNIO0FBQ0o7QUFDSixLQTNCRDs7QUE2QkEsYUFBUyxjQUFULEdBQTBCO0FBQ3RCLHNCQUFjLElBQWQsQ0FBbUIsSUFBbkI7O0FBRUEsYUFBSyxXQUFMLEdBQW1CLEVBQUMsR0FBRSxHQUFILEVBQVEsR0FBRSxHQUFWLEVBQW5CO0FBQ0g7O0FBRUQsbUJBQWUsU0FBZixHQUEyQixPQUFPLE1BQVAsQ0FBYyxjQUFjLFNBQTVCLENBQTNCO0FBQ0EsbUJBQWUsU0FBZixDQUF5QixXQUF6QixHQUF1QyxjQUF2Qzs7QUFFQSxtQkFBZSxTQUFmLENBQXlCLFNBQXpCLEdBQXFDLFVBQVMsQ0FBVCxFQUFZLE1BQVosRUFBb0IsUUFBcEIsRUFBOEI7QUFDL0QsWUFBSSxDQUFDLEtBQUssT0FBTixJQUFpQixVQUFVLGNBQTNCLElBQTZDLENBQUMsRUFBRSxNQUFoRCxJQUEwRCxDQUFDLElBQUksU0FBSixDQUFjLE9BQWQsQ0FBM0QsSUFBcUYsdUJBQXpGLEVBQWtIO0FBQzlHLGdCQUNJLEtBQUssZ0JBQWdCLEVBQUMsR0FBRyxNQUFKLEVBQVksR0FBRSxNQUFkLEVBQWhCLENBRFQ7O0FBR0EsaUJBQUssaUJBQUw7O0FBRUEsaUJBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxvQkFBUSxXQUFSLENBQW9CLEdBQUcsQ0FBdkIsRUFBMEIsR0FBRyxDQUE3QixFQUFnQyxRQUFoQzs7QUFFQSxpQkFBSyxXQUFMLEdBQW1CLEVBQW5COztBQUVBLG1CQUFPLElBQVA7QUFDSDtBQUNKLEtBZEQ7O0FBZ0JBLG1CQUFlLFNBQWYsQ0FBeUIsU0FBekIsR0FBcUMsVUFBUyxDQUFULEVBQVksUUFBWixFQUFzQjtBQUN2RCxZQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLGdCQUNJLEtBQUssZ0JBQWdCLEVBQUMsR0FBRyxNQUFKLEVBQVksR0FBRyxNQUFmLEVBQWhCLENBRFQ7QUFBQSxnQkFFSSxZQUFZLEtBQUssR0FBTCxDQUFTLEtBQVQsRUFBZ0IsS0FBSyxHQUFMLENBQVMsV0FBVyxZQUFYLEdBQTBCLFNBQW5DLEVBQThDLEdBQTlDLENBQWhCLENBRmhCOztBQUlBLGlCQUFLLFdBQUwsQ0FBaUIsQ0FBakIsR0FBcUIsQ0FBQyxNQUFNLFNBQVAsSUFBb0IsR0FBRyxDQUF2QixHQUEyQixZQUFZLEtBQUssV0FBTCxDQUFpQixDQUE3RTtBQUNBLGlCQUFLLFdBQUwsQ0FBaUIsQ0FBakIsR0FBcUIsQ0FBQyxNQUFNLFNBQVAsSUFBb0IsR0FBRyxDQUF2QixHQUEyQixZQUFZLEtBQUssV0FBTCxDQUFpQixDQUE3RTs7QUFFQSxvQkFBUSxjQUFSLENBQXVCLEtBQUssV0FBTCxDQUFpQixDQUF4QyxFQUEyQyxLQUFLLFdBQUwsQ0FBaUIsQ0FBNUQsRUFBK0QsUUFBL0Q7O0FBRUEsbUJBQU8sSUFBUDtBQUNILFNBWEQsTUFXTztBQUNILGlCQUFLLFNBQUwsQ0FBZSxDQUFmO0FBQ0g7QUFDSixLQWZEOztBQWlCQSxtQkFBZSxTQUFmLENBQXlCLE9BQXpCLEdBQW1DLFVBQVMsQ0FBVCxFQUFZLE1BQVosRUFBb0IsUUFBcEIsRUFBOEI7QUFDN0QsWUFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDZCxnQkFBSSxVQUFVLGNBQWQsRUFBOEI7QUFDMUIscUJBQUssT0FBTCxHQUFlLEtBQWY7QUFDQSx3QkFBUSxTQUFSO0FBQ0g7QUFDRCxtQkFBTyxJQUFQO0FBQ0g7QUFDSixLQVJEOztBQVVBLGFBQVMsVUFBVCxHQUFzQjtBQUNsQixZQUNJLFlBREo7QUFBQSxZQUNrQixVQURsQjtBQUFBLFlBRUkscUJBQXFCLENBRnpCOztBQUlBLGFBQUssU0FBTCxHQUFpQixVQUFTLENBQVQsRUFBWSxNQUFaLEVBQW9CLFFBQXBCLEVBQThCO0FBQzNDLGdCQUFJLENBQUMsS0FBSyxPQUFOLElBQWlCLFVBQVUsY0FBM0IsSUFBNkMsQ0FBQyxFQUFFLE1BQWhELElBQTBELENBQUMsSUFBSSxTQUFKLENBQWMsT0FBZCxDQUEzRCxJQUFxRix1QkFBekYsRUFBa0g7QUFDOUcscUJBQUssT0FBTCxHQUFlLElBQWY7QUFDQSwrQkFBZSxhQUFhLEVBQUMsR0FBRyxTQUFTLEdBQWIsRUFBa0IsR0FBRyxTQUFTLEdBQTlCLEVBQTVCOztBQUVBLHFCQUFLLGlCQUFMOztBQUVBLHVCQUFPLElBQVA7QUFDSDtBQUNKLFNBVEQ7O0FBV0EsYUFBSyxTQUFMLEdBQWlCLFVBQVMsQ0FBVCxFQUFZO0FBQ3pCLGdCQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkO0FBQ0E7QUFDSSxpQ0FBaUIscUJBQ2IsS0FBSyxHQUFMLENBQVMsYUFBYSxDQUF0QixFQUF5QixXQUFXLENBQXBDLElBQXlDLGtCQUF6QyxHQUE4RCxDQURqRCxFQUViLEtBQUssR0FBTCxDQUFTLGFBQWEsQ0FBdEIsRUFBeUIsV0FBVyxDQUFwQyxJQUF5QyxrQkFBekMsR0FBOEQsQ0FGakQsRUFHYixLQUFLLEdBQUwsQ0FBUyxhQUFhLENBQXRCLEVBQXlCLFdBQVcsQ0FBcEMsSUFBeUMsa0JBQXpDLEdBQThELENBQTlELEdBQWtFLENBSHJELEVBSWIsS0FBSyxHQUFMLENBQVMsYUFBYSxDQUF0QixFQUF5QixXQUFXLENBQXBDLElBQXlDLGtCQUF6QyxHQUE4RCxDQUE5RCxHQUFrRSxDQUpyRCxDQUZyQjs7QUFTQSw2QkFBYSxFQUFDLEdBQUcsU0FBUyxHQUFiLEVBQWtCLEdBQUcsU0FBUyxHQUE5QixFQUFiLENBVmMsQ0FVbUM7O0FBRWpELG9CQUFJLEVBQUUsUUFBTixFQUFnQjtBQUNaO0FBQ0Esd0JBQ0ksT0FBTyxLQUFLLEVBQUwsR0FBVSxDQURyQjtBQUFBLHdCQUVJLFFBQVEsS0FBSyxLQUFMLENBQVcsS0FBSyxLQUFMLENBQVcsV0FBVyxDQUFYLEdBQWUsYUFBYSxDQUF2QyxFQUEwQyxXQUFXLENBQVgsR0FBZSxhQUFhLENBQXRFLElBQTJFLElBQXRGLENBRlo7O0FBSUEsNEJBQVEsS0FBUjtBQUNJLDZCQUFLLENBQUw7QUFDQSw2QkFBSyxDQUFMO0FBQ0ksdUNBQVcsQ0FBWCxHQUFlLGFBQWEsQ0FBNUI7QUFDQTs7QUFFSiw2QkFBSyxDQUFMO0FBQ0EsNkJBQUssQ0FBTDtBQUNJLHVDQUFXLENBQVgsR0FBZSxhQUFhLENBQTVCO0FBQ0E7O0FBRUo7QUFDSSxxQ0FBUyxJQUFUOztBQUVBLGdDQUNJLFNBQVMsS0FBSyxJQUFMLENBQVUsQ0FBQyxXQUFXLENBQVgsR0FBZSxhQUFhLENBQTdCLEtBQW1DLFdBQVcsQ0FBWCxHQUFlLGFBQWEsQ0FBL0QsSUFBb0UsQ0FBQyxXQUFXLENBQVgsR0FBZSxhQUFhLENBQTdCLEtBQW1DLFdBQVcsQ0FBWCxHQUFlLGFBQWEsQ0FBL0QsQ0FBOUUsQ0FEYjs7QUFHQSx1Q0FBVyxDQUFYLEdBQWUsYUFBYSxDQUFiLEdBQWlCLFNBQVMsS0FBSyxHQUFMLENBQVMsS0FBVCxDQUF6QztBQUNBLHVDQUFXLENBQVgsR0FBZSxhQUFhLENBQWIsR0FBaUIsU0FBUyxLQUFLLEdBQUwsQ0FBUyxLQUFULENBQXpDO0FBbEJSO0FBb0JIOztBQUVEO0FBQ0EsK0JBQWUsS0FBZixDQUFxQixxQkFDakIsS0FBSyxHQUFMLENBQVMsYUFBYSxDQUF0QixFQUF5QixXQUFXLENBQXBDLElBQXlDLGtCQUF6QyxHQUE4RCxDQUQ3QyxFQUVqQixLQUFLLEdBQUwsQ0FBUyxhQUFhLENBQXRCLEVBQXlCLFdBQVcsQ0FBcEMsSUFBeUMsa0JBQXpDLEdBQThELENBRjdDLEVBR2pCLEtBQUssR0FBTCxDQUFTLGFBQWEsQ0FBdEIsRUFBeUIsV0FBVyxDQUFwQyxJQUF5QyxrQkFBekMsR0FBOEQsQ0FBOUQsR0FBa0UsQ0FIakQsRUFJakIsS0FBSyxHQUFMLENBQVMsYUFBYSxDQUF0QixFQUF5QixXQUFXLENBQXBDLElBQXlDLGtCQUF6QyxHQUE4RCxDQUE5RCxHQUFrRSxDQUpqRCxDQUFyQjs7QUFPQSw0QkFBWSxjQUFaOztBQUVBLHVCQUFPLElBQVA7QUFDSCxhQW5ERCxNQW1ETztBQUNILHFCQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLElBQXBCLEVBQTBCLENBQTFCO0FBQ0g7QUFDSixTQXZERDs7QUF5REEsYUFBSyxPQUFMLEdBQWUsVUFBUyxDQUFULEVBQVksTUFBWixFQUFvQixRQUFwQixFQUE4QjtBQUN6QyxnQkFBSSxLQUFLLE9BQUwsSUFBZ0IsVUFBVSxjQUE5QixFQUE4QztBQUMxQyxvQkFDSSxPQUFPLGdCQUFnQixZQUFoQixDQURYO0FBQUEsb0JBRUksS0FBSyxnQkFBZ0IsVUFBaEIsQ0FGVDs7QUFJQSxxQkFBSyxPQUFMLEdBQWUsS0FBZjs7QUFFQSxxQkFBSyxRQUFMLENBQWMsSUFBZCxFQUFvQixFQUFwQjs7QUFFQSxvQkFDSSxpQkFBaUIscUJBQ2IsS0FBSyxHQUFMLENBQVMsYUFBYSxDQUF0QixFQUF5QixXQUFXLENBQXBDLElBQXlDLGtCQUF6QyxHQUE4RCxDQURqRCxFQUViLEtBQUssR0FBTCxDQUFTLGFBQWEsQ0FBdEIsRUFBeUIsV0FBVyxDQUFwQyxJQUF5QyxrQkFBekMsR0FBOEQsQ0FGakQsRUFHYixLQUFLLEdBQUwsQ0FBUyxhQUFhLENBQXRCLEVBQXlCLFdBQVcsQ0FBcEMsSUFBeUMsa0JBQXpDLEdBQThELENBQTlELEdBQWtFLENBSHJELEVBSWIsS0FBSyxHQUFMLENBQVMsYUFBYSxDQUF0QixFQUF5QixXQUFXLENBQXBDLElBQXlDLGtCQUF6QyxHQUE4RCxDQUE5RCxHQUFrRSxDQUpyRCxDQURyQjs7QUFRQSw0QkFBWSxjQUFaOztBQUVBLHVCQUFPLElBQVA7QUFDSDtBQUNKLFNBdEJEOztBQXdCQSxhQUFLLEtBQUwsR0FBYSxZQUFXO0FBQ3BCLGdCQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLDhCQUFjLFNBQWQsR0FBMEIsa0JBQTFCO0FBQ0EsOEJBQWMsU0FBZDtBQUNBLDhCQUFjLE1BQWQsQ0FBcUIsYUFBYSxDQUFsQyxFQUFxQyxhQUFhLENBQWxEO0FBQ0EsOEJBQWMsTUFBZCxDQUFxQixXQUFXLENBQWhDLEVBQW1DLFdBQVcsQ0FBOUM7QUFDQSw4QkFBYyxNQUFkO0FBQ0gsYUFORCxNQU1PO0FBQ0g7QUFDQSw4QkFBYyxTQUFkLENBQXdCLEtBQXhCLENBQThCLElBQTlCLENBQW1DLElBQW5DO0FBQ0g7QUFDSixTQVhEOztBQWFBLHNCQUFjLElBQWQsQ0FBbUIsSUFBbkI7QUFDSDs7QUFFRCxlQUFXLFNBQVgsR0FBdUIsT0FBTyxNQUFQLENBQWMsY0FBYyxTQUE1QixDQUF2QjtBQUNBLGVBQVcsU0FBWCxDQUFxQixXQUFyQixHQUFtQyxVQUFuQzs7QUFFQSxlQUFXLFNBQVgsQ0FBcUIsUUFBckIsR0FBZ0MsVUFBUyxJQUFULEVBQWUsRUFBZixFQUFtQjtBQUMvQyxnQkFBUSxXQUFSLENBQW9CLEtBQUssQ0FBekIsRUFBNEIsS0FBSyxDQUFqQyxFQUFvQyxDQUFwQztBQUNBLGdCQUFRLGNBQVIsQ0FBdUIsR0FBRyxDQUExQixFQUE2QixHQUFHLENBQWhDLEVBQW1DLENBQW5DO0FBQ0EsZ0JBQVEsU0FBUjtBQUNILEtBSkQ7O0FBTUEsYUFBUyxZQUFULEdBQXdCO0FBQ3BCLFlBQ0ksZ0JBQWdCLEdBRHBCO0FBQUEsWUFFSSx3QkFBd0IsR0FGNUI7O0FBSUEsWUFDSSxpQkFBaUIsQ0FEckI7QUFBQSxZQUN3QjtBQUNwQixvQkFGSjtBQUFBLFlBRWtCLFlBRmxCO0FBQUEsWUFFZ0MsWUFGaEM7QUFBQSxZQUU4QyxZQUY5Qzs7QUFJQSxhQUFLLFNBQUwsR0FBaUIsVUFBUyxDQUFULEVBQVksTUFBWixFQUFvQixRQUFwQixFQUE4QjtBQUMzQyxnQkFBSSxDQUFDLEtBQUssT0FBTixJQUFpQixVQUFVLGNBQTNCLElBQTZDLENBQUMsRUFBRSxNQUFoRCxJQUEwRCxDQUFDLElBQUksU0FBSixDQUFjLE9BQWQsQ0FBM0QsSUFBcUYsdUJBQXpGLEVBQWtIO0FBQzlHLG9CQUNJLElBQUksZ0JBQWdCLEVBQUMsR0FBRyxNQUFKLEVBQVksR0FBRyxNQUFmLEVBQWhCLENBRFI7O0FBR0EsaUNBQWlCLENBQWpCO0FBQ0EsK0JBQWUsZUFBZSxlQUFlLGVBQWUsQ0FBNUQ7QUFDQSxxQkFBSyxPQUFMLEdBQWUsSUFBZjs7QUFFQSxxQkFBSyxpQkFBTDs7QUFFQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQWJEOztBQWVBO0FBQ0EsYUFBSyxTQUFMLEdBQWlCLFVBQVMsQ0FBVCxFQUFZO0FBQ3pCLGdCQUFJLEtBQUssT0FBTCxJQUFnQixrQkFBa0IsQ0FBdEMsRUFBeUM7QUFDckMsb0JBQ0ksSUFBSSxnQkFBZ0IsRUFBQyxHQUFHLE1BQUosRUFBWSxHQUFHLE1BQWYsRUFBaEIsQ0FEUjs7QUFHQSwrQkFBZSxlQUFlLENBQTlCOztBQUVBLHFCQUFLLFVBQUw7O0FBRUEsdUJBQU8sSUFBUDtBQUNILGFBVEQsTUFTTztBQUNILHFCQUFLLFNBQUwsQ0FBZSxJQUFmLENBQW9CLElBQXBCLEVBQTBCLENBQTFCO0FBQ0g7QUFDSixTQWJEOztBQWVBLGFBQUssT0FBTCxHQUFlLFVBQVMsQ0FBVCxFQUFZLE1BQVosRUFBb0IsUUFBcEIsRUFBOEI7QUFDekMsZ0JBQUksS0FBSyxPQUFMLElBQWdCLFVBQVUsY0FBOUIsRUFBOEM7QUFDMUMsb0JBQUksa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLHFDQUFpQixDQUFqQjtBQUNILGlCQUZELE1BRU8sSUFBSSxrQkFBa0IsQ0FBdEIsRUFBeUI7QUFDNUIscUNBQWlCLENBQWpCO0FBQ0gsaUJBRk0sTUFFQSxJQUFJLGtCQUFrQixDQUF0QixFQUF5QjtBQUM1Qix5QkFBSyxPQUFMLEdBQWUsS0FBZjs7QUFFQSx3QkFDSSxLQUFLLFlBRFQ7QUFBQSx3QkFFSSxLQUFLLFlBRlQ7QUFBQSx3QkFHSSxLQUFLLFlBSFQ7QUFBQSx3QkFJSSxLQUFLLFlBSlQ7QUFBQSx3QkFNSSxTQUFTLHdCQU5iOztBQVFBLDJCQUFPLEVBQVAsR0FBWSxHQUFHLENBQWY7QUFDQSwyQkFBTyxFQUFQLEdBQVksR0FBRyxDQUFmO0FBQ0EsMkJBQU8sRUFBUCxHQUFZLEdBQUcsQ0FBZjtBQUNBLDJCQUFPLEVBQVAsR0FBWSxHQUFHLENBQWY7QUFDQSwyQkFBTyxFQUFQLEdBQVksR0FBRyxDQUFmO0FBQ0EsMkJBQU8sRUFBUCxHQUFZLEdBQUcsQ0FBZjtBQUNBLDJCQUFPLEVBQVAsR0FBWSxHQUFHLENBQWY7QUFDQSwyQkFBTyxFQUFQLEdBQVksR0FBRyxDQUFmOztBQUVBLHdCQUNJLElBQUksSUFBSSxLQUFKLENBQVUsYUFBVixDQURSO0FBQUEsd0JBRUksSUFBSSxJQUFJLEtBQUosQ0FBVSxhQUFWLENBRlI7O0FBSUEsMkJBQU8sT0FBUCxDQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUIsYUFBckI7O0FBRUEsNEJBQVEsV0FBUixDQUFvQixFQUFFLENBQUYsQ0FBcEIsRUFBMEIsRUFBRSxDQUFGLENBQTFCLEVBQWdDLENBQWhDO0FBQ0EseUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxhQUFwQixFQUFtQyxHQUFuQyxFQUF3QztBQUNwQyxnQ0FBUSxjQUFSLENBQXVCLEVBQUUsQ0FBRixDQUF2QixFQUE2QixFQUFFLENBQUYsQ0FBN0IsRUFBbUMsQ0FBbkM7QUFDSDtBQUNELDRCQUFRLFNBQVI7QUFDQSx5QkFBSyxVQUFMO0FBQ0g7O0FBRUQsdUJBQU8sSUFBUDtBQUNIO0FBQ0osU0ExQ0Q7O0FBNENBLGFBQUssU0FBTCxHQUFpQixVQUFTLENBQVQsRUFBWSxRQUFaLEVBQXNCO0FBQ25DLGdCQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLG9CQUNJLElBQUksZ0JBQWdCLEVBQUMsR0FBRyxNQUFKLEVBQVksR0FBRyxNQUFmLEVBQWhCLENBRFI7O0FBR0Esb0JBQUksa0JBQWtCLENBQXRCLEVBQXlCO0FBQ3JCLG1DQUFlLENBQWY7QUFDSCxpQkFGRCxNQUVPLElBQUksa0JBQWtCLENBQXRCLEVBQXlCO0FBQzVCLG1DQUFlLENBQWY7QUFDSDtBQUNELHFCQUFLLFVBQUwsR0FUYyxDQVNLOztBQUVuQix1QkFBTyxJQUFQO0FBQ0gsYUFaRCxNQVlPO0FBQ0g7QUFDQSw4QkFBYyxTQUFkLENBQXdCLFNBQXhCLENBQWtDLElBQWxDLENBQXVDLElBQXZDLEVBQTZDLENBQTdDLEVBQWdELFFBQWhEO0FBQ0g7QUFDSixTQWpCRDs7QUFtQkEsYUFBSyxLQUFMLEdBQWEsWUFBVztBQUNwQixnQkFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDZCxvQkFDSSxTQUFTLHdCQURiO0FBQUEsb0JBR0ksS0FBSyxlQUFlLFlBQWYsQ0FIVDtBQUFBLG9CQUlJLEtBQUssZUFBZSxZQUFmLENBSlQ7QUFBQSxvQkFLSSxLQUFLLGVBQWUsWUFBZixDQUxUO0FBQUEsb0JBTUksS0FBSyxlQUFlLFlBQWYsQ0FOVDs7QUFRQSx1QkFBTyxFQUFQLEdBQVksR0FBRyxDQUFmO0FBQ0EsdUJBQU8sRUFBUCxHQUFZLEdBQUcsQ0FBZjtBQUNBLHVCQUFPLEVBQVAsR0FBWSxHQUFHLENBQWY7QUFDQSx1QkFBTyxFQUFQLEdBQVksR0FBRyxDQUFmO0FBQ0EsdUJBQU8sRUFBUCxHQUFZLEdBQUcsQ0FBZjtBQUNBLHVCQUFPLEVBQVAsR0FBWSxHQUFHLENBQWY7QUFDQSx1QkFBTyxFQUFQLEdBQVksR0FBRyxDQUFmO0FBQ0EsdUJBQU8sRUFBUCxHQUFZLEdBQUcsQ0FBZjs7QUFFQSxvQkFDSSxJQUFJLElBQUksS0FBSixDQUFVLHFCQUFWLENBRFI7QUFBQSxvQkFFSSxJQUFJLElBQUksS0FBSixDQUFVLHFCQUFWLENBRlI7O0FBSUEsdUJBQU8sT0FBUCxDQUFlLENBQWYsRUFBa0IsQ0FBbEIsRUFBcUIscUJBQXJCOztBQUVBLDhCQUFjLFNBQWQ7O0FBRUEsOEJBQWMsTUFBZCxDQUFxQixFQUFFLENBQUYsQ0FBckIsRUFBMkIsRUFBRSxDQUFGLENBQTNCO0FBQ0EscUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxxQkFBcEIsRUFBMkMsR0FBM0MsRUFBZ0Q7QUFDNUMsa0NBQWMsTUFBZCxDQUFxQixFQUFFLENBQUYsQ0FBckIsRUFBMkIsRUFBRSxDQUFGLENBQTNCO0FBQ0g7O0FBRUQsOEJBQWMsTUFBZCxDQUFxQixDQUFDLENBQUMsR0FBRyxDQUExQixFQUE2QixDQUFDLENBQUMsR0FBRyxDQUFsQztBQUNBLDhCQUFjLE1BQWQsQ0FBcUIsQ0FBQyxDQUFDLEdBQUcsQ0FBMUIsRUFBNkIsQ0FBQyxDQUFDLEdBQUcsQ0FBbEM7O0FBRUEsOEJBQWMsTUFBZCxDQUFxQixDQUFDLENBQUMsR0FBRyxDQUExQixFQUE2QixDQUFDLENBQUMsR0FBRyxDQUFsQztBQUNBLDhCQUFjLE1BQWQsQ0FBcUIsQ0FBQyxDQUFDLEdBQUcsQ0FBMUIsRUFBNkIsQ0FBQyxDQUFDLEdBQUcsQ0FBbEM7O0FBRUEsOEJBQWMsTUFBZDtBQUNILGFBdENELE1Bc0NPO0FBQ0g7QUFDQSw4QkFBYyxTQUFkLENBQXdCLEtBQXhCLENBQThCLElBQTlCLENBQW1DLElBQW5DO0FBQ0g7QUFDSixTQTNDRDs7QUE2Q0Esc0JBQWMsSUFBZCxDQUFtQixJQUFuQjtBQUNIOztBQUVELGlCQUFhLFNBQWIsR0FBeUIsT0FBTyxNQUFQLENBQWMsY0FBYyxTQUE1QixDQUF6QjtBQUNBLGlCQUFhLFNBQWIsQ0FBdUIsV0FBdkIsR0FBcUMsWUFBckM7O0FBRUEsYUFBUyxpQkFBVCxHQUE2QjtBQUN6QixZQUNJLFdBREo7O0FBR0EsYUFBSyxTQUFMLEdBQWlCLFVBQVMsQ0FBVCxFQUFZLE1BQVosRUFBb0IsUUFBcEIsRUFBOEI7QUFDM0MsZ0JBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2QsdUJBQU8sSUFBUDtBQUNILGFBRkQsTUFFTyxJQUFJLENBQUMsSUFBSSxTQUFKLENBQWMsT0FBZCxDQUFELEtBQTRCLFVBQVUsY0FBVixLQUE2QixDQUFDLEtBQUssU0FBTixJQUFtQixFQUFFLE1BQWxELEtBQTZELFVBQVUsZ0JBQW5HLENBQUosRUFBMEg7QUFDN0gsOEJBQWMsTUFBZDtBQUNBLHFCQUFLLE9BQUwsR0FBZSxJQUFmOztBQUVBLDBCQUFVLGdCQUFWOztBQUVBLHFCQUFLLFNBQUwsQ0FBZSxDQUFmOztBQUVBLHVCQUFPLElBQVA7QUFDSCxhQVRNLE1BU0EsSUFBSSxLQUFLLFNBQVQsRUFBb0I7QUFDdkI7QUFDQSwwQkFBVSxHQUFWO0FBQ0g7QUFDSixTQWhCRDs7QUFrQkEsYUFBSyxTQUFMLEdBQWlCLFVBQVMsQ0FBVCxFQUFZO0FBQ3pCLGdCQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLG9CQUNJLEtBQUssZ0JBQWdCLEVBQUMsR0FBRyxNQUFKLEVBQVksR0FBRyxNQUFmLEVBQWhCLENBRFQ7O0FBR0Esb0JBQUksUUFBUSxhQUFSLENBQXNCLEdBQUcsQ0FBekIsRUFBNEIsR0FBRyxDQUEvQixDQUFKLEVBQXVDO0FBQ25DLCtCQUFXLGNBQVgsQ0FBMEIsUUFBUSxXQUFSLENBQW9CLEdBQUcsQ0FBdkIsRUFBMEIsR0FBRyxDQUE3QixDQUExQjtBQUNIOztBQUVELHVCQUFPLElBQVA7QUFDSDtBQUNKLFNBWEQ7O0FBYUEsYUFBSyxPQUFMLEdBQWUsVUFBUyxDQUFULEVBQVksTUFBWixFQUFvQixRQUFwQixFQUE4QjtBQUN6QyxnQkFBSSxLQUFLLE9BQUwsSUFBZ0IsVUFBVSxXQUE5QixFQUEyQztBQUN2Qyw4QkFBYyxDQUFDLENBQWY7QUFDQSxxQkFBSyxPQUFMLEdBQWUsS0FBZjtBQUNBLDBCQUFVLGNBQVY7O0FBRUEsb0JBQUksS0FBSyxTQUFULEVBQW9CO0FBQ2hCLDhCQUFVLEdBQVY7QUFDSDs7QUFFRCx1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQVpEOztBQWNBLGFBQUssS0FBTCxHQUFhLFlBQVc7QUFDcEIsbUJBQU8sU0FBUCxDQUFpQixLQUFqQixDQUF1QixJQUF2QixDQUE0QixJQUE1QjtBQUNBLDBCQUFjLENBQUMsQ0FBZjtBQUNILFNBSEQ7QUFJSDs7QUFFRCxzQkFBa0IsU0FBbEIsR0FBOEIsT0FBTyxNQUFQLENBQWMsT0FBTyxTQUFyQixDQUE5QjtBQUNBLHNCQUFrQixTQUFsQixDQUE0QixXQUE1QixHQUEwQyxpQkFBMUM7O0FBRUEsYUFBUyxTQUFULEdBQXFCO0FBQ2pCLFlBQ0ksUUFESixFQUNjLFFBRGQsRUFFSSxhQUZKLEVBR0ksYUFISjs7QUFLQSxhQUFLLE9BQUwsR0FBZSxVQUFTLENBQVQsRUFBWTtBQUN2QixnQkFBSSxFQUFFLE9BQUYsSUFBYSxFQUFqQixDQUFvQixXQUFwQixFQUFpQztBQUM3QjtBQUNBLHdCQUFJLENBQUMsS0FBSyxPQUFWLEVBQW1CO0FBQ2Ysa0NBQVUsZUFBVjtBQUNIOztBQUVELDJCQUFPLElBQVA7QUFDSDtBQUNKLFNBVEQ7O0FBV0EsYUFBSyxLQUFMLEdBQWEsVUFBUyxDQUFULEVBQVk7QUFDckIsZ0JBQUksS0FBSyxTQUFMLElBQWtCLGlCQUFpQixZQUFuQyxJQUFtRCxFQUFFLE9BQUYsSUFBYSxFQUFwRSxDQUF1RSxXQUF2RSxFQUFvRjtBQUNoRiw4QkFBVSxjQUFWOztBQUVBLDhCQUFVLEdBQVYsR0FIZ0YsQ0FHL0Q7O0FBRWpCLDJCQUFPLElBQVA7QUFDSDtBQUNKLFNBUkQ7O0FBVUEsYUFBSyxTQUFMLEdBQWlCLFVBQVMsQ0FBVCxFQUFZLE1BQVosRUFBb0IsUUFBcEIsRUFBOEI7QUFDM0MsZ0JBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2QsdUJBQU8sSUFBUDtBQUNILGFBRkQsTUFFTyxJQUFJLFVBQVUsWUFBVixJQUEwQixJQUFJLFNBQUosQ0FBYyxPQUFkLEtBQTBCLFVBQVUsY0FBbEUsRUFBa0Y7QUFDckYscUJBQUssT0FBTCxHQUFlLElBQWY7QUFDQSxnQ0FBZ0IsTUFBaEI7QUFDQSwyQkFBVyxFQUFFLEtBQWI7QUFDQSwyQkFBVyxFQUFFLEtBQWI7QUFDQSxnQ0FBZ0IsS0FBSyxTQUFMLEVBQWhCO0FBQ0EsMEJBQVUsY0FBVjs7QUFFQSx1QkFBTyxJQUFQO0FBQ0gsYUFUTSxNQVNBLElBQUksS0FBSyxTQUFULEVBQW9CO0FBQ3ZCO0FBQ0EsMEJBQVUsR0FBVjtBQUNIO0FBQ0osU0FoQkQ7O0FBa0JBLGFBQUssU0FBTCxHQUFpQixVQUFTLENBQVQsRUFBWTtBQUN6QixnQkFBSSxLQUFLLE9BQVQsRUFBa0I7QUFDZCxxQkFBSyxTQUFMLENBQWUsY0FBYyxDQUFkLEdBQWtCLEVBQUUsS0FBcEIsR0FBNEIsUUFBM0MsRUFBcUQsY0FBYyxDQUFkLEdBQWtCLEVBQUUsS0FBcEIsR0FBNEIsUUFBakY7O0FBRUEsdUJBQU8sSUFBUDtBQUNIO0FBQ0osU0FORDs7QUFRQSxhQUFLLE9BQUwsR0FBZSxVQUFTLENBQVQsRUFBWSxNQUFaLEVBQW9CLFFBQXBCLEVBQThCO0FBQ3pDLGdCQUFJLEtBQUssT0FBTCxJQUFnQixVQUFVLGFBQTlCLEVBQTZDO0FBQ3pDLGdDQUFnQixDQUFDLENBQWpCO0FBQ0EscUJBQUssT0FBTCxHQUFlLEtBQWY7O0FBRUEsb0JBQUksS0FBSyxTQUFMLElBQWtCLENBQUMsSUFBSSxTQUFKLENBQWMsT0FBZCxDQUF2QixFQUErQztBQUMzQyw4QkFBVSxjQUFWOztBQUVBLDhCQUFVLEdBQVY7QUFDSDs7QUFFRCx1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQWJEOztBQWVBLGFBQUssS0FBTCxHQUFhLFlBQVc7QUFDcEIsc0JBQVUsZUFBVjtBQUNILFNBRkQ7QUFHSDs7QUFFRCxjQUFVLFNBQVYsR0FBc0IsT0FBTyxNQUFQLENBQWMsT0FBTyxTQUFyQixDQUF0QjtBQUNBLGNBQVUsU0FBVixDQUFvQixXQUFwQixHQUFrQyxlQUFsQzs7QUFFQSxhQUFTLGVBQVQsR0FBMkIsQ0FDMUI7O0FBRUQsb0JBQWdCLFNBQWhCLEdBQTRCLE9BQU8sTUFBUCxDQUFjLE9BQU8sU0FBckIsQ0FBNUI7QUFDQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsV0FBMUIsR0FBd0MsZUFBeEM7O0FBRUEsb0JBQWdCLFNBQWhCLENBQTBCLFNBQTFCLEdBQXNDLFVBQVMsQ0FBVCxFQUFZLE1BQVosRUFBb0IsUUFBcEIsRUFBOEI7QUFDaEUsWUFBSSxVQUFVLGNBQVYsSUFBNEIsQ0FBQyxFQUFFLE1BQS9CLElBQXlDLENBQUMsSUFBSSxTQUFKLENBQWMsT0FBZCxDQUExQyxJQUFvRSx1QkFBeEUsRUFBaUc7QUFDN0YsZ0JBQ0ksS0FBSyxnQkFBZ0IsRUFBQyxHQUFHLE1BQUosRUFBWSxHQUFHLE1BQWYsRUFBaEIsQ0FEVDs7QUFHQSxnQkFBSSxRQUFRLGFBQVIsQ0FBc0IsR0FBRyxDQUF6QixFQUE0QixHQUFHLENBQS9CLENBQUosRUFBdUM7QUFDbkMsd0JBQVEsU0FBUixDQUFrQixHQUFHLENBQXJCLEVBQXdCLEdBQUcsQ0FBM0I7QUFDQSxxQkFBSyxVQUFMO0FBQ0g7O0FBRUQsbUJBQU8sSUFBUDtBQUNIO0FBQ0osS0FaRDs7QUFjQSxhQUFTLG1CQUFULEdBQStCO0FBQzNCLFlBQ0ksVUFESjtBQUFBLFlBRUksVUFBVSxxQkFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQixDQUFwQixDQUZkO0FBQUEsWUFHSSxrQkFBa0IsQ0FBQyxDQUh2Qjs7QUFLQSxhQUFLLFNBQUwsR0FBaUIsVUFBVSxDQUFWLEVBQWEsTUFBYixFQUFxQixRQUFyQixFQUErQjtBQUM1QyxnQkFBSSxDQUFDLEtBQUssT0FBTixJQUFpQixVQUFVLGNBQTNCLElBQTZDLENBQUMsRUFBRSxNQUFoRCxJQUEwRCxDQUFDLElBQUksU0FBSixDQUFjLE9BQWQsQ0FBL0QsRUFBdUY7QUFDbkYsb0JBQ0ksSUFBSSxtQkFBbUIsRUFBQyxHQUFHLE1BQUosRUFBWSxHQUFHLE1BQWYsRUFBbkIsQ0FEUjs7QUFHQSxrQ0FBa0IsTUFBbEI7O0FBRUEsd0JBQVEsU0FBUjtBQUNBLDZCQUFhLENBQWI7O0FBRUEscUJBQUssVUFBTDs7QUFFQSxxQkFBSyxPQUFMLEdBQWUsSUFBZjs7QUFFQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQWhCRDs7QUFrQkEsYUFBSyxTQUFMLEdBQWlCLFVBQVMsQ0FBVCxFQUFZO0FBQ3pCLGdCQUFJLENBQUMsS0FBSyxPQUFWLEVBQ0ksT0FBTyxLQUFQOztBQUVKLGdCQUNJLElBQUksbUJBQW1CLEVBQUMsR0FBRyxNQUFKLEVBQVksR0FBRyxNQUFmLEVBQW5CLENBRFI7QUFBQSxnQkFFSSxTQUFTLEVBQUUsUUFGZjtBQUFBLGdCQUlJLGFBQWEsQ0FBQyxDQUFDLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLEVBQUUsQ0FBRixHQUFNLFdBQVcsQ0FBMUIsQ0FBVCxFQUF1QyxLQUFLLEdBQUwsQ0FBUyxFQUFFLENBQUYsR0FBTSxXQUFXLENBQTFCLENBQXZDLENBSm5COztBQU1BLGdCQUFJLEVBQUUsQ0FBRixJQUFPLFdBQVcsQ0FBdEIsRUFBeUI7QUFDckIsd0JBQVEsSUFBUixHQUFlLFdBQVcsQ0FBMUI7QUFDQSx3QkFBUSxLQUFSLEdBQWdCLENBQUMsU0FBUyxXQUFXLENBQVgsR0FBZSxVQUF4QixHQUFxQyxFQUFFLENBQXhDLElBQTZDLENBQTdEO0FBQ0gsYUFIRCxNQUdPO0FBQ0gsd0JBQVEsSUFBUixHQUFlLFNBQVMsV0FBVyxDQUFYLEdBQWUsVUFBeEIsR0FBcUMsRUFBRSxDQUF0RDtBQUNBLHdCQUFRLEtBQVIsR0FBZ0IsV0FBVyxDQUFYLEdBQWUsQ0FBL0I7QUFDSDs7QUFFRCxnQkFBSSxFQUFFLENBQUYsSUFBTyxXQUFXLENBQXRCLEVBQXlCO0FBQ3JCLHdCQUFRLEdBQVIsR0FBYyxXQUFXLENBQXpCO0FBQ0Esd0JBQVEsTUFBUixHQUFpQixDQUFDLFNBQVMsV0FBVyxDQUFYLEdBQWUsVUFBeEIsR0FBcUMsRUFBRSxDQUF4QyxJQUE2QyxDQUE5RDtBQUNILGFBSEQsTUFHTztBQUNILHdCQUFRLEdBQVIsR0FBYyxTQUFTLFdBQVcsQ0FBWCxHQUFlLFVBQXhCLEdBQXFDLEVBQUUsQ0FBckQ7QUFDQSx3QkFBUSxNQUFSLEdBQWlCLFdBQVcsQ0FBWCxHQUFlLENBQWhDO0FBQ0g7O0FBRUQsaUJBQUssVUFBTDs7QUFFQSxtQkFBTyxJQUFQO0FBQ0gsU0E3QkQ7O0FBK0JBLGFBQUssT0FBTCxHQUFlLFVBQVUsQ0FBVixFQUFhLE1BQWIsRUFBcUIsUUFBckIsRUFBK0I7QUFDMUMsZ0JBQUksS0FBSyxPQUFMLElBQWdCLFVBQVUsZUFBOUIsRUFBK0M7QUFDM0Msd0JBQVEsa0JBQVIsQ0FBMkIsT0FBM0I7QUFDQSx3QkFBUSxTQUFSOztBQUVBLHFCQUFLLFVBQUw7O0FBRUEscUJBQUssT0FBTCxHQUFlLEtBQWY7QUFDQSxrQ0FBa0IsQ0FBQyxDQUFuQjs7QUFFQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQVpEOztBQWNBLGFBQUssS0FBTCxHQUFhLFlBQVc7QUFDcEIsZ0JBQUksQ0FBQyxRQUFRLE9BQVIsRUFBTCxFQUF3QjtBQUNwQiw4QkFBYyxTQUFkLEdBQTBCLENBQTFCO0FBQ0Esa0NBQWtCLGFBQWxCLEVBQWlDLE9BQWpDO0FBQ0g7QUFDSixTQUxEO0FBTUg7O0FBRUQsd0JBQW9CLFNBQXBCLEdBQWdDLE9BQU8sTUFBUCxDQUFjLE9BQU8sU0FBckIsQ0FBaEM7QUFDQSx3QkFBb0IsU0FBcEIsQ0FBOEIsV0FBOUIsR0FBNEMsbUJBQTVDOztBQUVBLGFBQVMsY0FBVCxHQUEwQjtBQUN0QixZQUNJLFNBREo7QUFBQSxZQUVJLFFBRko7QUFBQSxZQUdJLFlBQVksS0FIaEI7O0FBS0EsYUFBSyxTQUFMLEdBQWlCLFVBQVMsQ0FBVCxFQUFZLE1BQVosRUFBb0IsUUFBcEIsRUFBOEI7QUFDM0MsZ0JBQUksQ0FBQyxLQUFLLE9BQU4sSUFBaUIsVUFBVSxjQUEzQixJQUE2QyxDQUFDLElBQUksU0FBSixDQUFjLE9BQWQsQ0FBOUMsSUFBd0UsdUJBQTVFLEVBQXFHO0FBQ2pHLDRCQUFZLGdCQUFnQixFQUFDLEdBQUcsTUFBSixFQUFZLEdBQUcsTUFBZixFQUFoQixDQUFaOztBQUVBLDJCQUFXLEVBQUUsTUFBYjtBQUNBLDRCQUFZLElBQVo7QUFDQSxxQkFBSyxPQUFMLEdBQWUsSUFBZjs7QUFFQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQVZEOztBQVlBLGFBQUssU0FBTCxHQUFpQixnQ0FBUyxFQUFULEVBQWEsVUFBUyxDQUFULEVBQVk7QUFDdEMsZ0JBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2Qsb0JBQ0ksSUFBSSxnQkFBZ0IsRUFBQyxHQUFHLE1BQUosRUFBWSxHQUFHLE1BQWYsRUFBaEIsQ0FEUjtBQUFBLG9CQUdJLFlBQVksRUFBQyxHQUFHLEVBQUUsQ0FBRixHQUFNLFVBQVUsQ0FBcEIsRUFBdUIsR0FBRyxFQUFFLENBQUYsR0FBTSxVQUFVLENBQTFDLEVBSGhCO0FBQUEsb0JBSUksVUFBVSxFQUFDLEdBQUcsQ0FBQyxDQUFDLFVBQVUsQ0FBaEIsRUFBbUIsR0FBRyxDQUFDLENBQUMsVUFBVSxDQUFsQyxFQUpkLENBRGMsQ0FLc0M7O0FBRXBELHdCQUFRLElBQVIsQ0FBYSxRQUFRLENBQXJCLEVBQXdCLFFBQVEsQ0FBaEMsRUFBbUMsWUFBWSxTQUEvQzs7QUFFQSw0QkFBWSxLQUFaOztBQUVBOzs7O0FBSUEsMEJBQVUsQ0FBVixHQUFjLEVBQUUsQ0FBRixJQUFPLFVBQVUsQ0FBVixHQUFjLFFBQVEsQ0FBN0IsQ0FBZDtBQUNBLDBCQUFVLENBQVYsR0FBYyxFQUFFLENBQUYsSUFBTyxVQUFVLENBQVYsR0FBYyxRQUFRLENBQTdCLENBQWQ7O0FBRUEsdUJBQU8sSUFBUDtBQUNIO0FBQ0osU0FyQmdCLENBQWpCOztBQXVCQSxhQUFLLE9BQUwsR0FBZSxVQUFTLENBQVQsRUFBWSxNQUFaLEVBQW9CLFFBQXBCLEVBQThCO0FBQ3pDLGdCQUFJLEtBQUssT0FBTCxJQUFnQixVQUFVLGNBQTlCLEVBQThDO0FBQzFDLHFCQUFLLE9BQUwsR0FBZSxLQUFmO0FBQ0Esb0JBQUksS0FBSyxTQUFULEVBQW9CO0FBQ2hCLDhCQUFVLEdBQVY7QUFDSDtBQUNELHVCQUFPLElBQVA7QUFDSDtBQUNKLFNBUkQ7QUFTSDs7QUFFRCxtQkFBZSxTQUFmLEdBQTJCLE9BQU8sTUFBUCxDQUFjLE9BQU8sU0FBckIsQ0FBM0I7QUFDQSxtQkFBZSxTQUFmLENBQXlCLFdBQXpCLEdBQXVDLGNBQXZDOztBQUVBLG1CQUFlLFNBQWYsQ0FBeUIsU0FBekIsR0FBcUMsVUFBUyxDQUFULEVBQVk7QUFDN0MsWUFBSSxDQUFDLElBQUksU0FBSixDQUFjLE9BQWQsQ0FBRCxJQUEyQixDQUFDLEVBQUUsTUFBbEMsRUFBMEM7QUFDdEMsc0JBQVUsV0FBVjtBQUNBLG1CQUFPLElBQVA7QUFDSDtBQUNKLEtBTEQ7O0FBT0EsbUJBQWUsU0FBZixDQUF5QixLQUF6QixHQUFpQyxZQUFXO0FBQ3hDLGtCQUFVLFdBQVY7QUFDSCxLQUZEOztBQUlBLGFBQVMsZUFBVCxHQUEyQjtBQUN2QixZQUNJLGdCQUFnQixDQURwQjtBQUFBLFlBR0ksWUFBWSxDQUFDLENBSGpCO0FBQUEsWUFJSSxjQUFjLENBQUMsQ0FKbkI7QUFBQSxZQUtJLFlBQVksQ0FBQyxDQUxqQjtBQUFBLFlBTUksaUJBQWlCLENBTnJCO0FBQUEsWUFPSSxjQUFjLENBUGxCO0FBQUEsWUFRSSxpQkFBaUIsQ0FSckI7QUFBQSxZQVNJLGNBQWMsQ0FUbEI7QUFBQSxZQVVJLGlCQUFpQixDQVZyQjtBQUFBLFlBV0ksY0FBYyxDQVhsQjtBQUFBLFlBWUksaUJBQWlCLENBWnJCO0FBQUEsWUFhSSxjQUFjLENBYmxCOztBQWVBO0FBQ0k7QUFDQSxjQUZKOztBQUdJO0FBQ0EsZUFKSjs7QUFLSTtBQUNBLHdCQU5KOztBQU9JO0FBQ0Esb0JBUko7QUFBQSxZQVVJLGVBQWUsU0FWbkI7QUFBQSxZQVlJLG9CQVpKO0FBQUEsWUFhSSxnQkFiSjs7O0FBZUk7QUFDQSwyQkFoQko7O0FBa0JOOzs7OztBQUtNLGlCQUFTLHVCQUFULEdBQW1DO0FBQy9CLG1CQUFPLGFBQWEsY0FBYixDQUE0QixTQUE1QixDQUFQO0FBQ0g7O0FBRUQsaUJBQVMsYUFBVCxDQUF1QixFQUF2QixFQUEyQixFQUEzQixFQUErQjtBQUMzQixtQkFBTyxFQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUgsR0FBTyxHQUFHLENBQVgsSUFBZ0IsQ0FBcEIsRUFBdUIsR0FBRyxDQUFDLEdBQUcsQ0FBSCxHQUFPLEdBQUcsQ0FBWCxJQUFnQixDQUExQyxFQUFQO0FBQ0g7O0FBRUQsaUJBQVMsVUFBVCxDQUFvQixDQUFwQixFQUF1QjtBQUNuQixtQkFBTyxFQUFDLEdBQUksS0FBSyxLQUFMLENBQVcsRUFBRSxDQUFiLENBQUwsRUFBc0IsR0FBRyxLQUFLLEtBQUwsQ0FBVyxFQUFFLENBQWIsQ0FBekIsRUFBUDtBQUNIOztBQUVQOzs7Ozs7O0FBT00saUJBQVMsa0JBQVQsQ0FBNEIsT0FBNUIsRUFBcUMsS0FBckMsRUFBNEM7QUFDeEMsZ0JBQ0ksd0JBQXdCLENBRDVCO0FBQUEsZ0JBRUksNEJBQTRCLHdCQUF3QixxQkFGeEQ7QUFBQSxnQkFHSSxzQkFBc0IscUJBSDFCO0FBQUEsZ0JBSUksMEJBQTBCLHNCQUFzQixtQkFKcEQ7O0FBTUE7QUFDQSxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBUixDQUFlLE1BQW5DLEVBQTJDLEdBQTNDLEVBQWdEO0FBQzVDLG9CQUFJLENBQUMsTUFBTSxDQUFOLEdBQVUsUUFBUSxNQUFSLENBQWUsQ0FBZixFQUFrQixDQUE3QixLQUFtQyxNQUFNLENBQU4sR0FBVSxRQUFRLE1BQVIsQ0FBZSxDQUFmLEVBQWtCLENBQS9ELElBQW9FLENBQUMsTUFBTSxDQUFOLEdBQVUsUUFBUSxNQUFSLENBQWUsQ0FBZixFQUFrQixDQUE3QixLQUFtQyxNQUFNLENBQU4sR0FBVSxRQUFRLE1BQVIsQ0FBZSxDQUFmLEVBQWtCLENBQS9ELENBQXBFLElBQXlJLHlCQUE3SSxFQUF3SztBQUNwSywyQkFBTyxJQUFJLENBQVg7QUFDSDtBQUNKOztBQUVEO0FBQ0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxRQUFRLE1BQVIsQ0FBZSxNQUFuQyxFQUEyQyxHQUEzQyxFQUFnRDtBQUM1QyxvQkFDSSxTQUFTLFFBQVEsTUFBUixDQUFlLENBQWYsQ0FEYjtBQUFBLG9CQUVJLFNBQVMsUUFBUSxNQUFSLENBQWUsQ0FBQyxJQUFJLENBQUwsSUFBVSxRQUFRLE1BQVIsQ0FBZSxNQUF4QyxDQUZiO0FBQUEsb0JBSUksUUFBUSx1QkFBYSxPQUFPLENBQVAsR0FBVyxPQUFPLENBQS9CLEVBQWtDLE9BQU8sQ0FBUCxHQUFXLE9BQU8sQ0FBcEQsQ0FKWjtBQUFBLG9CQUtJLFNBQVMsdUJBQWEsTUFBTSxDQUFOLEdBQVUsT0FBTyxDQUE5QixFQUFpQyxNQUFNLENBQU4sR0FBVSxPQUFPLENBQWxELENBTGI7QUFBQSxvQkFPSSxXQUFXLE1BQU0sU0FBTixFQVBmO0FBQUEsb0JBU0ksY0FBYyxNQUFNLFNBQU4sQ0FBZ0IsSUFBSSxRQUFwQixDQVRsQjtBQUFBLG9CQVVJLGVBQWUsT0FBTyxTQUFQLENBQWlCLElBQUksUUFBckIsQ0FWbkI7QUFBQSxvQkFZSSxrQkFBa0IsWUFBWSxhQUFaLENBQTBCLFlBQTFCLENBWnRCOztBQWNBO0FBQ0Esb0JBQUksbUJBQW1CLEdBQW5CLElBQTBCLG1CQUFtQixHQUFqRCxFQUFzRDtBQUNsRDtBQUNBLDBCQUFNLEtBQU4sQ0FBWSxlQUFaOztBQUVBLHdCQUFJLENBQUMsTUFBTSxDQUFOLEdBQVUsT0FBTyxDQUFsQixLQUF3QixNQUFNLENBQU4sR0FBVSxPQUFPLENBQXpDLElBQThDLENBQUMsTUFBTSxDQUFOLEdBQVUsT0FBTyxDQUFsQixLQUF3QixNQUFNLENBQU4sR0FBVSxPQUFPLENBQXpDLENBQTlDLElBQTZGLHVCQUFqRyxFQUEwSDtBQUN0SCwrQkFBTyxJQUFJLENBQUosR0FBUSxDQUFmO0FBQ0g7QUFDSjtBQUNKOztBQUVELGdCQUFJLFFBQVEsYUFBUixDQUFzQixLQUF0QixDQUFKLEVBQWtDO0FBQzlCLHVCQUFPLFNBQVA7QUFDSDs7QUFFRCxtQkFBTyxXQUFQO0FBQ0g7O0FBRUQsaUJBQVMsbUJBQVQsR0FBK0I7QUFDM0IsZ0JBQ0ksVUFBVSx5QkFEZDtBQUFBLGdCQUVJLFFBQVEsRUFBQyxHQUFHLE1BQUosRUFBWSxHQUFHLE1BQWYsRUFGWjtBQUFBLGdCQUdJLGFBQWEsbUJBQW1CLE9BQW5CLEVBQTRCLEtBQTVCLENBSGpCOztBQUtBLG9CQUFRLFVBQVI7QUFDSSxxQkFBSyxjQUFMO0FBQ0EscUJBQUssY0FBTDtBQUNBLHFCQUFLLGNBQUw7QUFDQSxxQkFBSyxjQUFMO0FBQ0k7QUFDQSx3QkFDSSxjQUFjLENBQUMsRUFBRSxhQUFhLENBQWYsQ0FEbkI7QUFBQSx3QkFFSSxlQUFlLFFBQVEsTUFBUixDQUFlLENBQUMsY0FBYyxDQUFmLElBQW9CLENBQW5DLENBRm5CO0FBQUEsd0JBR0ksU0FBUyxRQUFRLE1BQVIsQ0FBZSxXQUFmLENBSGI7QUFBQSx3QkFJSSxjQUFjLFFBQVEsTUFBUixDQUFlLENBQUMsY0FBYyxDQUFmLElBQW9CLENBQW5DLENBSmxCOzs7QUFNQTtBQUNJLDBCQUFNLG1CQUFTLGNBQVQsQ0FBd0IsWUFBeEIsRUFBc0MsTUFBdEMsRUFBOEMsU0FBOUMsR0FBMEQsR0FBMUQsQ0FBOEQsbUJBQVMsY0FBVCxDQUF3QixXQUF4QixFQUFxQyxNQUFyQyxFQUE2QyxTQUE3QyxFQUE5RCxDQVBWOztBQVNBLDZDQUF5QixHQUF6QjtBQUNBO0FBQ0oscUJBQUssV0FBTDtBQUNBLHFCQUFLLFdBQUw7QUFDQSxxQkFBSyxXQUFMO0FBQ0EscUJBQUssV0FBTDtBQUNJO0FBQ0Esd0JBQ0ksVUFBVSxRQUFRLE1BQVIsQ0FBZSxDQUFDLEVBQUUsYUFBYSxDQUFmLENBQWhCLENBRGQ7QUFBQSx3QkFFSSxVQUFVLFFBQVEsTUFBUixDQUFlLENBQUMsQ0FBQyxFQUFFLGFBQWEsQ0FBZixDQUFELEdBQXFCLENBQXRCLElBQTJCLENBQTFDLENBRmQ7QUFBQSx3QkFHSSxRQUFRLG1CQUFTLGNBQVQsQ0FBd0IsT0FBeEIsRUFBaUMsT0FBakMsRUFBMEMsZ0JBQTFDLEVBSFo7O0FBS0EsNkNBQXlCLEtBQXpCO0FBQ0E7QUFDSixxQkFBSyxTQUFMO0FBQ0ksOEJBQVUsV0FBVjtBQUNBO0FBQ0oscUJBQUssV0FBTDtBQUNJLDhCQUFVLGNBQVYsRUFESixDQUMrQjtBQUMzQjtBQUNKO0FBQ0ksOEJBQVUsY0FBVjtBQXBDUjtBQXNDSDs7QUFFRCxhQUFLLFNBQUwsR0FBaUIsVUFBUyxDQUFULEVBQVksTUFBWixFQUFvQixRQUFwQixFQUE4QjtBQUMzQyxnQkFBSSxDQUFDLEtBQUssT0FBTixJQUFpQixVQUFVLGNBQTNCLElBQTZDLENBQUMsRUFBRSxNQUFoRCxJQUEwRCxDQUFDLElBQUksU0FBSixDQUFjLE9BQWQsQ0FBL0QsRUFBdUY7QUFDbkYsb0JBQ0ksVUFBVSx5QkFEZDs7QUFHQSwrQkFBZSxtQkFBbUIsT0FBbkIsRUFBNEIsRUFBQyxHQUFHLE1BQUosRUFBWSxHQUFHLE1BQWYsRUFBNUIsQ0FBZjs7QUFFQSx1Q0FBdUIsRUFBQyxHQUFHLE1BQUosRUFBWSxHQUFHLE1BQWYsRUFBdkI7QUFDQSxtQ0FBbUIsZ0JBQWdCLG9CQUFoQixDQUFuQjs7QUFFQSxxQkFBSyxPQUFMLEdBQWUsSUFBZjs7QUFFQTs7QUFFQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQWhCRDs7QUFrQkEsYUFBSyxTQUFMLEdBQWlCLGdDQUFTLEVBQVQsRUFBYSxVQUFTLENBQVQsRUFBWTtBQUN0QyxnQkFDSSxZQUFZLEtBRGhCOztBQUdBLGdCQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLG9CQUNJLG1CQUFtQixFQUFDLEdBQUcsTUFBSixFQUFZLEdBQUcsTUFBZixFQUR2Qjs7QUFHQSx3QkFBUSxZQUFSO0FBQ0kseUJBQUssU0FBTDtBQUNJLDRCQUNJLGVBQWUsV0FBVyxnQkFBZ0IsZ0JBQWhCLENBQVgsQ0FEbkI7QUFBQSw0QkFHSSxjQUFjLG1CQUFTLGNBQVQsQ0FBd0IsWUFBeEIsRUFBc0MsZ0JBQXRDLENBSGxCOzs7QUFLSTtBQUNBLDZDQUFxQixZQUFZLFlBQVosRUFOekI7QUFBQSw0QkFRSSx1QkFBdUIsWUFBWSxRQUFaLENBQXFCLGtCQUFyQixDQVIzQjtBQUFBLDRCQVVJLG9CQUFvQiwyQkFWeEI7O0FBWUE7OztBQUdBLDBDQUFrQixTQUFsQixDQUE0QixtQkFBbUIsQ0FBL0MsRUFBa0QsbUJBQW1CLENBQXJFOztBQUVBLCtCQUFPLFdBQVAsQ0FBbUIsaUJBQW5COztBQUVBO0FBQ0EsMkNBQW1CLG1CQUFTLGNBQVQsQ0FBd0IsWUFBeEIsRUFBc0Msb0JBQXRDLENBQW5CO0FBQ0o7QUFDQSx5QkFBSyxXQUFMO0FBQ0ksNEJBQ0kseUJBQXlCLEtBQUssRUFBTCxHQUFVLENBRHZDOztBQUdBLDRCQUNJLFlBQVksYUFBYSxTQUFiLEVBRGhCO0FBQUEsNEJBRUksZ0JBQWdCLGVBQWUsU0FBZixDQUZwQjtBQUFBLDRCQUlJLGdCQUFnQixLQUFLLEtBQUwsQ0FBVyxxQkFBcUIsQ0FBckIsR0FBeUIsY0FBYyxDQUFsRCxFQUFxRCxxQkFBcUIsQ0FBckIsR0FBeUIsY0FBYyxDQUE1RixDQUpwQjtBQUFBLDRCQUtJLGdCQUFnQixLQUFLLEtBQUwsQ0FBVyxpQkFBaUIsQ0FBakIsR0FBcUIsY0FBYyxDQUE5QyxFQUFpRCxpQkFBaUIsQ0FBakIsR0FBcUIsY0FBYyxDQUFwRixDQUxwQjtBQUFBLDRCQU1JLGtCQUFrQixnQkFBZ0IsYUFOdEM7QUFBQSw0QkFRSSxvQkFSSjtBQUFBLDRCQVNJLGlCQUFpQiwyQkFUckI7O0FBV0EsK0NBQXVCLGVBQXZCOztBQUVBLDRCQUFJLEVBQUUsUUFBTixFQUFnQjtBQUNaOzs7OztBQUtBLDBDQUFjLENBQUMsT0FBTyxTQUFQLEdBQW1CLE1BQXBCLEdBQTZCLEtBQUssS0FBTCxDQUFXLHNCQUFzQixzQkFBakMsSUFBMkQsc0JBQXRHO0FBQ0gseUJBUEQsTUFPTztBQUNILDBDQUFjLGVBQWQ7QUFDSDs7QUFFRDs7O0FBR0EsdUNBQWUsaUJBQWYsQ0FBaUMsV0FBakMsRUFBOEMsVUFBVSxDQUF4RCxFQUEyRCxVQUFVLENBQXJFOztBQUVBLCtCQUFPLFdBQVAsQ0FBbUIsY0FBbkI7O0FBRUEsK0NBQXVCLGdCQUF2QjtBQUNKO0FBQ0EseUJBQUssY0FBTDtBQUNBLHlCQUFLLGNBQUw7QUFDQSx5QkFBSyxjQUFMO0FBQ0EseUJBQUssY0FBTDtBQUNBO0FBQ0ksZ0NBQ0ksaUJBQWlCLENBQUMsRUFBRSxlQUFlLENBQWpCLENBRHRCO0FBQUEsZ0NBR0ksWUFBWSxpQkFBaUIsTUFBakIsQ0FBd0IsY0FBeEIsQ0FIaEI7O0FBSUE7QUFDSSx3Q0FBWSxPQUFPLFdBQVAsR0FBcUIsbUJBQXJCLENBQXlDLFdBQVcsZ0JBQWdCLGdCQUFoQixDQUFYLENBQXpDLENBTGhCOzs7QUFPQTtBQUNJLHdDQUFZLGlCQUFpQixNQUFqQixDQUF3QixDQUFDLGlCQUFpQixDQUFsQixJQUF1QixDQUEvQyxDQVJoQjs7O0FBVUE7OztBQUdJLHFDQUFTLENBQUMsVUFBVSxDQUFWLEdBQWMsVUFBVSxDQUF6QixLQUErQixVQUFVLENBQVYsR0FBYyxVQUFVLENBQXZELENBYmI7QUFBQSxnQ0FjSSxTQUFTLENBQUMsVUFBVSxDQUFWLEdBQWMsVUFBVSxDQUF6QixLQUErQixVQUFVLENBQVYsR0FBYyxVQUFVLENBQXZELENBZGI7O0FBZ0JBOzs7O0FBSUEsZ0NBQUksS0FBSyxHQUFMLENBQVMsTUFBVCxJQUFtQixTQUFuQixJQUFnQyxLQUFLLEdBQUwsQ0FBUyxNQUFULElBQW1CLFNBQW5ELElBQWdFLE1BQU0sTUFBTixDQUFoRSxJQUFpRixNQUFNLE1BQU4sQ0FBckYsRUFBb0c7QUFDaEcsdUNBQU8sSUFBUDtBQUNIOztBQUVEO0FBQ0EsZ0NBQUksRUFBRSxRQUFOLEVBQWdCO0FBQ1osb0NBQ0ksZUFBZSxLQUFLLEdBQUwsQ0FBUyxNQUFULEVBQWlCLE1BQWpCLENBRG5COztBQUdBLHlDQUFTLFlBQVQ7QUFDQSx5Q0FBUyxZQUFUO0FBQ0g7O0FBRUQ7QUFDQSxtQ0FBTyxnQkFBUCxDQUF3QixNQUF4QixFQUFnQyxNQUFoQyxFQUF3QyxVQUFVLENBQWxELEVBQXFELFVBQVUsQ0FBL0Q7QUFDSDtBQUNEO0FBQ0EseUJBQUssV0FBTDtBQUNBLHlCQUFLLFdBQUw7QUFDQSx5QkFBSyxXQUFMO0FBQ0EseUJBQUssV0FBTDtBQUNBO0FBQ0ksZ0NBQ0ksY0FBYyxDQUFDLEVBQUUsZUFBZSxDQUFqQixDQURuQjtBQUFBLGdDQUdJLFlBQVksY0FBYyxpQkFBaUIsTUFBakIsQ0FBd0IsV0FBeEIsQ0FBZCxFQUFvRCxpQkFBaUIsTUFBakIsQ0FBd0IsQ0FBQyxjQUFjLENBQWYsSUFBb0IsQ0FBNUMsQ0FBcEQsQ0FIaEI7OztBQUtBO0FBQ0ksd0NBQVksT0FBTyxXQUFQLEdBQXFCLG1CQUFyQixDQUF5QyxXQUFXLGdCQUFnQixnQkFBaEIsQ0FBWCxDQUF6QyxDQU5oQjs7O0FBUUE7QUFDSSx3Q0FBWSxjQUFjLGlCQUFpQixNQUFqQixDQUF3QixDQUFDLGNBQWMsQ0FBZixJQUFvQixDQUE1QyxDQUFkLEVBQThELGlCQUFpQixNQUFqQixDQUF3QixDQUFDLGNBQWMsQ0FBZixJQUFvQixDQUE1QyxDQUE5RCxDQVRoQjtBQUFBLGdDQVdJLGdCQVhKO0FBQUEsZ0NBV1ksZ0JBWFo7QUFBQSxnQ0FhSSxZQUFZLG1CQUFTLGNBQVQsQ0FBd0IsU0FBeEIsRUFBbUMsU0FBbkMsQ0FiaEI7QUFBQSxnQ0FjSSxZQUFZLG1CQUFTLGNBQVQsQ0FBd0IsU0FBeEIsRUFBbUMsU0FBbkMsQ0FkaEI7QUFBQSxnQ0FnQkksWUFBWSxVQUFVLFNBQVYsRUFoQmhCOztBQWlCQTtBQUNJLHdDQUFZLFVBQVUsYUFBVixDQUF3QixTQUF4QixJQUFxQyxTQWxCckQ7QUFBQSxnQ0FvQkksV0FBVyxZQUFZLFNBcEIzQjs7QUFzQkE7Ozs7QUFJQSxnQ0FBSSxLQUFLLEdBQUwsQ0FBUyxRQUFULElBQXFCLFNBQXJCLElBQWtDLE1BQU0sUUFBTixDQUF0QyxFQUF1RDtBQUNuRCx1Q0FBTyxJQUFQO0FBQ0g7O0FBRUQsZ0NBQUksZ0JBQWdCLFdBQWhCLElBQStCLGdCQUFnQixXQUFuRCxFQUFnRTtBQUM1RCwwQ0FBUyxHQUFUO0FBQ0EsMENBQVMsUUFBVDtBQUNILDZCQUhELE1BR087QUFDSCwwQ0FBUyxRQUFUO0FBQ0EsMENBQVMsR0FBVDtBQUNIOztBQUVELG1DQUFPLGdCQUFQLENBQXdCLE9BQXhCLEVBQWdDLE9BQWhDLEVBQXdDLFVBQVUsQ0FBbEQsRUFBcUQsVUFBVSxDQUEvRDtBQUNIO0FBQ0Q7QUFwSko7O0FBdUpBLCtCQUFlLGlCQUFpQixjQUFqQixDQUFnQyxNQUFoQyxDQUFmOztBQUVBLHdCQUFRLG9CQUFSLENBQTZCLE1BQTdCOztBQUVBO0FBQ0EscUJBQUssVUFBTDs7QUFFQSx1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQXhLZ0IsQ0FBakI7O0FBMEtBLGFBQUssT0FBTCxHQUFlLFVBQVMsQ0FBVCxFQUFZLE1BQVosRUFBb0IsUUFBcEIsRUFBOEI7QUFDekMsZ0JBQUksS0FBSyxPQUFMLElBQWdCLFVBQVUsY0FBOUIsRUFBOEM7QUFDMUMscUJBQUssT0FBTCxHQUFlLEtBQWY7QUFDQSwrQkFBZSxTQUFmO0FBQ0EsdUJBQU8sSUFBUDtBQUNIO0FBQ0osU0FORDs7QUFRQTs7O0FBR0EsaUJBQVMsd0JBQVQsQ0FBa0MsQ0FBbEMsRUFBcUM7QUFDakMsZ0JBQ0ksUUFBUSxLQUFLLEtBQUwsQ0FBVyxDQUFDLEVBQUUsQ0FBZCxFQUFpQixFQUFFLENBQW5CLENBRFo7O0FBRUE7Ozs7QUFJSSxvQkFBUSxLQUFLLEtBQUwsQ0FBVyxTQUFTLEtBQUssRUFBTCxHQUFVLENBQW5CLElBQXdCLEdBQW5DLENBTlo7QUFBQSxnQkFPSSxlQVBKOztBQVNBO0FBQ0EsZ0JBQUksUUFBUSxDQUFaLEVBQWU7QUFDWCx5QkFBUyxDQUFUO0FBQ0g7O0FBRUQsb0JBQVEsS0FBUjtBQUNJLHFCQUFLLENBQUw7QUFDQTtBQUNJLDZCQUFTLGdCQUFUO0FBQ0o7QUFDQSxxQkFBSyxDQUFMO0FBQ0ksNkJBQVMsa0JBQVQ7QUFDSjtBQUNBLHFCQUFLLENBQUw7QUFDSSw2QkFBUyxnQkFBVDtBQUNKO0FBQ0EscUJBQUssQ0FBTDtBQUNJLDZCQUFTLGtCQUFUO0FBQ0o7QUFiSjs7QUFnQkEsc0JBQVUsTUFBVjtBQUNIOztBQUVELGFBQUssU0FBTCxHQUFpQixZQUFXO0FBQ3hCO0FBQ0EsZ0JBQUksQ0FBQyxLQUFLLE9BQVYsRUFBbUI7QUFDZjtBQUNIO0FBQ0osU0FMRDs7QUFPQSxhQUFLLEtBQUwsR0FBYSxZQUFXO0FBQ3BCLGdCQUNJLFVBQVUsMEJBQTBCLE1BRHhDO0FBQUEsZ0JBRUksVUFBVSxJQUFJLEtBQUosQ0FBVSxRQUFRLE1BQVIsR0FBaUIsQ0FBM0IsQ0FGZDs7QUFJQTtBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyx3QkFBUSxDQUFSLElBQWEsUUFBUSxDQUFSLENBQWI7QUFDSDs7QUFFRCxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsb0JBQ0ksU0FBUyxRQUFRLENBQVIsQ0FEYjtBQUFBLG9CQUVJLFNBQVMsUUFBUSxDQUFDLElBQUksQ0FBTCxJQUFVLFFBQVEsTUFBMUIsQ0FGYjtBQUFBLG9CQUlJLFNBQVMsRUFBQyxHQUFHLENBQUMsT0FBTyxDQUFQLEdBQVcsT0FBTyxDQUFuQixJQUF3QixDQUE1QixFQUErQixHQUFHLENBQUMsT0FBTyxDQUFQLEdBQVcsT0FBTyxDQUFuQixJQUF3QixDQUExRCxFQUpiOztBQU1BLHdCQUFRLElBQUksUUFBUSxNQUFwQixJQUE4QixNQUE5QjtBQUNIOztBQUVELG9DQUF3QixhQUF4QixFQUF1QyxNQUF2QztBQUNBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBUSxNQUE1QixFQUFvQyxHQUFwQyxFQUF5QztBQUNyQyw4QkFBYyxRQUFkLENBQXVCLFFBQVEsQ0FBUixFQUFXLENBQVgsR0FBZSxhQUF0QyxFQUFxRCxRQUFRLENBQVIsRUFBVyxDQUFYLEdBQWUsYUFBcEUsRUFBbUYsZ0JBQWdCLENBQWhCLEdBQW9CLENBQXZHLEVBQTBHLGdCQUFnQixDQUFoQixHQUFvQixDQUE5SDtBQUNIOztBQUVELDBCQUFjLGFBQWQsRUFBNkIsT0FBN0I7QUFDSCxTQTFCRDs7QUE0QkEsYUFBSyxPQUFMLEdBQWUsVUFBUyxDQUFULEVBQVk7QUFDdkIsZ0JBQUksRUFBRSxPQUFGLElBQWEsRUFBakIsQ0FBb0IsV0FBcEIsRUFBaUM7QUFDN0IsK0JBQVcsZUFBWCxDQUEyQixFQUFDLFFBQVEsbUJBQVQsRUFBM0I7O0FBRUEsMkJBQU8sSUFBUDtBQUNILGlCQUpELE1BSU8sSUFBSSxFQUFFLE9BQUYsSUFBYSxFQUFqQixDQUFvQixZQUFwQixFQUFrQztBQUNyQywrQkFBVyxlQUFYLENBQTJCLEVBQUMsUUFBUSxtQkFBVCxFQUEzQjs7QUFFQSwyQkFBTyxJQUFQO0FBQ0g7QUFDSixTQVZEOztBQVlBLGFBQUssS0FBTCxHQUFhLFlBQVc7QUFDcEIsbUJBQU8sU0FBUCxDQUFpQixLQUFqQixDQUF1QixJQUF2QixDQUE0QixJQUE1Qjs7QUFFQTtBQUNBLGdCQUNJLFVBQVUsUUFBUSxvQkFBUixFQURkO0FBQUEsZ0JBRUksZ0JBRko7O0FBSUEscUJBQVMsUUFBUSxTQUFqQjtBQUNBLHNCQUFVLFFBQVEsSUFBbEI7O0FBRUE7QUFDQSwrQkFBbUIsUUFBUSxTQUEzQjs7QUFFQTtBQUNBLGdCQUFJLGlCQUFpQixPQUFqQixFQUFKLEVBQWdDO0FBQzVCLG1DQUFtQixRQUFRLElBQVIsQ0FBYSxLQUFiLEVBQW5CO0FBQ0g7O0FBRUQsK0JBQW1CLHdCQUFjLGlCQUFpQixRQUFqQixFQUFkLENBQW5CO0FBQ0EsMkJBQWUsaUJBQWlCLGNBQWpCLENBQWdDLE1BQWhDLENBQWY7O0FBRUEsMkJBQWUsQ0FBQyxDQUFoQjtBQUNBLGtDQUFzQixDQUF0Qjs7QUFFQSxpQkFBSyxVQUFMO0FBQ0gsU0ExQkQ7O0FBNEJBLGFBQUssS0FBTCxHQUFhLFlBQVc7QUFDcEIsbUJBQU8sU0FBUCxDQUFpQixLQUFqQixDQUF1QixJQUF2QixDQUE0QixJQUE1QjtBQUNBLGlCQUFLLFVBQUw7QUFDSCxTQUhEO0FBSUg7O0FBRUQsb0JBQWdCLFNBQWhCLEdBQTRCLE9BQU8sTUFBUCxDQUFjLE9BQU8sU0FBckIsQ0FBNUI7QUFDQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsV0FBMUIsR0FBd0MsZUFBeEM7O0FBRUEsYUFBUyxrQkFBVCxHQUE4QjtBQUMxQixZQUNJLFVBREo7QUFBQSxZQUVJLFlBQVksR0FGaEI7QUFBQSxZQUdJLGFBSEo7QUFBQSxZQUlJLFVBQVUsS0FKZDtBQUFBLFlBTUksZUFBZSxDQUFDLENBTnBCOztBQVFBLGFBQUssU0FBTCxHQUFpQixVQUFTLENBQVQsRUFBWSxNQUFaLEVBQW9CLFFBQXBCLEVBQThCO0FBQzNDLGdCQUFJLEtBQUssT0FBVCxFQUFrQjtBQUNkLHVCQUFPLElBQVA7QUFDSCxhQUZELE1BRU8sSUFBSSxDQUFDLEtBQUssU0FBTixJQUFtQixVQUFVLGNBQTdCLElBQStDLENBQUMsRUFBRSxNQUFsRCxJQUE0RCxDQUFDLElBQUksU0FBSixDQUFjLE9BQWQsQ0FBN0QsSUFDQSxFQUFFLE1BQUYsS0FBYSxVQUFVLFlBQVYsSUFBMEIsVUFBVSxjQUFWLElBQTRCLElBQUksU0FBSixDQUFjLE9BQWQsQ0FBbkUsQ0FESixFQUNnRztBQUNuRyw2QkFBYSxFQUFDLEdBQUcsTUFBSixFQUFZLEdBQUcsTUFBZixFQUFiOztBQUVBLDRCQUFZLEtBQUssV0FBTCxFQUFaO0FBQ0EsZ0NBQWdCLFVBQVUsS0FBVixFQUFoQjs7QUFFQSwwQkFBVSxLQUFWOztBQUVBLHFCQUFLLE9BQUwsR0FBZSxJQUFmO0FBQ0EsK0JBQWUsTUFBZjs7QUFFQSx1QkFBTyxJQUFQO0FBQ0gsYUFiTSxNQWFBLElBQUksS0FBSyxTQUFULEVBQW9CO0FBQ3ZCLDBCQUFVLEdBQVY7QUFDSDtBQUNKLFNBbkJEOztBQXFCQSxhQUFLLFNBQUwsR0FBaUIsVUFBUyxDQUFULEVBQVk7QUFDekIsZ0JBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2Qsb0JBQ0ksSUFBSSxFQUFDLEdBQUcsTUFBSixFQUFZLEdBQUcsTUFBZixFQURSO0FBQUEsb0JBR0ksZ0JBQWdCLEVBQUMsR0FBRyxFQUFFLE1BQUYsRUFBVSxLQUFWLEtBQW9CLENBQXhCLEVBQTJCLEdBQUcsRUFBRSxNQUFGLEVBQVUsTUFBVixLQUFxQixDQUFuRCxFQUhwQjtBQUFBLG9CQUlJLGVBQWUsRUFBQyxHQUFHLE9BQU8sS0FBUCxHQUFlLENBQW5CLEVBQXNCLEdBQUcsT0FBTyxNQUFQLEdBQWdCLENBQXpDLEVBSm5CO0FBQUEsb0JBTUksYUFBYSxLQUFLLEtBQUwsQ0FBVyxFQUFFLENBQUYsR0FBTSxjQUFjLENBQS9CLEVBQWtDLEVBQUUsQ0FBRixHQUFNLGNBQWMsQ0FBdEQsSUFBMkQsS0FBSyxLQUFMLENBQVcsV0FBVyxDQUFYLEdBQWUsY0FBYyxDQUF4QyxFQUEyQyxXQUFXLENBQVgsR0FBZSxjQUFjLENBQXhFLENBTjVFO0FBQUEsb0JBUUksV0FBVywyQkFSZjs7QUFVQSx5QkFBUyxpQkFBVCxDQUEyQixVQUEzQixFQUF1QyxhQUFhLENBQXBELEVBQXVELGFBQWEsQ0FBcEU7O0FBRUEseUJBQVMsUUFBVCxDQUFrQixhQUFsQjs7QUFFQSxxQkFBSyxXQUFMLENBQWlCLFlBQVksVUFBN0I7QUFDQSxxQkFBSyxTQUFMLENBQWUsQ0FBQyxDQUFDLFNBQVMsYUFBVCxFQUFqQixFQUEyQyxDQUFDLENBQUMsU0FBUyxhQUFULEVBQTdDOztBQUVBLDBCQUFVLElBQVY7O0FBRUEsdUJBQU8sSUFBUDtBQUNIO0FBQ0osU0F2QkQ7O0FBeUJBOzs7QUFHQSxpQkFBUyxjQUFULEdBQTBCO0FBQ3RCLGdCQUNJLHNCQUFzQixDQUQxQjs7QUFHQSxnQkFDSSxZQUFZLEtBQUssS0FBTCxDQUFXLGtCQUFrQixLQUFLLEVBQUwsR0FBVSxDQUE1QixDQUFYLElBQTZDLEtBQUssRUFBbEQsR0FBdUQsQ0FEdkU7O0FBR0EsZ0JBQUksS0FBSyxHQUFMLENBQVMsaUJBQWlCLFNBQTFCLElBQXVDLHNCQUFzQixHQUF0QixHQUE0QixLQUFLLEVBQTVFLEVBQWdGO0FBQzVFLG9CQUNJLGFBQWEsWUFBWSxTQUQ3QjtBQUFBLG9CQUdJLFNBQVMsRUFBQyxHQUFHLE9BQU8sS0FBUCxHQUFlLENBQW5CLEVBQXNCLEdBQUcsT0FBTyxNQUFQLEdBQWdCLENBQXpDLEVBSGI7QUFBQSxvQkFLSSxXQUFXLDJCQUxmOztBQU9BLHlCQUFTLGlCQUFULENBQTJCLFVBQTNCLEVBQXVDLE9BQU8sQ0FBOUMsRUFBaUQsT0FBTyxDQUF4RDs7QUFFQSx5QkFBUyxRQUFULENBQWtCLGFBQWxCOztBQUVBLHFCQUFLLFdBQUwsQ0FBaUIsWUFBWSxVQUE3QjtBQUNBLHFCQUFLLFNBQUwsQ0FBZSxDQUFDLENBQUMsU0FBUyxhQUFULEVBQWpCLEVBQTJDLENBQUMsQ0FBQyxTQUFTLGFBQVQsRUFBN0M7O0FBRUEscUJBQUssVUFBTDtBQUNIO0FBQ0o7O0FBRUQsYUFBSyxPQUFMLEdBQWUsVUFBUyxDQUFULEVBQVksTUFBWixFQUFvQixRQUFwQixFQUE4QjtBQUN6QyxnQkFBSSxLQUFLLE9BQUwsSUFBZ0IsVUFBVSxZQUE5QixFQUE0QztBQUN4QyxvQkFBSSxPQUFKLEVBQWE7QUFDVDtBQUNILGlCQUZELE1BRU87QUFDSCx5QkFBSyxhQUFMO0FBQ0g7O0FBRUQscUJBQUssT0FBTCxHQUFlLEtBQWY7O0FBRUEsb0JBQUksS0FBSyxTQUFMLElBQWtCLEVBQUUsSUFBSSxTQUFKLENBQWMsT0FBZCxLQUEwQixJQUFJLEdBQWhDLENBQXRCLEVBQTREO0FBQ3hELDhCQUFVLEdBQVY7QUFDSDs7QUFFRCx1QkFBTyxJQUFQO0FBQ0g7QUFDSixTQWhCRDs7QUFrQkEsYUFBSyxLQUFMLEdBQWEsVUFBUyxDQUFULEVBQVk7QUFDckIsZ0JBQUksS0FBSyxTQUFMLElBQWtCLGdCQUFnQixZQUFsQyxJQUFrRCxFQUFFLE9BQUYsSUFBYSxFQUFuRSxDQUFzRSxXQUF0RSxFQUFtRjtBQUMvRSw4QkFBVSxjQUFWOztBQUVBLDhCQUFVLEdBQVYsR0FIK0UsQ0FHOUQ7O0FBRWpCLDJCQUFPLElBQVA7QUFDSDtBQUNKLFNBUkQ7O0FBVUEsYUFBSyxPQUFMLEdBQWUsVUFBUyxDQUFULEVBQVk7QUFDdkIsZ0JBQUksRUFBRSxPQUFGLElBQWEsRUFBYixDQUFnQixXQUFoQixJQUErQixFQUFFLE1BQXJDLEVBQTZDO0FBQ3pDO0FBQ0EsdUJBQU8sSUFBUDtBQUNIO0FBQ0osU0FMRDtBQU1IOztBQUVELHVCQUFtQixTQUFuQixHQUErQixPQUFPLE1BQVAsQ0FBYyxPQUFPLFNBQXJCLENBQS9CO0FBQ0EsdUJBQW1CLFNBQW5CLENBQTZCLFdBQTdCLEdBQTJDLGtCQUEzQzs7QUFFQSxhQUFTLGtCQUFULEdBQThCO0FBQzFCO0FBQ0EsbUJBQVcsSUFBWCxDQUFnQixJQUFoQjtBQUNIOztBQUVELHVCQUFtQixTQUFuQixHQUErQixPQUFPLE1BQVAsQ0FBYyxXQUFXLFNBQXpCLENBQS9CO0FBQ0EsdUJBQW1CLFNBQW5CLENBQTZCLFdBQTdCLEdBQTJDLGtCQUEzQzs7QUFFQSx1QkFBbUIsU0FBbkIsQ0FBNkIsUUFBN0IsR0FBd0MsVUFBUyxJQUFULEVBQWUsRUFBZixFQUFtQjtBQUN2RCxnQkFBUSxZQUFSLENBQXFCLEtBQUssS0FBTCxDQUFXLEtBQUssQ0FBaEIsQ0FBckIsRUFBeUMsS0FBSyxLQUFMLENBQVcsS0FBSyxDQUFoQixDQUF6QyxFQUE2RCxLQUFLLEtBQUwsQ0FBVyxHQUFHLENBQWQsQ0FBN0QsRUFBK0UsS0FBSyxLQUFMLENBQVcsR0FBRyxDQUFkLENBQS9FLEVBQWlHLFdBQVcsY0FBWCxFQUFqRztBQUNILEtBRkQ7O0FBSUEsdUJBQW1CLFNBQW5CLENBQTZCLGlCQUE3QixHQUFpRCxZQUFXO0FBQ3hEO0FBQ0gsS0FGRDs7QUFJQSxhQUFTLFNBQVQsQ0FBbUIsTUFBbkIsRUFBMkI7QUFDdkIsWUFBSSxPQUFPLFlBQVAsQ0FBb0IsYUFBcEIsS0FBc0MsTUFBMUMsRUFBa0Q7QUFDOUMsbUJBQU8sWUFBUCxDQUFvQixhQUFwQixFQUFtQyxNQUFuQztBQUNIO0FBQ0o7O0FBRUo7Ozs7OztBQU1HLGFBQVMscUJBQVQsR0FBaUM7QUFDN0IsWUFDSSxjQUFjLFFBQVEsY0FBUixFQURsQjs7QUFHQSxZQUFJLENBQUMsWUFBWSxPQUFqQixFQUEwQjtBQUN0Qix1QkFBVyxxQkFBWCxDQUFpQyxRQUFRLG1CQUFSLEVBQWpDLEVBQWdFLHdDQUFoRSxFQUEwRyxPQUExRzs7QUFFQSxtQkFBTyxLQUFQO0FBQ0gsU0FKRCxNQUlPLElBQUksWUFBWSxLQUFaLElBQXFCLENBQXpCLEVBQTRCO0FBQy9CLHVCQUFXLHFCQUFYLENBQWlDLFFBQVEsbUJBQVIsRUFBakMsRUFBZ0UsOENBQWhFLEVBQWdILFNBQWhIOztBQUVBLG1CQUFPLEtBQVA7QUFDSDs7QUFFRCxlQUFPLElBQVA7QUFDSDs7QUFFRDs7Ozs7Ozs7O0FBU0EsYUFBUyxlQUFULENBQXlCLFNBQXpCLEVBQW9DLE1BQXBDLEVBQTRDLFFBQTVDLEVBQXNELFFBQXRELEVBQWdFLE1BQWhFLEVBQXdFO0FBQ3BFLFlBQ0ksT0FBTyxTQUFTLFFBQVQsR0FBb0IsTUFBcEIsR0FBNkIsV0FBVyxDQURuRDtBQUFBLFlBRUksT0FBTyxTQUFTLFFBQVQsR0FBb0IsTUFBcEIsR0FBNkIsV0FBVyxDQUZuRDs7QUFJQSxrQkFBVSxTQUFWLENBQW9CLENBQUMsTUFBckIsRUFBNkIsUUFBN0IsRUFBdUMsSUFBdkMsRUFBNkMsSUFBN0M7O0FBRUEsa0JBQVUsaUJBQVYsQ0FBNEIsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBRSxXQUFXLEdBQWIsQ0FBYixDQUE1QjtBQUNBLGtCQUFVLGdCQUFWLENBQTJCLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDLEVBQUUsV0FBVyxHQUFiLENBQWIsQ0FBM0I7QUFDSDs7QUFFRCxhQUFTLGdCQUFULEdBQTRCO0FBQ3hCLFlBQUksY0FBYyxJQUFkLElBQXNCLGNBQWMsSUFBcEMsSUFDTyxXQUFXLG1CQUFYLEVBRFAsSUFDMkMsV0FBVyxtQkFBWCxFQUQvQyxFQUNrRjtBQUMvRTtBQUNIOztBQUVELFlBQ0ksY0FBYyxlQUFlLHFCQUFXLENBQVgsRUFBYyxDQUFkLEVBQWlCLGNBQWMsS0FBL0IsRUFBc0MsY0FBYyxNQUFwRCxDQUFmLENBRGxCOztBQUdBLHdCQUFnQixVQUFoQixFQUE0QixZQUFZLElBQXhDLEVBQThDLFlBQVksUUFBWixFQUE5QyxFQUFzRSxFQUFFLE1BQUYsRUFBVSxLQUFWLEVBQXRFLEVBQXlGLEtBQUssU0FBTCxHQUFpQixDQUExRztBQUNBLHdCQUFnQixVQUFoQixFQUE0QixZQUFZLEdBQXhDLEVBQTZDLFlBQVksU0FBWixFQUE3QyxFQUFzRSxFQUFFLE1BQUYsRUFBVSxNQUFWLEVBQXRFLEVBQTBGLEtBQUssU0FBTCxHQUFpQixDQUEzRztBQUNGOztBQUVELGFBQVMsZUFBVCxHQUEyQjtBQUN2QixrQkFBVSxhQUFWO0FBQ0Esa0JBQVUsU0FBVixDQUFvQixPQUFwQixFQUE2QixPQUE3QjtBQUNBLGtCQUFVLEtBQVYsQ0FBZ0IsSUFBaEIsRUFBc0IsSUFBdEI7QUFDQSxrQkFBVSxNQUFWLENBQWlCLGNBQWpCOztBQUVBO0FBQ0EsYUFBSyxVQUFMO0FBQ0g7O0FBRUQ7OztBQUdBLGFBQVMsZUFBVCxDQUF5QixLQUF6QixFQUFnQztBQUM1QjtBQUNBLGVBQU8sVUFBVSxXQUFWLEdBQXdCLG1CQUF4QixDQUE0QyxLQUE1QyxDQUFQO0FBQ0g7O0FBRUQ7OztBQUdBLGFBQVMsa0JBQVQsQ0FBNEIsS0FBNUIsRUFBbUM7QUFDL0IsWUFDSSxTQUFTLGdCQUFnQixLQUFoQixDQURiOztBQUdBLGVBQU8sQ0FBUCxHQUFXLEtBQUssS0FBTCxDQUFXLE9BQU8sQ0FBbEIsQ0FBWDtBQUNBLGVBQU8sQ0FBUCxHQUFXLEtBQUssS0FBTCxDQUFXLE9BQU8sQ0FBbEIsQ0FBWDs7QUFFQSxlQUFPLE1BQVA7QUFDSDs7QUFFRDs7O0FBR0EsYUFBUyxrQkFBVCxDQUE0QixLQUE1QixFQUFtQztBQUMvQixZQUNJLE9BQU8sT0FBTyxxQkFBUCxFQURYOztBQUdBLGVBQU8sRUFBQyxHQUFHLE1BQU0sQ0FBTixHQUFVLEtBQUssSUFBZixHQUFzQixPQUFPLFdBQWpDLEVBQThDLEdBQUcsTUFBTSxDQUFOLEdBQVUsS0FBSyxHQUFmLEdBQXFCLE9BQU8sV0FBN0UsRUFBUDtBQUNIOztBQUVELGFBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQjtBQUN2QixlQUFPLFVBQVUsbUJBQVYsQ0FBOEIsQ0FBOUIsQ0FBUDtBQUNIOztBQUVELGFBQVMsaUJBQVQsQ0FBMkIsQ0FBM0IsRUFBOEI7QUFDMUIsWUFDSSxTQUFTLGVBQWUsQ0FBZixDQURiOztBQUdBLGVBQU8sQ0FBUCxHQUFXLEtBQUssS0FBTCxDQUFXLE9BQU8sQ0FBbEIsQ0FBWDtBQUNBLGVBQU8sQ0FBUCxHQUFXLEtBQUssS0FBTCxDQUFXLE9BQU8sQ0FBbEIsQ0FBWDs7QUFFQSxlQUFPLE1BQVA7QUFDSDs7QUFFSjs7Ozs7O0FBTUcsYUFBUyxhQUFULENBQXVCLElBQXZCLEVBQTZCO0FBQ3pCLFlBQ0ksU0FBUyxlQUFlLEVBQUMsR0FBRyxDQUFDLEtBQUssSUFBTCxHQUFZLEtBQUssS0FBbEIsSUFBMkIsQ0FBL0IsRUFBa0MsR0FBRyxDQUFDLEtBQUssR0FBTCxHQUFXLEtBQUssTUFBakIsSUFBMkIsQ0FBaEUsRUFBZixDQURiO0FBQUEsWUFFSSxTQUFTLEtBQUssUUFBTCxFQUZiOztBQUlBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQTNCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLG1CQUFPLENBQVAsSUFBWSxrQkFBa0IsT0FBTyxDQUFQLENBQWxCLENBQVo7O0FBRUE7QUFDQSxtQkFBTyxDQUFQLEVBQVUsQ0FBVixJQUFnQixLQUFLLElBQUwsQ0FBVSxPQUFPLENBQVAsR0FBVyxPQUFPLENBQVAsRUFBVSxDQUEvQixJQUFvQyxHQUFwRDtBQUNBLG1CQUFPLENBQVAsRUFBVSxDQUFWLElBQWdCLEtBQUssSUFBTCxDQUFVLE9BQU8sQ0FBUCxHQUFXLE9BQU8sQ0FBUCxFQUFVLENBQS9CLElBQW9DLEdBQXBEO0FBQ0g7O0FBRUQsZUFBTyxNQUFQO0FBQ0g7O0FBRUQsYUFBUyxhQUFULENBQXVCLE9BQXZCLEVBQWdDLE1BQWhDLEVBQXdDO0FBQ3BDLGdCQUFRLFNBQVI7O0FBRUEsZ0JBQVEsTUFBUixDQUFlLE9BQU8sQ0FBUCxFQUFVLENBQXpCLEVBQTRCLE9BQU8sQ0FBUCxFQUFVLENBQXRDO0FBQ0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sTUFBM0IsRUFBbUMsR0FBbkMsRUFBd0M7QUFDcEMsb0JBQVEsTUFBUixDQUFlLE9BQU8sQ0FBUCxFQUFVLENBQXpCLEVBQTRCLE9BQU8sQ0FBUCxFQUFVLENBQXRDO0FBQ0g7QUFDRCxnQkFBUSxNQUFSLENBQWUsT0FBTyxDQUFQLEVBQVUsQ0FBekIsRUFBNEIsT0FBTyxDQUFQLEVBQVUsQ0FBdEM7O0FBRUEsZ0JBQVEsTUFBUjtBQUNIOztBQUVEOzs7QUFHQSxhQUFTLGlCQUFULENBQTJCLE9BQTNCLEVBQW9DLElBQXBDLEVBQTBDO0FBQ3RDLHNCQUFjLE9BQWQsRUFBdUIsY0FBYyxJQUFkLENBQXZCO0FBQ0g7O0FBRUQ7OztBQUdBLGFBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQjtBQUN2QixZQUNJLEtBQUssa0JBQWtCLEVBQUMsR0FBRyxFQUFFLElBQUYsR0FBUyxDQUFiLEVBQWdCLEdBQUcsRUFBRSxHQUFGLEdBQVEsQ0FBM0IsRUFBbEIsQ0FEVDtBQUFBLFlBRUksS0FBSyxrQkFBa0IsRUFBQyxHQUFHLEVBQUUsSUFBRixHQUFTLENBQWIsRUFBZ0IsR0FBRyxFQUFFLE1BQXJCLEVBQWxCLENBRlQ7QUFBQSxZQUdJLEtBQUssa0JBQWtCLEVBQUMsR0FBRyxFQUFFLEtBQU4sRUFBYSxHQUFHLEVBQUUsR0FBRixHQUFRLENBQXhCLEVBQWxCLENBSFQ7QUFBQSxZQUlJLEtBQUssa0JBQWtCLEVBQUMsR0FBRyxFQUFFLEtBQU4sRUFBYSxHQUFHLEVBQUUsTUFBbEIsRUFBbEIsQ0FKVDtBQUFBLFlBTUksS0FBSyxxQkFDRCxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxHQUFHLENBQVosRUFBZSxHQUFHLENBQWxCLENBQVQsRUFBK0IsS0FBSyxHQUFMLENBQVMsR0FBRyxDQUFaLEVBQWUsR0FBRyxDQUFsQixDQUEvQixDQURDLEVBRUQsS0FBSyxHQUFMLENBQVMsS0FBSyxHQUFMLENBQVMsR0FBRyxDQUFaLEVBQWUsR0FBRyxDQUFsQixDQUFULEVBQStCLEtBQUssR0FBTCxDQUFTLEdBQUcsQ0FBWixFQUFlLEdBQUcsQ0FBbEIsQ0FBL0IsQ0FGQyxFQUdELEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLEdBQUcsQ0FBWixFQUFlLEdBQUcsQ0FBbEIsQ0FBVCxFQUErQixLQUFLLEdBQUwsQ0FBUyxHQUFHLENBQVosRUFBZSxHQUFHLENBQWxCLENBQS9CLElBQXVELENBSHRELEVBSUQsS0FBSyxHQUFMLENBQVMsS0FBSyxHQUFMLENBQVMsR0FBRyxDQUFaLEVBQWUsR0FBRyxDQUFsQixDQUFULEVBQStCLEtBQUssR0FBTCxDQUFTLEdBQUcsQ0FBWixFQUFlLEdBQUcsQ0FBbEIsQ0FBL0IsSUFBdUQsQ0FKdEQsQ0FOVDs7QUFhQSxXQUFHLElBQUgsQ0FBUSxDQUFSLEVBQVcsQ0FBWCxFQWR1QixDQWNSOztBQUVmLGVBQU8sRUFBUDtBQUNIOztBQUVEOzs7QUFHQSxhQUFTLFlBQVQsR0FBd0I7QUFDcEIsWUFDSSxRQUFRLE9BQU8sS0FEbkI7QUFBQSxZQUVJLFNBQVMsT0FBTyxNQUZwQjtBQUFBLFlBSUksZ0JBQWdCLGVBQWUsRUFBQyxHQUFHLFFBQVEsS0FBUixHQUFnQixDQUFwQixFQUF1QixHQUFHLFFBQVEsTUFBUixHQUFpQixDQUEzQyxFQUFmLENBSnBCOztBQU1BLGFBQUssU0FBTCxDQUNJLEtBQUssS0FBTCxDQUFXLFVBQVUsUUFBUSxHQUFsQixHQUF3QixjQUFjLENBQWpELENBREosRUFFSSxLQUFLLEtBQUwsQ0FBVyxVQUFVLFNBQVMsR0FBbkIsR0FBeUIsY0FBYyxDQUFsRCxDQUZKO0FBSUg7O0FBRUQsU0FBSyxPQUFMLEdBQWUsVUFBUyxLQUFULEVBQWdCO0FBQzNCLGVBQU8sS0FBUDtBQUNBO0FBQ0gsS0FIRDs7QUFLQSxTQUFLLE9BQUwsR0FBZSxZQUFXO0FBQ3RCLGVBQU8sSUFBUDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxXQUFMLEdBQW1CLFVBQVMsU0FBVCxFQUFvQjtBQUNuQyxtQkFBVyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEtBQUwsQ0FBVyxTQUFYLENBQVQsRUFBZ0MsQ0FBaEMsQ0FBWDtBQUNBLGFBQUssVUFBTDtBQUNILEtBSEQ7O0FBS0EsU0FBSyxXQUFMLEdBQW1CLFlBQVc7QUFDMUIsZUFBTyxRQUFQO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLFNBQUwsR0FBaUIsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQzVCLFlBQUksTUFBTSxDQUFOLEtBQVksTUFBTSxDQUFOLENBQWhCLEVBQTBCO0FBQ3RCLG9CQUFRLEdBQVIsQ0FBWSxZQUFaO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsc0JBQVUsQ0FBVjtBQUNBLHNCQUFVLENBQVY7QUFDQTtBQUNIO0FBQ0osS0FSRDs7QUFVQSxTQUFLLFNBQUwsR0FBaUIsWUFBVztBQUN4QixlQUFPLEVBQUMsR0FBRyxPQUFKLEVBQWEsR0FBRyxPQUFoQixFQUFQO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLGdCQUFMLEdBQXdCLFVBQVMsT0FBVCxFQUFrQjtBQUN0Qyx3QkFBZ0IsT0FBaEI7O0FBRUEsZ0RBQXVCLGFBQXZCLEVBQXNDLE9BQXRDOztBQUVBLGFBQUssVUFBTDtBQUNILEtBTkQ7O0FBUUEsU0FBSyxXQUFMLEdBQW1CLFVBQVMsS0FBVCxFQUFnQjtBQUMvQix5QkFBaUIsU0FBUyxJQUFJLEtBQUssRUFBbEIsQ0FBakI7QUFDQTtBQUNILEtBSEQ7O0FBS0E7Ozs7O0FBS0EsU0FBSyxXQUFMLEdBQW1CLFlBQVc7QUFDMUIsZUFBTyxjQUFQO0FBQ0gsS0FGRDs7QUFJQTs7O0FBR0EsU0FBSyxhQUFMLEdBQXFCLFlBQVc7QUFDNUIsWUFDSSxXQUFXLEtBQUssS0FBTCxDQUFXLEtBQUssV0FBTCxLQUFxQixLQUFLLEVBQTFCLEdBQStCLENBQTFDLENBRGY7O0FBR0E7QUFDQSxvQkFBWSxDQUFaOztBQUVBO0FBQ0EsWUFBSSxXQUFXLENBQWYsRUFBa0I7QUFDZCx3QkFBWSxDQUFaO0FBQ0g7O0FBRUQsZUFBTyxRQUFQO0FBQ0gsS0FiRDs7QUFlQTs7Ozs7O0FBTUEsYUFBUyxXQUFULENBQXFCLElBQXJCLEVBQTJCLE9BQTNCLEVBQW9DLE9BQXBDLEVBQTZDO0FBQ3pDLGVBQU8sS0FBSyxHQUFMLENBQVMsUUFBVCxFQUFtQixLQUFLLEdBQUwsQ0FBUyxRQUFULEVBQW1CLElBQW5CLENBQW5CLENBQVA7O0FBRUEsWUFBSSxLQUFLLE9BQUwsTUFBa0IsSUFBdEIsRUFBNEI7QUFDeEIsZ0JBQ0ksU0FBUyxLQUFLLFNBQUwsRUFEYjs7QUFHQSxpQkFBSyxTQUFMLENBQ0ksT0FBTyxDQUFQLEdBQVcsQ0FBQyxFQUFFLENBQUMsVUFBVSxPQUFPLENBQWxCLEtBQXdCLElBQUksT0FBTyxLQUFLLE9BQUwsRUFBbkMsQ0FBRixDQURoQixFQUVJLE9BQU8sQ0FBUCxHQUFXLENBQUMsRUFBRSxDQUFDLFVBQVUsT0FBTyxDQUFsQixLQUF3QixJQUFJLE9BQU8sS0FBSyxPQUFMLEVBQW5DLENBQUYsQ0FGaEI7O0FBS0EsaUJBQUssT0FBTCxDQUFhLElBQWI7O0FBRUE7Ozs7OztBQU1BLGlCQUFLLFVBQUw7QUFDSDtBQUNKOztBQUVEO0FBQ0EsYUFBUyxZQUFULENBQXNCLElBQXRCLEVBQTRCO0FBQ3hCLFlBQ0ksUUFBUSxFQUFFLE1BQUYsRUFBVSxLQUFWLEVBRFo7QUFBQSxZQUVJLFNBQVMsRUFBRSxNQUFGLEVBQVUsTUFBVixFQUZiOztBQUlBLG9CQUFZLElBQVosRUFBa0IsUUFBUSxDQUExQixFQUE2QixTQUFTLENBQXRDO0FBQ0g7O0FBRUQsU0FBSyxNQUFMLEdBQWMsWUFBVztBQUNyQixxQkFBYSxLQUFLLE9BQUwsS0FBaUIsQ0FBOUI7QUFDSCxLQUZEOztBQUlBLFNBQUssT0FBTCxHQUFlLFlBQVc7QUFDdEIscUJBQWEsS0FBSyxPQUFMLEtBQWlCLEdBQTlCO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLE9BQUwsR0FBZSxZQUFXO0FBQ3RCLHFCQUFhLENBQWI7QUFDQTtBQUNILEtBSEQ7O0FBS0EsU0FBSyxhQUFMLEdBQXFCLFlBQVc7QUFDNUIsWUFDSSxTQUFTLEVBQUMsR0FBRyxPQUFPLEtBQVAsR0FBZSxDQUFuQixFQUFzQixHQUFHLE9BQU8sTUFBUCxHQUFnQixDQUF6QyxFQURiO0FBQUEsWUFHSSxXQUFXLDJCQUhmOztBQUtBLGlCQUFTLGlCQUFULENBQTJCLENBQUMsS0FBSyxXQUFMLEVBQTVCLEVBQWdELE9BQU8sQ0FBdkQsRUFBMEQsT0FBTyxDQUFqRTtBQUNBLGlCQUFTLFFBQVQsQ0FBa0IsU0FBbEI7O0FBRUEsYUFBSyxTQUFMLENBQWUsQ0FBQyxDQUFDLFNBQVMsYUFBVCxFQUFqQixFQUEyQyxDQUFDLENBQUMsU0FBUyxhQUFULEVBQTdDO0FBQ0EsYUFBSyxXQUFMLENBQWlCLENBQWpCO0FBQ0gsS0FYRDs7QUFhQTs7O0FBR0EsYUFBUyxrQkFBVCxDQUE0QixDQUE1QixFQUErQjtBQUMzQjtBQUNBLFlBQUksWUFBSixFQUFrQjtBQUNkLG1CQUFPLE9BQU8sV0FBUCxFQUFQO0FBQ0gsU0FGRCxNQUVPO0FBQ0g7OztBQUdBLG1CQUFPLEVBQUUsUUFBRixHQUFhLENBQXBCO0FBQ0g7QUFDSjs7QUFFRCxRQUNJLHFCQUFxQixLQUR6Qjs7QUFHQSxhQUFTLGdCQUFULENBQTBCLENBQTFCLEVBQTZCO0FBQ3pCLFlBQUksRUFBRSxNQUFGLElBQVksQ0FBaEIsRUFBbUI7QUFDZixnQkFBSSxDQUFDLGtCQUFELElBQXVCLEtBQUssR0FBTCxDQUFTLEVBQUUsTUFBWCxJQUFxQixFQUFoRCxFQUFvRDtBQUNoRCxvQkFDSSxNQURKOztBQUdBLG9CQUFJLEVBQUUsTUFBRixHQUFXLENBQWYsRUFBa0I7QUFDZCw2QkFBUyxJQUFJLElBQWI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsNkJBQVMsSUFBVDtBQUNIOztBQUVELG9CQUNJLGNBQWMsbUJBQW1CLEVBQUMsR0FBRyxFQUFFLEtBQU4sRUFBYSxHQUFHLEVBQUUsS0FBbEIsRUFBbkIsQ0FEbEI7QUFBQSxvQkFFSSxXQUFXLGdCQUFnQixXQUFoQixDQUZmOztBQUlBLG9CQUFJLFFBQVEsYUFBUixDQUFzQixTQUFTLENBQS9CLEVBQWtDLFNBQVMsQ0FBM0MsQ0FBSixFQUFtRDtBQUMvQyxnQ0FDSSxLQUFLLE9BQUwsS0FBaUIsTUFEckIsRUFFSSxZQUFZLENBRmhCLEVBR0ksWUFBWSxDQUhoQjtBQUtILGlCQU5ELE1BTU87QUFDSCxnQ0FDSSxLQUFLLE9BQUwsS0FBaUIsTUFEckIsRUFFSSxVQUFVLENBQUMsRUFBRSxRQUFRLEtBQVIsR0FBZ0IsSUFBaEIsR0FBdUIsQ0FBekIsQ0FGZixFQUdJLFVBQVUsQ0FBQyxFQUFFLFFBQVEsTUFBUixHQUFpQixJQUFqQixHQUF3QixDQUExQixDQUhmO0FBS0g7O0FBRUQscUNBQXFCLHNCQUFzQixXQUFXLFlBQVc7QUFDN0QseUNBQXFCLEtBQXJCO0FBQ0gsaUJBRjBDLEVBRXhDLEVBRndDLENBQTNDO0FBR0g7O0FBRUQsY0FBRSxjQUFGO0FBQ0g7QUFDSjs7QUFFRCxRQUNJLGdCQURKOztBQUdBLGFBQVMsaUJBQVQsQ0FBMkIsQ0FBM0IsRUFBOEI7QUFDMUI7QUFDQSxZQUFJLENBQUMsZ0JBQUwsRUFBdUI7QUFDbkIsK0JBQW1CLE9BQU8scUJBQVAsRUFBbkI7QUFDSDs7QUFFRDs7O0FBR0EsaUJBQVMsRUFBRSxPQUFGLEdBQVksaUJBQWlCLElBQXRDO0FBQ0EsaUJBQVMsRUFBRSxPQUFGLEdBQVksaUJBQWlCLEdBQXRDOztBQUVBO0FBQ0EsWUFDSSxlQUFlLENBRG5CO0FBQUEsWUFFSSxpQkFBaUIsQ0FGckI7QUFBQSxZQUdJLGFBQWEsQ0FIakI7O0FBS0EsWUFDSSxhQUFhLEVBQUUsT0FBRixJQUFhLENBRDlCO0FBQUEsWUFFSSxXQUFXLG1CQUFtQixDQUFuQixDQUZmOztBQUlOO0FBQ00sWUFBSyxDQUFDLEVBQUUsT0FBRixHQUFZLFlBQWIsS0FBOEIsQ0FBL0IsSUFBcUMsVUFBVSxjQUFWLENBQXpDLEVBQW9FO0FBQ2hFLGdCQUFJLEVBQUUsV0FBRixLQUFrQixHQUF0QixFQUEyQjtBQUN2Qjs7Ozs7QUFLQSx1QkFOdUIsQ0FNZjtBQUNYOztBQUVELHNCQUFVLGNBQVYsSUFBNEIsQ0FBQyxVQUFVLGNBQVYsQ0FBN0I7O0FBRUEsZ0JBQUksVUFBVSxjQUFWLENBQUosRUFBK0I7QUFDM0IsMEJBQVUsU0FBVixDQUFvQixDQUFwQixFQUF1QixjQUF2QixFQUF1QyxRQUF2QztBQUNILGFBRkQsTUFFTztBQUNILDBCQUFVLE9BQVYsQ0FBa0IsQ0FBbEIsRUFBcUIsY0FBckIsRUFBcUMsUUFBckM7QUFDSDtBQUNKOztBQUVELFlBQUssQ0FBQyxFQUFFLE9BQUYsR0FBWSxjQUFiLEtBQWdDLENBQWpDLElBQXVDLFVBQVUsZ0JBQVYsQ0FBM0MsRUFBd0U7QUFDcEUsc0JBQVUsZ0JBQVYsSUFBOEIsQ0FBQyxVQUFVLGdCQUFWLENBQS9COztBQUVBLGdCQUFJLFVBQVUsZ0JBQVYsQ0FBSixFQUFpQztBQUM3QiwwQkFBVSxTQUFWLENBQW9CLENBQXBCLEVBQXVCLGdCQUF2QixFQUF5QyxRQUF6QztBQUNILGFBRkQsTUFFTztBQUNILDBCQUFVLE9BQVYsQ0FBa0IsQ0FBbEIsRUFBcUIsZ0JBQXJCLEVBQXVDLFFBQXZDO0FBQ0g7QUFDSjs7QUFFRCxZQUFLLENBQUMsRUFBRSxPQUFGLEdBQVksVUFBYixLQUE0QixDQUE3QixJQUFtQyxVQUFVLFlBQVYsQ0FBdkMsRUFBZ0U7QUFDNUQsc0JBQVUsWUFBVixJQUEwQixDQUFDLFVBQVUsWUFBVixDQUEzQjs7QUFFQSxnQkFBSSxVQUFVLFlBQVYsQ0FBSixFQUE2QjtBQUN6QiwwQkFBVSxTQUFWLENBQW9CLENBQXBCLEVBQXVCLFlBQXZCLEVBQXFDLFFBQXJDO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsMEJBQVUsT0FBVixDQUFrQixDQUFsQixFQUFxQixZQUFyQixFQUFtQyxRQUFuQztBQUNIO0FBQ0o7O0FBRUQsWUFBSSxVQUFKLEVBQWdCO0FBQ1osc0JBQVUsU0FBVixDQUFvQixDQUFwQixFQUF1QixRQUF2QjtBQUNILFNBRkQsTUFFTztBQUNILHNCQUFVLFNBQVYsQ0FBb0IsQ0FBcEIsRUFBdUIsUUFBdkI7QUFDSDtBQUNKOztBQUVEO0FBQ0EsYUFBUyxlQUFULENBQXlCLENBQXpCLEVBQTRCO0FBQ3hCLGtCQUFVLGNBQVYsSUFBNEIsS0FBNUI7QUFDQSxrQkFBVSxnQkFBVixJQUE4QixLQUE5QjtBQUNBLGtCQUFVLFlBQVYsSUFBMEIsS0FBMUI7O0FBRUEsdUJBQWUsS0FBZjtBQUNBLGtCQUFVLE9BQVYsQ0FBa0IsQ0FBbEIsRUFBcUIsRUFBRSxNQUF2QixFQUErQixHQUEvQjtBQUNBLGVBQU8scUJBQVAsQ0FBNkIsRUFBRSxTQUEvQjtBQUNIOztBQUVEO0FBQ0EsYUFBUyxpQkFBVCxDQUEyQixDQUEzQixFQUE4QjtBQUMxQixlQUFPLGlCQUFQLENBQXlCLEVBQUUsU0FBM0I7O0FBRUEsMkJBQW1CLE9BQU8scUJBQVAsRUFBbkI7O0FBRUE7QUFDQSxpQkFBUyxFQUFFLE9BQUYsR0FBWSxpQkFBaUIsSUFBdEM7QUFDQSxpQkFBUyxFQUFFLE9BQUYsR0FBWSxpQkFBaUIsR0FBdEM7O0FBRUEsdUJBQWUsT0FBTyxLQUFQLEVBQWY7O0FBRUEsa0JBQVUsY0FBVixJQUE0QixLQUE1QjtBQUNBLGtCQUFVLGdCQUFWLElBQThCLEtBQTlCO0FBQ0Esa0JBQVUsWUFBVixJQUEwQixLQUExQjs7QUFFQSxrQkFBVSxFQUFFLE1BQVosSUFBc0IsSUFBdEI7O0FBRUEsa0JBQVUsU0FBVixDQUFvQixDQUFwQixFQUF1QixFQUFFLE1BQXpCLEVBQWlDLG1CQUFtQixDQUFuQixDQUFqQztBQUNIOztBQUVELGFBQVMsYUFBVCxDQUF1QixDQUF2QixFQUEwQjtBQUN0QixrQkFBVSxPQUFWLENBQWtCLENBQWxCO0FBQ0g7O0FBRUQsYUFBUyxXQUFULENBQXFCLENBQXJCLEVBQXdCO0FBQ3BCLGtCQUFVLEtBQVYsQ0FBZ0IsQ0FBaEI7QUFDSDs7QUFFRDtBQUNBLFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLGVBQU8sZUFBUDtBQUNILEtBRkQ7O0FBSUE7OztBQUdBLGFBQVMsT0FBVCxHQUFtQjtBQUNmLFlBQUksQ0FBQyxnQkFBTCxFQUF1QjtBQUNuQiwrQkFBbUIsSUFBbkI7QUFDQSxtQkFBTyxxQkFBUCxDQUE2QixZQUFXO0FBQ3BDLHFCQUFLLEtBQUw7QUFDSCxhQUZEO0FBR0g7QUFDSjs7QUFFRDs7O0FBR0EsU0FBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsc0JBQWMsSUFBZCxHQUFxQixDQUFyQjtBQUNBLHNCQUFjLEdBQWQsR0FBb0IsQ0FBcEI7QUFDQSxzQkFBYyxLQUFkLEdBQXNCLE9BQU8sS0FBN0I7QUFDQSxzQkFBYyxNQUFkLEdBQXVCLE9BQU8sTUFBOUI7O0FBRUE7QUFDSCxLQVBEOztBQVNBOzs7OztBQUtBLGFBQVMsV0FBVCxDQUFxQixJQUFyQixFQUEyQjtBQUN2QixzQkFBYyxLQUFkLENBQW9CLElBQXBCOztBQUVBO0FBQ0g7O0FBRUo7Ozs7Ozs7QUFPRyxhQUFTLHVCQUFULENBQWlDLGFBQWpDLEVBQWdELElBQWhELEVBQXNEO0FBQ2xELGVBQU8sT0FBTyxPQUFkO0FBQ0Esc0JBQWMsd0JBQWQsR0FBeUMsV0FBekM7O0FBRUEsWUFBSSxjQUFjLHdCQUFkLElBQTBDLFdBQTlDLEVBQTJEO0FBQ3ZEO0FBQ0EsMEJBQWMsSUFBZCxJQUFzQixPQUF0QjtBQUNILFNBSEQsTUFHTztBQUNIO0FBQ0E7QUFDQSwwQkFBYyx3QkFBZCxHQUF5QyxZQUF6QztBQUNBLDBCQUFjLElBQWQsSUFBc0IsTUFBdEI7O0FBRUE7QUFDQSxnQkFBSSxjQUFjLHdCQUFkLElBQTBDLFlBQTlDLEVBQTREO0FBQ3hELDhCQUFjLElBQWQsSUFBc0IsT0FBdEI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsU0FBSyxLQUFMLEdBQWEsWUFBVztBQUNwQixZQUNJLG9CQUFvQixLQUR4Qjs7QUFHQSwyQkFBbUIsS0FBbkI7O0FBRUE7QUFDQSxZQUFJLENBQUMsY0FBYyxPQUFkLEVBQUwsRUFBOEI7QUFDMUIsMEJBQWMsSUFBZDs7QUFFQSxnQkFBSSxjQUFjLElBQWxCLEVBQXdCO0FBQ3BCLDhCQUFjLFNBQWQ7O0FBRUEsOEJBQWMsSUFBZCxHQUFxQixjQUFjLElBQWQsR0FBcUIsQ0FBMUM7QUFDQSw4QkFBYyxHQUFkLEdBQW9CLGNBQWMsR0FBZCxHQUFvQixDQUF4Qzs7QUFFQSw4QkFBYyxJQUFkLENBQ0ksY0FBYyxJQURsQixFQUVJLGNBQWMsR0FGbEIsRUFHSSxLQUFLLElBQUwsQ0FBVSxjQUFjLFFBQWQsRUFBVixDQUhKLEVBSUksS0FBSyxJQUFMLENBQVUsY0FBYyxTQUFkLEVBQVYsQ0FKSjs7QUFPQSw4QkFBYyxJQUFkO0FBQ0g7O0FBRUQsZ0NBQW9CLElBQXBCO0FBQ0g7O0FBRUQ7QUFDQSxZQUFJLENBQUMsb0JBQW9CLE9BQXBCLEVBQUwsRUFBb0M7QUFDaEMsZ0JBQ0ksWUFBWSxRQUFRLFlBQVIsRUFEaEI7O0FBR0EsaUNBQXFCLFlBQXJCLENBQ0ksU0FESixFQUNlLENBRGYsRUFDa0IsQ0FEbEIsRUFDcUIsb0JBQW9CLElBRHpDLEVBQytDLG9CQUFvQixHQURuRSxFQUN3RSxvQkFBb0IsUUFBcEIsRUFEeEUsRUFDd0csb0JBQW9CLFNBQXBCLEVBRHhHOztBQUlBLGdDQUFvQixTQUFwQjtBQUNIOztBQUVELHNCQUFjLFNBQWQsR0FBMEIsU0FBMUI7QUFDQSxzQkFBYyxRQUFkLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLE9BQU8sS0FBcEMsRUFBMkMsT0FBTyxNQUFsRDs7QUFFQTtBQUNBLHNCQUFjLElBQWQ7QUFDQTtBQUNJLDBCQUFjLFlBQWQsQ0FBMkIsVUFBVSxDQUFWLENBQVksQ0FBWixDQUEzQixFQUEyQyxVQUFVLENBQVYsQ0FBWSxDQUFaLENBQTNDLEVBQTJELFVBQVUsQ0FBVixDQUFZLENBQVosQ0FBM0QsRUFBMkUsVUFBVSxDQUFWLENBQVksQ0FBWixDQUEzRSxFQUEyRixVQUFVLENBQVYsQ0FBWSxDQUFaLENBQTNGLEVBQTJHLFVBQVUsQ0FBVixDQUFZLENBQVosQ0FBM0c7O0FBRUEsMEJBQWMsU0FBZCxHQUEwQixtQkFBMUI7QUFDQSwwQkFBYyxRQUFkLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLFFBQVEsS0FBckMsRUFBNEMsUUFBUSxNQUFwRDs7QUFFQSwwQkFBYyxTQUFkLENBQ0ksYUFESixFQUNtQixDQURuQixFQUNzQixDQUR0QixFQUN5QixjQUFjLEtBRHZDLEVBQzhDLGNBQWMsTUFENUQ7QUFHSDtBQUNELHNCQUFjLE9BQWQ7O0FBRUE7QUFDQSxnQ0FBd0IsYUFBeEIsRUFBdUMsUUFBdkM7O0FBRUEsc0JBQWMsU0FBZCxHQUEwQixHQUExQjs7QUFFQTtBQUNBLFlBQUksQ0FBQyxRQUFRLFlBQVIsR0FBdUIsT0FBdkIsRUFBRCxJQUFxQyxFQUFFLFVBQVUsSUFBVixjQUE0QixtQkFBNUIsSUFBbUQsVUFBVSxJQUFWLEdBQWlCLE9BQXRFLENBQXpDLEVBQXlIO0FBQ3JILDBCQUFjLFdBQWQsQ0FBMEIsQ0FBQyxDQUFELEVBQUksQ0FBSixDQUExQjs7QUFFQSw4QkFBa0IsYUFBbEIsRUFBaUMsUUFBUSxZQUFSLEVBQWpDOztBQUVBLDBCQUFjLFdBQWQsQ0FBMEIsRUFBMUI7QUFDSDs7QUFFRDtBQUNBLFlBQUksUUFBSixFQUFjO0FBQ1YsZ0JBQ0ksU0FBUyxRQUFRLFNBQVIsRUFEYjtBQUFBLGdCQUdJLGtCQUFrQixPQUFPLFFBSDdCOztBQUtBOzs7QUFHQSxnQkFBSSxrQkFBa0IsQ0FBdEIsRUFBeUI7QUFDckIsOEJBQWMsU0FBZDs7QUFFQTtBQUNBLHFCQUFLLElBQUksSUFBSSxXQUFXLENBQXhCLEVBQTJCLElBQUksT0FBTyxLQUF0QyxFQUE2QyxLQUFLLFFBQWxELEVBQTREO0FBQ3hELHdCQUNJLEtBQUssZUFBZSxFQUFDLEdBQUcsQ0FBSixFQUFPLEdBQUcsT0FBTyxHQUFqQixFQUFmLENBRFQ7QUFBQSx3QkFFSSxLQUFLLGVBQWUsRUFBQyxHQUFHLENBQUosRUFBTyxHQUFHLE9BQU8sTUFBakIsRUFBZixDQUZUOztBQUlBLGtDQUFjLE1BQWQsQ0FBcUIsR0FBRyxDQUFILEdBQU8sR0FBNUIsRUFBaUMsR0FBRyxDQUFILEdBQU8sR0FBeEM7QUFDQSxrQ0FBYyxNQUFkLENBQXFCLEdBQUcsQ0FBSCxHQUFPLEdBQTVCLEVBQWlDLEdBQUcsQ0FBSCxHQUFPLEdBQXhDO0FBQ0g7O0FBRUQ7QUFDQSxxQkFBSyxJQUFJLElBQUksV0FBVyxDQUF4QixFQUEyQixJQUFJLE9BQU8sTUFBdEMsRUFBOEMsS0FBSyxRQUFuRCxFQUE2RDtBQUN6RCx3QkFDSSxLQUFLLGVBQWUsRUFBQyxHQUFHLENBQUosRUFBTyxHQUFHLENBQVYsRUFBZixDQURUO0FBQUEsd0JBRUksS0FBSyxlQUFlLEVBQUMsR0FBRyxPQUFPLEtBQVgsRUFBa0IsR0FBRyxDQUFyQixFQUFmLENBRlQ7O0FBSUEsa0NBQWMsTUFBZCxDQUFxQixHQUFHLENBQUgsR0FBTyxHQUE1QixFQUFpQyxHQUFHLENBQUgsR0FBTyxHQUF4QztBQUNBLGtDQUFjLE1BQWQsQ0FBcUIsR0FBRyxDQUFILEdBQU8sR0FBNUIsRUFBaUMsR0FBRyxDQUFILEdBQU8sR0FBeEM7QUFDSDs7QUFFRCw4QkFBYyxNQUFkO0FBQ0g7QUFDSjs7QUFFRDtBQUNBLGtCQUFVLEtBQVYsQ0FBZ0IsYUFBaEI7O0FBRUEsc0JBQWMsd0JBQWQsR0FBeUMsYUFBekM7O0FBRUEsWUFBSSxpQkFBSixFQUF1QjtBQUNuQiwwQkFBYyxTQUFkOztBQUVBLDBCQUFjLE9BQWQ7QUFDSDtBQUNKLEtBdkhEOztBQXlIQSxTQUFLLFFBQUwsR0FBZ0IsVUFBUyxJQUFULEVBQWU7QUFDM0IsbUJBQVcsSUFBWDtBQUNBLGFBQUssVUFBTDtBQUNILEtBSEQ7O0FBS0E7Ozs7OztBQU1BLFNBQUssTUFBTCxHQUFjLFVBQVMsTUFBVCxFQUFpQixVQUFqQixFQUE2QjtBQUN2QztBQUNBLGtCQUFVLEVBQUUscUJBQUYsRUFBeUIsV0FBekIsRUFBVjs7QUFFQSxVQUFFLE1BQUYsRUFBVSxHQUFWLENBQWMsUUFBZCxFQUF3QixTQUFTLElBQWpDOztBQUVBLGVBQU8sS0FBUCxHQUFlLEVBQUUsTUFBRixFQUFVLEtBQVYsRUFBZjtBQUNBLGVBQU8sTUFBUCxHQUFnQixNQUFoQjs7QUFFQSwyQkFBbUIsSUFBbkI7O0FBRUEsWUFBSSxDQUFDLFVBQUwsRUFBaUI7QUFDYjtBQUNIOztBQUVEO0FBQ0EsYUFBSyxnQkFBTCxDQUFzQixhQUF0Qjs7QUFFQSxhQUFLLFVBQUw7QUFDSCxLQW5CRDs7QUFxQkEsZUFBVyxFQUFYLENBQWMsWUFBZCxFQUE0QixVQUFTLElBQVQsRUFBZSxRQUFmLEVBQXlCO0FBQ2pELFlBQ0ksVUFBVSxhQUFhLFNBQVMsVUFBdEIsQ0FEZDs7QUFHQTtBQUNBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxVQUFVLEtBQVYsQ0FBZ0IsTUFBcEMsRUFBNEMsR0FBNUMsRUFBaUQ7QUFDN0MsZ0JBQUksVUFBVSxLQUFWLENBQWdCLENBQWhCLGFBQThCLGFBQWxDLEVBQWlEO0FBQzdDLDBCQUFVLEtBQVYsQ0FBZ0IsQ0FBaEIsRUFBbUIsS0FBbkI7QUFDQSwwQkFBVSxLQUFWLENBQWdCLENBQWhCLElBQXFCLE9BQXJCO0FBQ0EsMEJBQVUsS0FBVixDQUFnQixDQUFoQixFQUFtQixLQUFuQjs7QUFFQTtBQUNIO0FBQ0o7O0FBRUQsc0JBQWMsT0FBZDtBQUNILEtBaEJEOztBQWtCQSxlQUFXLEVBQVgsQ0FBYyxZQUFkLEVBQTRCLFVBQVMsSUFBVCxFQUFlO0FBQ3ZDLFlBQ0ksT0FESjs7QUFHQSxnQkFBUSxJQUFSO0FBQ0ksaUJBQUssdUJBQWEsTUFBbEI7QUFDSSwwQkFBVSxXQUFWO0FBQ0E7O0FBRUosaUJBQUssdUJBQWEsV0FBbEI7QUFDSSwwQkFBVSxhQUFWO0FBQ0E7O0FBRUosaUJBQUssdUJBQWEsY0FBbEI7QUFDSSwwQkFBVSxnQkFBVjtBQUNBOztBQUVKLGlCQUFLLHVCQUFhLGdCQUFsQjtBQUNJLDBCQUFVLGlCQUFWO0FBQ0E7O0FBRUosaUJBQUssdUJBQWEsV0FBbEI7QUFDSSwwQkFBVSxZQUFWO0FBQ0E7O0FBRUosaUJBQUssdUJBQWEsZUFBbEI7QUFDSSwwQkFBVSxnQkFBVjtBQUNBOztBQUVKLGlCQUFLLHVCQUFhLGNBQWxCO0FBQ0ksMEJBQVUsZUFBVjtBQUNBOztBQUVKLGlCQUFLLHVCQUFhLFdBQWxCO0FBQ0ksMEJBQVUsYUFBVjtBQUNBO0FBL0JSOztBQWtDQSxrQkFBVSxXQUFWLENBQXNCLE9BQXRCO0FBQ0gsS0F2Q0Q7O0FBeUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFjLElBQUksYUFBSixFQUFkO0FBQ0Esc0JBQWtCLElBQUksaUJBQUosRUFBbEI7QUFDQSxjQUFVLElBQUksU0FBSixFQUFWO0FBQ0EsdUJBQW1CLElBQUksa0JBQUosRUFBbkI7QUFDQSxvQkFBZ0IsSUFBSSxlQUFKLEVBQWhCO0FBQ0EsdUJBQW1CLElBQUksa0JBQUosRUFBbkI7QUFDQSx3QkFBb0IsSUFBSSxtQkFBSixFQUFwQjtBQUNBLG1CQUFlLElBQUksY0FBSixFQUFmO0FBQ0Esb0JBQWdCLElBQUksZUFBSixFQUFoQjs7QUFFQTtBQUNBLG1CQUFlLENBQUMsSUFBSSxjQUFKLEVBQUQsRUFBdUIsSUFBSSxVQUFKLEVBQXZCLEVBQXlDLElBQUksWUFBSixFQUF6QyxDQUFmOztBQUVBLGtCQUFjLGFBQWEsc0JBQVksV0FBekIsQ0FBZDs7QUFFQTtBQUNBLGNBQVUsY0FBVixDQUF5QixXQUF6QjtBQUNBLGNBQVUsV0FBVixDQUFzQixXQUF0Qjs7QUFFQSxrQkFBYyxLQUFkLEdBQXNCLFFBQVEsS0FBOUI7QUFDQSxrQkFBYyxNQUFkLEdBQXVCLFFBQVEsTUFBL0I7O0FBRUEsV0FBTyxLQUFQLEdBQWUsR0FBZjtBQUNBLFdBQU8sTUFBUCxHQUFnQixHQUFoQjtBQUNBLFdBQU8sU0FBUCxHQUFtQixxQkFBbkI7QUFDQSxXQUFPLFlBQVAsQ0FBb0IsY0FBcEIsRUFBb0MsTUFBcEM7O0FBRUEsUUFBSSxDQUFDLGNBQWMsV0FBbkIsRUFBZ0M7QUFDNUIsc0JBQWMsV0FBZCxHQUE0QixZQUFZLENBQUUsQ0FBMUMsQ0FENEIsQ0FDZ0I7QUFDL0M7O0FBRUQsV0FBTyxnQkFBUCxDQUF3QixhQUF4QixFQUF1QyxVQUFTLENBQVQsRUFBWTtBQUMvQyxVQUFFLGNBQUY7QUFDSCxLQUZEOztBQUlBLFdBQU8sZ0JBQVAsQ0FBd0IsWUFBeEIsRUFBc0MsWUFBVztBQUM3QyxrQkFBVSxJQUFWO0FBQ0gsS0FGRDs7QUFJQSxXQUFPLGdCQUFQLENBQXdCLFlBQXhCLEVBQXNDLFlBQVc7QUFDN0Msa0JBQVUsS0FBVjs7QUFFQSxZQUFJLENBQUMsVUFBVSxjQUFWLENBQUQsSUFBOEIsQ0FBQyxVQUFVLGdCQUFWLENBQS9CLElBQThELENBQUMsVUFBVSxZQUFWLENBQW5FLEVBQTRGO0FBQ3hGLGlCQUFLLFVBQUw7QUFDSDtBQUNKLEtBTkQ7O0FBUUEsV0FBTyxnQkFBUCxDQUF3QixhQUF4QixFQUF1QyxpQkFBdkM7QUFDQSxXQUFPLGdCQUFQLENBQXdCLGFBQXhCLEVBQXVDLGlCQUF2QztBQUNBLFdBQU8sZ0JBQVAsQ0FBd0IsV0FBeEIsRUFBcUMsZUFBckM7QUFDQSxXQUFPLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLGdCQUFqQzs7QUFFQSxhQUFTLGdCQUFULENBQTBCLFNBQTFCLEVBQXFDLGFBQXJDO0FBQ0EsYUFBUyxnQkFBVCxDQUEwQixPQUExQixFQUFtQyxXQUFuQzs7QUFFQTs7O0FBR0EsYUFBUyxnQkFBVCxDQUEwQixrQkFBMUIsRUFBOEMsWUFBVztBQUNyRCxZQUNJLFlBQVksT0FBTyxNQUFQLEdBQWdCLEVBQUUscUJBQUYsRUFBeUIsV0FBekIsRUFEaEM7O0FBR0EsZUFBTyxLQUFQLEdBQWUsQ0FBZjtBQUNBLGVBQU8sTUFBUCxHQUFnQixDQUFoQjs7QUFFQSxhQUFLLE1BQUwsQ0FBWSxTQUFaLEVBQXVCLElBQXZCO0FBQ0gsS0FSRCxFQVFHLEtBUkg7O0FBVUEsV0FBTyxnQkFBUCxDQUF3QixRQUF4QixFQUFrQyxZQUFXO0FBQ3pDLDJCQUFtQixJQUFuQjtBQUNILEtBRkQ7O0FBSUEsV0FBTyxnQkFBUCxDQUF3QixXQUF4QixFQUFxQyxVQUFTLENBQVQsRUFBWTtBQUM3QyxZQUFJLEVBQUUsTUFBRixJQUFZLFlBQWhCLEVBQThCO0FBQzFCO0FBQ0EsY0FBRSxjQUFGO0FBQ0g7QUFDSixLQUxEOztBQU9BLFlBQVEsRUFBUixDQUFXLGlCQUFYLEVBQThCLFlBQVc7QUFDckM7QUFDQSxhQUFLLFVBQUw7QUFDSCxLQUhEOztBQUtBLFlBQVEsRUFBUixDQUFXLGNBQVgsRUFBMkIsVUFBUyxNQUFULEVBQWlCO0FBQ3hDLDRCQUFvQixLQUFwQixDQUEwQixNQUExQjs7QUFFQSxvQkFBWSxlQUFlLG1CQUFmLENBQVo7QUFDSCxLQUpEOztBQU1BLGVBQVcsRUFBWCxDQUFjLGNBQWQsRUFBOEIsVUFBUyxLQUFULEVBQWdCO0FBQzFDLFlBQ0ksSUFBSSxLQUFLLFNBQUwsRUFEUjs7QUFHQSxhQUFLLFNBQUwsQ0FBZSxDQUFDLEtBQWhCLEVBQXVCLEVBQUUsQ0FBekI7QUFDSCxLQUxEOztBQU9BLGVBQVcsRUFBWCxDQUFjLGNBQWQsRUFBOEIsVUFBUyxLQUFULEVBQWdCO0FBQzFDLFlBQ0ksSUFBSSxLQUFLLFNBQUwsRUFEUjs7QUFHQSxhQUFLLFNBQUwsQ0FBZSxFQUFFLENBQWpCLEVBQW9CLENBQUMsS0FBckI7QUFDSCxLQUxEOztBQU9BLFNBQUssZ0JBQUwsQ0FBc0IsS0FBdEI7O0FBRUEsUUFDSSx1QkFBdUIsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRDNCOztBQUdBLHlCQUFxQixTQUFyQixHQUFpQyx1Q0FBakM7QUFDQSx5QkFBcUIsV0FBckIsQ0FBaUMsTUFBakM7O0FBRUEsdUJBQW1CLFNBQW5CLEdBQStCLG1DQUEvQjtBQUNBLHVCQUFtQixXQUFuQixDQUErQixvQkFBL0I7QUFDQSx1QkFBbUIsV0FBbkIsQ0FBK0IsV0FBVyxVQUFYLEVBQS9COztBQUVBLDBCQUFzQixTQUF0QixHQUFrQyxzQ0FBbEM7QUFDQSwwQkFBc0IsV0FBdEIsQ0FBa0MsV0FBVyxVQUFYLEVBQWxDOztBQUVBLG9CQUFnQixXQUFoQixDQUE0QixrQkFBNUI7QUFDQSxvQkFBZ0IsV0FBaEIsQ0FBNEIscUJBQTVCOztBQUVBLGVBQVcsU0FBWCxDQUFxQixJQUFyQjtBQUNIOzs7Ozs7Ozs7a0JDbmlGdUIsVTtBQXRCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQmUsU0FBUyxVQUFULENBQW9CLEtBQXBCLEVBQTJCLEtBQTNCLEVBQWtDO0FBQzdDLFFBQ0ksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FEYjtBQUFBLFFBRUksZ0JBQWdCLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQUZwQjtBQUFBLFFBSUksT0FBTyxJQUpYOztBQU1BLFNBQUssS0FBTCxHQUFhLFNBQVMsS0FBdEI7O0FBRUEsYUFBUyxLQUFULEdBQWlCO0FBQ2IsWUFDSSxRQUFRLE9BQU8sS0FEbkI7QUFBQSxZQUVJLFNBQVMsT0FBTyxNQUZwQjs7QUFJQSxzQkFBYyxTQUFkLENBQXdCLENBQXhCLEVBQTJCLENBQTNCLEVBQThCLEtBQTlCLEVBQXFDLE1BQXJDOztBQUVBLHNCQUFjLFNBQWQ7QUFDQSxzQkFBYyxHQUFkLENBQWtCLFFBQVEsQ0FBUixHQUFZLENBQTlCLEVBQWlDLFFBQVEsQ0FBUixHQUFZLENBQTdDLEVBQWdELEtBQUssR0FBTCxDQUFTLFFBQVEsQ0FBakIsRUFBb0IsQ0FBcEIsSUFBeUIsQ0FBekUsRUFBNEUsQ0FBNUUsRUFBK0UsS0FBSyxFQUFMLEdBQVUsQ0FBekY7O0FBRUEsWUFBSSxLQUFLLEtBQVQsRUFBZ0I7QUFDWiwwQkFBYyxJQUFkO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsMEJBQWMsTUFBZDtBQUNIO0FBQ0o7O0FBRUQsU0FBSyxRQUFMLEdBQWdCLFVBQVMsQ0FBVCxFQUFZO0FBQ3hCLFlBQUksS0FBSyxLQUFMLElBQWMsQ0FBbEIsRUFBcUI7QUFDakIsaUJBQUssS0FBTCxHQUFhLENBQWI7O0FBRUEsaUJBQUssU0FBTCxDQUFlLGFBQWYsRUFBOEIsQ0FBQyxDQUFELENBQTlCOztBQUVBO0FBQ0g7QUFDSixLQVJEOztBQVVBLFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLGVBQU8sTUFBUDtBQUNILEtBRkQ7O0FBSUEsV0FBTyxnQkFBUCxDQUF3QixXQUF4QixFQUFxQyxVQUFTLENBQVQsRUFBWTtBQUM3QyxhQUFLLFFBQUwsQ0FBYyxDQUFDLEtBQUssS0FBcEI7QUFDSCxLQUZEOztBQUlBLFdBQU8sS0FBUCxHQUFlLFNBQVMsRUFBeEI7QUFDQSxXQUFPLFNBQVAsR0FBbUIsdUJBQW5COztBQUVBLFdBQU8sS0FBUCxHQUFlLEVBQWY7QUFDQSxXQUFPLE1BQVAsR0FBZ0IsRUFBaEI7O0FBRUEsV0FBTyxTQUFQLEdBQW1CLE9BQW5CO0FBQ0EsV0FBTyxXQUFQLEdBQXFCLE9BQXJCOztBQUVBO0FBQ0g7O0FBRUQsV0FBVyxTQUFYLEdBQXVCLE9BQU8sTUFBUCxDQUFjLGFBQWEsU0FBM0IsQ0FBdkI7QUFDQSxXQUFXLFNBQVgsQ0FBcUIsV0FBckIsR0FBbUMsVUFBbkM7Ozs7Ozs7OztrQkNuRHdCLGM7O0FBTnhCOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUVBOzs7Ozs7QUExQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QmUsU0FBUyxjQUFULENBQXdCLFlBQXhCLEVBQXNDO0FBQ2pELHdCQUFVLElBQVYsQ0FBZSxJQUFmLEVBQXFCLFlBQXJCLEVBQW1DLE9BQW5DLEVBQTRDLE9BQTVDOztBQUVBLFFBQ0ksY0FBYyw0QkFBa0IsWUFBbEIsQ0FEbEI7QUFBQSxRQUVJLGNBQWMsNEJBQWtCLFlBQWxCLEVBQWdDLFdBQWhDLENBRmxCO0FBQUEsUUFHSSxZQUFZLElBQUksV0FBSixDQUFnQixZQUFoQixDQUhoQjtBQUFBLFFBS0ksT0FBTyxLQUFLLGNBQUwsRUFMWDtBQUFBLFFBTUksYUFBYSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FOakI7O0FBUUEsZUFBVyxTQUFYLEdBQXVCLDhCQUF2Qjs7QUFFQSxlQUFXLFdBQVgsQ0FBdUIsWUFBWSxVQUFaLEVBQXZCO0FBQ0EsZUFBVyxXQUFYLENBQXVCLFlBQVksVUFBWixFQUF2Qjs7QUFFQSxTQUFLLFdBQUwsQ0FBaUIsVUFBakI7QUFDQSxTQUFLLFdBQUwsQ0FBaUIsVUFBVSxVQUFWLEVBQWpCO0FBQ0g7O0FBRUQsU0FBUyxXQUFULENBQXFCLFlBQXJCLEVBQW1DO0FBQy9CLFFBQ0ksUUFBUSxDQURaO0FBQUEsUUFHSSxVQUFVLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUhkOztBQUtBLGFBQVMsT0FBVCxDQUFpQixNQUFqQixFQUF5QixPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxlQUFPLE9BQU8sTUFBUCxHQUFnQixHQUF2QixFQUE0QjtBQUN4QixxQkFBUyxVQUFVLE1BQW5CO0FBQ0g7QUFDRCxlQUFPLE1BQVA7QUFDSDs7QUFFRCxhQUFTLEtBQVQsR0FBaUI7QUFDYixnQkFBUSxLQUFSLENBQWMsZUFBZCxHQUFnQyxNQUFNLFFBQVEsT0FBTyxLQUFQLEVBQWMsUUFBZCxDQUF1QixFQUF2QixDQUFSLEVBQW9DLEdBQXBDLEVBQXlDLENBQXpDLENBQXRDO0FBQ0g7O0FBRUQsYUFBUyxVQUFULENBQW9CLENBQXBCLEVBQXVCO0FBQ25CLFVBQUUsY0FBRjs7QUFFQSxZQUNJLFNBQVMsTUFBTSxRQUFRLE9BQU8sS0FBUCxFQUFjLFFBQWQsQ0FBdUIsRUFBdkIsQ0FBUixFQUFvQyxHQUFwQyxFQUF5QyxDQUF6QyxDQURuQjs7QUFHQSxpQkFBUyxPQUFPLE1BQVAsQ0FBYyxvQ0FBZCxFQUFvRCxNQUFwRCxDQUFUOztBQUVBLFlBQUksVUFBVSxJQUFkLEVBQW9CO0FBQ2hCLGdCQUFJO0FBQ0Esb0JBQUksT0FBTyxLQUFQLENBQWEsSUFBYixLQUFzQixPQUFPLEtBQVAsQ0FBYSxJQUFiLENBQTFCLEVBQThDO0FBQzFDLDZCQUFTLE9BQU8sU0FBUCxDQUFpQixDQUFqQixDQUFUO0FBQ0g7O0FBRUQsb0JBQ0ksV0FBVyxTQUFTLE1BQVQsRUFBaUIsRUFBakIsQ0FEZjs7QUFHQSw2QkFBYSxXQUFiLENBQXlCLHNCQUFZLFFBQVosQ0FBekI7QUFDSCxhQVRELENBU0UsT0FBTyxDQUFQLEVBQVUsQ0FDWDtBQUNKO0FBQ0o7O0FBRUQsU0FBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsZUFBTyxPQUFQO0FBQ0gsS0FGRDs7QUFJQSxpQkFBYSxFQUFiLENBQWdCLGFBQWhCLEVBQStCLFVBQVMsTUFBVCxFQUFpQjtBQUM1QyxnQkFBUSxPQUFPLE1BQVAsRUFBUjtBQUNBO0FBQ0gsS0FIRDs7QUFLQSxZQUFRLFNBQVIsR0FBb0IsK0JBQXBCOztBQUVBLFlBQVEsZ0JBQVIsQ0FBeUIsT0FBekIsRUFBa0MsVUFBbEM7O0FBRUE7QUFDSDs7QUFFRCxlQUFlLFNBQWYsR0FBMkIsT0FBTyxNQUFQLENBQWMsb0JBQVUsU0FBeEIsQ0FBM0I7QUFDQSxlQUFlLFNBQWYsQ0FBeUIsV0FBekIsR0FBdUMsY0FBdkM7Ozs7Ozs7OztrQkNoRndCLGE7O0FBSHhCOzs7O0FBQ0E7Ozs7OztBQXZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCZSxTQUFTLGFBQVQsQ0FBdUIsWUFBdkIsRUFBcUMsWUFBckMsRUFBbUQ7QUFDOUQsUUFDSSxJQUFJLEdBRFI7QUFBQSxRQUNhLElBQUksR0FEakI7QUFBQSxRQUdJLFNBQVMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBSGI7QUFBQSxRQUlJLGdCQUFnQixPQUFPLFVBQVAsQ0FBa0IsSUFBbEIsQ0FKcEI7QUFBQSxRQU1JLFlBQVksY0FBYyxlQUFkLENBQThCLENBQTlCLEVBQWlDLENBQWpDLENBTmhCO0FBQUEsUUFPSSxPQUFPLFVBQVUsSUFQckI7QUFBQSxRQVFJLFFBQVEsdUJBUlo7QUFBQSxRQVVJLGNBQWMsSUFWbEI7QUFBQSxRQVlJLGdCQUFnQixLQVpwQjs7QUFjQSxhQUFTLFVBQVQsR0FBc0I7QUFDbEIsWUFDSSxNQUFNLE1BQU0sS0FBTixFQURWO0FBQUEsWUFFSSxXQUFXLENBRmY7O0FBSUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLENBQXBCLEVBQXVCLEdBQXZCLEVBQTRCO0FBQ3hCLGdCQUFJLFFBQUosQ0FBYSxNQUFPLElBQUksR0FBTCxHQUFZLENBQS9COztBQUVBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsb0JBQUksYUFBSixDQUFtQixJQUFJLEdBQUwsR0FBWSxDQUE5Qjs7QUFFQSxxQkFBSyxXQUFXLHFCQUFXLGVBQTNCLElBQStDLElBQUksR0FBSixJQUFXLEVBQVosR0FBa0IsSUFBaEU7QUFDQSxxQkFBSyxXQUFXLHFCQUFXLGlCQUEzQixJQUFpRCxJQUFJLEdBQUosSUFBVyxDQUFaLEdBQWlCLElBQWpFO0FBQ0EscUJBQUssV0FBVyxxQkFBVyxnQkFBM0IsSUFBK0MsSUFBSSxHQUFKLEdBQVUsSUFBekQ7QUFDQSxxQkFBSyxXQUFXLHFCQUFXLGlCQUEzQixJQUFnRCxJQUFoRDs7QUFFQSw0QkFBWSxxQkFBVyxlQUF2QjtBQUNIO0FBQ0o7O0FBRUQsc0JBQWMsS0FBZDtBQUNIOztBQUVELGFBQVMsS0FBVCxHQUFpQjtBQUNiLFlBQUksV0FBSixFQUFpQjtBQUNiO0FBQ0g7O0FBRUQsc0JBQWMsWUFBZCxDQUEyQixTQUEzQixFQUFzQyxDQUF0QyxFQUF5QyxDQUF6QyxFQUE0QyxDQUE1QyxFQUErQyxDQUEvQyxFQUFrRCxDQUFsRCxFQUFxRCxDQUFyRDs7QUFFQSxZQUNJLElBQUksTUFBTSxhQUFOLEtBQXdCLENBQXhCLEdBQTRCLEdBRHBDO0FBQUEsWUFFSSxJQUFJLENBQUMsTUFBTSxNQUFNLFFBQU4sRUFBUCxJQUEyQixDQUEzQixHQUErQixHQUZ2Qzs7QUFJQSxzQkFBYyx3QkFBZCxHQUF5QyxXQUF6QztBQUNBLHNCQUFjLFdBQWQsR0FBNEIsT0FBNUI7QUFDQSxzQkFBYyxTQUFkLEdBQTBCLEdBQTFCOztBQUVBLHNCQUFjLFNBQWQ7QUFDQSxzQkFBYyxHQUFkLENBQWtCLENBQWxCLEVBQXFCLENBQXJCLEVBQXdCLENBQXhCLEVBQTJCLENBQTNCLEVBQThCLEtBQUssRUFBTCxHQUFVLENBQXhDO0FBQ0Esc0JBQWMsTUFBZDs7QUFFQSxzQkFBYyx3QkFBZCxHQUF5QyxhQUF6QztBQUNIOztBQUVELGFBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQjtBQUN2QixZQUNJLElBQUksRUFBRSxLQUFGLEdBQVUsRUFBRSxNQUFGLEVBQVUsTUFBVixHQUFtQixJQURyQztBQUFBLFlBRUksSUFBSSxFQUFFLEtBQUYsR0FBVSxFQUFFLE1BQUYsRUFBVSxNQUFWLEdBQW1CLEdBRnJDO0FBQUEsWUFJSSxNQUFNLElBQUksR0FBSixHQUFVLENBSnBCO0FBQUEsWUFLSSxRQUFRLE1BQU0sSUFBSSxHQUFKLEdBQVUsQ0FMNUI7O0FBT0EsY0FBTSxhQUFOLENBQW9CLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsR0FBZCxDQUFaLENBQXBCO0FBQ0EsY0FBTSxRQUFOLENBQWUsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFkLENBQVosQ0FBZjs7QUFFQTtBQUNBLHFCQUFhLFdBQWIsQ0FBeUIsS0FBekI7QUFDSDs7QUFFRCxhQUFTLFlBQVQsQ0FBc0IsQ0FBdEIsRUFBeUI7QUFDckIsdUJBQWUsQ0FBZjtBQUNIOztBQUVELGFBQVMsT0FBVCxDQUFpQixDQUFqQixFQUFvQjtBQUNoQixlQUFPLHFCQUFQLENBQTZCLEVBQUUsU0FBL0I7QUFDQSx3QkFBZ0IsS0FBaEI7QUFDQSxlQUFPLG1CQUFQLENBQTJCLFdBQTNCLEVBQXdDLE9BQXhDO0FBQ0EsZUFBTyxtQkFBUCxDQUEyQixhQUEzQixFQUEwQyxZQUExQztBQUNIOztBQUVELGFBQVMsU0FBVCxDQUFtQixDQUFuQixFQUFzQjtBQUNsQixZQUFJLENBQUMsYUFBTCxFQUFvQjtBQUNoQiw0QkFBZ0IsSUFBaEI7QUFDQSxtQkFBTyxpQkFBUCxDQUF5QixFQUFFLFNBQTNCO0FBQ0EsbUJBQU8sZ0JBQVAsQ0FBd0IsV0FBeEIsRUFBcUMsT0FBckM7QUFDQSxtQkFBTyxnQkFBUCxDQUF3QixhQUF4QixFQUF1QyxZQUF2QztBQUNIOztBQUVELHVCQUFlLENBQWY7QUFDSDs7QUFFRCxTQUFLLE1BQUwsR0FBYyxVQUFTLEdBQVQsRUFBYztBQUN4QixZQUFJLE1BQU0sTUFBTixNQUFrQixHQUF0QixFQUEyQjtBQUN2QixrQkFBTSxNQUFOLENBQWEsR0FBYjtBQUNBLHlCQUFhLFdBQWIsQ0FBeUIsS0FBekI7QUFDSDtBQUNKLEtBTEQ7O0FBT0EsU0FBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsZUFBTyxNQUFQO0FBQ0gsS0FGRDs7QUFJQSxpQkFBYSxFQUFiLENBQWdCLGFBQWhCLEVBQStCLFVBQVMsQ0FBVCxFQUFZO0FBQ3ZDLGNBQU0sUUFBTixDQUFlLENBQWY7O0FBRUEsc0JBQWMsSUFBZDtBQUNBO0FBQ0gsS0FMRDs7QUFPQSxXQUFPLGdCQUFQLENBQXdCLGFBQXhCLEVBQXVDLFNBQXZDOztBQUVBLFdBQU8sU0FBUCxHQUFtQixpQ0FBbkI7QUFDQSxXQUFPLFlBQVAsQ0FBb0IsY0FBcEIsRUFBb0MsTUFBcEM7O0FBRUEsV0FBTyxLQUFQLEdBQWUsQ0FBZjtBQUNBLFdBQU8sTUFBUCxHQUFnQixDQUFoQjs7QUFFQSxRQUFJLFlBQUosRUFBa0I7QUFDZCxjQUFNLFFBQU4sQ0FBZSxZQUFmO0FBQ0g7O0FBRUQ7QUFDSDs7Ozs7Ozs7O2tCQ2hJdUIsYTs7QUFIeEI7Ozs7QUFDQTs7Ozs7O0FBdkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJlLFNBQVMsYUFBVCxDQUF1QixZQUF2QixFQUFxQyxRQUFyQyxFQUErQyxVQUEvQyxFQUEyRDtBQUN0RSxRQUNJLE9BQU8sSUFEWDtBQUFBLFFBR0ksSUFBSSxFQUhSO0FBQUEsUUFHWSxJQUFJLEdBSGhCO0FBQUEsUUFLSSxTQUFTLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUxiO0FBQUEsUUFNSSxnQkFBZ0IsT0FBTyxVQUFQLENBQWtCLElBQWxCLENBTnBCO0FBQUEsUUFRSSxZQUFZLGNBQWMsZUFBZCxDQUE4QixDQUE5QixFQUFpQyxDQUFqQyxDQVJoQjtBQUFBLFFBU0ksT0FBTyxVQUFVLElBVHJCO0FBQUEsUUFXSSxnQkFBZ0IsS0FYcEI7QUFBQSxRQWFJLE1BQU0sY0FBYyxDQWJ4Qjs7QUFlQSxhQUFTLFVBQVQsR0FBc0I7QUFDbEIsWUFDSSxRQUFRLHVCQURaO0FBQUEsWUFFSSxXQUFXLENBRmY7O0FBSUEsY0FBTSxnQkFBTixDQUF1QixDQUF2QixFQUEwQixHQUExQixFQUErQixHQUEvQjs7QUFFQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIsa0JBQU0sTUFBTixDQUFjLElBQUksR0FBTCxHQUFZLENBQXpCOztBQUVBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksQ0FBcEIsRUFBdUIsR0FBdkIsRUFBNEI7QUFDeEIscUJBQUssV0FBVyxxQkFBVyxlQUEzQixJQUErQyxNQUFNLEdBQU4sSUFBYSxFQUFkLEdBQW9CLElBQWxFO0FBQ0EscUJBQUssV0FBVyxxQkFBVyxpQkFBM0IsSUFBaUQsTUFBTSxHQUFOLElBQWEsQ0FBZCxHQUFtQixJQUFuRTtBQUNBLHFCQUFLLFdBQVcscUJBQVcsZ0JBQTNCLElBQStDLE1BQU0sR0FBTixHQUFZLElBQTNEO0FBQ0EscUJBQUssV0FBVyxxQkFBVyxpQkFBM0IsSUFBZ0QsSUFBaEQ7O0FBRUEsNEJBQVkscUJBQVcsZUFBdkI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsYUFBUyxLQUFULEdBQWlCO0FBQ2Isc0JBQWMsWUFBZCxDQUEyQixTQUEzQixFQUFzQyxDQUF0QyxFQUF5QyxDQUF6QyxFQUE0QyxDQUE1QyxFQUErQyxDQUEvQyxFQUFrRCxDQUFsRCxFQUFxRCxDQUFyRDs7QUFFQSxZQUNJLElBQUssTUFBTSxDQUFQLEdBQVksR0FEcEI7O0FBR0Esc0JBQWMsd0JBQWQsR0FBeUMsV0FBekM7QUFDQSxzQkFBYyxXQUFkLEdBQTRCLE9BQTVCO0FBQ0Esc0JBQWMsU0FBZCxHQUEwQixHQUExQjs7QUFFQSxzQkFBYyxTQUFkO0FBQ0Esc0JBQWMsTUFBZCxDQUFxQixDQUFyQixFQUF3QixDQUF4QjtBQUNBLHNCQUFjLE1BQWQsQ0FBcUIsQ0FBckIsRUFBd0IsQ0FBeEI7QUFDQSxzQkFBYyxNQUFkOztBQUVBLHNCQUFjLHdCQUFkLEdBQXlDLGFBQXpDO0FBQ0g7O0FBRUQsYUFBUyxjQUFULENBQXdCLENBQXhCLEVBQTJCO0FBQ3ZCLFlBQ0ksSUFBSSxFQUFFLEtBQUYsR0FBVSxFQUFFLE1BQUYsRUFBVSxNQUFWLEdBQW1CLEdBRHJDO0FBQUEsWUFHSSxPQUFPLENBQUMsRUFBRSxJQUFJLEdBQUosR0FBVSxDQUFaLENBSFo7O0FBS0EsY0FBTSxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLElBQWQsQ0FBWixDQUFOO0FBQ0E7O0FBRUEsWUFBSSxZQUFZLElBQWhCLEVBQXNCO0FBQ2xCLHFCQUFTLE1BQVQsQ0FBZ0IsR0FBaEI7QUFDSDtBQUNKOztBQUVELGFBQVMsWUFBVCxDQUFzQixDQUF0QixFQUF5QjtBQUNyQix1QkFBZSxDQUFmO0FBQ0g7O0FBRUQsYUFBUyxPQUFULENBQWlCLENBQWpCLEVBQW9CO0FBQ2hCLGVBQU8scUJBQVAsQ0FBNkIsRUFBRSxTQUEvQjtBQUNBLHdCQUFnQixLQUFoQjtBQUNBLGVBQU8sbUJBQVAsQ0FBMkIsV0FBM0IsRUFBd0MsT0FBeEM7QUFDQSxlQUFPLG1CQUFQLENBQTJCLGFBQTNCLEVBQTBDLFlBQTFDO0FBQ0g7O0FBRUQsYUFBUyxTQUFULENBQW1CLENBQW5CLEVBQXNCO0FBQ2xCLFlBQUksQ0FBQyxhQUFMLEVBQW9CO0FBQ2hCLDRCQUFnQixJQUFoQjtBQUNBLG1CQUFPLGlCQUFQLENBQXlCLEVBQUUsU0FBM0I7QUFDQSxtQkFBTyxnQkFBUCxDQUF3QixXQUF4QixFQUFxQyxPQUFyQztBQUNBLG1CQUFPLGdCQUFQLENBQXdCLGFBQXhCLEVBQXVDLFlBQXZDO0FBQ0g7O0FBRUQsdUJBQWUsQ0FBZjtBQUNIOztBQUVELFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLGVBQU8sTUFBUDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxNQUFMLEdBQWMsVUFBUyxDQUFULEVBQVk7QUFDdEIsY0FBTSxDQUFOO0FBQ0E7QUFDSCxLQUhEOztBQUtBLGlCQUFhLEVBQWIsQ0FBZ0IsYUFBaEIsRUFBK0IsVUFBUyxLQUFULEVBQWdCO0FBQzNDLGFBQUssTUFBTCxDQUFZLE1BQU0sTUFBTixFQUFaO0FBQ0gsS0FGRDs7QUFJQSxXQUFPLFlBQVAsQ0FBb0IsY0FBcEIsRUFBb0MsTUFBcEM7O0FBRUEsV0FBTyxnQkFBUCxDQUF3QixhQUF4QixFQUF1QyxTQUF2Qzs7QUFFQSxXQUFPLEtBQVAsR0FBZSxDQUFmO0FBQ0EsV0FBTyxNQUFQLEdBQWdCLENBQWhCOztBQUVBLFdBQU8sU0FBUCxHQUFtQixpQ0FBbkI7O0FBRUE7QUFDQTtBQUVIOzs7Ozs7Ozs7a0JDakh1QixhOztBQU54Qjs7OztBQUVBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBMUJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNEJlLFNBQVMsYUFBVCxDQUF1QixZQUF2QixFQUFxQyxZQUFyQyxFQUFtRDtBQUM5RCxRQUNJLE9BQU8sSUFEWDtBQUFBLFFBRUksUUFBUSxzQkFBWSxDQUFaLENBRlo7QUFBQSxRQUdJLFFBQVEsR0FIWjtBQUFBLFFBS0ksVUFBVSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FMZDs7QUFPQSxhQUFTLE9BQVQsQ0FBaUIsTUFBakIsRUFBeUIsT0FBekIsRUFBa0MsR0FBbEMsRUFBdUM7QUFDbkMsZUFBTyxPQUFPLE1BQVAsR0FBZ0IsR0FBdkIsRUFBNEI7QUFDeEIscUJBQVMsVUFBVSxNQUFuQjtBQUNIO0FBQ0QsZUFBTyxNQUFQO0FBQ0g7O0FBRUQsYUFBUyxLQUFULEdBQWlCO0FBQ2IsZ0JBQVEsS0FBUixDQUFjLGVBQWQsR0FBZ0MsTUFBTSxRQUFRLE9BQU8sTUFBTSxNQUFOLEVBQVAsRUFBdUIsUUFBdkIsQ0FBZ0MsRUFBaEMsQ0FBUixFQUE2QyxHQUE3QyxFQUFrRCxDQUFsRCxDQUF0QztBQUNIOztBQUVELGFBQVMsVUFBVCxDQUFvQixDQUFwQixFQUF1QjtBQUNuQixVQUFFLGNBQUY7QUFDSDs7QUFFRCxTQUFLLFVBQUwsR0FBa0IsWUFBVztBQUN6QixlQUFPLE9BQVA7QUFDSCxLQUZEOztBQUlBLFNBQUssUUFBTCxHQUFnQixVQUFTLE1BQVQsRUFBaUI7QUFDN0IsWUFBSSxDQUFDLE1BQU0sT0FBTixDQUFjLE1BQWQsQ0FBTCxFQUE0QjtBQUN4QixrQkFBTSxRQUFOLENBQWUsTUFBZjs7QUFFQTs7QUFFQSxpQkFBSyxTQUFMLENBQWUsYUFBZixFQUE4QixDQUFDLEtBQUQsQ0FBOUI7QUFDSDtBQUNKLEtBUkQ7O0FBVUEsU0FBSyxRQUFMLEdBQWdCLFVBQVMsTUFBVCxFQUFpQjtBQUM3QixZQUFJLFVBQVUsS0FBZCxFQUFxQjtBQUNqQixvQkFBUSxNQUFSOztBQUVBOztBQUVBLGlCQUFLLFNBQUwsQ0FBZSxhQUFmLEVBQThCLENBQUMsS0FBRCxDQUE5QjtBQUNIO0FBQ0osS0FSRDs7QUFVQSxTQUFLLFdBQUwsR0FBbUIsWUFBVztBQUMxQixlQUFPLE1BQU0sTUFBTixFQUFQO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLFFBQUwsR0FBZ0IsWUFBVztBQUN2QixlQUFPLEtBQVA7QUFDSCxLQUZEOztBQUlBLFNBQUssV0FBTCxHQUFtQixLQUFLLFFBQXhCOztBQUVBLGFBQVMsbUJBQVQsR0FBK0I7QUFDM0IsWUFDSSxRQUFRLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQURaO0FBQUEsWUFFSSxRQUFRLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUZaO0FBQUEsWUFHSSxTQUFTLDRCQUFrQixJQUFsQixFQUF3QixLQUF4QixDQUhiO0FBQUEsWUFJSSxTQUFTLDRCQUFrQixJQUFsQixFQUF3QixNQUF4QixFQUFnQyxNQUFNLE1BQU4sRUFBaEMsQ0FKYjtBQUFBLFlBS0ksY0FBYyx1QkFBYSxDQUFiLEVBQWdCLEdBQWhCLENBTGxCOztBQU9BLGNBQU0sU0FBTixHQUFrQiwrQkFBbEI7O0FBRUEsY0FBTSxTQUFOLEdBQWtCLDhCQUFsQjs7QUFFQSxjQUFNLFdBQU4sQ0FBa0IsT0FBTyxVQUFQLEVBQWxCO0FBQ0EsY0FBTSxXQUFOLENBQWtCLE9BQU8sVUFBUCxFQUFsQjs7QUFFQSxjQUFNLFdBQU4sQ0FBa0IsS0FBbEI7O0FBRUEsb0JBQVksS0FBWixHQUFvQixLQUFwQjtBQUNBLG9CQUFZLEtBQVosR0FBb0IsVUFBUyxLQUFULEVBQWdCO0FBQ2hDLG1CQUFPLGNBQWMsS0FBckI7QUFDSCxTQUZEO0FBR0Esb0JBQVksRUFBWixDQUFlLGFBQWYsRUFBOEIsVUFBUyxLQUFULEVBQWdCO0FBQzFDLGlCQUFLLFFBQUwsQ0FBYyxLQUFkO0FBQ0gsU0FGRDs7QUFJQSxjQUFNLFdBQU4sQ0FBa0IsWUFBWSxVQUFaLEVBQWxCOztBQUVBLG1CQUFXLFlBQVc7QUFDbEIsd0JBQVksTUFBWjtBQUNILFNBRkQsRUFFRyxDQUZIOztBQUlBLGVBQU8sS0FBUDtBQUNIOztBQUVELFlBQVEsU0FBUixHQUFvQixnQ0FBcEI7O0FBRUEsWUFBUSxnQkFBUixDQUF5QixPQUF6QixFQUFrQyxVQUFsQzs7QUFFQSxRQUFJLFlBQUosRUFBa0I7QUFDZCxjQUFNLFFBQU4sQ0FBZSxZQUFmO0FBQ0g7O0FBRUQsUUFBSSxZQUFKLEVBQWtCO0FBQ2QsZ0JBQVEsWUFBUjtBQUNIOztBQUVEO0FBQ0EsYUFBUyxpQkFBVCxDQUEyQixDQUEzQixFQUE4QjtBQUMxQixZQUFJLEVBQUUsRUFBRSxNQUFKLEVBQVksT0FBWixDQUFvQixVQUFwQixFQUFnQyxNQUFoQyxJQUEwQyxDQUExQyxJQUErQyxFQUFFLEVBQUUsTUFBSixFQUFZLE9BQVosQ0FBb0IsaUNBQXBCLEVBQXVELENBQXZELEtBQTZELE9BQWhILEVBQXlIO0FBQ3JILGNBQUUsT0FBRixFQUFXLE9BQVgsQ0FBbUIsTUFBbkI7QUFDSDtBQUNKOztBQUVELE1BQUUsT0FBRixFQUNLLE9BREwsQ0FDYTtBQUNMLGNBQU0sSUFERDtBQUVMLGlCQUFTLG1CQUFXO0FBQ2hCLG1CQUFPLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLGlCQUFyQzs7QUFFQSxtQkFBTyxxQkFBUDtBQUNILFNBTkk7QUFPTCxpQkFBUyxRQVBKO0FBUUwsbUJBQVc7O0FBUk4sS0FEYixFQVlLLEVBWkwsQ0FZUSxPQVpSLEVBWWlCLFlBQVc7QUFDcEIsVUFBRSxJQUFGLEVBQVEsT0FBUixDQUFnQixRQUFoQjtBQUNILEtBZEwsRUFlSyxFQWZMLENBZVEsbUJBZlIsRUFlNkIsWUFBVztBQUNoQyxlQUFPLG1CQUFQLENBQTJCLFdBQTNCLEVBQXdDLGlCQUF4QztBQUNILEtBakJMOztBQW1CQTtBQUNIOztBQUVELGNBQWMsU0FBZCxHQUEwQixPQUFPLE1BQVAsQ0FBYyxhQUFhLFNBQTNCLENBQTFCO0FBQ0EsY0FBYyxTQUFkLENBQXdCLFdBQXhCLEdBQXNDLGFBQXRDOzs7Ozs7Ozs7a0JDNUl3Qix3QjtBQXJCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXFCZSxTQUFTLHdCQUFULENBQWtDLE1BQWxDLEVBQTBDLFVBQTFDLEVBQXNEO0FBQ3BFLEtBQ0MsU0FDQyxpM0NBRkY7QUFBQSxLQTBCQyxPQUFPLElBMUJSO0FBQUEsS0E0QkMsY0FBYyxFQUFFLGdDQUFGLEVBQW9DLE1BQXBDLENBNUJmO0FBQUEsS0E2QkMsZUFBZSxFQUFFLGdDQUFGLEVBQW9DLE1BQXBDLENBN0JoQjs7QUErQkEsYUFBWSxLQUFaLENBQWtCLFVBQVMsQ0FBVCxFQUFZO0FBQzdCLGFBQVcsZUFBWCxDQUEyQixFQUFDLFFBQVEsbUJBQVQsRUFBM0I7QUFDQSxPQUFLLFNBQUwsQ0FBZSxRQUFmO0FBQ0EsRUFIRDs7QUFLQSxjQUFhLEtBQWIsQ0FBbUIsVUFBUyxDQUFULEVBQVk7QUFDOUIsYUFBVyxlQUFYLENBQTJCLEVBQUMsUUFBUSxtQkFBVCxFQUEzQjtBQUNBLE9BQUssU0FBTCxDQUFlLFFBQWY7QUFDQSxFQUhEOztBQUtBLFFBQ0UsS0FERixDQUNRO0FBQ04sUUFBTTtBQURBLEVBRFIsRUFJRSxFQUpGLENBSUssZ0JBSkwsRUFJdUIsWUFBVztBQUNoQyxjQUFZLEtBQVo7QUFDQSxFQU5GLEVBT0UsRUFQRixDQU9LLGlCQVBMLEVBT3dCLFVBQVMsQ0FBVCxFQUFZO0FBQ2xDO0FBQ0EsU0FBTyxNQUFQO0FBQ0EsRUFWRixFQVdFLEVBWEYsQ0FXSyxVQVhMLEVBV2lCLFVBQVMsQ0FBVCxFQUFZO0FBQzNCLE1BQUksRUFBRSxPQUFGLElBQWEsRUFBakIsRUFBcUI7QUFDcEIsZUFBWSxLQUFaO0FBQ0E7QUFDRCxFQWZGOztBQWlCQTtBQUNBLFFBQU8sSUFBUCxDQUFZLFVBQVosRUFBd0IsS0FBeEIsR0FBZ0MsRUFBRSxNQUFGLENBQWhDOztBQUVBLFFBQU8sV0FBUCxDQUFtQixPQUFPLENBQVAsQ0FBbkI7O0FBRUEsTUFBSyxJQUFMLEdBQVksWUFBVztBQUN0QixTQUFPLEtBQVAsQ0FBYSxNQUFiO0FBQ0EsRUFGRDtBQUdBOztBQUVELHlCQUF5QixTQUF6QixHQUFxQyxPQUFPLE1BQVAsQ0FBYyxhQUFhLFNBQTNCLENBQXJDO0FBQ0EseUJBQXlCLFNBQXpCLENBQW1DLFdBQW5DLEdBQWlELHdCQUFqRDs7Ozs7Ozs7O1FDckZnQix5QixHQUFBLHlCO0FBTmhCOzs7Ozs7QUFNTyxTQUFTLHlCQUFULENBQW1DLGFBQW5DLEVBQWtEO0FBQ3JELFFBQ0kscUJBQXFCLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUR6QjtBQUFBLFFBRUksc0JBQXNCLG1CQUFtQixVQUFuQixDQUE4QixJQUE5QixDQUYxQjtBQUFBLFFBSUksWUFBWSxvQkFBb0IsZUFBcEIsQ0FBb0MsRUFBcEMsRUFBd0MsRUFBeEMsQ0FKaEI7QUFBQSxRQUtJLE9BQU8sVUFBVSxJQUxyQjtBQUFBLFFBT0ksY0FBYyxDQVBsQjs7QUFTQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksRUFBcEIsRUFBd0IsR0FBeEIsRUFBNkI7QUFDekIsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEVBQXBCLEVBQXdCLEdBQXhCLEVBQTZCO0FBQ3pCLGdCQUFJLENBQUMsSUFBSSxHQUFMLEtBQWEsQ0FBYixHQUFpQixDQUFDLElBQUksR0FBTCxLQUFhLENBQWxDLEVBQXFDO0FBQ2pDO0FBQ0EscUJBQUssYUFBTCxJQUFzQixJQUF0QjtBQUNBLHFCQUFLLGFBQUwsSUFBc0IsSUFBdEI7QUFDQSxxQkFBSyxhQUFMLElBQXNCLElBQXRCO0FBQ0EscUJBQUssYUFBTCxJQUFzQixJQUF0QjtBQUNILGFBTkQsTUFNTztBQUNIO0FBQ0EscUJBQUssYUFBTCxJQUFzQixJQUF0QjtBQUNBLHFCQUFLLGFBQUwsSUFBc0IsSUFBdEI7QUFDQSxxQkFBSyxhQUFMLElBQXNCLElBQXRCO0FBQ0EscUJBQUssYUFBTCxJQUFzQixJQUF0QjtBQUNIO0FBQ0o7QUFDSjs7QUFFRCx1QkFBbUIsS0FBbkIsR0FBMkIsRUFBM0I7QUFDQSx1QkFBbUIsTUFBbkIsR0FBNEIsRUFBNUI7QUFDQSx3QkFBb0IsWUFBcEIsQ0FBaUMsU0FBakMsRUFBNEMsQ0FBNUMsRUFBK0MsQ0FBL0M7O0FBRUEsV0FBTyxjQUFjLGFBQWQsQ0FBNEIsa0JBQTVCLEVBQWdELFFBQWhELENBQVA7QUFDSDs7Ozs7Ozs7a0JDakJ1QixZO0FBdEJ4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCZSxTQUFTLFlBQVQsQ0FBc0IsTUFBdEIsRUFBOEIsTUFBOUIsRUFBc0M7QUFDakQsUUFDSSxTQUNJLGk1Q0FGUjtBQUFBLFFBNEJJLGVBQWUsRUFBRSx5QkFBRixFQUE2QixNQUE3QixDQTVCbkI7QUFBQSxRQTZCSSxjQUFjLEVBQUUsbUNBQUYsRUFBdUMsTUFBdkMsQ0E3QmxCOztBQStCQSxpQkFBYSxHQUFiLENBQWlCLE9BQU8sV0FBUCxFQUFqQjs7QUFFQSxNQUFFLG1DQUFGLEVBQXVDLE1BQXZDLEVBQStDLEtBQS9DLENBQXFELFVBQVMsQ0FBVCxFQUFZO0FBQzdELFlBQ0ksV0FBVyxTQUFTLGFBQWEsR0FBYixFQUFULEVBQTZCLEVBQTdCLENBRGY7O0FBR0EsZUFBTyxXQUFQLENBQW1CLFFBQW5CO0FBQ0gsS0FMRDs7QUFPQSxXQUNLLEtBREwsQ0FDVztBQUNILGNBQU07QUFESCxLQURYLEVBSUssRUFKTCxDQUlRLGdCQUpSLEVBSTBCLFlBQVc7QUFDN0IscUJBQWEsS0FBYjtBQUNILEtBTkwsRUFNTyxFQU5QLENBTVUsVUFOVixFQU1zQixVQUFTLENBQVQsRUFBWTtBQUMxQixZQUFJLEVBQUUsT0FBRixJQUFhLEVBQWpCLEVBQXFCO0FBQ2pCLHdCQUFZLEtBQVo7QUFDSDtBQUNKLEtBVkw7O0FBWUE7QUFDQSxXQUFPLElBQVAsQ0FBWSxVQUFaLEVBQXdCLEtBQXhCLEdBQWdDLEVBQUUsTUFBRixDQUFoQzs7QUFFQSxXQUFPLFdBQVAsQ0FBbUIsT0FBTyxDQUFQLENBQW5COztBQUVBLFNBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsZUFBTyxLQUFQLENBQWEsTUFBYjtBQUNILEtBRkQ7QUFHSDs7Ozs7Ozs7O2tCQzFEdUIsZTs7QUFIeEI7Ozs7QUFDQTs7Ozs7O0FBdkJBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBeUJlLFNBQVMsZUFBVCxDQUF5QixVQUF6QixFQUFxQztBQUNoRCx3QkFBVSxJQUFWLENBQWUsSUFBZixFQUFxQixVQUFyQixFQUFpQyxRQUFqQyxFQUEyQyxRQUEzQyxFQUFxRCxJQUFyRDs7QUFFQSxRQUNJLGFBQWEsQ0FDUCxRQURPLEVBQ0csVUFESCxFQUNlLEtBRGYsRUFDc0IsUUFEdEIsRUFDZ0MsU0FEaEMsRUFDMkMsUUFEM0MsRUFDcUQsVUFEckQsRUFDaUUsT0FEakUsRUFDMEUsTUFEMUUsRUFFUCxTQUZPLEVBRUksWUFGSixFQUVrQixZQUZsQixFQUVnQyxhQUZoQyxFQUUrQyxjQUYvQyxFQUUrRCxXQUYvRCxDQURqQjs7QUFNQSxRQUNJLFVBQVUsSUFEZDtBQUFBLFFBRUksU0FBUyxFQUZiO0FBQUEsUUFFaUIsT0FBTyxFQUZ4QjtBQUFBLFFBSUksT0FBTyxLQUFLLGNBQUwsRUFKWDtBQUFBLFFBTUksY0FBYyxJQUFJLGFBQUosRUFObEI7QUFBQSxRQU9JLGNBQWMsdUJBQWEsQ0FBYixFQUFnQixHQUFoQixDQVBsQjtBQUFBLFFBUUksYUFBYSxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FSakI7QUFBQSxRQVVJLGNBQWMsSUFBSSxhQUFKLEVBVmxCO0FBQUEsUUFZSSxvQkFBb0IsU0FBUyxhQUFULENBQXVCLE9BQXZCLENBWnhCO0FBQUEsUUFhSSxjQUFjLFNBQVMsYUFBVCxDQUF1QixPQUF2QixDQWJsQjtBQUFBLFFBZUksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsQ0FmaEI7QUFBQSxRQWdCSSxlQUFlLFNBQVMsYUFBVCxDQUF1QixJQUF2QixDQWhCbkI7O0FBa0JBLGFBQVMsWUFBVCxDQUFzQixLQUF0QixFQUE2QixXQUE3QixFQUEwQztBQUN0QyxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksWUFBWSxNQUFoQyxFQUF3QyxHQUF4QyxFQUE2QztBQUN6QyxnQkFDSSxTQUFTLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQURiOztBQUdBLG1CQUFPLFdBQVAsQ0FBbUIsU0FBUyxjQUFULENBQXdCLFlBQVksQ0FBWixDQUF4QixDQUFuQjtBQUNBLG1CQUFPLEtBQVAsR0FBZSxDQUFmOztBQUVBLGtCQUFNLFdBQU4sQ0FBa0IsTUFBbEI7QUFDSDtBQUNKOztBQUVELGFBQVMscUJBQVQsQ0FBK0IsUUFBL0IsRUFBeUMsS0FBekMsRUFBZ0Q7QUFDNUMsWUFDSSxNQUFNLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQURWO0FBQUEsWUFFSSxRQUFRLFNBQVMsYUFBVCxDQUF1QixPQUF2QixDQUZaOztBQUlBLFlBQUksU0FBSixHQUFnQixVQUFoQjs7QUFFQSxjQUFNLFdBQU4sQ0FBa0IsUUFBbEI7QUFDQSxjQUFNLFdBQU4sQ0FBa0IsU0FBUyxjQUFULENBQXdCLEtBQXhCLENBQWxCOztBQUVBLFlBQUksV0FBSixDQUFnQixLQUFoQjs7QUFFQSxlQUFPLEdBQVA7QUFDSDs7QUFFRCxhQUFTLGlCQUFULENBQTJCLFVBQTNCLEVBQXVDO0FBQ25DLFlBQ0ksSUFBSSxZQUFZLFVBQVosRUFEUjtBQUFBLFlBRUksVUFBVSxXQUFXLFVBQVgsRUFGZDtBQUFBLFlBR0ksUUFBUSxRQUFRLFFBQVIsQ0FBaUIsVUFBakIsQ0FIWjs7QUFLQSxvQkFBWSxJQUFaLENBQ0ksT0FBTyxPQUFPLGdCQURsQixFQUVJLEVBQUUsTUFBRixHQUFXLENBQUMsYUFBYSxDQUFkLElBQW1CLE1BQW5CLEdBQTRCLE9BQU8sZ0JBRmxELEVBR0ksVUFISixFQUlJLE1BQU0sSUFKVjtBQU1IOztBQUVELFFBQ0ksZ0JBQWdCLEtBQUssT0FEekI7QUFBQSxRQUVJLGtCQUFrQixLQUFLLFNBRjNCOztBQUlBLFNBQUssT0FBTCxHQUFlLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZTtBQUMxQixzQkFBYyxJQUFkLENBQW1CLElBQW5CLEVBQXlCLENBQXpCLEVBQTRCLENBQTVCOztBQUVBLG9CQUFZLE1BQVo7QUFDQSxvQkFBWSxNQUFaO0FBQ0gsS0FMRDs7QUFPQSxTQUFLLFNBQUwsR0FBaUIsVUFBUyxDQUFULEVBQVk7QUFDekIsd0JBQWdCLElBQWhCLENBQXFCLElBQXJCLEVBQTJCLENBQTNCOztBQUVBLG9CQUFZLE1BQVo7QUFDSCxLQUpEOztBQU1BLGFBQVMsYUFBVCxHQUF5QjtBQUNyQixZQUNJLHNDQUFzQyxFQUQxQztBQUFBLFlBRUksOEJBQThCLElBRmxDOztBQUlBLFlBQ0ksU0FESjtBQUFBLFlBQ2UsZUFEZjtBQUFBLFlBRUksY0FGSjtBQUFBLFlBRW9CLFVBRnBCO0FBQUEsWUFJSSxZQUFZLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUpoQjtBQUFBLFlBTUksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FOYjtBQUFBLFlBT0ksZ0JBQWdCLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQVBwQjtBQUFBLFlBU0ksaUJBVEo7QUFBQSxZQVVJLHNCQUFzQixFQVYxQjtBQUFBLFlBV0kseUJBQXlCLENBQUMsQ0FYOUI7QUFBQSxZQVlJLHVCQUF1QixFQVozQjtBQUFBLFlBY0ksZUFBZSxLQWRuQjtBQUFBLFlBZ0JJLE9BQU8sSUFoQlg7O0FBa0JBOzs7QUFHQSxhQUFLLFVBQUwsR0FBa0IsWUFBVztBQUN6QixtQkFBTyxFQUFDLE9BQU8sRUFBRSxNQUFGLEVBQVUsS0FBVixFQUFSLEVBQTJCLFFBQVEsRUFBRSxNQUFGLEVBQVUsTUFBVixFQUFuQyxFQUFQO0FBQ0gsU0FGRDs7QUFJQSxpQkFBUyxhQUFULENBQXVCLEtBQXZCLEVBQThCO0FBQzFCLG1CQUFPLEtBQUssS0FBTCxDQUFXLENBQUMsT0FBTyxNQUFQLEdBQWdCLE1BQU0sQ0FBTixHQUFVLEVBQUUsTUFBRixFQUFVLE1BQVYsRUFBVixHQUErQixPQUFPLE1BQXZELElBQWlFLE1BQTVFLENBQVA7QUFDSDs7QUFFRDs7OztBQUlBLGlCQUFTLFNBQVQsQ0FBbUIsS0FBbkIsRUFBMEIsUUFBMUIsRUFBb0M7QUFDaEMsZ0JBQ0ksSUFBSSxFQUFDLE9BQU8sT0FBTyxLQUFmLEVBQXNCLFFBQVEsT0FBTyxNQUFyQyxFQURSOztBQUdBLGdCQUFJLFFBQUosRUFBYztBQUNWLDhCQUFjLFNBQWQsR0FBMEIsU0FBMUI7QUFDSCxhQUZELE1BRU87QUFDSCw4QkFBYyxTQUFkLEdBQTBCLE9BQTFCO0FBQ0g7QUFDRCwwQkFBYyxRQUFkLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLEVBQUUsS0FBL0IsRUFBc0MsTUFBdEM7O0FBRUEsMEJBQWMsU0FBZDs7QUFFQSwwQkFBYyxNQUFkLENBQXFCLENBQXJCLEVBQXdCLENBQXhCO0FBQ0EsMEJBQWMsTUFBZCxDQUFxQixFQUFFLEtBQXZCLEVBQThCLENBQTlCOztBQUVBLDBCQUFjLE1BQWQsQ0FBcUIsSUFBckIsRUFBMkIsQ0FBM0I7QUFDQSwwQkFBYyxNQUFkLENBQXFCLElBQXJCLEVBQTJCLE1BQTNCOztBQUVBLDBCQUFjLE1BQWQsQ0FBcUIsT0FBTyxJQUFJLE9BQU8sZ0JBQXZDLEVBQXlELFNBQVMsQ0FBbEU7QUFDQSwwQkFBYyxNQUFkLENBQXFCLEVBQUUsS0FBRixHQUFVLElBQUksT0FBTyxnQkFBMUMsRUFBNEQsU0FBUyxDQUFyRTs7QUFFQSwwQkFBYyxNQUFkOztBQUVBLDBCQUFjLFNBQWQsR0FBMEIsT0FBMUI7O0FBRUEsMEJBQWMsUUFBZCxDQUF1QixNQUFNLElBQTdCLEVBQW1DLE9BQU8sSUFBSSxPQUFPLGdCQUFyRCxFQUF1RSxLQUFLLE9BQU8sZ0JBQW5GO0FBQ0EsMEJBQWMsUUFBZCxDQUF1QixXQUFXLE1BQU0sU0FBakIsSUFBOEIsSUFBOUIsR0FBcUMsTUFBTSxLQUEzQyxHQUFtRCxHQUExRSxFQUErRSxPQUFPLElBQUksT0FBTyxnQkFBakcsRUFBbUgsU0FBUyxJQUFJLE9BQU8sZ0JBQXZJOztBQUVBLDBCQUFjLFNBQWQ7QUFDQSxnQkFBSSxNQUFNLE9BQVYsRUFBbUI7QUFDZiw4QkFBYyxHQUFkLENBQWtCLE9BQU8sQ0FBekIsRUFBNEIsU0FBUyxDQUFyQyxFQUF3QyxJQUFJLE9BQU8sZ0JBQW5ELEVBQXFFLENBQXJFLEVBQXdFLEtBQUssRUFBTCxHQUFVLENBQWxGO0FBQ0EsOEJBQWMsSUFBZDtBQUNILGFBSEQsTUFHTztBQUNILDhCQUFjLEdBQWQsQ0FBa0IsT0FBTyxDQUF6QixFQUE0QixTQUFTLENBQXJDLEVBQXdDLElBQUksT0FBTyxnQkFBbkQsRUFBcUUsQ0FBckUsRUFBd0UsS0FBSyxFQUFMLEdBQVUsQ0FBbEY7QUFDQSw4QkFBYyxNQUFkO0FBQ0g7QUFDSjs7QUFFRCxpQkFBUyxPQUFULENBQWlCLENBQWpCLEVBQW9CO0FBQ2hCLGdCQUFJLEVBQUUsTUFBRixJQUFZLENBQWhCLEVBQW1CO0FBQ2Ysb0JBQ0ksU0FBUyxFQUFFLE1BQUYsRUFBVSxNQUFWLEVBRGI7QUFBQSxvQkFHSSxVQUFVLFdBQVcsVUFBWCxFQUhkO0FBQUEsb0JBSUksU0FBUyxRQUFRLFNBQVIsRUFKYjtBQUFBLG9CQU1JLFdBQVcsRUFBQyxHQUFHLEVBQUUsS0FBRixHQUFVLE9BQU8sSUFBckIsRUFBMkIsR0FBRyxFQUFFLEtBQUYsR0FBVSxPQUFPLEdBQS9DLEVBTmY7QUFBQSxvQkFPSSxZQUFZLGNBQWMsUUFBZCxDQVBoQjs7QUFTQTs7QUFFQSxvQkFBSSxhQUFhLENBQWIsSUFBa0IsYUFBYSxPQUFPLE1BQXRDLElBQWdELGFBQWEsY0FBN0QsSUFBK0UsYUFBYSxpQkFBaUIsQ0FBakgsRUFBb0g7QUFDaEgsK0JBQVcsZUFBWCxDQUEyQixFQUFDLFFBQVEsYUFBVCxFQUF3QixXQUFXLGNBQW5DLEVBQW1ELFNBQVMsU0FBNUQsRUFBM0I7QUFDSDs7QUFFRDtBQUNBLG9CQUFJLGVBQUosRUFBcUI7QUFDakIsc0NBQWtCLEtBQWxCO0FBQ0EseUJBQUssS0FBTDtBQUNIOztBQUVELDRCQUFZLEtBQVo7O0FBRUEsdUJBQU8sbUJBQVAsQ0FBMkIsV0FBM0IsRUFBd0MsWUFBeEM7QUFDQSx1QkFBTyxtQkFBUCxDQUEyQixTQUEzQixFQUFzQyxPQUF0QztBQUNIO0FBQ0o7O0FBRUQsaUJBQVMsWUFBVCxDQUFzQixDQUF0QixFQUF5QjtBQUNyQixnQkFBSSxTQUFKLEVBQWU7QUFDWCxrQ0FBa0IsSUFBbEI7QUFDQSw2QkFBYSxFQUFFLEtBQUYsR0FBVSxFQUFFLE1BQUYsRUFBVSxNQUFWLEdBQW1CLEdBQTFDO0FBQ0EscUJBQUssS0FBTDtBQUNIO0FBQ0o7O0FBRUQ7OztBQUdBLGFBQUssVUFBTCxHQUFrQixVQUFTLFVBQVQsRUFBcUI7QUFDbkMsZ0JBQ0ksUUFBUSxRQUFRLFFBQVIsQ0FBaUIsVUFBakIsQ0FEWjtBQUFBLGdCQUVJLFdBQVcsT0FBTyxNQUFQLEdBQWdCLFVBQVUsYUFBYSxDQUF2QixDQUYvQjs7QUFJQSwwQkFBYyxJQUFkOztBQUVBLDBCQUFjLFNBQWQsR0FBMEIsU0FBMUI7QUFDQSwwQkFBYyxRQUFkLENBQXVCLENBQXZCLEVBQTBCLFFBQTFCLEVBQW9DLE9BQU8sS0FBM0MsRUFBa0QsTUFBbEQ7O0FBRUEsMEJBQWMsV0FBZCxHQUE0QixPQUE1Qjs7QUFFQSwwQkFBYyxTQUFkLENBQXdCLENBQXhCLEVBQTJCLFFBQTNCO0FBQ0Esc0JBQVUsS0FBVixFQUFpQixjQUFjLFFBQVEsbUJBQVIsRUFBL0I7O0FBRUEsMEJBQWMsT0FBZDtBQUNILFNBaEJEOztBQWtCQTs7O0FBR0EsYUFBSyxLQUFMLEdBQWEsWUFBVztBQUNwQixnQkFDSSxVQUFVLFdBQVcsVUFBWCxFQURkO0FBQUEsZ0JBRUksU0FBUyxRQUFRLFNBQVIsRUFGYjtBQUFBLGdCQUlJLElBQUksRUFBQyxPQUFPLE9BQU8sS0FBZixFQUFzQixRQUFRLE9BQU8sTUFBckMsRUFKUjtBQUFBLGdCQU1JLG9CQUFvQixPQUFPLE1BQVAsR0FBZ0IsRUFBRSxNQUFGLEVBQVUsTUFBVixFQU54Qzs7QUFRQSwwQkFBYyxJQUFkOztBQUVBLDBCQUFjLFNBQWQsR0FBMEIsU0FBMUI7QUFDQSwwQkFBYyxRQUFkLENBQXVCLENBQXZCLEVBQTBCLENBQTFCLEVBQTZCLEVBQUUsS0FBL0IsRUFBc0MsRUFBRSxNQUFGLEdBQVcsT0FBTyxNQUFQLEdBQWdCLE1BQWpFOztBQUVBLDBCQUFjLFdBQWQsR0FBNEIsT0FBNUI7O0FBRUE7QUFDQSwwQkFBYyxTQUFkLENBQXdCLENBQXhCLEVBQTJCLEVBQUUsTUFBRixHQUFXLE1BQXRDOztBQUVBLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxNQUEzQixFQUFtQyxHQUFuQyxFQUF3QztBQUNwQywwQkFBVSxPQUFPLENBQVAsQ0FBVixFQUFxQixLQUFLLFFBQVEsbUJBQVIsRUFBMUI7QUFDQSw4QkFBYyxTQUFkLENBQXdCLENBQXhCLEVBQTJCLENBQUMsTUFBNUI7QUFDSDs7QUFFRCxnQkFBSSxlQUFKLEVBQXFCO0FBQ2pCLDhCQUFjLFNBQWQsQ0FBd0IsQ0FBeEIsRUFBMkIsT0FBTyxNQUFQLEdBQWdCLE1BQWhCLElBQTBCLEVBQUUsTUFBRixHQUFXLE1BQXJDLENBQTNCO0FBQ0EsOEJBQWMsVUFBZCxDQUF5QixDQUF6QixFQUE0QixhQUFhLGlCQUFiLEdBQWtDLFNBQVMsQ0FBdkUsRUFBMEUsRUFBRSxLQUE1RSxFQUFtRixNQUFuRjs7QUFFQSxvQkFDSSxZQUFZLGNBQWMsRUFBQyxHQUFHLENBQUosRUFBTyxHQUFHLFVBQVYsRUFBZCxDQURoQjs7QUFHQSxvQkFBSSxhQUFhLE9BQU8sTUFBcEIsSUFBOEIsYUFBYSxjQUEzQyxJQUE2RCxhQUFhLGlCQUFpQixDQUEvRixFQUFrRztBQUM5RixrQ0FBYyxRQUFkLENBQXVCLENBQXZCLEVBQTBCLEVBQUUsTUFBRixHQUFXLFlBQVksTUFBdkIsR0FBZ0MsQ0FBMUQsRUFBNkQsRUFBRSxLQUEvRCxFQUFzRSxJQUFJLE9BQU8sZ0JBQWpGO0FBQ0g7QUFDSjs7QUFFRCwwQkFBYyxPQUFkO0FBQ0gsU0FyQ0Q7O0FBdUNBLGFBQUssTUFBTCxHQUFjLFlBQVc7QUFDckIsZ0JBQ0ksVUFBVSxXQUFXLFVBQVgsRUFEZDs7O0FBR0k7QUFDQSxxQkFBUyxFQUFFLE1BQUYsRUFBVSxNQUFWLEVBSmI7QUFBQSxnQkFLSSxlQUFlLE9BQU8sTUFBUCxFQUxuQjtBQUFBLGdCQU1JLGNBQWMsT0FBTyxLQUFQLEVBTmxCO0FBQUEsZ0JBUUksUUFSSjtBQUFBLGdCQVFjLFNBUmQ7O0FBVUEscUJBQVMsS0FBSyxPQUFPLGdCQUFyQjtBQUNBLG1CQUFPLEtBQUssT0FBTyxnQkFBbkI7O0FBRUEsdUJBQVcsY0FBYyxPQUFPLGdCQUFoQztBQUNBLHdCQUFZLEtBQUssR0FBTCxDQUFTLFNBQVMsUUFBUSxhQUFSLEVBQWxCLEVBQTJDLGVBQWUsT0FBTyxnQkFBakUsQ0FBWjs7QUFFQTtBQUNBLGdCQUFJLFlBQVksZUFBZSxPQUFPLGdCQUF0QyxFQUF3RDtBQUNwRDtBQUNBLDRCQUFZLEtBQUssT0FBTyxnQkFBeEI7QUFDQSx1QkFBTyxDQUFQLEVBQVUsS0FBVixDQUFnQixTQUFoQixHQUE0QixRQUE1QjtBQUNILGFBSkQsTUFJTztBQUNILHVCQUFPLENBQVAsRUFBVSxLQUFWLENBQWdCLFNBQWhCLEdBQTRCLFFBQTVCO0FBQ0g7O0FBRUQsbUJBQU8sS0FBUCxHQUFlLFFBQWY7QUFDQSxtQkFBTyxNQUFQLEdBQWdCLFNBQWhCOztBQUVBLG1CQUFPLEtBQVAsQ0FBYSxLQUFiLEdBQXNCLFdBQVcsT0FBTyxnQkFBbkIsR0FBdUMsSUFBNUQ7QUFDQSxtQkFBTyxLQUFQLENBQWEsTUFBYixHQUF1QixZQUFZLE9BQU8sZ0JBQXBCLEdBQXdDLElBQTlEOztBQUVBLDBCQUFjLElBQWQsR0FBc0IsU0FBUyxJQUFWLEdBQWtCLGVBQXZDOztBQUVBLGlCQUFLLEtBQUw7QUFDQSxpQkFBSyxtQkFBTDtBQUNILFNBcENEOztBQXNDQSxhQUFLLFVBQUwsR0FBa0IsWUFBVztBQUN6QixtQkFBTyxTQUFQO0FBQ0gsU0FGRDs7QUFJQSxlQUFPLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLFVBQVMsQ0FBVCxFQUFZO0FBQ3pDLGdCQUFJLFlBQVksU0FBWixFQUFKLEVBQTZCO0FBQ3pCLDRCQUFZLGFBQVo7QUFDSDtBQUNKLFNBSkQ7O0FBTUEsZUFBTyxnQkFBUCxDQUF3QixVQUF4QixFQUFvQyxVQUFTLENBQVQsRUFBWTtBQUM1QyxnQkFDSSxTQUFTLEVBQUUsTUFBRixFQUFVLE1BQVYsRUFEYjtBQUFBLGdCQUVJLFdBQVcsRUFBQyxHQUFHLEVBQUUsS0FBRixHQUFVLE9BQU8sSUFBckIsRUFBMkIsR0FBRyxFQUFFLEtBQUYsR0FBVSxPQUFPLEdBQS9DLEVBRmY7QUFBQSxnQkFJSSxhQUFhLGNBQWMsUUFBZCxDQUpqQjs7QUFNQSxnQkFBSSxTQUFTLENBQVQsR0FBYSxPQUFPLGdCQUFwQixHQUF1QyxJQUF2QyxJQUErQyxjQUFjLENBQTdELElBQWtFLGFBQWEsUUFBUSxhQUFSLEVBQW5GLEVBQTRHO0FBQ3hHLGtDQUFrQixVQUFsQjtBQUNIO0FBQ0osU0FWRDs7QUFZQSxlQUFPLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLFVBQVMsQ0FBVCxFQUFZO0FBQzdDLGdCQUNJLFNBQVMsRUFBRSxNQUFGLEVBQVUsTUFBVixFQURiO0FBQUEsZ0JBRUksV0FBVyxFQUFDLEdBQUcsRUFBRSxLQUFGLEdBQVUsT0FBTyxJQUFyQixFQUEyQixHQUFHLEVBQUUsS0FBRixHQUFVLE9BQU8sR0FBL0MsRUFGZjs7QUFJQTtBQUNBLGdCQUFJLEVBQUUsTUFBRixJQUFZLENBQWhCLEVBQW1CO0FBQUU7QUFDakIsb0JBQ0ksVUFBVSxXQUFXLFVBQVgsRUFEZDtBQUFBLG9CQUVJLFNBQVMsUUFBUSxTQUFSLEVBRmI7QUFBQSxvQkFJSSxhQUFhLGNBQWMsUUFBZCxDQUpqQjs7QUFNQSxvQkFBSSxjQUFjLENBQWQsSUFBbUIsYUFBYSxRQUFRLGFBQVIsRUFBcEMsRUFBNkQ7QUFDekQsd0JBQ0ksUUFBUSxRQUFRLFFBQVIsQ0FBaUIsVUFBakIsQ0FEWjs7QUFHQSx3QkFBSSxTQUFTLENBQVQsR0FBYSxFQUFFLE1BQUYsRUFBVSxLQUFWLEVBQWIsR0FBaUMsT0FBTyxLQUF4QyxHQUFnRCxJQUFwRCxFQUEwRDtBQUN0RCxtQ0FBVyxlQUFYLENBQTJCLEVBQUMsUUFBUSxzQkFBVCxFQUFpQyxZQUFZLFVBQTdDLEVBQXlELFNBQVMsQ0FBQyxNQUFNLE9BQXpFLEVBQTNCO0FBQ0gscUJBRkQsTUFFTyxJQUFJLFFBQVEsbUJBQVIsTUFBaUMsVUFBckMsRUFBaUQ7QUFDcEQsbUNBQVcsZUFBWCxDQUEyQixFQUFDLFFBQVEsdUJBQVQsRUFBa0MsWUFBWSxVQUE5QyxFQUEzQjtBQUNIO0FBQ0o7O0FBRUQsb0JBQUksYUFBYSxPQUFPLE1BQXhCLEVBQWdDO0FBQzVCLGdDQUFZLElBQVo7QUFDQSxpQ0FBYSxTQUFTLENBQXRCO0FBQ0EscUNBQWlCLFVBQWpCOztBQUVBLDJCQUFPLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLFlBQXJDO0FBQ0EsMkJBQU8sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsT0FBbkM7QUFDSDtBQUNKO0FBQ0osU0FqQ0Q7O0FBbUNBOzs7OztBQUtBLGlCQUFTLFdBQVQsQ0FBcUIsVUFBckIsRUFBaUM7QUFDN0IsZ0JBQ0ksaUJBQWlCLE9BQU8scUJBQVAsRUFEckI7QUFBQSxnQkFHSSxlQUFlLFVBQVUscUJBQVYsRUFIbkI7QUFBQSxnQkFJSSxrQkFBa0IsYUFBYSxNQUFiLEdBQXNCLGFBQWEsR0FKekQ7QUFBQSxnQkFNSSxjQUFjLFNBQVMsT0FBTyxnQkFObEM7QUFBQSxnQkFRSSxXQUFXLGVBQWUsTUFBZixHQUF3QixlQUFlLGFBQWEsQ0FBNUIsQ0FSdkM7QUFBQSxnQkFTSSxjQUFjLFdBQVcsV0FUN0I7O0FBV0Esc0JBQVUsU0FBVixHQUFzQixLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxVQUFVLFNBQW5CLEVBQThCLGNBQWMsZUFBZSxHQUE3QixHQUFtQyxlQUFqRSxDQUFULEVBQTRGLFdBQVcsZUFBZSxHQUF0SCxDQUFULEVBQXFJLENBQXJJLENBQXRCO0FBQ0g7O0FBRUQsYUFBSyxtQkFBTCxHQUEyQixZQUFXO0FBQ2xDLGNBQUUsTUFBRixFQUFVLE9BQVYsQ0FBa0IsTUFBbEI7QUFDSCxTQUZEOztBQUlBLGFBQUssZ0JBQUwsR0FBd0IsVUFBUyxVQUFULEVBQXFCLE9BQXJCLEVBQThCLEtBQTlCLEVBQXFDO0FBQ3pELGtDQUFzQixPQUF0QjtBQUNBLHFDQUF5QixVQUF6Qjs7QUFFQSxnQkFBSSxRQUFRLG1CQUFSLE1BQWlDLFVBQWpDLElBQStDLFNBQVMsU0FBNUQsRUFBdUU7QUFDbkUsdUNBQXVCLFNBQXZCO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsdUNBQXVCLE9BQXZCO0FBQ0EsNEJBQVksVUFBWjtBQUNIOztBQUVELGNBQUUsTUFBRixFQUFVLE9BQVYsQ0FBa0IsTUFBbEI7O0FBRUEsZ0JBQUksWUFBSixFQUFrQjtBQUNkLDZCQUFhLFlBQWI7QUFDSDtBQUNELDJCQUFlLFdBQVcsWUFBVztBQUNqQywrQkFBZSxLQUFmO0FBQ0EscUJBQUssbUJBQUw7QUFDSCxhQUhjLEVBR1osS0FBSyxHQUFMLENBQVMsS0FBSyxLQUFMLENBQVcsb0JBQW9CLE1BQXBCLEdBQTZCLG1DQUF4QyxDQUFULEVBQXVGLDJCQUF2RixDQUhZLENBQWY7QUFJSCxTQXBCRDs7QUFzQkE7QUFDQSxpQkFBUywwQkFBVCxDQUFvQyxNQUFwQyxFQUE0QyxTQUE1QyxFQUF1RDtBQUNuRCw4QkFBa0IsSUFBbEIsQ0FBdUIsSUFBdkIsRUFBNkIsTUFBN0IsRUFBcUMsU0FBckM7O0FBRUEsZ0JBQ0ksT0FBTyxLQUFLLEdBQUwsRUFEWDtBQUFBLGdCQUVJLFNBQVMsS0FBSyxLQUFMLEVBRmI7QUFBQSxnQkFHSSxpQkFBaUIsT0FBTyxxQkFBUCxFQUhyQjtBQUFBLGdCQUlJLGVBQWUsVUFBVSxxQkFBVixFQUpuQjs7QUFNQSxvQkFBUSxvQkFBUjtBQUNJLHFCQUFLLE9BQUw7QUFDSSx3QkFDSSxjQUFjLGVBQWUsTUFBZixHQUF3QixTQUFTLE9BQU8sZ0JBQWhCLElBQW9DLHlCQUF5QixHQUE3RCxDQUQxQzs7QUFHQSxrQ0FBYyxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxXQUFULEVBQXNCLGFBQWEsR0FBbkMsQ0FBVCxFQUFrRCxhQUFhLE1BQS9ELENBQWQ7O0FBRUEseUJBQUssTUFBTCxDQUFZO0FBQ1IsNkJBQUssY0FBYyxTQUFTLElBQVQsQ0FBYyxTQUE1QixHQUF3QyxLQUFLLE1BQUwsS0FBZ0IsQ0FEckQ7QUFFUiw4QkFBTSxlQUFlLElBQWYsR0FBc0IsS0FBSyxVQUFMLEVBQXRCLEdBQTBDLE9BQU8sVUFBUDtBQUZ4QyxxQkFBWjtBQUlKO0FBQ0EscUJBQUssU0FBTDtBQUNJLHdCQUNJLGlCQUFpQixZQUFZLFVBQVosR0FBeUIscUJBQXpCLEVBRHJCOztBQUdBLHlCQUFLLE1BQUwsQ0FBWTtBQUNSLDZCQUFLLENBQUMsZUFBZSxHQUFmLEdBQXFCLGVBQWUsTUFBcEMsR0FBNkMsS0FBSyxNQUFMLEVBQTlDLElBQStELENBQS9ELEdBQW1FLFNBQVMsSUFBVCxDQUFjLFNBRDlFO0FBRVIsOEJBQU0sZUFBZSxJQUFmLEdBQXNCLEtBQUssVUFBTCxFQUF0QixHQUEwQyxPQUFPLFVBQVA7QUFGeEMscUJBQVo7QUFJSjtBQXBCSjs7QUF1QkEsbUJBQU8sR0FBUCxDQUFXLEtBQVgsRUFBa0IsS0FBbEI7QUFDSDs7QUFFRCxtQkFBVyxFQUFYLENBQWMsbUJBQWQsRUFBbUMsS0FBSyxnQkFBTCxDQUFzQixJQUF0QixDQUEyQixJQUEzQixDQUFuQzs7QUFFQSxVQUFFLE1BQUYsRUFDSyxPQURMLENBQ2E7QUFDTCxrQkFBTSxLQUREO0FBRUwscUJBQVMsbUJBQVc7QUFDaEIsdUJBQU8sbUJBQVA7QUFDSCxhQUpJO0FBS0wsdUJBQVcsTUFMTjtBQU1MLHFCQUFTLFFBTko7QUFPTCx1QkFBVyxRQUFRLFVBQVI7QUFQTixTQURiOztBQVdBLFlBQ0ksVUFBVSxFQUFFLE1BQUYsRUFBVSxJQUFWLENBQWUsWUFBZixDQURkOztBQUdBO0FBQ0EsNEJBQW9CLFFBQVEsY0FBNUI7O0FBRUEsZ0JBQVEsY0FBUixHQUF5QiwwQkFBekI7O0FBRUEsWUFBSSxDQUFDLE9BQU8sZ0JBQVosRUFBOEI7QUFDMUIsbUJBQU8sZ0JBQVAsR0FBMEIsR0FBMUI7QUFDSDs7QUFFRCxzQkFBYyxXQUFkLEdBQTRCLE9BQTVCOztBQUVBLGtCQUFVLFNBQVYsR0FBc0IsNEJBQXRCO0FBQ0Esa0JBQVUsV0FBVixDQUFzQixNQUF0QjtBQUNIOztBQUVELGFBQVMsYUFBVCxHQUF5QjtBQUNyQixZQUNJLGFBQWEsQ0FBQyxDQURsQjtBQUFBLFlBRUksVUFBVSxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsQ0FGZDtBQUFBLFlBSUksT0FBTyxJQUpYOztBQU1BLGFBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIseUJBQWEsQ0FBQyxDQUFkO0FBQ0Esb0JBQVEsS0FBUixDQUFjLE9BQWQsR0FBd0IsTUFBeEI7QUFDSCxTQUhEOztBQUtBLGFBQUssYUFBTCxHQUFxQixZQUFXO0FBQzVCLGdCQUFJLFFBQVEsUUFBUixDQUFpQixVQUFqQixFQUE2QixJQUE3QixJQUFxQyxRQUFRLEtBQWpELEVBQXdEO0FBQ3BELDJCQUFXLGVBQVgsQ0FBMkIsRUFBQyxRQUFRLGdCQUFULEVBQTJCLFlBQVksVUFBdkMsRUFBbUQsTUFBTSxRQUFRLEtBQWpFLEVBQTNCO0FBQ0g7O0FBRUQsaUJBQUssSUFBTDtBQUNILFNBTkQ7O0FBUUEsYUFBSyxTQUFMLEdBQWlCLFlBQVc7QUFDeEIsbUJBQU8sUUFBUSxLQUFSLENBQWMsT0FBZCxJQUF5QixNQUFoQztBQUNILFNBRkQ7O0FBSUEsYUFBSyxXQUFMLEdBQW1CLFVBQVMsU0FBVCxFQUFvQixTQUFwQixFQUErQjtBQUM5QyxvQkFBUSxLQUFSLENBQWMsSUFBZCxHQUFxQixZQUFZLElBQWpDO0FBQ0Esb0JBQVEsS0FBUixDQUFjLEdBQWQsR0FBb0IsWUFBWSxJQUFoQztBQUNILFNBSEQ7O0FBS0EsYUFBSyxJQUFMLEdBQVksVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlLFdBQWYsRUFBNEIsU0FBNUIsRUFBdUM7QUFDL0MseUJBQWEsV0FBYjtBQUNBLG9CQUFRLEtBQVIsR0FBZ0IsU0FBaEI7QUFDQSxpQkFBSyxXQUFMLENBQWlCLENBQWpCLEVBQW9CLENBQXBCOztBQUVBLG9CQUFRLEtBQVIsQ0FBYyxPQUFkLEdBQXdCLE9BQXhCO0FBQ0Esb0JBQVEsTUFBUjtBQUNILFNBUEQ7O0FBU0EsYUFBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsbUJBQU8sT0FBUDtBQUNILFNBRkQ7O0FBSUEsZ0JBQVEsSUFBUixHQUFlLE1BQWY7QUFDQSxnQkFBUSxTQUFSLEdBQW9CLG1EQUFwQjtBQUNBLGdCQUFRLEtBQVIsQ0FBYyxPQUFkLEdBQXdCLE1BQXhCOztBQUVBLGdCQUFRLGdCQUFSLENBQXlCLFNBQXpCLEVBQW9DLFVBQVMsQ0FBVCxFQUFZO0FBQzVDO0FBQ0EsY0FBRSxlQUFGO0FBQ0gsU0FIRDs7QUFLQSxnQkFBUSxnQkFBUixDQUF5QixVQUF6QixFQUFxQyxVQUFTLENBQVQsRUFBWTtBQUM3QyxnQkFBSSxFQUFFLE9BQUYsSUFBYSxFQUFqQixFQUFxQjtBQUFFO0FBQ25CLHFCQUFLLGFBQUw7QUFDSDtBQUNELGNBQUUsZUFBRjtBQUNILFNBTEQ7O0FBT0EsZ0JBQVEsZ0JBQVIsQ0FBeUIsT0FBekIsRUFBa0MsVUFBUyxDQUFULEVBQVk7QUFDMUMsZ0JBQUksRUFBRSxPQUFGLElBQWEsRUFBakIsRUFBcUI7QUFBRTtBQUNuQixxQkFBSyxJQUFMO0FBQ0g7QUFDRCxjQUFFLGVBQUY7QUFDSCxTQUxEOztBQU9BLGdCQUFRLGdCQUFSLENBQXlCLE1BQXpCLEVBQWlDLFVBQVMsQ0FBVCxFQUFZO0FBQ3pDLGdCQUFJLGNBQWMsQ0FBQyxDQUFuQixFQUFzQjtBQUNsQixxQkFBSyxhQUFMO0FBQ0g7QUFDSixTQUpEO0FBS0g7O0FBRUQsZUFBVyxTQUFYLEdBQXVCLGNBQXZCO0FBQ0EsZUFBVyxLQUFYLEdBQW1CLHFCQUFuQjtBQUNBLGVBQVcsZ0JBQVgsQ0FBNEIsUUFBNUIsRUFBc0MsVUFBUyxDQUFULEVBQVk7QUFDOUMsbUJBQVcsZUFBWCxDQUEyQixFQUFDLFFBQVEscUJBQVQsRUFBZ0MsWUFBWSxRQUFRLG1CQUFSLEVBQTVDLEVBQTJFLFdBQVcsU0FBUyxXQUFXLEtBQXBCLEVBQTJCLEVBQTNCLENBQXRGLEVBQTNCO0FBQ0gsS0FGRDs7QUFJQSxpQkFBYSxVQUFiLEVBQXlCLFVBQXpCOztBQUVBLFNBQUssV0FBTCxDQUFpQixVQUFqQjs7QUFFQSxnQkFBWSxLQUFaLEdBQW9CLFVBQVMsS0FBVCxFQUFnQjtBQUNoQyxlQUFPLGNBQWMsS0FBZCxHQUFzQixHQUE3QjtBQUNILEtBRkQ7O0FBSUEsZ0JBQVksRUFBWixDQUFlLGFBQWYsRUFBOEIsVUFBUyxLQUFULEVBQWdCO0FBQzFDLG1CQUFXLGVBQVgsQ0FBMkIsRUFBQyxRQUFRLGlCQUFULEVBQTRCLFlBQVksUUFBUSxtQkFBUixFQUF4QyxFQUF1RSxPQUFPLEtBQTlFLEVBQTNCO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLFdBQUwsQ0FBaUIsWUFBWSxVQUFaLEVBQWpCOztBQUVBLHNCQUFrQixJQUFsQixHQUF5QixVQUF6QjtBQUNBLHNCQUFrQixnQkFBbEIsQ0FBbUMsT0FBbkMsRUFBNEMsVUFBUyxDQUFULEVBQVk7QUFDcEQsWUFDSSxVQUFVLFdBQVcsVUFBWCxFQURkOztBQUdBLGdCQUFRLGtCQUFSLENBQTJCLGtCQUFrQixPQUE3QztBQUNILEtBTEQ7O0FBT0EsU0FBSyxXQUFMLENBQWlCLHNCQUFzQixpQkFBdEIsRUFBeUMsbUJBQXpDLENBQWpCOztBQUVBLGdCQUFZLElBQVosR0FBbUIsVUFBbkI7QUFDQSxnQkFBWSxnQkFBWixDQUE2QixPQUE3QixFQUFzQyxVQUFTLENBQVQsRUFBWTtBQUM5QyxZQUNJLFVBQVUsV0FBVyxVQUFYLEVBRGQ7O0FBR0QsZ0JBQVEsWUFBUixDQUFxQixZQUFZLE9BQWpDO0FBQ0YsS0FMRDs7QUFPQSxTQUFLLFdBQUwsQ0FBaUIsc0JBQXNCLFdBQXRCLEVBQW1DLFlBQW5DLENBQWpCOztBQUVBLGdCQUFZLFVBQVosR0FBeUIsV0FBekIsQ0FBcUMsWUFBWSxVQUFaLEVBQXJDOztBQUVBLFNBQUssV0FBTCxDQUFpQixZQUFZLFVBQVosRUFBakI7O0FBRUE7QUFDQSxRQUNJLHFCQUFxQixTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsQ0FEekI7O0FBR0EsdUJBQW1CLFNBQW5CLEdBQStCLDZDQUEvQjs7QUFFQSxjQUFVLFNBQVYsR0FBc0IsMERBQXRCO0FBQ0EsY0FBVSxLQUFWLEdBQWtCLFdBQWxCO0FBQ0EsY0FBVSxnQkFBVixDQUEyQixPQUEzQixFQUFvQyxZQUFXO0FBQzNDLG1CQUFXLGVBQVgsQ0FBMkIsRUFBQyxRQUFRLFlBQVQsRUFBM0I7QUFDSCxLQUZEOztBQUlBLGlCQUFhLFNBQWIsR0FBeUIsNkRBQXpCO0FBQ0EsaUJBQWEsS0FBYixHQUFxQixjQUFyQjtBQUNBLGlCQUFhLGdCQUFiLENBQThCLE9BQTlCLEVBQXVDLFlBQVc7QUFDOUMsbUJBQVcsZUFBWCxDQUEyQixFQUFDLFFBQVEsZUFBVCxFQUEzQjtBQUNILEtBRkQ7O0FBSUEsdUJBQW1CLFdBQW5CLENBQStCLFNBQS9CO0FBQ0EsdUJBQW1CLFdBQW5CLENBQStCLFlBQS9COztBQUVBLFNBQUssV0FBTCxDQUFpQixrQkFBakI7O0FBRUEsUUFDSSxVQUFVLFdBQVcsVUFBWCxFQURkOztBQUdBO0FBQ0EsZ0JBQVksUUFBWixDQUFxQixRQUFRLGNBQVIsR0FBeUIsUUFBekIsRUFBckI7QUFDQSxlQUFXLEtBQVgsR0FBbUIsUUFBUSxjQUFSLEdBQXlCLFlBQXpCLEVBQW5COztBQUVBLFlBQVEsRUFBUixDQUFXLGFBQVgsRUFBMEIsVUFBUyxVQUFULEVBQXFCO0FBQzNDLFlBQ0ksVUFBVSxJQURkOztBQUdBLFlBQUksUUFBUSxjQUFSLEdBQXlCLFFBQXpCLE1BQXVDLFlBQVksS0FBdkQsRUFBOEQ7QUFDMUQsd0JBQVksUUFBWixDQUFxQixRQUFRLGNBQVIsR0FBeUIsUUFBekIsRUFBckI7QUFDSDs7QUFFRCxZQUFJLFFBQVEsY0FBUixHQUF5QixZQUF6QixNQUEyQyxTQUFTLFdBQVcsS0FBcEIsRUFBMkIsRUFBM0IsQ0FBL0MsRUFBK0U7QUFDM0UsdUJBQVcsS0FBWCxHQUFtQixRQUFRLGNBQVIsR0FBeUIsWUFBekIsRUFBbkI7QUFDSDs7QUFFRCxZQUFJLGVBQWUsU0FBbkIsRUFBOEI7QUFDMUIsd0JBQVksVUFBWixDQUF1QixVQUF2QjtBQUNILFNBRkQsTUFFTztBQUNIO0FBQ0Esd0JBQVksTUFBWjtBQUNIOztBQUVELG9CQUFZLG1CQUFaO0FBQ0gsS0FwQkQ7QUFxQkg7O0FBRUQsZ0JBQWdCLFNBQWhCLEdBQTRCLE9BQU8sTUFBUCxDQUFjLG9CQUFVLFNBQXhCLENBQTVCO0FBQ0EsZ0JBQWdCLFNBQWhCLENBQTBCLFdBQTFCLEdBQXdDLGVBQXhDOzs7Ozs7Ozs7a0JDaG9Cd0IsUzs7QUFKeEI7Ozs7QUFDQTs7OztBQUNBOzs7Ozs7QUFFZSxTQUFTLFNBQVQsQ0FBbUIsVUFBbkIsRUFBK0IsTUFBL0IsRUFBdUM7QUFDbEQsUUFDSSxZQUFZLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQURoQjtBQUFBLFFBRUksU0FBUyx1QkFBYSxVQUFiLENBRmI7QUFBQSxRQUdJLGlCQUFpQiwrQkFBcUIsVUFBckIsQ0FIckI7QUFBQSxRQUlJLE9BSko7QUFBQSxRQU1JLGlCQUFpQixLQU5yQjtBQUFBLFFBUUksT0FBTyxJQVJYOztBQVVBLFNBQUssY0FBTCxHQUFzQixZQUFXO0FBQzdCLHVCQUFlLGNBQWY7QUFDSCxLQUZEOztBQUlBLFNBQUssZUFBTCxHQUF1QixZQUFXO0FBQzlCO0FBQ0EsbUJBQVcsZUFBZSxlQUFmLENBQStCLElBQS9CLENBQW9DLGNBQXBDLENBQVgsRUFBZ0UsQ0FBaEU7QUFDSCxLQUhEOztBQUtBLFNBQUssaUJBQUwsR0FBeUIsWUFBVztBQUNoQyx1QkFBZSxpQkFBZjtBQUNILEtBRkQ7O0FBSUEsU0FBSyxXQUFMLEdBQW1CLFVBQVMsV0FBVCxFQUFzQixJQUF0QixFQUE0QjtBQUMzQyx1QkFBZSxpQkFBZixDQUFpQyxXQUFqQyxFQUE4QyxJQUE5QztBQUNILEtBRkQ7O0FBSUEsU0FBSyxXQUFMLEdBQW1CLFlBQVc7QUFDMUIsZUFBTyxlQUFlLFFBQWYsQ0FBd0IsUUFBeEIsQ0FBaUMsV0FBakMsRUFBUDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxXQUFMLEdBQW1CLFVBQVMsUUFBVCxFQUFtQjtBQUNsQyx1QkFBZSxRQUFmLENBQXdCLFFBQXhCLENBQWlDLFdBQWpDLENBQTZDLFFBQTdDO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLGlCQUFMLEdBQXlCLFlBQVc7QUFDaEMsZUFBTyxjQUFQO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLFdBQUwsR0FBbUIsVUFBUyxRQUFULEVBQW1CO0FBQ2xDLGVBQU8sV0FBUCxDQUFtQixRQUFuQjtBQUNILEtBRkQ7O0FBSUEsU0FBSyxpQkFBTCxHQUF5QixVQUFTLEtBQVQsRUFBZ0I7QUFDckMseUJBQWlCLEtBQWpCOztBQUVBLGFBQUssTUFBTDtBQUNBLGFBQUssZUFBTDtBQUNILEtBTEQ7O0FBT0EsU0FBSyxNQUFMLEdBQWMsWUFBVztBQUNyQixZQUNJLFNBREo7O0FBR0EsWUFBSSxjQUFKLEVBQW9CO0FBQ2hCLHdCQUFZLEVBQUUsTUFBRixFQUFVLE1BQVYsS0FBcUIsRUFBRSxRQUFRLFVBQVIsRUFBRixFQUF3QixNQUF4QixFQUFqQztBQUNILFNBRkQsTUFFTztBQUNILHdCQUFZLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFVLEVBQUUsTUFBRixFQUFVLE1BQVYsS0FBcUIsRUFBRSxRQUFRLFVBQVIsRUFBRixFQUF3QixNQUF4QixFQUFyQixHQUF3RCxFQUFsRSxFQUF1RSxHQUF2RSxDQUFULEVBQXNGLEdBQXRGLENBQVo7QUFDSDs7QUFFRCxlQUFPLE1BQVAsQ0FBYyxTQUFkO0FBQ0EsYUFBSyxpQkFBTDtBQUNILEtBWkQ7O0FBY0EsY0FBVSx5QkFBZSxVQUFmLEVBQTJCLElBQTNCLENBQVY7O0FBRUEsV0FBTyxXQUFQLENBQW1CLFFBQVEsVUFBUixFQUFuQjs7QUFFQSxjQUFVLFNBQVYsR0FBc0IsMkJBQXRCOztBQUVBLGNBQVUsV0FBVixDQUFzQixPQUFPLFVBQVAsRUFBdEI7QUFDQSxjQUFVLFdBQVYsQ0FBc0IsZUFBZSxVQUFmLEVBQXRCOztBQUVBLFdBQU8sV0FBUCxDQUFtQixTQUFuQjs7QUFFQSxXQUFPLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDLEtBQUssTUFBTCxDQUFZLElBQVosQ0FBaUIsSUFBakIsQ0FBbEM7O0FBRUEsZUFBVyxLQUFLLE1BQUwsQ0FBWSxJQUFaLENBQWlCLElBQWpCLENBQVgsRUFBbUMsQ0FBbkM7QUFDSCxDLENBekdEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBMkdBLFVBQVUsU0FBVixHQUFzQixPQUFPLE1BQVAsQ0FBYyxhQUFhLFNBQTNCLENBQXRCO0FBQ0EsVUFBVSxTQUFWLENBQW9CLFdBQXBCLEdBQWtDLFNBQWxDOzs7Ozs7Ozs7a0JDa1J3QixVO0FBOVh4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQSxJQUNJLGVBQWUsQ0FDWDtBQUNJLFVBQU0sTUFEVjtBQUVJLGNBQVUsR0FGZDtBQUdJLGNBQVUsQ0FDTjtBQUNJLGNBQU0scUJBRFY7QUFFSSxnQkFBUSxRQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGtCQUFVO0FBSmQsS0FETSxFQU9OO0FBQ0ksY0FBTSxhQURWO0FBRUksZ0JBQVEsUUFGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxrQkFBVTtBQUpkLEtBUE07QUFIZCxDQURXLEVBbUJYO0FBQ0ksVUFBTSxNQURWO0FBRUksY0FBVSxHQUZkO0FBR0ksY0FBVSxDQUNOO0FBQ0ksY0FBTSxNQURWO0FBRUksZ0JBQVEsUUFGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxrQkFBVSxRQUpkO0FBS0ksZUFBTztBQUxYLEtBRE0sRUFRTjtBQUNJLGNBQU0sTUFEVjtBQUVJLGdCQUFRLFFBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVUsY0FKZDtBQUtJLGVBQU87QUFMWCxLQVJNLEVBZU47QUFDSSxjQUFNLGVBRFY7QUFFSSxnQkFBUSxnQkFGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxlQUFPO0FBSlgsS0FmTSxFQXFCTjtBQUNJLGNBQU07QUFEVixLQXJCTSxFQXdCTjtBQUNJLGNBQU0sS0FEVjtBQUVJLGdCQUFRLE9BRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVU7QUFKZCxLQXhCTSxFQThCTjtBQUNJLGNBQU0sTUFEVjtBQUVJLGdCQUFRLFFBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVU7QUFKZCxLQTlCTSxFQW9DTjtBQUNJLGNBQU0sYUFEVjtBQUVJLGdCQUFRLGNBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVU7QUFKZCxLQXBDTSxFQTBDTjtBQUNJLGNBQU0sT0FEVjtBQUVJLGdCQUFRLFNBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVU7QUFKZCxLQTFDTSxFQWdETjtBQUNJLGNBQU07QUFEVixLQWhETSxFQW1ETjtBQUNJLGNBQU0sWUFEVjtBQUVJLGdCQUFRLGFBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVU7QUFKZCxLQW5ETSxFQXlETjtBQUNJLGNBQU0sVUFEVjtBQUVJLGdCQUFRLGVBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVU7QUFKZCxLQXpETSxFQStETjtBQUNJLGNBQU07QUFEVixLQS9ETSxFQWtFTjtBQUNJLGNBQU0sV0FEVjtBQUVJLGdCQUFRLGFBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVU7QUFKZCxLQWxFTTtBQUhkLENBbkJXLEVBZ0dYO0FBQ0ksVUFBTSxRQURWO0FBRUksY0FBVSxHQUZkO0FBR0ksY0FBVSxDQUNOO0FBQ0ksY0FBTSxXQURWO0FBRUksZ0JBQVEsa0JBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVUsY0FKZDtBQUtJLGVBQU87QUFMWCxLQURNLEVBUU47QUFDSSxjQUFNO0FBRFYsS0FSTSxFQVdOO0FBQ0ksY0FBTSxZQURWO0FBRUksZ0JBQVEsa0JBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVUsUUFKZDtBQUtJLGVBQU87QUFMWCxLQVhNLEVBa0JOO0FBQ0ksY0FBTSxrQkFEVjtBQUVJLGdCQUFRLGlCQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGVBQU87QUFKWCxLQWxCTTtBQUhkLENBaEdXLEVBNkhYO0FBQ0ksVUFBTSxTQURWO0FBRUksY0FBVSxHQUZkO0FBR0ksY0FBVSxDQUNOO0FBQ0ksY0FBTSxPQURWO0FBRUksZ0JBQVEsU0FGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxrQkFBVSxlQUpkO0FBS0ksZUFBTztBQUxYLEtBRE0sRUFRTjtBQUNJLGNBQU0sTUFEVjtBQUVJLGdCQUFRLFFBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVUsUUFKZDtBQUtJLGVBQU87QUFMWCxLQVJNLEVBZU47QUFDSSxjQUFNLGlCQURWO0FBRUksZ0JBQVEsU0FGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxlQUFPO0FBSlgsS0FmTSxFQXFCTjtBQUNJLGNBQU0sZUFEVjtBQUVJLGdCQUFRLFNBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksZUFBTztBQUpYLEtBckJNLEVBMkJOO0FBQ0ksY0FBTSxRQURWO0FBRUksZ0JBQVEsWUFGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxlQUFPO0FBSlgsS0EzQk0sRUFpQ047QUFDSSxjQUFNO0FBRFYsS0FqQ00sRUFvQ047QUFDSSxjQUFNLGFBRFY7QUFFSSxnQkFBUSxhQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGVBQU87QUFKWCxLQXBDTSxFQTBDTjtBQUNJLGNBQU07QUFEVixLQTFDTSxFQTZDTjtBQUNJLGNBQU0scUJBRFY7QUFFSSxnQkFBUSxVQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGVBQU87QUFKWCxLQTdDTSxFQW1ETjtBQUNJLGNBQU0sYUFEVjtBQUVJLGdCQUFRLFVBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksZUFBTztBQUpYLEtBbkRNO0FBSGQsQ0E3SFcsRUEyTFg7QUFDSSxVQUFNLE1BRFY7QUFFSSxjQUFVLEdBRmQ7QUFHSSxjQUFVLENBQ047QUFDSSxjQUFNLGtCQURWO0FBRUksZ0JBQVEsY0FGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxrQkFBVSxJQUpkO0FBS0ksaUJBQVM7QUFMYixLQURNLEVBUU47QUFDSSxjQUFNO0FBRFYsS0FSTSxFQVdOO0FBQ0ksY0FBTSxTQURWO0FBRUksZ0JBQVEsVUFGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxrQkFBVSxRQUpkO0FBS0ksZUFBTztBQUxYLEtBWE0sRUFrQk47QUFDSSxjQUFNLFVBRFY7QUFFSSxnQkFBUSxXQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGtCQUFVLFFBSmQ7QUFLSSxlQUFPO0FBTFgsS0FsQk0sRUF5Qk47QUFDSSxjQUFNLFdBRFY7QUFFSSxnQkFBUSxXQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGtCQUFVLFFBSmQ7QUFLSSxlQUFPO0FBTFgsS0F6Qk0sRUFnQ047QUFDSSxnQkFBUSx1QkFEWjtBQUVJLGNBQU07QUFGVixLQWhDTSxFQW9DTjtBQUNJLGNBQU0sMEJBRFY7QUFFSSxnQkFBUSx1QkFGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxlQUFPLHNGQUpYO0FBS0ksa0JBQVU7QUFMZCxLQXBDTSxFQTJDTjtBQUNJLGNBQU07QUFEVixLQTNDTSxFQThDTjtBQUNJLGNBQU0sV0FEVjtBQUVJLGdCQUFRLGNBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVUsUUFKZDtBQUtJLGVBQU8sZ0NBTFg7QUFNSSxrQkFBVSxJQU5kO0FBT0ksaUJBQVM7QUFQYixLQTlDTSxFQXVETjtBQUNJLGNBQU0saUJBRFY7QUFFSSxnQkFBUSxlQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGVBQU87QUFKWCxLQXZETTtBQUhkLENBM0xXLEVBNlBYO0FBQ0ksVUFBTSxVQURWO0FBRUksY0FBVSxHQUZkO0FBR0ksY0FBVSxDQUNOO0FBQ0ksY0FBTSxXQURWO0FBRUksZ0JBQVEsbUJBRlo7QUFHSSxlQUFPO0FBSFgsS0FETSxFQU1OO0FBQ0ksY0FBTSxpQkFEVjtBQUVJLGdCQUFRLGtCQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGtCQUFVLEtBSmQ7QUFLSSxlQUFPO0FBTFgsS0FOTSxFQWFOO0FBQ0ksY0FBTTtBQURWLEtBYk0sRUFnQk47QUFDSSxjQUFNLG1CQURWO0FBRUksZ0JBQVEsWUFGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxrQkFBVSxJQUpkO0FBS0ksaUJBQVM7QUFMYixLQWhCTSxFQXVCTjtBQUNJLGNBQU0sWUFEVjtBQUVJLGdCQUFRLFlBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVUsSUFKZDtBQUtJLGlCQUFTO0FBTGIsS0F2Qk0sRUE4Qk47QUFDSSxjQUFNLGFBRFY7QUFFSSxnQkFBUSxhQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGtCQUFVLElBSmQ7QUFLSSxpQkFBUztBQUxiLEtBOUJNLEVBcUNOO0FBQ0ksY0FBTSxXQURWO0FBRUksZ0JBQVEsV0FGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxrQkFBVSxJQUpkO0FBS0ksaUJBQVM7QUFMYixLQXJDTSxFQTRDTjtBQUNJLGNBQU0sYUFEVjtBQUVJLGdCQUFRLGFBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVUsSUFKZDtBQUtJLGlCQUFTO0FBTGIsS0E1Q00sRUFtRE47QUFDSSxjQUFNLGVBRFY7QUFFSSxnQkFBUSxlQUZaO0FBR0ksa0JBQVUsR0FIZDtBQUlJLGtCQUFVLElBSmQ7QUFLSSxpQkFBUztBQUxiLEtBbkRNLEVBMEROO0FBQ0ksY0FBTSxlQURWO0FBRUksZ0JBQVEsZUFGWjtBQUdJLGtCQUFVLEdBSGQ7QUFJSSxrQkFBVSxJQUpkO0FBS0ksaUJBQVM7QUFMYixLQTFETSxFQWlFTjtBQUNJLGNBQU0sWUFEVjtBQUVJLGdCQUFRLFdBRlo7QUFHSSxrQkFBVSxHQUhkO0FBSUksa0JBQVUsSUFKZDtBQUtJLGlCQUFTO0FBTGIsS0FqRU07QUFIZCxDQTdQVyxFQTBVWDtBQUNJLFVBQU0sTUFEVjtBQUVJLGNBQVUsR0FGZDtBQUdJLGNBQVUsQ0FDTjtBQUNJLGNBQU0sZ0JBRFY7QUFFSSxrQkFBVSxHQUZkO0FBR0ksZ0JBQVEsaUJBSFo7QUFJSSxlQUFPO0FBSlgsS0FETSxFQU9OO0FBQ0ksY0FBTSxXQURWO0FBRUksa0JBQVUsR0FGZDtBQUdJLGdCQUFRLGFBSFo7QUFJSSxlQUFPO0FBSlgsS0FQTSxFQWFOO0FBQ0ksY0FBTTtBQURWLEtBYk0sRUFnQk47QUFDSSxjQUFNLE9BRFY7QUFFSSxrQkFBVSxHQUZkO0FBR0ksZ0JBQVEsU0FIWjtBQUlJLGVBQU87QUFKWCxLQWhCTTtBQUhkLENBMVVXLENBRG5COztBQXdXZSxTQUFTLFVBQVQsQ0FBb0IsVUFBcEIsRUFBZ0MsT0FBaEMsRUFBeUM7QUFDcEQsUUFDSSxNQUFNLEVBQ0Ysd0NBQ00sK0JBRE4sR0FFVSw2QkFGVixHQUdjLG1EQUhkLEdBSVUsUUFKVixHQUtVLDZCQUxWLEdBTVUsT0FOVixHQU9NLFFBUE4sR0FRRSxRQVRBLENBRFY7QUFBQSxRQVlJLGNBQWMsUUFBUSxJQUFSLENBQWEsVUFBVSxRQUF2QixDQVpsQjs7QUFjQSxhQUFTLGVBQVQsQ0FBeUIsTUFBekIsRUFBaUM7QUFDN0IsWUFDSSxTQUFTLE9BQU8sSUFBUCxDQUFZLFFBQVosQ0FEYjtBQUFBLFlBRUksV0FBVyxPQUFPLElBQVAsQ0FBWSxVQUFaLENBRmY7QUFBQSxZQUdJLFFBSEo7O0FBS0EsWUFBSSxRQUFKLEVBQWM7QUFDVixtQkFBTyxXQUFQLENBQW1CLFVBQW5CO0FBQ0EsdUJBQVcsT0FBTyxRQUFQLENBQWdCLFVBQWhCLENBQVg7QUFDSCxTQUhELE1BR087QUFDSCx1QkFBVyxLQUFYO0FBQ0g7O0FBRUQsbUJBQVcsZUFBWCxDQUEyQjtBQUN2QixvQkFBUSxNQURlO0FBRXZCLHNCQUFVLFFBRmE7QUFHdkIsc0JBQVU7QUFIYSxTQUEzQjtBQUtIOztBQUVELGFBQVMsbUJBQVQsQ0FBNkIsUUFBN0IsRUFBdUM7QUFDbkMsbUJBQVcsU0FBUyxXQUFULEVBQVg7O0FBRUE7QUFDQSxtQkFBVyxTQUFTLE9BQVQsQ0FBaUIsUUFBakIsRUFBMkIsRUFBM0IsQ0FBWDs7QUFFQTtBQUNBLG1CQUFXLFNBQVMsT0FBVCxDQUFpQixRQUFqQixFQUEyQixRQUEzQixDQUFYO0FBQ0EsbUJBQVcsU0FBUyxPQUFULENBQWlCLEtBQWpCLEVBQXdCLEtBQXhCLENBQVg7O0FBRUEsWUFBSSxXQUFKLEVBQWlCO0FBQ2IsdUJBQVcsU0FBUyxPQUFULENBQWlCLFdBQWpCLEVBQThCLElBQTlCLENBQVg7QUFDSCxTQUZELE1BRU87QUFDSCx1QkFBVyxTQUFTLE9BQVQsQ0FBaUIsV0FBakIsRUFBOEIsS0FBOUIsQ0FBWDtBQUNIOztBQUVELGVBQU8sUUFBUDtBQUNIOztBQUVELGFBQVMsZUFBVCxDQUF5QixRQUF6QixFQUFtQyxPQUFuQyxFQUE0QztBQUN4QyxpQkFBUyxNQUFULENBQWdCLFFBQVEsR0FBUixDQUFZLFVBQVMsS0FBVCxFQUFnQjtBQUN4QyxnQkFDSSxTQURKOztBQUdBLGdCQUFJLE1BQU0sTUFBTixJQUFnQixDQUFDLFdBQVcsaUJBQVgsQ0FBNkIsTUFBTSxNQUFuQyxDQUFyQixFQUFpRTtBQUM3RDtBQUNIOztBQUVELGdCQUFJLE1BQU0sTUFBTixJQUFnQixRQUFoQixJQUE0QixDQUFDLFdBQVcsaUJBQVgsQ0FBNkIsWUFBN0IsQ0FBakMsRUFBNkU7QUFDekU7QUFDQSxzQkFBTSxJQUFOLEdBQWEsYUFBYjtBQUNBLHNCQUFNLFFBQU4sR0FBaUIsUUFBakI7QUFDSDs7QUFFRCxnQkFBSSxNQUFNLFFBQVYsRUFBb0I7QUFDaEIsNEJBQVksRUFDUiwwQkFDTSxzSEFETixHQUMrSCxNQUFNLElBRHJJLEdBQzRJLGtDQUQ1SSxHQUVNLDRCQUZOLEdBR00sT0FITixHQUlFLE9BTE0sQ0FBWjs7QUFRQSxrQkFBRSxrQkFBRixFQUFzQixTQUF0QixFQUFpQyxRQUFqQzs7QUFFQSwwQkFBVSxFQUFWLENBQWEsa0JBQWIsRUFBaUMsWUFBVztBQUN4Qzs7O0FBR0Esc0JBQUUsUUFBRixFQUFZLEdBQVosQ0FBZ0IsT0FBaEIsRUFBeUIsWUFBVztBQUNoQyw0QkFBSSxVQUFVLFFBQVYsQ0FBbUIsTUFBbkIsQ0FBSixFQUFnQztBQUM1Qiw4QkFBRSxrQkFBRixFQUFzQixTQUF0QixFQUFpQyxRQUFqQyxDQUEwQyxRQUExQztBQUNIO0FBQ0oscUJBSkQ7QUFLSCxpQkFURDs7QUFXQSxnQ0FBZ0IsRUFBRSxnQkFBRixFQUFvQixTQUFwQixDQUFoQixFQUFnRCxNQUFNLFFBQXREO0FBQ0gsYUF2QkQsTUF1Qk8sSUFBSSxNQUFNLElBQU4sSUFBYyxHQUFsQixFQUF1QjtBQUMxQiw0QkFBWSxFQUFFLDRDQUFGLENBQVo7QUFDSCxhQUZNLE1BRUE7QUFDSCw0QkFBWSxFQUFFLGtDQUFrQyxNQUFNLE1BQXhDLEdBQWlELFVBQWpELEdBQThELE1BQU0sSUFBcEUsR0FBMkUsa0JBQTdFLENBQVo7O0FBRUEsb0JBQUksTUFBTSxRQUFWLEVBQW9CO0FBQ2hCLHNCQUFFLEdBQUYsRUFBTyxTQUFQLEVBQ0ssSUFETCxDQUNVLFVBRFYsRUFDc0IsSUFEdEIsRUFFSyxXQUZMLENBRWlCLFVBRmpCLEVBRTZCLENBQUMsQ0FBQyxNQUFNLE9BRnJDO0FBR0g7QUFDSjs7QUFFRCxnQkFBSSxNQUFNLEtBQVYsRUFBaUI7QUFDYiwwQkFBVSxJQUFWLENBQWUsT0FBZixFQUF3QixNQUFNLEtBQTlCO0FBQ0g7O0FBRUQsZ0JBQUksTUFBTSxRQUFWLEVBQW9CO0FBQ2hCLG9CQUNJLFdBQVcsRUFBRSxLQUFGLEVBQVMsU0FBVCxDQURmO0FBQUEsb0JBRUksZUFBZSxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsQ0FGbkI7O0FBSUE7QUFDQSxvQkFBSSxXQUFKLEVBQWlCO0FBQ2IsMEJBQU0sUUFBTixHQUFpQixNQUFNLFFBQU4sQ0FBZSxPQUFmLENBQXVCLFNBQXZCLEVBQWtDLEdBQWxDLENBQWpCO0FBQ0EsMEJBQU0sUUFBTixHQUFpQixNQUFNLFFBQU4sQ0FBZSxPQUFmLENBQXVCLE9BQXZCLEVBQWdDLEdBQWhDLENBQWpCO0FBQ0EsMEJBQU0sUUFBTixHQUFpQixNQUFNLFFBQU4sQ0FBZSxPQUFmLENBQXVCLFFBQXZCLEVBQWlDLEdBQWpDLENBQWpCO0FBQ0g7O0FBRUQsNkJBQWEsU0FBYixHQUF5Qix1QkFBekI7QUFDQSw2QkFBYSxTQUFiLEdBQXlCLG9CQUFvQixNQUFNLFFBQTFCLENBQXpCOztBQUVBLHlCQUFTLE1BQVQsQ0FBZ0IsWUFBaEI7O0FBRUEsb0JBQUksTUFBTSxRQUFWLEVBQW9CLFVBQVMsQ0FBVCxFQUFZO0FBQzVCLG9DQUFnQixRQUFoQjs7QUFFQSxzQkFBRSxjQUFGO0FBQ0Esc0JBQUUsZUFBRjs7QUFFQSwyQkFBTyxLQUFQO0FBQ0gsaUJBUEQ7QUFRSDs7QUFFRCxtQkFBTyxTQUFQO0FBQ0gsU0FqRmUsQ0FBaEI7QUFrRkg7O0FBRUQsU0FBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsZUFBTyxJQUFJLENBQUosQ0FBUDtBQUNILEtBRkQ7O0FBSUEsb0JBQWdCLEVBQUUsYUFBRixFQUFpQixHQUFqQixDQUFoQixFQUF1QyxZQUF2Qzs7QUFFQSxNQUFFLEdBQUYsRUFBTyxFQUFQLENBQVUsT0FBVixFQUFtQix5QkFBbkIsRUFBOEMsVUFBUyxDQUFULEVBQVk7QUFDdEQsd0JBQWdCLEVBQUUsSUFBRixDQUFoQjtBQUNBLFVBQUUsY0FBRjtBQUNILEtBSEQ7O0FBS0EsYUFBUyxrQkFBVCxDQUE0QixXQUE1QixFQUF5QyxJQUF6QyxFQUErQztBQUMzQztBQUNBLFlBQ0ksZUFBZSxFQUFFLHlCQUF5QixZQUFZLFNBQVosQ0FBc0IsQ0FBdEIsRUFBeUIsQ0FBekIsRUFBNEIsV0FBNUIsRUFBekIsR0FBcUUsWUFBWSxTQUFaLENBQXNCLENBQXRCLENBQXJFLEdBQWdHLEtBQWxHLEVBQXlHLEdBQXpHLENBRG5COztBQUdBLHFCQUFhLFdBQWIsQ0FBeUIsVUFBekIsRUFBcUMsSUFBckM7QUFDSDs7QUFFRCxZQUFRLGlCQUFSLEdBQTRCLEVBQTVCLENBQStCLGtCQUEvQixFQUFtRCxrQkFBbkQ7QUFDSDs7Ozs7Ozs7O2tCQ3JnQnVCLGE7O0FBRnhCOzs7Ozs7QUFFZSxTQUFTLGFBQVQsQ0FBdUIsWUFBdkIsRUFBcUM7QUFDaEQsd0JBQVUsSUFBVixDQUFlLElBQWYsRUFBcUIsWUFBckIsRUFBbUMsTUFBbkMsRUFBMkMsTUFBM0M7O0FBRUEsUUFDSSxPQUFPLElBRFg7QUFBQSxRQUdJLFVBQVUsQ0FDTjtBQUNJLG1CQUFXLDJCQURmO0FBRUksaUJBQVMsVUFGYjtBQUdJLGlCQUFTO0FBSGIsS0FETSxFQU1OO0FBQ0ksbUJBQVcsNEJBRGY7QUFFSSxpQkFBUyxXQUZiO0FBR0ksaUJBQVM7QUFIYixLQU5NLEVBV047QUFDSSxtQkFBVyw0QkFEZjtBQUVJLGlCQUFTLFdBRmI7QUFHSSxpQkFBUztBQUhiLEtBWE0sRUFnQk47QUFDSSxtQkFBVyx3QkFEZjtBQUVJLGlCQUFTLFFBRmI7QUFHSSxpQkFBUztBQUhiLEtBaEJNLEVBcUJOO0FBQ0ksbUJBQVcsd0JBRGY7QUFFSSxpQkFBUyxRQUZiO0FBR0ksaUJBQVM7QUFIYixLQXJCTSxFQTBCTjtBQUNJLG1CQUFXLHdCQURmO0FBRUksaUJBQVMsUUFGYjtBQUdJLGlCQUFTO0FBSGIsS0ExQk0sQ0FIZDs7QUFvQ0EsYUFBUyxZQUFULEdBQXdCO0FBQ3BCLFlBQ0ksT0FBTyxLQUFLLGNBQUwsRUFEWDtBQUFBLFlBRUksV0FBVyxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsQ0FGZjs7QUFJQSxpQkFBUyxTQUFULEdBQXFCLHVDQUFyQjs7QUFFQSxhQUFLLElBQUksQ0FBVCxJQUFjLE9BQWQsRUFBdUI7QUFDbkIsZ0JBQ0ksU0FBUyxRQUFRLENBQVIsQ0FEYjtBQUFBLGdCQUVJLGFBQWEsU0FBUyxhQUFULENBQXVCLElBQXZCLENBRmpCOztBQUlBLGdCQUFJLE9BQU8sT0FBUCxJQUFrQixRQUFsQixJQUE4QixDQUFDLGFBQWEsaUJBQWIsQ0FBK0IsWUFBL0IsQ0FBbkMsRUFBaUY7QUFDN0UsdUJBQU8sT0FBUCxHQUFpQix3QkFBakI7QUFDQSx1QkFBTyxTQUFQLEdBQW1CLGdDQUFuQjtBQUNIOztBQUVELHVCQUFXLFNBQVgsR0FBdUIsaUNBQWlDLE9BQU8sU0FBL0Q7QUFDQSx1QkFBVyxZQUFYLENBQXdCLGtCQUF4QixFQUE0QyxDQUE1Qzs7QUFFQSxxQkFBUyxXQUFULENBQXFCLFVBQXJCO0FBQ0g7O0FBRUQsaUJBQVMsZ0JBQVQsQ0FBMEIsV0FBMUIsRUFBdUMsVUFBUyxDQUFULEVBQVk7QUFDL0MsZ0JBQUksRUFBRSxNQUFGLElBQVksRUFBRSxNQUFGLENBQVMsUUFBVCxJQUFxQixJQUFyQyxFQUEyQztBQUN2QyxrQkFBRSxFQUFFLE1BQUosRUFBWSxRQUFaLENBQXFCLFVBQXJCO0FBQ0g7QUFDSixTQUpEOztBQU1ELGlCQUFTLGdCQUFULENBQTBCLFNBQTFCLEVBQXFDLFVBQVMsQ0FBVCxFQUFZO0FBQzVDLGdCQUFJLEVBQUUsTUFBRixJQUFZLEVBQUUsTUFBRixDQUFTLFFBQVQsSUFBcUIsSUFBckMsRUFBMkM7QUFDdkMsa0JBQUUsRUFBRSxNQUFKLEVBQVksV0FBWixDQUF3QixVQUF4QjtBQUNIO0FBQ0osU0FKRjs7QUFNQyxpQkFBUyxnQkFBVCxDQUEwQixPQUExQixFQUFtQyxVQUFTLENBQVQsRUFBWTtBQUMzQyxnQkFBSSxFQUFFLE1BQUYsSUFBWSxFQUFFLE1BQUYsQ0FBUyxRQUFULElBQXFCLElBQXJDLEVBQTJDO0FBQ3ZDLG9CQUNJLFNBQVMsUUFBUSxTQUFTLEVBQUUsTUFBRixDQUFTLFlBQVQsQ0FBc0Isa0JBQXRCLENBQVQsRUFBb0QsRUFBcEQsQ0FBUixDQURiOztBQUdBLDZCQUFhLGVBQWIsQ0FBNkIsRUFBQyxRQUFRLE9BQU8sT0FBaEIsRUFBN0I7QUFDSDtBQUNKLFNBUEQ7O0FBU0EsYUFBSyxXQUFMLENBQWlCLFFBQWpCO0FBQ0g7O0FBRUQ7QUFDSCxDLENBL0dEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBaUhBLGNBQWMsU0FBZCxHQUEwQixPQUFPLE1BQVAsQ0FBYyxvQkFBVSxTQUF4QixDQUExQjtBQUNBLGNBQWMsU0FBZCxDQUF3QixXQUF4QixHQUFzQyxhQUF0Qzs7Ozs7Ozs7O2tCQzVGd0IsUztBQXRCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQmUsU0FBUyxTQUFULENBQW1CLFlBQW5CLEVBQWlDLFNBQWpDLEVBQTRDLEtBQTVDLEVBQW1ELFVBQW5ELEVBQStEO0FBQzFFLFNBQUssS0FBTCxHQUFhLEtBQWI7QUFDQSxTQUFLLElBQUwsR0FBWSxTQUFaO0FBQ0EsU0FBSyxVQUFMLEdBQWtCLGNBQWMsS0FBaEM7O0FBRUEsUUFDSSxtQkFBbUIsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRHZCO0FBQUEsUUFFSSxjQUFjLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUZsQjtBQUFBLFFBR0ksY0FBYyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FIbEI7QUFBQSxRQUlJLGNBQWMsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBSmxCO0FBQUEsUUFNSSxhQUFhLElBTmpCO0FBQUEsUUFRSSxVQVJKO0FBQUEsUUFVSSxPQUFPLElBVlg7O0FBWUEsU0FBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsZUFBTyxnQkFBUDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxjQUFMLEdBQXNCLFlBQVc7QUFDN0IsZUFBTyxXQUFQO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLFFBQUwsR0FBZ0IsWUFBVztBQUN2QixlQUFPLEVBQUUsZ0JBQUYsRUFBb0IsVUFBcEIsRUFBUDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxTQUFMLEdBQWlCLFlBQVc7QUFDeEIsZUFBTyxFQUFFLGdCQUFGLEVBQW9CLFdBQXBCLEVBQVA7QUFDSCxLQUZEOztBQUlBLFNBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsZUFBTyxTQUFTLGlCQUFpQixLQUFqQixDQUF1QixJQUFoQyxFQUFzQyxFQUF0QyxLQUE2QyxDQUFwRDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxJQUFMLEdBQVksWUFBVztBQUNuQixlQUFPLFNBQVMsaUJBQWlCLEtBQWpCLENBQXVCLEdBQWhDLEVBQXFDLEVBQXJDLEtBQTRDLENBQW5EO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLFdBQUwsR0FBbUIsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQzlCLHlCQUFpQixLQUFqQixDQUF1QixJQUF2QixHQUE4QixJQUFJLElBQWxDO0FBQ0EseUJBQWlCLEtBQWpCLENBQXVCLEdBQXZCLEdBQTZCLElBQUksSUFBakM7QUFDSCxLQUhEOztBQUtBLFNBQUssUUFBTCxHQUFnQixVQUFTLEtBQVQsRUFBZ0I7QUFDNUIseUJBQWlCLEtBQWpCLENBQXVCLEtBQXZCLEdBQStCLFFBQVEsSUFBdkM7QUFDSCxLQUZEOztBQUlBLFNBQUssU0FBTCxHQUFpQixVQUFTLE1BQVQsRUFBaUI7QUFDOUIseUJBQWlCLEtBQWpCLENBQXVCLE1BQXZCLEdBQWdDLFNBQVMsSUFBekM7QUFDSCxLQUZEOztBQUlBLFNBQUssT0FBTCxHQUFlLFVBQVMsS0FBVCxFQUFnQixNQUFoQixFQUF3QjtBQUNuQyxhQUFLLFFBQUwsQ0FBYyxLQUFkO0FBQ0EsYUFBSyxTQUFMLENBQWUsTUFBZjtBQUNILEtBSEQ7O0FBS0EsYUFBUyxTQUFULENBQW1CLENBQW5CLEVBQXNCO0FBQ2xCLGFBQUssV0FBTCxDQUFpQixFQUFFLEtBQUYsR0FBVSxXQUFXLENBQXRDLEVBQXlDLEVBQUUsS0FBRixHQUFVLFdBQVcsQ0FBOUQ7QUFDSDs7QUFFRCxhQUFTLGdCQUFULENBQTBCLENBQTFCLEVBQTZCO0FBQ3pCLGVBQU8sbUJBQVAsQ0FBMkIsV0FBM0IsRUFBd0MsU0FBeEM7QUFDQSxlQUFPLG1CQUFQLENBQTJCLFNBQTNCLEVBQXNDLGdCQUF0QztBQUNIOztBQUVELGFBQVMsY0FBVCxDQUF3QixDQUF4QixFQUEyQjtBQUN2QixhQUFLLFNBQUwsQ0FBZSxFQUFFLEtBQUYsR0FBVSxFQUFFLGdCQUFGLEVBQW9CLE1BQXBCLEdBQTZCLEdBQXREO0FBQ0g7O0FBRUQsYUFBUyxpQkFBVCxDQUEyQixDQUEzQixFQUE4QjtBQUMxQixlQUFPLG1CQUFQLENBQTJCLFdBQTNCLEVBQXdDLGNBQXhDO0FBQ0EsZUFBTyxtQkFBUCxDQUEyQixTQUEzQixFQUFzQyxpQkFBdEM7QUFDSDs7QUFFRCxhQUFTLG1CQUFULENBQTZCLENBQTdCLEVBQWdDO0FBQzVCLGVBQU8sZ0JBQVAsQ0FBd0IsV0FBeEIsRUFBcUMsY0FBckM7QUFDQSxlQUFPLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLGlCQUFuQztBQUNIOztBQUVELGFBQVMsbUJBQVQsR0FBK0I7QUFDM0IscUJBQWEsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBQWI7O0FBRUEsbUJBQVcsU0FBWCxHQUF1QixpQ0FBdkI7O0FBRUEsbUJBQVcsZ0JBQVgsQ0FBNEIsV0FBNUIsRUFBeUMsbUJBQXpDOztBQUVBLHlCQUFpQixXQUFqQixDQUE2QixVQUE3QjtBQUNIOztBQUVELGdCQUFZLElBQVosR0FBbUIsUUFBbkI7QUFDQSxnQkFBWSxTQUFaLEdBQXdCLE9BQXhCO0FBQ0EsZ0JBQVksU0FBWixHQUF3QixTQUF4Qjs7QUFFQSxxQkFBaUIsU0FBakIsR0FBNkIsK0NBQStDLFNBQTVFOztBQUVBLGdCQUFZLFNBQVosR0FBd0IsMkJBQXhCOztBQUVBLFFBQ0ksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsQ0FEaEI7O0FBR0EsY0FBVSxTQUFWLEdBQXNCLGFBQXRCO0FBQ0EsY0FBVSxXQUFWLENBQXNCLFNBQVMsY0FBVCxDQUF3QixLQUFLLEtBQTdCLENBQXRCOztBQUVBLGdCQUFZLFdBQVosQ0FBd0IsV0FBeEI7QUFDQSxnQkFBWSxXQUFaLENBQXdCLFNBQXhCOztBQUVBLGdCQUFZLFNBQVosR0FBd0IsMkJBQXhCOztBQUVBLHFCQUFpQixXQUFqQixDQUE2QixXQUE3QjtBQUNBLHFCQUFpQixXQUFqQixDQUE2QixXQUE3Qjs7QUFFQSxRQUFJLEtBQUssVUFBVCxFQUFxQjtBQUNqQjtBQUNIOztBQUVELGdCQUFZLGdCQUFaLENBQTZCLFdBQTdCLEVBQTBDLFVBQVMsQ0FBVCxFQUFZO0FBQ2xELFlBQUksRUFBRSxNQUFGLElBQVksQ0FBaEIsRUFBbUI7QUFBQztBQUNoQixnQkFBSSxFQUFFLE1BQUYsQ0FBUyxRQUFULElBQXFCLFFBQXpCLEVBQW1DO0FBQy9CLHFCQUFLLFNBQUwsQ0FBZSxrQkFBZixFQUFtQyxDQUFDLElBQUQsRUFBTyxLQUFQLENBQW5DO0FBQ0gsYUFGRCxNQUVPO0FBQ0gsdUJBQU8sZ0JBQVAsQ0FBd0IsV0FBeEIsRUFBcUMsU0FBckM7QUFDQSx1QkFBTyxnQkFBUCxDQUF3QixTQUF4QixFQUFtQyxnQkFBbkM7O0FBRUEsNkJBQWEsRUFBQyxHQUFHLEVBQUUsS0FBRixHQUFVLEVBQUUsZ0JBQUYsRUFBb0IsUUFBcEIsR0FBK0IsSUFBN0MsRUFBbUQsR0FBRyxFQUFFLEtBQUYsR0FBVSxFQUFFLGdCQUFGLEVBQW9CLFFBQXBCLEdBQStCLEdBQS9GLEVBQWI7QUFDSDtBQUNKO0FBQ0osS0FYRDtBQVlIOztBQUVELFVBQVUsU0FBVixHQUFzQixPQUFPLE1BQVAsQ0FBYyxhQUFhLFNBQTNCLENBQXRCO0FBQ0EsVUFBVSxTQUFWLENBQW9CLFdBQXBCLEdBQWtDLFlBQWxDOzs7Ozs7Ozs7a0JDNUh3QixnQjs7QUFUeEI7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFDQTs7Ozs7O0FBN0JBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBK0JlLFNBQVMsZ0JBQVQsQ0FBMEIsWUFBMUIsRUFBd0M7QUFDbkQsUUFDSSxXQUFXO0FBQ1AsY0FBTSw0QkFBa0IsWUFBbEIsQ0FEQztBQUVQLGNBQU0sNEJBQWtCLFlBQWxCLENBRkM7QUFHUCxnQkFBUSw4QkFBb0IsWUFBcEIsQ0FIRDtBQUlQLGVBQU8sNkJBQW1CLFlBQW5CLENBSkE7QUFLUCxlQUFPLDZCQUFtQixZQUFuQixDQUxBO0FBTVAsZ0JBQVEsOEJBQW9CLFlBQXBCLENBTkQ7QUFPUCxrQkFBVSwrQkFBcUIsWUFBckIsQ0FQSDtBQVFQLGtCQUFVLGdDQUFzQixZQUF0QjtBQVJILEtBRGY7QUFBQSxRQVlJLGdCQUFnQixFQVpwQjtBQUFBLFFBYUksZUFBZSxFQWJuQjtBQUFBLFFBZUksYUFBYSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FmakI7QUFBQSxRQWlCSSxPQUFPLElBakJYOztBQW1CQSxTQUFLLFFBQUwsR0FBZ0IsUUFBaEI7O0FBRUEsYUFBUyxXQUFULENBQXFCLE9BQXJCLEVBQThCLElBQTlCLEVBQW9DO0FBQ2hDLFlBQ0ksYUFBYSxRQUFRLFVBQVIsRUFEakI7O0FBR0EsWUFBSSxJQUFKLEVBQVU7QUFDTix1QkFBVyxXQUFYLENBQXVCLFVBQXZCO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsdUJBQVcsV0FBWCxDQUF1QixVQUF2QjtBQUNIO0FBQ0QsYUFBSyxTQUFMLENBQWUsa0JBQWYsRUFBbUMsQ0FBQyxRQUFRLElBQVQsRUFBZSxJQUFmLENBQW5DOztBQUVBO0FBQ0E7QUFDSDs7QUFFRCxTQUFLLGlCQUFMLEdBQXlCLFVBQVMsV0FBVCxFQUFzQixJQUF0QixFQUE0QjtBQUNqRCxZQUNJLFVBQVUsU0FBUyxXQUFULENBRGQ7O0FBR0EsWUFBSSxPQUFKLEVBQWE7QUFDVCx3QkFBWSxPQUFaLEVBQXFCLElBQXJCO0FBQ0g7QUFDSixLQVBEOztBQVNBLFNBQUssY0FBTCxHQUFzQixZQUFXO0FBQzdCLFlBQUksYUFBYSxNQUFiLElBQXVCLENBQTNCLEVBQThCO0FBQzFCLGNBQUUseUJBQUYsRUFBNkIsVUFBN0IsRUFBeUMsSUFBekMsQ0FBOEMsWUFBVztBQUNyRCxxQkFBSyxpQkFBTCxDQUF1QixLQUFLLFlBQUwsQ0FBa0Isa0JBQWxCLENBQXZCLEVBQThELEtBQTlEO0FBQ0EsNkJBQWEsSUFBYixDQUFrQixJQUFsQjtBQUNILGFBSEQ7QUFJSCxTQUxELE1BS087QUFDSCxpQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLGFBQWEsTUFBakMsRUFBeUMsR0FBekMsRUFBOEM7QUFDMUMsb0JBQ0ksUUFBUSxhQUFhLENBQWIsQ0FEWjs7QUFHQSxxQkFBSyxpQkFBTCxDQUF1QixNQUFNLFlBQU4sQ0FBbUIsa0JBQW5CLENBQXZCLEVBQStELElBQS9EO0FBQ0g7QUFDRCwyQkFBZSxFQUFmO0FBQ0g7QUFDSixLQWZEOztBQWlCQTs7O0FBR0EsU0FBSyxpQkFBTCxHQUF5QixZQUFXO0FBQ2hDLFlBQ0ksY0FBYyxFQUFFLFVBQUYsRUFBYyxPQUFkLENBQXNCLDRCQUF0QixFQUFvRCxLQUFwRCxFQURsQjtBQUFBLFlBRUksZUFBZSxFQUFFLFVBQUYsRUFBYyxPQUFkLENBQXNCLDRCQUF0QixFQUFvRCxNQUFwRCxFQUZuQjs7QUFJQSxhQUFLLElBQUksQ0FBVCxJQUFjLFFBQWQsRUFBd0I7QUFDcEIsZ0JBQUksVUFBVSxTQUFTLENBQVQsQ0FBZDs7QUFFQTtBQUNBLGdCQUFJLFFBQVEsSUFBUixLQUFpQixRQUFRLFFBQVIsS0FBcUIsQ0FBdEMsR0FBMEMsV0FBOUMsRUFBMkQ7QUFDdkQsd0JBQVEsV0FBUixDQUFvQixjQUFjLFFBQVEsUUFBUixFQUFsQyxFQUFzRCxRQUFRLElBQVIsRUFBdEQ7QUFDSDs7QUFFRCxnQkFBSSxRQUFRLElBQVIsS0FBaUIsUUFBUSxTQUFSLEtBQXNCLENBQXZDLEdBQTJDLFlBQS9DLEVBQTZEO0FBQ3pELHdCQUFRLFdBQVIsQ0FBb0IsUUFBUSxJQUFSLEVBQXBCLEVBQW9DLGVBQWUsUUFBUSxTQUFSLEVBQW5EO0FBQ0g7QUFDSjs7QUFFRDtBQUNBOztBQUVBO0FBQ0EsWUFDSSxlQUFlLGNBQWMsU0FBUyxJQUFULENBQWMsUUFBZCxFQUFkLEdBQXlDLFNBQVMsSUFBVCxDQUFjLFFBQWQsRUFBekMsR0FBb0UsU0FBUyxNQUFULENBQWdCLFFBQWhCLEVBQXBFLEdBQWlHLFNBQVMsS0FBVCxDQUFlLFFBQWYsRUFBakcsR0FBNkgsU0FBUyxLQUFULENBQWUsUUFBZixFQUE3SCxHQUF5SixFQUF6SixHQUE4SixDQURqTDs7QUFHQSxZQUFJLFNBQVMsUUFBVCxDQUFrQixJQUFsQixLQUEyQixTQUFTLFFBQVQsQ0FBa0IsUUFBbEIsRUFBM0IsSUFBNEQsU0FBUyxLQUFULENBQWUsSUFBZixLQUF3QixTQUFTLEtBQVQsQ0FBZSxRQUFmLEVBQXBGLElBQ0ksS0FBSyxHQUFMLENBQVMsU0FBUyxRQUFULENBQWtCLElBQWxCLEtBQTJCLFNBQVMsS0FBVCxDQUFlLElBQWYsRUFBcEMsSUFBNkQsRUFEckUsRUFDeUU7QUFDckUscUJBQVMsUUFBVCxDQUFrQixXQUFsQixDQUE4QixTQUFTLEtBQVQsQ0FBZSxJQUFmLEtBQXdCLFNBQVMsUUFBVCxDQUFrQixRQUFsQixFQUF4QixJQUF3RCxlQUFlLENBQWYsR0FBbUIsQ0FBM0UsQ0FBOUIsRUFBNkcsQ0FBN0c7QUFDSDs7QUFFRDtBQUNBLFlBQUksU0FBUyxNQUFULENBQWdCLElBQWhCLEtBQXlCLFNBQVMsTUFBVCxDQUFnQixTQUFoQixFQUF6QixHQUF1RCxZQUEzRCxFQUF5RTtBQUNyRSxxQkFBUyxNQUFULENBQWdCLFNBQWhCLENBQTBCLEtBQUssR0FBTCxDQUFTLGVBQWUsU0FBUyxNQUFULENBQWdCLElBQWhCLEVBQXhCLEVBQWdELEdBQWhELENBQTFCO0FBQ0g7QUFDSixLQWxDRDs7QUFvQ0E7OztBQUdBLFNBQUssZUFBTCxHQUF1QixZQUFXO0FBQzlCLFlBQ0ksY0FBYyxFQUFFLFVBQUYsRUFBYyxPQUFkLENBQXNCLDRCQUF0QixFQUFvRCxLQUFwRCxFQURsQjtBQUFBLFlBRUksZUFBZSxFQUFFLFVBQUYsRUFBYyxPQUFkLENBQXNCLDRCQUF0QixFQUFvRCxNQUFwRCxFQUZuQjtBQUFBLFlBSUksbUJBQW1CLGNBQWMsU0FBUyxJQUFULENBQWMsUUFBZCxFQUFkLEdBQXlDLFNBQVMsSUFBVCxDQUFjLFFBQWQsRUFBekMsR0FBb0UsU0FBUyxNQUFULENBQWdCLFFBQWhCLEVBQXBFLEdBQWlHLFNBQVMsS0FBVCxDQUFlLFFBQWYsRUFBakcsR0FBNkgsU0FBUyxLQUFULENBQWUsUUFBZixFQUE3SCxHQUF5SixFQUF6SixHQUE4SixDQUpyTDs7QUFNQSxpQkFBUyxLQUFULENBQWUsV0FBZixDQUEyQixjQUFjLFNBQVMsS0FBVCxDQUFlLFFBQWYsRUFBZCxHQUEwQyxFQUFyRSxFQUF5RSxDQUF6RTs7QUFFQSxZQUNJLGdCQUFnQixTQUFTLEtBQVQsQ0FBZSxJQUFmLEtBQXdCLFNBQVMsS0FBVCxDQUFlLFNBQWYsRUFENUM7O0FBR0EsaUJBQVMsTUFBVCxDQUFnQixXQUFoQixDQUE0QixTQUFTLEtBQVQsQ0FBZSxJQUFmLEVBQTVCLEVBQW1ELGVBQWUsYUFBZixHQUErQixHQUEvQixHQUFxQyxnQkFBZ0IsQ0FBckQsR0FBeUQsYUFBNUc7QUFDQSxpQkFBUyxNQUFULENBQWdCLE9BQWhCLENBQXdCLFNBQVMsS0FBVCxDQUFlLFFBQWYsRUFBeEIsRUFBbUQsZUFBZSxTQUFTLE1BQVQsQ0FBZ0IsSUFBaEIsRUFBbEU7O0FBRUEsaUJBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsQ0FBMUIsRUFBNkIsQ0FBN0I7O0FBRUEsaUJBQVMsSUFBVCxDQUFjLFdBQWQsQ0FBMEIsU0FBUyxJQUFULENBQWMsSUFBZCxLQUF1QixTQUFTLElBQVQsQ0FBYyxRQUFkLEVBQXZCLElBQW1ELG1CQUFtQixDQUFuQixHQUF1QixDQUExRSxDQUExQixFQUF3RyxDQUF4Rzs7QUFFQSxZQUFJLGdCQUFKLEVBQXNCO0FBQ2xCLHFCQUFTLE1BQVQsQ0FBZ0IsV0FBaEIsQ0FBNEIsU0FBUyxJQUFULENBQWMsSUFBZCxLQUF1QixTQUFTLElBQVQsQ0FBYyxRQUFkLEVBQXZCLElBQW1ELG1CQUFtQixDQUFuQixHQUF1QixDQUExRSxDQUE1QixFQUEwRyxDQUExRztBQUNILFNBRkQsTUFFTztBQUNILHFCQUFTLE1BQVQsQ0FBZ0IsV0FBaEIsQ0FBNEIsU0FBUyxJQUFULENBQWMsSUFBZCxFQUE1QixFQUFrRCxTQUFTLElBQVQsQ0FBYyxJQUFkLEtBQXVCLFNBQVMsSUFBVCxDQUFjLFNBQWQsRUFBdkIsR0FBbUQsQ0FBckc7QUFDSDs7QUFFRCxpQkFBUyxRQUFULENBQWtCLFdBQWxCLENBQThCLFNBQVMsS0FBVCxDQUFlLElBQWYsS0FBd0IsU0FBUyxRQUFULENBQWtCLFFBQWxCLEVBQXhCLElBQXdELG1CQUFtQixDQUFuQixHQUF1QixDQUEvRSxDQUE5QixFQUFpSCxDQUFqSDs7QUFFQSxpQkFBUyxRQUFULENBQWtCLFFBQWxCLENBQTJCLEtBQUssR0FBTCxDQUFTLFNBQVMsTUFBVCxDQUFnQixJQUFoQixLQUF5QixTQUFTLFFBQVQsQ0FBa0IsSUFBbEIsRUFBbEMsRUFBNEQsR0FBNUQsQ0FBM0I7QUFDQSxpQkFBUyxRQUFULENBQWtCLFdBQWxCLENBQThCLFNBQVMsS0FBVCxDQUFlLElBQWYsS0FBd0IsU0FBUyxLQUFULENBQWUsUUFBZixFQUF4QixHQUFvRCxDQUFsRixFQUFxRixlQUFlLFNBQVMsUUFBVCxDQUFrQixTQUFsQixFQUFwRzs7QUFFQSxpQkFBUyxLQUFULENBQWUsV0FBZixDQUEyQixDQUEzQixFQUE4QixLQUFLLEdBQUwsQ0FBUyxTQUFTLElBQVQsQ0FBYyxJQUFkLEtBQXVCLFNBQVMsSUFBVCxDQUFjLFNBQWQsRUFBaEMsRUFBMkQsZUFBZSxTQUFTLEtBQVQsQ0FBZSxTQUFmLEVBQTFFLENBQTlCO0FBQ0gsS0EvQkQ7O0FBaUNBLFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLGVBQU8sVUFBUDtBQUNILEtBRkQ7O0FBSUEsZUFBVyxTQUFYLEdBQXVCLHVCQUF2Qjs7QUFFQSxTQUFLLElBQUksV0FBVCxJQUF3QixRQUF4QixFQUFrQztBQUM5QixZQUNJLFVBQVUsU0FBUyxXQUFULENBRGQ7QUFBQSxZQUVJLGFBQWEsUUFBUSxVQUFSLEVBRmpCOztBQUlBLGdCQUFRLEVBQVIsQ0FBVyxrQkFBWCxFQUErQixZQUFXO0FBQ3RDLHdCQUFZLElBQVosRUFBa0IsS0FBbEI7QUFDSCxTQUZEOztBQUlBLG1CQUFXLFlBQVgsQ0FBd0Isa0JBQXhCLEVBQTRDLFdBQTVDO0FBQ0Esc0JBQWMsSUFBZCxDQUFtQixVQUFuQjtBQUNIOztBQUVELFNBQUssSUFBSSxXQUFULElBQXdCLFFBQXhCLEVBQWtDO0FBQzlCLFlBQ0ksYUFBYSxTQUFTLFdBQVQsRUFBc0IsVUFBdEIsRUFEakI7O0FBR0EsbUJBQVcsV0FBWCxDQUF1QixVQUF2QjtBQUNIO0FBQ0o7O0FBRUQsaUJBQWlCLFNBQWpCLEdBQTZCLE9BQU8sTUFBUCxDQUFjLGFBQWEsU0FBM0IsQ0FBN0I7QUFDQSxpQkFBaUIsU0FBakIsQ0FBMkIsV0FBM0IsR0FBeUMsZ0JBQXpDOzs7Ozs7Ozs7a0JDNUt3QixXO0FBekJ4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTs7O0FBR2UsU0FBUyxXQUFULENBQXFCLFFBQXJCLEVBQStCO0FBQzFDLFFBQ0ksTUFBTSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FEVjtBQUFBLFFBRUksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FGYjtBQUFBLFFBR0ksY0FBYyxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FIbEI7QUFBQSxRQUtJLE1BQU0sQ0FMVjtBQUFBLFFBS2EsTUFBTSxDQUxuQjtBQUFBLFFBS3NCLFNBQVMsQ0FML0I7QUFBQSxRQUtrQyxlQUFlLENBTGpEO0FBQUEsUUFPSSxpQkFBaUIsRUFQckI7QUFBQSxRQU95QixnQkFBZ0IsQ0FQekM7QUFBQSxRQVNJLG1CQUFtQixLQVR2QjtBQUFBLFFBV0ksYUFBYSxDQVhqQjtBQUFBLFFBYUksY0FiSjtBQUFBLFFBZUksT0FBTyxJQWZYOztBQWlCQSxhQUFTLFNBQVQsR0FBcUI7QUFDakIsWUFDSSxnQkFBZ0IsV0FBVyxFQUFFLEdBQUYsRUFBTyxNQUFQLEVBQVgsR0FBNkIsRUFBRSxHQUFGLEVBQU8sS0FBUCxFQURqRDs7QUFHSTs7O0FBR0oscUJBQWEsZ0JBQWdCLE1BQU0sR0FBdEIsSUFBNkIsYUFBMUM7O0FBRUEsWUFDSSxlQUFlLENBQUMsU0FBUyxHQUFWLEtBQWtCLE1BQU0sR0FBeEIsS0FBZ0MsZ0JBQWdCLFVBQWhELENBRG5COztBQUdBLG9CQUFZLEtBQVosQ0FBa0IsV0FBVyxRQUFYLEdBQXNCLE9BQXhDLElBQW1ELGFBQWEsSUFBaEU7QUFDQSxlQUFPLEtBQVAsQ0FBYSxXQUFXLFFBQVgsR0FBc0IsT0FBbkMsSUFBOEMsYUFBYSxJQUEzRDs7QUFFQSxlQUFPLEtBQVAsQ0FBYSxXQUFXLEtBQVgsR0FBbUIsTUFBaEMsSUFBMEMsZUFBZSxJQUF6RDtBQUNIOztBQUVELFNBQUssU0FBTCxHQUFpQixVQUFTLE9BQVQsRUFBa0IsYUFBbEIsRUFBaUMsSUFBakMsRUFBdUMsSUFBdkMsRUFBNkM7QUFDMUQsaUJBQVMsT0FBVDtBQUNBLHVCQUFlLGFBQWY7QUFDQSxjQUFNLElBQU47QUFDQSxjQUFNLElBQU47O0FBRUE7QUFDSCxLQVBEOztBQVNBLFNBQUssaUJBQUwsR0FBeUIsVUFBUyxTQUFULEVBQW9CO0FBQ3pDLHlCQUFpQixTQUFqQjtBQUNILEtBRkQ7O0FBSUEsU0FBSyxnQkFBTCxHQUF3QixVQUFTLFNBQVQsRUFBb0I7QUFDeEMsd0JBQWdCLFNBQWhCO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLFVBQUwsR0FBa0IsWUFBVztBQUN6QixlQUFPLEdBQVA7QUFDSCxLQUZEOztBQUlBLFNBQUssbUJBQUwsR0FBMkIsWUFBVztBQUNsQyxlQUFPLGdCQUFQO0FBQ0gsS0FGRDs7QUFJQSxhQUFTLFVBQVQsQ0FBb0IsQ0FBcEIsRUFBdUI7QUFDbkIsWUFBSSxRQUFRLEdBQVosRUFBaUI7QUFDYixnQkFDSSxXQUFXLFdBQVcsRUFBRSxLQUFGLEdBQVUsRUFBRSxHQUFGLEVBQU8sTUFBUCxHQUFnQixHQUFyQyxHQUEyQyxFQUFFLEtBQUYsR0FBVSxFQUFFLEdBQUYsRUFBTyxNQUFQLEdBQWdCLElBRHBGO0FBQUEsZ0JBRUksU0FBUyxTQUFTLE9BQU8sS0FBUCxDQUFhLFdBQVcsS0FBWCxHQUFtQixNQUFoQyxDQUFULEVBQWtELEVBQWxELENBRmI7O0FBSUEsZ0JBQUksV0FBVyxNQUFmLEVBQXVCO0FBQ25CLDBCQUFVLGNBQVY7QUFDSCxhQUZELE1BRU87QUFDSCwwQkFBVSxjQUFWO0FBQ0g7O0FBRUQsaUJBQUssU0FBTCxDQUFlLGNBQWYsRUFBK0IsQ0FBQyxNQUFELENBQS9CO0FBQ0E7QUFDSDtBQUNKOztBQUVELGFBQVMsYUFBVCxDQUF1QixDQUF2QixFQUEwQjtBQUN0QixVQUFFLGVBQUY7QUFDQSx5QkFBaUIsV0FBVyxFQUFFLEtBQUYsR0FBVSxFQUFFLEdBQUYsRUFBTyxNQUFQLEdBQWdCLEdBQXJDLEdBQTJDLEVBQUUsS0FBRixHQUFVLEVBQUUsR0FBRixFQUFPLE1BQVAsR0FBZ0IsSUFBdEY7O0FBRUEsVUFBRSxNQUFGLEVBQVUsUUFBVixDQUFtQixVQUFuQjtBQUNBLGVBQU8sZ0JBQVAsQ0FBd0IsU0FBeEIsRUFBbUMsZUFBbkM7QUFDQSxlQUFPLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLFlBQXJDO0FBQ0g7O0FBRUQsYUFBUyxhQUFULENBQXVCLENBQXZCLEVBQTBCO0FBQ3RCLFVBQUUsZUFBRjtBQUNIOztBQUVELGFBQVMsWUFBVCxDQUFzQixDQUF0QixFQUF5QjtBQUNyQiwyQkFBbUIsSUFBbkI7O0FBRUEsWUFDSSxnQkFBZ0IsV0FBVyxFQUFFLEdBQUYsRUFBTyxNQUFQLEVBQVgsR0FBNkIsRUFBRSxHQUFGLEVBQU8sS0FBUCxFQURqRDtBQUFBLFlBRUksY0FBYyxXQUFXLEVBQUUsS0FBRixHQUFVLEVBQUUsR0FBRixFQUFPLE1BQVAsR0FBZ0IsR0FBckMsR0FBMkMsRUFBRSxLQUFGLEdBQVUsRUFBRSxHQUFGLEVBQU8sTUFBUCxHQUFnQixJQUZ2Rjs7QUFJQSxpQkFBUyxTQUFTLENBQUMsY0FBYyxjQUFmLEtBQWtDLE1BQU0sR0FBeEMsS0FBZ0QsZ0JBQWdCLFVBQWhFLENBQWxCOztBQUVBLGlCQUFTLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBTCxDQUFTLE1BQVQsRUFBaUIsR0FBakIsQ0FBVCxFQUFnQyxHQUFoQyxDQUFUOztBQUVBLHlCQUFpQixXQUFqQjs7QUFFQSxhQUFLLFNBQUwsQ0FBZSxjQUFmLEVBQStCLENBQUMsTUFBRCxDQUEvQjtBQUNBOztBQUVBLDJCQUFtQixLQUFuQjtBQUNIOztBQUVELGFBQVMsZUFBVCxDQUF5QixDQUF6QixFQUE0QjtBQUN4QixVQUFFLGVBQUY7QUFDQSxVQUFFLE1BQUYsRUFBVSxXQUFWLENBQXNCLFVBQXRCO0FBQ0EsZUFBTyxtQkFBUCxDQUEyQixTQUEzQixFQUFzQyxlQUF0QztBQUNBLGVBQU8sbUJBQVAsQ0FBMkIsV0FBM0IsRUFBd0MsWUFBeEM7QUFDSDs7QUFFRCxRQUFJLFNBQUosR0FBZ0IsNkJBQThCLFdBQVcsaUNBQVgsR0FBK0MsbUNBQTdFLENBQWhCO0FBQ0EsV0FBTyxTQUFQLEdBQW1CLCtCQUFuQjtBQUNBLGdCQUFZLFNBQVosR0FBd0IscUNBQXhCOztBQUVBLFdBQU8sV0FBUCxDQUFtQixXQUFuQjtBQUNBLFFBQUksV0FBSixDQUFnQixNQUFoQjs7QUFFQSxXQUFPLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLGFBQXJDO0FBQ0EsV0FBTyxnQkFBUCxDQUF3QixPQUF4QixFQUFpQyxhQUFqQzs7QUFFQSxRQUFJLGdCQUFKLENBQXFCLE9BQXJCLEVBQThCLFVBQTlCO0FBQ0g7O0FBRUQsWUFBWSxTQUFaLEdBQXdCLE9BQU8sTUFBUCxDQUFjLGFBQWEsU0FBM0IsQ0FBeEI7QUFDQSxZQUFZLFNBQVosQ0FBc0IsV0FBdEIsR0FBb0MsV0FBcEM7Ozs7Ozs7OztrQkN0SXdCLFk7QUF0QnhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JlLFNBQVMsWUFBVCxDQUFzQixVQUF0QixFQUFrQyxNQUFsQyxFQUEwQyxhQUExQyxFQUF5RDtBQUNwRSxRQUNJLFNBQ0ksb2dKQUZSO0FBQUEsUUFvRUksc0JBQXNCLEVBQUUsdUNBQUYsRUFBMkMsTUFBM0MsQ0FwRTFCO0FBQUEsUUFxRUksZ0JBQWdCLEVBQUUsb0NBQUYsRUFBd0MsTUFBeEMsQ0FyRXBCO0FBQUEsUUFzRUksZUFBZSxFQUFFLGVBQUYsRUFBbUIsTUFBbkIsQ0F0RW5CO0FBQUEsUUF3RUksT0FBTyxJQXhFWDs7QUEwRUEsa0JBQWMsRUFBZCxDQUFpQixnQkFBakIsRUFBbUMsVUFBUyxRQUFULEVBQW1CLE9BQW5CLEVBQTRCO0FBQzNELG9CQUFZLEdBQVo7O0FBRUEsNEJBQW9CLElBQXBCLENBQXlCLE9BQXpCOztBQUVBLFVBQUUsWUFBRixFQUNLLElBREwsQ0FDVSxlQURWLEVBQzJCLFFBRDNCLEVBRUssR0FGTCxDQUVTLE9BRlQsRUFFa0IsV0FBVyxHQUY3QjtBQUdILEtBUkQ7O0FBVUEsa0JBQWMsRUFBZCxDQUFpQixnQkFBakIsRUFBbUMsWUFBVztBQUMxQyxVQUFFLHFDQUFGLEVBQXlDLE1BQXpDLEVBQWlELElBQWpEOztBQUVBLFlBQUksV0FBVyxpQkFBWCxDQUE2QixZQUE3QixDQUFKLEVBQWdEO0FBQzVDLGdCQUFJLFdBQVcsaUJBQVgsQ0FBNkIsUUFBN0IsQ0FBSixFQUE0QztBQUN4QyxrQkFBRSw0REFBRixFQUFnRSxNQUFoRSxFQUF3RSxJQUF4RTtBQUNILGFBRkQsTUFFTztBQUNILGtCQUFFLHFEQUFGLEVBQXlELE1BQXpELEVBQWlFLElBQWpFO0FBQ0g7QUFDSixTQU5ELE1BTU87QUFDSCxjQUFFLCtDQUFGLEVBQW1ELE1BQW5ELEVBQTJELElBQTNEO0FBQ0g7QUFDSixLQVpEOztBQWNBLGtCQUFjLEVBQWQsQ0FBaUIsZUFBakIsRUFBa0MsVUFBUyxhQUFULEVBQXdCO0FBQ3RELHFCQUFhLFFBQWIsQ0FBc0IscUJBQXRCOztBQUVBLFlBQ0ksZUFBZSxpRUFEbkI7O0FBR0EsWUFBSSxhQUFKLEVBQW1CO0FBQ2YsNEJBQWdCLGNBQWMsT0FBZCxDQUFzQixnQkFBdEIsRUFBd0MsRUFBeEMsQ0FBaEI7O0FBRUEsZ0JBQUksY0FBYyxNQUFkLEdBQXVCLENBQTNCLEVBQThCO0FBQzFCLGdDQUFnQixpREFBaEI7O0FBRUEsOEJBQ0ssSUFETCxDQUNVLGFBRFYsRUFFSyxJQUZMO0FBR0g7O0FBRUQsZ0NBQW9CLElBQXBCLENBQXlCLFlBQXpCO0FBQ0g7QUFFSixLQXBCRDs7QUFzQkEsTUFBRSw0QkFBRixFQUFnQyxNQUFoQyxFQUF3QyxLQUF4QyxDQUE4QyxZQUFXO0FBQ3JELG1CQUFXLGVBQVgsQ0FBMkIsRUFBQyxRQUFRLFFBQVQsRUFBM0I7QUFDSCxLQUZEOztBQUlBLE1BQUUsb0JBQUYsRUFBd0IsTUFBeEIsRUFDSyxNQURMLENBQ1ksV0FBVyxpQkFBWCxDQUE2QixRQUE3QixDQURaLEVBRUssS0FGTCxDQUVXLFlBQVc7QUFDZCxjQUFNLHVHQUNBLDBDQUROO0FBRUEsbUJBQVcsZUFBWCxDQUEyQixFQUFDLFFBQVEsUUFBVCxFQUEzQjtBQUNILEtBTkw7O0FBUUEsTUFBRSwyQkFBRixFQUErQixNQUEvQixFQUF1QyxLQUF2QyxDQUE2QyxZQUFXO0FBQ3BELHNCQUFjLE1BQWQ7QUFDSCxLQUZEOztBQUlBO0FBQ0EsV0FBTyxFQUFQLENBQVUsaUJBQVYsRUFBNkIsVUFBUyxDQUFULEVBQVk7QUFDckMsZUFBTyxNQUFQO0FBQ0gsS0FGRDs7QUFJQSxXQUFPLEtBQVAsQ0FBYTtBQUNULGNBQU07QUFERyxLQUFiOztBQUlBLFdBQU8sRUFBUCxDQUFVLGdCQUFWLEVBQTRCLFlBQVc7QUFDbkMsYUFBSyxTQUFMLENBQWUsT0FBZjtBQUNILEtBRkQ7O0FBSUE7QUFDQSxXQUFPLElBQVAsQ0FBWSxVQUFaLEVBQXdCLEtBQXhCLEdBQWdDLEVBQUUsTUFBRixDQUFoQzs7QUFFQSxXQUFPLFdBQVAsQ0FBbUIsT0FBTyxDQUFQLENBQW5COztBQUVBLFNBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsZUFBTyxLQUFQLENBQWEsTUFBYjtBQUNILEtBRkQ7QUFHSDs7QUFFRCxhQUFhLFNBQWIsR0FBeUIsT0FBTyxNQUFQLENBQWMsYUFBYSxTQUEzQixDQUF6QjtBQUNBLGFBQWEsU0FBYixDQUF1QixVQUF2QixHQUFvQyxZQUFwQzs7Ozs7Ozs7O2tCQ2pLd0IsaUI7QUF0QnhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JlLFNBQVMsaUJBQVQsQ0FBMkIsTUFBM0IsRUFBbUM7QUFDOUMsUUFDSSxTQUNJLDBoVEFGUjs7QUE0SUE7QUFDQSxXQUFPLEVBQVAsQ0FBVSxpQkFBVixFQUE2QixVQUFTLENBQVQsRUFBWTtBQUNyQyxlQUFPLE1BQVA7QUFDSCxLQUZEOztBQUlBLFdBQU8sS0FBUCxDQUFhO0FBQ1QsY0FBTTtBQURHLEtBQWI7O0FBSUE7QUFDQSxXQUFPLElBQVAsQ0FBWSxVQUFaLEVBQXdCLEtBQXhCLEdBQWdDLEVBQUUsTUFBRixDQUFoQzs7QUFFQSxXQUFPLFdBQVAsQ0FBbUIsT0FBTyxDQUFQLENBQW5COztBQUVBLFNBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsZUFBTyxLQUFQLENBQWEsTUFBYjtBQUNILEtBRkQ7QUFHSDs7Ozs7Ozs7O2tCQzNKdUIsUTtBQXpCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkE7OztBQUdlLFNBQVMsUUFBVCxDQUFrQixRQUFsQixFQUE0QixRQUE1QixFQUFzQyxVQUF0QyxFQUFrRCxPQUFsRCxFQUEyRDtBQUN0RSxRQUNJLHFCQUFxQixDQUR6QjtBQUFBLFFBRUksa0JBQWtCLEdBRnRCOztBQUlBLFFBQ0ksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FEYjtBQUFBLFFBRUksZ0JBQWdCLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQUZwQjtBQUFBLFFBSUksYUFBYSxXQUFXLFFBSjVCO0FBQUEsUUFNSSxhQUFhLEtBTmpCO0FBQUEsUUFNd0IsY0FBYyxLQU50QztBQUFBLFFBT0ksWUFQSjtBQUFBLFFBU0ksbUJBQW1CLEtBVHZCO0FBQUEsUUFXSSxPQUFPLElBWFg7O0FBYUEsU0FBSyxLQUFMLEdBQWEsU0FBYjs7QUFFQTs7Ozs7OztBQU9BLFNBQUssS0FBTCxHQUFhLEVBQWI7O0FBRUEsaUJBQWEsY0FBYyxLQUEzQjs7QUFFQSxhQUFTLEtBQVQsR0FBaUI7QUFDYixZQUNJLFFBQVEsT0FBTyxLQURuQjtBQUFBLFlBRUksU0FBUyxPQUFPLE1BRnBCO0FBQUEsWUFHSSxRQUFRLE9BQU8sS0FBSyxLQUFaLEtBQXNCLFFBQXRCLEdBQWlDLEtBQUssS0FBdEMsR0FBOEMsS0FBSyxLQUFMLENBQVcsS0FBSyxLQUFoQixDQUgxRDtBQUFBLFlBSUksUUFBUSxJQUFJLE9BQU8sZ0JBSnZCO0FBQUEsWUFLSSxRQUFRLE9BQU8sTUFBUCxHQUFnQixJQUw1Qjs7QUFPQSxZQUFJLFVBQUosRUFBZ0I7QUFDWiwwQkFBYyxJQUFkOztBQUVBLDBCQUFjLFNBQWQsR0FBMEIsT0FBMUI7O0FBRUEsMEJBQWMsUUFBZCxDQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixLQUE3QixFQUFvQyxNQUFwQzs7QUFFQSwwQkFBYyxTQUFkLEdBQTBCLE9BQTFCOztBQUVBLDBCQUFjLFFBQWQsQ0FBdUIsS0FBdkIsRUFBOEIsS0FBOUIsRUFBcUMsS0FBckM7QUFDQSwwQkFBYyxTQUFkOztBQUVBLGdCQUFJLEtBQUssS0FBTCxJQUFjLGFBQWEsQ0FBL0IsRUFBa0M7QUFDOUIsOEJBQWMsSUFBZCxDQUFtQixRQUFRLENBQTNCLEVBQThCLENBQTlCLEVBQWlDLENBQUMsS0FBSyxLQUFMLEdBQWEsYUFBYSxDQUEzQixJQUFnQyxLQUFoQyxHQUF3QyxVQUF6RSxFQUFxRixNQUFyRjtBQUNILGFBRkQsTUFFTztBQUNILDhCQUFjLElBQWQsQ0FBbUIsS0FBSyxLQUFMLEdBQWEsS0FBYixHQUFxQixVQUF4QyxFQUFvRCxDQUFwRCxFQUF1RCxDQUFDLGFBQWEsQ0FBYixHQUFpQixLQUFLLEtBQXZCLElBQWdDLEtBQWhDLEdBQXdDLFVBQS9GLEVBQTJHLE1BQTNHO0FBQ0g7O0FBRUQsMEJBQWMsSUFBZDtBQUNBLDBCQUFjLElBQWQ7O0FBRUEsMEJBQWMsU0FBZCxHQUEwQixPQUExQjtBQUNBLDBCQUFjLFFBQWQsQ0FBdUIsS0FBdkIsRUFBOEIsS0FBOUIsRUFBcUMsS0FBckM7O0FBRUEsMEJBQWMsT0FBZDtBQUNILFNBekJELE1BeUJPO0FBQ0gsZ0JBQ0ksVUFBVSxDQUFDLEtBQUssS0FBTCxHQUFhLFFBQWQsSUFBMEIsVUFEeEM7QUFBQSxnQkFFSSxRQUZKOztBQUlBLGdCQUFJLE9BQUosRUFBYTtBQUNULDBCQUFVLEtBQUssR0FBTCxDQUFTLE9BQVQsRUFBa0IsSUFBSSxlQUF0QixDQUFWO0FBQ0g7O0FBRUQsdUJBQVcsVUFBVSxLQUFyQjs7QUFFQSwwQkFBYyxJQUFkO0FBQ0EsMEJBQWMsSUFBZDs7QUFFQSwwQkFBYyxTQUFkLEdBQTBCLE9BQTFCOztBQUVBLDBCQUFjLFNBQWQ7QUFDQSwwQkFBYyxJQUFkLENBQW1CLENBQW5CLEVBQXNCLENBQXRCLEVBQXlCLFFBQXpCLEVBQW1DLE1BQW5DO0FBQ0EsMEJBQWMsSUFBZDs7QUFFQSwwQkFBYyxJQUFkOztBQUVBLDBCQUFjLFNBQWQsR0FBMEIsT0FBMUI7QUFDQSwwQkFBYyxRQUFkLENBQXVCLEtBQXZCLEVBQThCLEtBQTlCLEVBQXFDLEtBQXJDOztBQUVBO0FBQ0EsMEJBQWMsT0FBZDs7QUFFQSwwQkFBYyxTQUFkLEdBQTBCLE9BQTFCOztBQUVBLDBCQUFjLFNBQWQ7QUFDQSwwQkFBYyxJQUFkLENBQW1CLFFBQW5CLEVBQTZCLENBQTdCLEVBQWdDLEtBQWhDLEVBQXVDLE1BQXZDO0FBQ0EsMEJBQWMsSUFBZDs7QUFFQSwwQkFBYyxJQUFkOztBQUVBLDBCQUFjLFNBQWQsR0FBMEIsT0FBMUI7QUFDQSwwQkFBYyxRQUFkLENBQXVCLEtBQXZCLEVBQThCLEtBQTlCLEVBQXFDLEtBQXJDOztBQUVBLDBCQUFjLE9BQWQ7QUFDSDtBQUNKOztBQUVELGFBQVMsV0FBVCxDQUFxQixDQUFyQixFQUF3QjtBQUNwQixZQUNJLFFBQVEsRUFBRSxNQUFGLEVBQVUsS0FBVixFQURaO0FBQUEsWUFFSSxPQUFPLEVBQUUsTUFBRixFQUFVLE1BQVYsR0FBbUIsSUFGOUI7QUFBQSxZQUlJLGFBQWEsQ0FBQyxFQUFFLEtBQUYsR0FBVSxJQUFYLElBQW1CLEtBSnBDOztBQU1BLFlBQUksT0FBSixFQUFhO0FBQ1Q7QUFDQSx5QkFBYSxLQUFLLEdBQUwsQ0FBUyxLQUFLLEdBQUwsQ0FBUyxVQUFULEVBQXFCLEdBQXJCLENBQVQsRUFBb0MsZUFBcEMsQ0FBYjtBQUNIOztBQUVELGFBQUssUUFBTCxDQUFjLGFBQWEsVUFBYixHQUEwQixRQUF4QztBQUNIOztBQUVELGFBQVMsWUFBVCxDQUFzQixDQUF0QixFQUF5QjtBQUNyQixZQUFJLFVBQUosRUFBZ0I7QUFDWix3QkFBWSxDQUFaO0FBQ0gsU0FGRCxNQUVPLElBQUksV0FBSixFQUFpQjtBQUNwQixnQkFDSSxPQUFPLENBQUMsRUFBRSxLQUFGLEdBQVUsWUFBWCxJQUEyQixrQkFEdEM7O0FBR0EsZ0JBQUksUUFBUSxDQUFaLEVBQWU7QUFDWCxvQkFDSSxZQUFZLEtBQUssS0FBTCxHQUFhLElBRDdCO0FBQUEsb0JBRUksVUFBVSxZQUFZLENBRjFCOztBQUlBLHFCQUFLLFFBQUwsQ0FBYyxPQUFkOztBQUVBOzs7QUFHQSwrQkFBZSxFQUFFLEtBQUYsR0FBVSxDQUFDLFlBQVksT0FBYixJQUF3QixrQkFBakQ7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsYUFBUyxPQUFULENBQWlCLENBQWpCLEVBQW9CO0FBQ2hCLFlBQUksY0FBYyxFQUFFLE1BQUYsSUFBWSxDQUE5QixFQUFpQztBQUM3Qix5QkFBYSxLQUFiO0FBQ0gsU0FGRCxNQUVPLElBQUksZUFBZSxFQUFFLE1BQUYsSUFBWSxDQUEvQixFQUFrQztBQUNyQywwQkFBYyxLQUFkO0FBQ0gsU0FGTSxNQUVBO0FBQ0g7QUFDSDs7QUFFRCxlQUFPLHFCQUFQLENBQTZCLEVBQUUsU0FBL0I7QUFDQSxlQUFPLG1CQUFQLENBQTJCLFdBQTNCLEVBQXdDLE9BQXhDO0FBQ0EsZUFBTyxtQkFBUCxDQUEyQixhQUEzQixFQUEwQyxZQUExQztBQUNIOztBQUVELFNBQUssUUFBTCxHQUFnQixVQUFTLE1BQVQsRUFBaUI7QUFDN0IsaUJBQVMsQ0FBQyxDQUFDLEtBQUssR0FBTCxDQUFTLFFBQVQsRUFBbUIsS0FBSyxHQUFMLENBQVMsUUFBVCxFQUFtQixNQUFuQixDQUFuQixDQUFYOztBQUVBLFlBQUksS0FBSyxLQUFMLElBQWMsTUFBbEIsRUFBMEI7QUFDdEIsaUJBQUssS0FBTCxHQUFhLE1BQWI7O0FBRUE7QUFDQSxpQkFBSyxTQUFMLENBQWUsYUFBZixFQUE4QixDQUFDLEtBQUssS0FBTixDQUE5Qjs7QUFFQSxnQkFBSSxnQkFBSixFQUFzQjtBQUNsQjtBQUNILGFBRkQsTUFFTztBQUNIO0FBQ0EsbUNBQW1CLElBQW5CO0FBQ0EscUJBQUssTUFBTDtBQUNIO0FBQ0o7QUFDSixLQWpCRDs7QUFtQkE7OztBQUdBLFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLGVBQU8sTUFBUDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxNQUFMLEdBQWMsWUFBVztBQUNyQixlQUFPLEtBQVAsR0FBZSxFQUFFLE1BQUYsRUFBVSxLQUFWLE1BQXFCLEdBQXBDO0FBQ0EsZUFBTyxNQUFQLEdBQWdCLEVBQUUsTUFBRixFQUFVLE1BQVYsTUFBc0IsRUFBdEM7O0FBRUEsWUFBSSxPQUFPLGdCQUFQLEdBQTBCLENBQTlCLEVBQWlDO0FBQzdCO0FBQ0EsbUJBQU8sS0FBUCxDQUFhLE1BQWIsR0FBc0IsT0FBTyxNQUFQLEdBQWdCLElBQXRDOztBQUVBLG1CQUFPLEtBQVAsR0FBZSxPQUFPLEtBQVAsR0FBZSxPQUFPLGdCQUFyQztBQUNBLG1CQUFPLE1BQVAsR0FBZ0IsT0FBTyxNQUFQLEdBQWdCLE9BQU8sZ0JBQXZDO0FBQ0g7O0FBRUQsc0JBQWMsSUFBZCxHQUFzQixPQUFPLE1BQVAsR0FBZ0IsSUFBakIsR0FBeUIsZUFBOUM7O0FBRUE7QUFDSCxLQWZEOztBQWlCQSxXQUFPLGdCQUFQLENBQXdCLGFBQXhCLEVBQXVDLFVBQVMsQ0FBVCxFQUFZO0FBQy9DLFlBQ0ksV0FBVyxjQUFjLFdBRDdCOztBQUdBLFlBQUksQ0FBQyxRQUFMLEVBQWU7QUFDWCxtQkFBTyxpQkFBUCxDQUF5QixFQUFFLFNBQTNCOztBQUVBLG9CQUFRLEVBQUUsTUFBVjtBQUNJLHFCQUFLLENBQUw7QUFBUTtBQUNKLGlDQUFhLElBQWI7QUFDQSxnQ0FBWSxDQUFaO0FBQ0o7QUFDQSxxQkFBSyxDQUFMO0FBQVE7QUFDSixrQ0FBYyxJQUFkO0FBQ0EsbUNBQWUsRUFBRSxLQUFqQjtBQUNKO0FBQ0E7QUFDSTtBQVZSOztBQWFBLG1CQUFPLGdCQUFQLENBQXdCLFdBQXhCLEVBQXFDLE9BQXJDO0FBQ0EsbUJBQU8sZ0JBQVAsQ0FBd0IsYUFBeEIsRUFBdUMsWUFBdkM7QUFDSDtBQUNKLEtBdkJEOztBQXlCQSxXQUFPLGdCQUFQLENBQXdCLGFBQXhCLEVBQXVDLFVBQVMsQ0FBVCxFQUFZO0FBQy9DLFVBQUUsY0FBRjtBQUNILEtBRkQ7O0FBSUEsV0FBTyxZQUFQLENBQW9CLGNBQXBCLEVBQW9DLE1BQXBDOztBQUVBLFdBQU8sU0FBUCxHQUFtQixxQkFBbkI7O0FBRUEsUUFBSSxDQUFDLE9BQU8sZ0JBQVosRUFBOEI7QUFDMUI7QUFDQSxlQUFPLGdCQUFQLEdBQTBCLEdBQTFCO0FBQ0g7QUFDSjs7QUFFRCxTQUFTLFNBQVQsR0FBcUIsT0FBTyxNQUFQLENBQWMsYUFBYSxTQUEzQixDQUFyQjtBQUNBLFNBQVMsU0FBVCxDQUFtQixXQUFuQixHQUFpQyxRQUFqQzs7Ozs7Ozs7O2tCQzFRd0IsYztBQUFULFNBQVMsY0FBVCxDQUF3QixRQUF4QixFQUFrQyxNQUFsQyxFQUEwQyxhQUExQyxFQUF5RDtBQUNwRSxRQUNJLHNCQUFzQixHQUQxQjs7QUFHQSxRQUNJLFNBQVMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBRGI7QUFBQSxRQUVJLGdCQUFnQixPQUFPLFVBQVAsQ0FBa0IsSUFBbEIsQ0FGcEI7QUFBQSxRQUlJLE1BQU0sSUFBSSxLQUFKLEVBSlY7QUFBQSxRQUtJLE1BQU0sSUFBSSxLQUFKLEVBTFY7QUFBQSxRQU1JLFdBQVcsSUFBSSxLQUFKLEVBTmY7QUFBQSxRQU9JLE9BQU8sSUFBSSxLQUFKLEVBUFg7QUFBQSxRQVNJLFVBQVUsSUFBSSxLQUFKLEVBVGQ7QUFBQSxRQVVJLGFBQWEsSUFBSSxLQUFKLEVBVmpCO0FBQUEsUUFXSSxXQUFXLElBQUksS0FBSixFQVhmO0FBQUEsUUFhSSxTQUFTLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxRQUFYLEVBQXFCLElBQXJCLEVBQTJCLE9BQTNCLEVBQW9DLFVBQXBDLEVBQWdELFFBQWhELENBYmI7QUFBQSxRQWNJLGNBQWMsQ0FkbEI7QUFBQSxRQWdCSSxZQWhCSjtBQUFBLFFBZ0JrQixpQkFoQmxCO0FBQUEsUUFpQkksbUJBakJKO0FBQUEsUUFpQnlCLHdCQWpCekI7QUFBQSxRQW1CSSxXQUFXLEdBbkJmO0FBQUEsUUFvQkksVUFBVSxFQXBCZDtBQUFBLFFBc0JJLGFBQWEsRUF0QmpCOztBQXdCQSxRQUFJLFlBQVksZ0JBQWdCLFNBQWhDOztBQUVBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQTNCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLGVBQU8sQ0FBUCxFQUFVLE1BQVYsR0FBbUIsWUFBVztBQUMxQjs7QUFFQSxnQkFBSSxlQUFlLE9BQU8sTUFBMUIsRUFBa0M7QUFDOUI7QUFDSDtBQUNKLFNBTkQ7QUFPSDs7QUFFRCxRQUFJLEdBQUosR0FBVSxZQUFZLFNBQXRCO0FBQ0EsZUFBVyxHQUFYLEdBQWlCLFlBQVksZ0JBQTdCO0FBQ0EsUUFBSSxHQUFKLEdBQVUsWUFBWSxTQUF0QjtBQUNBLGFBQVMsR0FBVCxHQUFlLFlBQVksV0FBM0I7QUFDQSxZQUFRLEdBQVIsR0FBYyxZQUFZLGFBQTFCO0FBQ0EsYUFBUyxHQUFULEdBQWUsWUFBWSxjQUEzQjtBQUNBLFNBQUssR0FBTCxHQUFXLFlBQVksVUFBdkI7O0FBRUEsYUFBUyxzQkFBVCxDQUFnQyxRQUFoQyxFQUEwQyxTQUExQyxFQUFxRCxRQUFyRCxFQUErRDtBQUMzRCxZQUFJLENBQUMsaUJBQUwsRUFBd0I7QUFDcEIsZ0NBQW9CLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUFwQjs7QUFFQSw4QkFBa0IsS0FBbEIsR0FBMEIsUUFBMUI7QUFDQSw4QkFBa0IsTUFBbEIsR0FBMkIsU0FBM0I7O0FBRUEsdUNBQTJCLGtCQUFrQixVQUFsQixDQUE2QixJQUE3QixDQUEzQjtBQUNIOztBQUVEO0FBQ0EsaUNBQXlCLHdCQUF6QixHQUFvRCxNQUFwRDtBQUNBLGlDQUF5QixTQUF6QixDQUFtQyxRQUFuQyxFQUE2QyxDQUE3QyxFQUFnRCxDQUFoRDs7QUFFQTtBQUNBLGlDQUF5Qix3QkFBekIsR0FBb0QsV0FBcEQ7QUFDQSxpQ0FBeUIsU0FBekIsQ0FBbUMsUUFBbkMsRUFBNkMsQ0FBN0MsRUFBZ0QsS0FBSyxLQUFMLENBQVcsV0FBVyxtQkFBdEIsQ0FBaEQ7QUFDSDs7QUFFRCxhQUFTLGlCQUFULENBQTJCLFFBQTNCLEVBQXFDLFNBQXJDLEVBQWdELFFBQWhELEVBQTBEO0FBQ3RELFlBQUksQ0FBQyxZQUFMLEVBQW1CO0FBQ2YsMkJBQWUsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBQWY7O0FBRUEseUJBQWEsS0FBYixHQUFxQixRQUFyQjtBQUNBLHlCQUFhLE1BQWIsR0FBc0IsU0FBdEI7O0FBRUEsa0NBQXNCLGFBQWEsVUFBYixDQUF3QixJQUF4QixDQUF0QjtBQUNIOztBQUVELDRCQUFvQix3QkFBcEIsR0FBK0MsTUFBL0M7QUFDQSw0QkFBb0IsU0FBcEIsQ0FBOEIsR0FBOUIsRUFBbUMsQ0FBbkMsRUFBc0MsQ0FBdEM7O0FBRUEsK0JBQXVCLFFBQXZCLEVBQWlDLFNBQWpDLEVBQTRDLFFBQTVDOztBQUVBLDRCQUFvQix3QkFBcEIsR0FBK0MsYUFBL0M7QUFDQSw0QkFBb0IsU0FBcEIsQ0FBOEIsaUJBQTlCLEVBQWlELENBQWpELEVBQW9ELENBQXBEOztBQUVBLDRCQUFvQixTQUFwQixDQUE4QixHQUE5QixFQUFtQyxDQUFuQyxFQUFzQyxDQUF0Qzs7QUFFQSw0QkFBb0Isd0JBQXBCLEdBQStDLFFBQS9DO0FBQ0EsNEJBQW9CLFNBQXBCLENBQThCLFVBQTlCLEVBQTBDLENBQTFDLEVBQTZDLENBQTdDOztBQUVBLDRCQUFvQix3QkFBcEIsR0FBK0MsVUFBL0M7QUFDQSw0QkFBb0IsU0FBcEIsQ0FBOEIsT0FBOUIsRUFBdUMsQ0FBdkMsRUFBMEMsQ0FBMUM7O0FBRUEsZUFBTyxZQUFQO0FBQ0g7O0FBRUQsYUFBUyxPQUFULEdBQW1CO0FBQ2YsWUFDSSxVQUFVLE9BQU8sS0FBUCxHQUFlLENBRDdCO0FBQUEsWUFFSSxVQUFVLE9BQU8sTUFBUCxHQUFnQixDQUY5Qjs7QUFJQSxzQkFBYyxTQUFkLEdBQTBCLE9BQTFCO0FBQ0Esc0JBQWMsUUFBZCxDQUF1QixDQUF2QixFQUEwQixDQUExQixFQUE2QixPQUFPLEtBQXBDLEVBQTJDLE9BQU8sTUFBbEQ7O0FBRUEsWUFBSSxlQUFlLE9BQU8sTUFBMUIsRUFBa0M7QUFDOUIsZ0JBQ0ksV0FBVyxLQUFLLEtBRHBCO0FBQUEsZ0JBRUksWUFBWSxLQUFLLE1BRnJCO0FBQUEsZ0JBR0ksT0FBTyxLQUFLLEtBQUwsQ0FBVyxVQUFVLFdBQVcsQ0FBaEMsQ0FIWDtBQUFBLGdCQUlJLE1BQU0sS0FBSyxLQUFMLENBQVcsVUFBVSxZQUFZLENBQWpDLENBSlY7O0FBTUEsMEJBQWMsU0FBZCxDQUF3QixJQUF4QixFQUE4QixJQUE5QixFQUFvQyxHQUFwQzs7QUFFQSw4QkFBa0IsUUFBbEIsRUFBNEIsU0FBNUIsRUFBdUMsUUFBdkM7O0FBRUE7QUFDQSwwQkFBYyxXQUFkLEdBQTRCLElBQTVCO0FBQ0EsMEJBQWMsU0FBZCxDQUF3QixZQUF4QixFQUFzQyxJQUF0QyxFQUE0QyxHQUE1Qzs7QUFFQSwwQkFBYyxXQUFkLEdBQTRCLEdBQTVCOztBQUVBLDBCQUFjLFNBQWQsQ0FBd0IsUUFBeEIsRUFBa0MsSUFBbEMsRUFBd0MsR0FBeEM7O0FBRUEsc0JBQVUsS0FBSyxLQUFMLENBQVcsVUFBVSxZQUFZLENBQXRCLEdBQTBCLENBQXJDLENBQVY7QUFDSDs7QUFFRCxZQUFJLFdBQVcsRUFBZixFQUFtQjtBQUNmLDBCQUFjLFNBQWQsR0FBMEIsT0FBMUI7O0FBRUEsZ0JBQ0ksUUFBUSxRQUFRLEtBQVIsQ0FBYyxJQUFkLENBRFo7O0FBR0EsaUJBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxNQUFNLE1BQTFCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLG9CQUNJLE9BQU8sTUFBTSxDQUFOLENBRFg7QUFBQSxvQkFFSSxZQUFZLGNBQWMsV0FBZCxDQUEwQixJQUExQixFQUFnQyxLQUZoRDs7QUFJQSwyQkFBVyxhQUFhLENBQXhCOztBQUVBLDhCQUFjLFFBQWQsQ0FBdUIsSUFBdkIsRUFBNkIsVUFBVSxZQUFZLENBQW5ELEVBQXNELE9BQXREO0FBQ0g7QUFDSjtBQUNKOztBQUVELGFBQVMsTUFBVCxHQUFrQjtBQUNkO0FBQ0EsZUFBTyxLQUFQLEdBQWUsT0FBTyxXQUF0QjtBQUNBLGVBQU8sTUFBUCxHQUFnQixPQUFPLFlBQXZCOztBQUVBLHNCQUFjLElBQWQsR0FBcUIsYUFBYSxlQUFsQzs7QUFFQTtBQUNIOztBQUVELFdBQU8sRUFBUCxDQUFVLGlCQUFWLEVBQTZCLFVBQVMsU0FBVCxFQUFvQixRQUFwQixFQUE4QjtBQUN2RCxtQkFBVyxTQUFYO0FBQ0Esa0JBQVUsUUFBVjs7QUFFQTtBQUNILEtBTEQ7O0FBT0EsV0FBTyxFQUFQLENBQVUsZ0JBQVYsRUFBNEIsVUFBUyxRQUFULEVBQW1CO0FBQzNDLG1CQUFXLENBQVg7QUFDQSxrQkFBVSxRQUFWOztBQUVBO0FBQ0gsS0FMRDs7QUFPQSxXQUFPLEVBQVAsQ0FBVSxpQkFBVixFQUE2QixZQUFXO0FBQ3BDLGVBQU8sbUJBQVAsQ0FBMkIsUUFBM0IsRUFBcUMsTUFBckM7QUFDQSxpQkFBUyxXQUFULENBQXFCLE1BQXJCO0FBQ0gsS0FIRDs7QUFLQSxXQUFPLGdCQUFQLENBQXdCLFFBQXhCLEVBQWtDLE1BQWxDOztBQUVBLFdBQU8sU0FBUCxHQUFtQiw0QkFBbkI7O0FBRUEsYUFBUyxXQUFULENBQXFCLE1BQXJCOztBQUVBO0FBQ0g7Ozs7Ozs7OztrQkMxSnVCLGU7O0FBSnhCOzs7O0FBRUE7Ozs7OztBQXhCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQTBCZSxTQUFTLGVBQVQsQ0FBeUIsWUFBekIsRUFBdUM7QUFDbEQsd0JBQVUsSUFBVixDQUFlLElBQWYsRUFBcUIsWUFBckIsRUFBbUMsUUFBbkMsRUFBNkMsUUFBN0M7O0FBRUEsUUFDSSxPQUFPLElBRFg7QUFBQSxRQUdJLFVBQVUsQ0FDTjtBQUNJLG1CQUFXLDRCQURmO0FBRUksaUJBQVMsWUFGYjtBQUdJLGlCQUFTLFdBSGI7QUFJSSxrQkFBVTtBQUpkLEtBRE0sRUFPTjtBQUNJLG1CQUFXLHdCQURmO0FBRUksaUJBQVMsUUFGYjtBQUdJLGlCQUFTO0FBSGIsS0FQTSxFQVlOO0FBQ0ksbUJBQVcsMEJBRGY7QUFFSSxpQkFBUyxVQUZiO0FBR0ksaUJBQVM7QUFIYixLQVpNLENBSGQ7QUFBQSxRQXNCSSxPQUFPLEtBQUssY0FBTCxFQXRCWDs7QUF3QkEsYUFBUyxZQUFULEdBQXdCO0FBQ3BCLFlBQ0ksV0FBVyxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsQ0FEZjs7QUFHQSxpQkFBUyxTQUFULEdBQXFCLHlDQUFyQjs7QUFFQSxhQUFLLElBQUksQ0FBVCxJQUFjLE9BQWQsRUFBdUI7QUFDbkIsZ0JBQ0ksU0FBUyxRQUFRLENBQVIsQ0FEYjtBQUFBLGdCQUVJLGFBQWEsU0FBUyxhQUFULENBQXVCLElBQXZCLENBRmpCOztBQUlBLHVCQUFXLFNBQVgsR0FBdUIsaUNBQWlDLE9BQU8sU0FBL0Q7QUFDQSx1QkFBVyxZQUFYLENBQXdCLGtCQUF4QixFQUE0QyxDQUE1Qzs7QUFFQSxnQkFBSSxPQUFPLFFBQVgsRUFBcUI7QUFDakIsMkJBQVcsU0FBWCxHQUF1QixXQUFXLFNBQVgsR0FBdUIsV0FBOUM7QUFDSDs7QUFFRCxxQkFBUyxXQUFULENBQXFCLFVBQXJCO0FBQ0g7O0FBRUQsaUJBQVMsZ0JBQVQsQ0FBMEIsT0FBMUIsRUFBbUMsVUFBUyxDQUFULEVBQVk7QUFDM0MsZ0JBQUksRUFBRSxNQUFGLElBQVksRUFBRSxNQUFGLENBQVMsUUFBVCxJQUFxQixJQUFyQyxFQUEyQztBQUN2QyxvQkFDSSxTQUFTLFFBQVEsU0FBUyxFQUFFLE1BQUYsQ0FBUyxZQUFULENBQXNCLGtCQUF0QixDQUFULEVBQW9ELEVBQXBELENBQVIsQ0FEYjs7QUFHQSxrQkFBRSxJQUFGLEVBQVEsUUFBUixFQUFrQixXQUFsQixDQUE4QixVQUE5QjtBQUNBLGtCQUFFLEVBQUUsTUFBSixFQUFZLFFBQVosQ0FBcUIsVUFBckI7O0FBRUEsNkJBQWEsZUFBYixDQUE2QixFQUFDLFFBQVEsT0FBTyxPQUFoQixFQUE3QjtBQUNIO0FBQ0osU0FWRDs7QUFZQSxhQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSDs7QUFFRDs7QUFFQSxpQkFBYSxFQUFiLENBQWdCLFlBQWhCLEVBQThCLFVBQVMsSUFBVCxFQUFlLFFBQWYsRUFBeUI7QUFDbkQsVUFBRSw2QkFBRixFQUFpQyxJQUFqQyxFQUF1QyxXQUF2QyxDQUFtRCxVQUFuRCxFQUErRCxTQUFTLFVBQVQsSUFBdUIsc0JBQVksV0FBbEc7QUFDQSxVQUFFLHlCQUFGLEVBQTZCLElBQTdCLEVBQW1DLFdBQW5DLENBQStDLFVBQS9DLEVBQTJELFNBQVMsVUFBVCxJQUF1QixzQkFBWSxPQUE5RjtBQUNBLFVBQUUsMkJBQUYsRUFBK0IsSUFBL0IsRUFBcUMsV0FBckMsQ0FBaUQsVUFBakQsRUFBNkQsU0FBUyxVQUFULElBQXVCLHNCQUFZLFNBQWhHO0FBQ0gsS0FKRDtBQUtIOztBQUVELGdCQUFnQixTQUFoQixHQUE0QixPQUFPLE1BQVAsQ0FBYyxvQkFBVSxTQUF4QixDQUE1QjtBQUNBLGdCQUFnQixTQUFoQixDQUEwQixXQUExQixHQUF3QyxlQUF4Qzs7Ozs7Ozs7O2tCQ3BEd0IsaUI7O0FBekJ4Qjs7OztBQUVBOzs7O0FBQ0E7Ozs7OztBQUVBLFNBQVMsT0FBVCxDQUFpQixNQUFqQixFQUF5QixPQUF6QixFQUFrQyxHQUFsQyxFQUF1QztBQUNuQyxXQUFPLE9BQU8sTUFBUCxHQUFnQixHQUF2QixFQUE0QjtBQUN4QixpQkFBUyxVQUFVLE1BQW5CO0FBQ0g7QUFDRCxXQUFPLE1BQVA7QUFDSCxDLENBaENEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBa0NBLFNBQVMsWUFBVCxDQUFzQixDQUF0QixFQUF5QixZQUF6QixFQUF1QztBQUNuQyxRQUNJLFNBQVMsU0FBUyxhQUFULENBQXVCLFlBQXZCLENBRGI7O0FBR0EsV0FBTyxXQUFQLENBQW1CLENBQW5COztBQUVBLFdBQU8sTUFBUDtBQUNIOztBQUVELFNBQVMsaUJBQVQsR0FBNkI7QUFDekIsV0FBTyxPQUFPLElBQVAsSUFBZSxPQUFPLFVBQXRCLElBQW9DLE9BQU8sUUFBM0MsSUFBdUQsT0FBTyxJQUFyRTtBQUNIOztBQUVjLFNBQVMsaUJBQVQsQ0FBMkIsVUFBM0IsRUFBdUM7QUFDbEQsd0JBQVUsSUFBVixDQUFlLElBQWYsRUFBcUIsVUFBckIsRUFBaUMsVUFBakMsRUFBNkMsZ0JBQTdDOztBQUVBLFFBQ0ksY0FBYyxDQUFDLFFBQUQsRUFBVyxRQUFYLEVBQXFCLFFBQXJCLEVBQStCLFFBQS9CLEVBQXlDLFFBQXpDLEVBQW1ELFFBQW5ELENBRGxCO0FBQUEsUUFHSSxXQUFXLEtBSGY7QUFBQSxRQUlJLGNBQWMsU0FBUyxhQUFULENBQXVCLElBQXZCLENBSmxCO0FBQUEsUUFLSSxjQUFjLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUxsQjtBQUFBLFFBT0ksU0FQSjtBQUFBLFFBU0ksT0FBTyxJQVRYOztBQVdBLGFBQVMsYUFBVCxDQUF1QixLQUF2QixFQUE4QjtBQUMxQixZQUNJLFVBQVUsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRGQ7QUFBQSxZQUVJLGFBQWEsU0FBUyxhQUFULENBQXVCLEdBQXZCLENBRmpCO0FBQUEsWUFHSSxhQUFhLFNBQVMsYUFBVCxDQUF1QixJQUF2QixDQUhqQjtBQUFBLFlBS0ksWUFBWSxTQUFTLGFBQVQsQ0FBdUIsR0FBdkIsQ0FMaEI7QUFBQSxZQU1JLGtCQUFrQixTQUFTLGFBQVQsQ0FBdUIsR0FBdkIsQ0FOdEI7QUFBQSxZQVFJLE9BQU8sSUFSWDs7QUFVQSxhQUFLLFVBQUwsR0FBa0IsWUFBVztBQUN6QixtQkFBTyxPQUFQO0FBQ0gsU0FGRDs7QUFJQSxhQUFLLFFBQUwsR0FBZ0IsVUFBUyxLQUFULEVBQWdCO0FBQzVCLHVCQUFXLFlBQVgsQ0FBd0IsWUFBeEIsRUFBc0MsS0FBdEM7QUFDQSx1QkFBVyxLQUFYLENBQWlCLGVBQWpCLEdBQW1DLE1BQU0sUUFBUSxLQUFLLE9BQU8sS0FBUCxFQUFjLFFBQWQsQ0FBdUIsRUFBdkIsQ0FBYixFQUF5QyxHQUF6QyxFQUE4QyxDQUE5QyxDQUF6QztBQUNILFNBSEQ7O0FBS0EsYUFBSyxRQUFMLENBQWMsS0FBZDs7QUFFQSxtQkFBVyxJQUFYLEdBQWtCLEdBQWxCO0FBQ0EsbUJBQVcsU0FBWCxHQUF1QiwyQ0FBdkI7QUFDQSxtQkFBVyxZQUFYLENBQXdCLGFBQXhCLEVBQXVDLFVBQXZDOztBQUVBLGtCQUFVLElBQVYsR0FBaUIsR0FBakI7QUFDQSxrQkFBVSxTQUFWLEdBQXNCLFFBQXRCOztBQUVBLGtCQUFVLGdCQUFWLENBQTJCLE9BQTNCLEVBQW9DLFVBQVMsQ0FBVCxFQUFZO0FBQzVDLGNBQUUsY0FBRjtBQUNBLGNBQUUsT0FBRixFQUFXLE1BQVg7O0FBRUEsdUJBQVcsSUFBWDtBQUNILFNBTEQ7O0FBT0Esd0JBQWdCLElBQWhCLEdBQXVCLEdBQXZCO0FBQ0Esd0JBQWdCLFNBQWhCLEdBQTRCLDRCQUE1Qjs7QUFFQSx3QkFBZ0IsZ0JBQWhCLENBQWlDLE9BQWpDLEVBQTBDLFVBQVMsQ0FBVCxFQUFZO0FBQ2xELGNBQUUsY0FBRjs7QUFFQSxpQkFBSyxRQUFMLENBQWMsV0FBVyxXQUFYLEdBQXlCLE1BQXpCLEVBQWQ7O0FBRUEsdUJBQVcsSUFBWDtBQUNILFNBTkQ7O0FBUUEsbUJBQVcsU0FBWCxHQUF1QixlQUF2Qjs7QUFFQSxtQkFBVyxXQUFYLENBQXVCLGFBQWEsU0FBYixFQUF3QixJQUF4QixDQUF2QjtBQUNBLG1CQUFXLFdBQVgsQ0FBdUIsYUFBYSxlQUFiLEVBQThCLElBQTlCLENBQXZCOztBQUVBLGdCQUFRLFNBQVIsR0FBb0IsbUNBQXBCO0FBQ0EsZ0JBQVEsV0FBUixDQUFvQixVQUFwQjtBQUNBLGdCQUFRLFdBQVIsQ0FBb0IsVUFBcEI7O0FBRUEsVUFBRSxPQUFGLEVBQVcsRUFBWCxDQUFjLGtCQUFkLEVBQWtDLFlBQVc7QUFDekMsZ0JBQ0ksZUFBZSxFQUFFLElBQUYsRUFBUSxJQUFSLENBQWEsa0JBQWIsQ0FEbkI7QUFBQSxnQkFFSSxjQUFjLEVBQUUsSUFBRixFQUFRLElBQVIsQ0FBYSxnQkFBYixDQUZsQjs7QUFJQSx3QkFBWSxHQUFaLENBQWdCO0FBQ1osdUJBQVEsYUFBYSxRQUFiLEdBQXdCLEdBQXhCLEdBQThCLGFBQWEsV0FBYixDQUF5QixJQUF6QixDQUEvQixHQUFpRSxJQUQ1RDtBQUVaLHdCQUFRLGFBQWEsUUFBYixHQUF3QixJQUF4QixHQUErQjtBQUYzQixhQUFoQjtBQUlILFNBVEQ7QUFVSDs7QUFFRCxhQUFTLGFBQVQsR0FBeUI7QUFDckIsZUFBTyxZQUFZLFNBQW5CLEVBQThCO0FBQzFCLHdCQUFZLFdBQVosQ0FBd0IsWUFBWSxTQUFwQztBQUNIO0FBQ0o7O0FBRUQsYUFBUyxTQUFULENBQW1CLEtBQW5CLEVBQTBCO0FBQ3RCLFlBQ0ksU0FBUyxJQUFJLGFBQUosQ0FBa0IsS0FBbEIsQ0FEYjs7QUFHQSxvQkFBWSxXQUFaLENBQXdCLE9BQU8sVUFBUCxFQUF4QjtBQUNIOztBQUVEOzs7QUFHQSxTQUFLLFdBQUwsR0FBbUIsWUFBVztBQUMxQixZQUNJLFdBQVcsRUFBRSw0QkFBRixFQUFnQyxXQUFoQyxDQURmO0FBQUEsWUFFSSxTQUFTLElBQUksS0FBSixDQUFVLFNBQVMsTUFBbkIsQ0FGYjs7QUFJQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxtQkFBTyxDQUFQLElBQVksU0FBUyxTQUFTLEdBQVQsQ0FBYSxDQUFiLEVBQWdCLFlBQWhCLENBQTZCLFlBQTdCLENBQVQsRUFBcUQsRUFBckQsQ0FBWjtBQUNIOztBQUVELGVBQU8sTUFBUDtBQUNILEtBVkQ7O0FBWUEsU0FBSyxXQUFMLEdBQW1CLFVBQVMsUUFBVCxFQUFtQjtBQUNsQzs7QUFFQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksU0FBUyxNQUE3QixFQUFxQyxHQUFyQyxFQUEwQztBQUN0QyxzQkFBVSxTQUFTLENBQVQsQ0FBVjtBQUNIOztBQUVELG1CQUFXLElBQVg7QUFDSCxLQVJEOztBQVVBLFNBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLGVBQU8sUUFBUDtBQUNILEtBRkQ7O0FBSUEsYUFBUyxZQUFULEdBQXdCO0FBQ3BCLGtCQUFVLFFBQVYsR0FBcUIsWUFBVztBQUM1QixnQkFDSSxXQUFXLEtBQUssS0FEcEI7O0FBR0EsZ0JBQUksU0FBUyxNQUFULEdBQWtCLENBQXRCLEVBQ0k7O0FBRUosZ0JBQ0ksT0FBTyxTQUFTLENBQVQsQ0FEWDtBQUFBLGdCQUVJLFNBQVMsSUFBSSxVQUFKLEVBRmI7O0FBSUEsbUJBQU8sTUFBUCxHQUFnQixZQUFXO0FBQ3ZCLG9CQUNJLFdBQVcsZ0NBQXNCLElBQXRCLENBQTJCLEtBQUssTUFBaEMsQ0FEZjs7QUFHQSxvQkFBSSxZQUFZLElBQVosSUFBb0IsU0FBUyxNQUFULEdBQWtCLENBQTFDLEVBQTZDO0FBQ3pDLHlCQUFLLFdBQUwsQ0FBaUIsUUFBakI7QUFDSCxpQkFGRCxNQUVPO0FBQ0gsMEJBQU0sOERBQU47QUFDSDtBQUNKLGFBVEQ7O0FBV0EsbUJBQU8saUJBQVAsQ0FBeUIsSUFBekI7QUFDSCxTQXZCRDs7QUF5QkEsa0JBQVUsS0FBVjtBQUNIOztBQUVELGFBQVMsWUFBVCxHQUF3QjtBQUNwQixZQUNJLE1BQU0sZ0NBQXNCLEtBQXRCLENBQTRCLEtBQUssV0FBTCxFQUE1QixDQURWO0FBQUEsWUFFSSxPQUFPLElBQUksSUFBSixDQUFTLENBQUMsR0FBRCxDQUFULEVBQWdCLEVBQUMsTUFBTSwwQkFBUCxFQUFoQixDQUZYOztBQUlBLGVBQU8sTUFBUCxDQUFjLElBQWQsRUFBb0Isb0JBQXBCO0FBQ0g7O0FBRUQsYUFBUyxlQUFULEdBQTJCO0FBQ3ZCLG9CQUFZLFNBQVosR0FBd0IsMkNBQXhCOztBQUVBLGFBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxZQUFZLE1BQWhDLEVBQXdDLEdBQXhDLEVBQTZDO0FBQ3pDLHdCQUFZLFdBQVosQ0FBd0IsSUFBSSxhQUFKLENBQWtCLFlBQVksQ0FBWixDQUFsQixFQUFrQyxVQUFsQyxFQUF4QjtBQUNIOztBQUVELG9CQUFZLGdCQUFaLENBQTZCLE9BQTdCLEVBQXNDLFVBQVMsQ0FBVCxFQUFZO0FBQzlDLGdCQUNJLFNBQVMsRUFBRSxNQURmOztBQUdBLGdCQUFJLENBQUMsNEJBQTRCLElBQTVCLENBQWlDLE9BQU8sU0FBeEMsQ0FBTCxFQUF5RDtBQUNyRDtBQUNIOztBQUVELGdCQUFJLEVBQUUsTUFBRixJQUFZLENBQVosQ0FBYyxVQUFkLElBQTRCLE9BQU8sWUFBUCxDQUFvQixZQUFwQixNQUFzQyxTQUF0RSxFQUFpRjtBQUM3RSwyQkFBVyxXQUFYLENBQXVCLHNCQUFZLFNBQVMsT0FBTyxZQUFQLENBQW9CLFlBQXBCLENBQVQsRUFBNEMsRUFBNUMsQ0FBWixDQUF2QjtBQUNBLGtCQUFFLGVBQUY7QUFDQSxrQkFBRSxjQUFGO0FBQ0g7QUFDSixTQWJEOztBQWVBLG9CQUFZLGdCQUFaLENBQTZCLGFBQTdCLEVBQTRDLFVBQVMsQ0FBVCxFQUFZO0FBQ3BELGdCQUNJLFNBQVMsRUFBRSxNQURmOztBQUdBLGdCQUFJLENBQUMsNEJBQTRCLElBQTVCLENBQWlDLE9BQU8sU0FBeEMsQ0FBTCxFQUF5RDtBQUNyRDtBQUNIOztBQUVELGNBQUUsY0FBRjs7QUFFQSxjQUFFLE1BQUYsRUFDSyxRQURMLENBQ2MsUUFEZCxFQUVLLEdBRkwsQ0FFUyxtQkFGVCxFQVZvRCxDQVlyQjtBQUNsQyxTQWJEO0FBY0g7O0FBRUQsYUFBUyxnQkFBVCxHQUE0QjtBQUN4QixZQUNJLGNBQWMsU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRGxCO0FBQUEsWUFFSSxTQUFTLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUZiO0FBQUEsWUFJSSxlQUFlLFNBQVMsYUFBVCxDQUF1QixJQUF2QixDQUpuQjtBQUFBLFlBTUksVUFBVSxTQUFTLGFBQVQsQ0FBdUIsR0FBdkIsQ0FOZDtBQUFBLFlBT0ksVUFBVyxTQUFTLGFBQVQsQ0FBdUIsR0FBdkIsQ0FQZjs7QUFTQSxlQUFPLEtBQVAsR0FBZSw2Q0FBZjtBQUNBLGVBQU8sU0FBUCxHQUFtQixpRUFBbkI7O0FBRUEsb0JBQVksU0FBWixHQUF3QixzRUFBeEI7QUFDQSxvQkFBWSxZQUFaLENBQXlCLGFBQXpCLEVBQXdDLFVBQXhDO0FBQ0EsVUFBRSxXQUFGLEVBQWUsUUFBZjs7QUFFQSxnQkFBUSxJQUFSLEdBQWUsR0FBZjtBQUNBLGdCQUFRLFNBQVIsR0FBb0IsbUNBQXBCO0FBQ0EsZ0JBQVEsZ0JBQVIsQ0FBeUIsT0FBekIsRUFBa0MsVUFBUyxDQUFULEVBQVk7QUFDMUMsY0FBRSxjQUFGOztBQUVBO0FBQ0gsU0FKRDs7QUFNQSxnQkFBUSxJQUFSLEdBQWUsR0FBZjtBQUNBLGdCQUFRLFNBQVIsR0FBb0IscUNBQXBCO0FBQ0EsZ0JBQVEsZ0JBQVIsQ0FBeUIsT0FBekIsRUFBa0MsVUFBUyxDQUFULEVBQVk7QUFDMUMsY0FBRSxjQUFGOztBQUVBO0FBQ0gsU0FKRDs7QUFNQSxxQkFBYSxTQUFiLEdBQXlCLG1DQUF6Qjs7QUFFQSxxQkFBYSxXQUFiLENBQXlCLGFBQWEsT0FBYixFQUFzQixJQUF0QixDQUF6QjtBQUNBLHFCQUFhLFdBQWIsQ0FBeUIsYUFBYSxPQUFiLEVBQXNCLElBQXRCLENBQXpCOztBQUVBLFlBQ0ksdUJBQXVCLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUQzQjs7QUFHQSw2QkFBcUIsU0FBckIsR0FBaUMsVUFBakM7QUFDQSw2QkFBcUIsV0FBckIsQ0FBaUMsV0FBakM7QUFDQSw2QkFBcUIsV0FBckIsQ0FBaUMsWUFBakM7O0FBRUEsVUFBRSxvQkFBRixFQUF3QixFQUF4QixDQUEyQixrQkFBM0IsRUFBK0MsWUFBVztBQUN0RDs7O0FBR0EsY0FBRSxRQUFGLEVBQVksR0FBWixDQUFnQixPQUFoQixFQUF5QixZQUFXO0FBQ2hDLG9CQUFJLEVBQUUsb0JBQUYsRUFBd0IsUUFBeEIsQ0FBaUMsTUFBakMsQ0FBSixFQUE4QztBQUMxQyxzQkFBRSxXQUFGLEVBQWUsUUFBZixDQUF3QixRQUF4QjtBQUNIO0FBQ0osYUFKRDtBQUtILFNBVEQ7O0FBV0EsZUFBTyxnQkFBUCxDQUF3QixPQUF4QixFQUFpQyxVQUFTLENBQVQsRUFBWTtBQUN6QyxzQkFBVSxXQUFXLFdBQVgsR0FBeUIsTUFBekIsRUFBVjtBQUNBLHVCQUFXLElBQVg7QUFDSCxTQUhEOztBQUtBLG9CQUFZLFNBQVosR0FBd0IscUNBQXhCOztBQUVBO0FBQ0EsWUFBSSxtQkFBSixFQUF5QjtBQUNyQix3QkFBWSxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsQ0FBWjs7QUFFQSxzQkFBVSxJQUFWLEdBQWlCLE1BQWpCO0FBQ0Esc0JBQVUsUUFBVixHQUFxQixLQUFyQjtBQUNBLHNCQUFVLEtBQVYsQ0FBZ0IsT0FBaEIsR0FBMEIsTUFBMUI7O0FBRUEsd0JBQVksV0FBWixDQUF3QixvQkFBeEI7QUFDQSx3QkFBWSxXQUFaLENBQXdCLFNBQXhCO0FBQ0g7O0FBRUQsb0JBQVksV0FBWixDQUF3QixNQUF4QjtBQUNIOztBQUVEO0FBQ0EsU0FBSyxjQUFMLEdBQXNCLFdBQXRCLENBQWtDLFdBQWxDOztBQUVBO0FBQ0EsU0FBSyxjQUFMLEdBQXNCLFdBQXRCLENBQWtDLFdBQWxDO0FBQ0g7O0FBRUQsa0JBQWtCLFNBQWxCLEdBQThCLE9BQU8sTUFBUCxDQUFjLG9CQUFVLFNBQXhCLENBQTlCO0FBQ0Esa0JBQWtCLFNBQWxCLENBQTRCLFdBQTVCLEdBQTBDLGlCQUExQzs7Ozs7Ozs7O2tCQ3BUd0IsYzs7QUFGeEI7Ozs7OztBQUVlLFNBQVMsY0FBVCxDQUF3QixNQUF4QixFQUFnQztBQUMzQyxRQUNJLFNBQ0ksdXFMQUZSOztBQXlGQSxRQUNJLG1CQUFtQixFQUFFLDZCQUFGLEVBQWlDLE1BQWpDLENBRHZCO0FBQUEsUUFFSSxnQkFBZ0IsRUFBRSxxQ0FBRixFQUF5QyxNQUF6QyxDQUZwQjtBQUFBLFFBR0ksa0JBQWtCLEVBQUUsNENBQUYsRUFBZ0QsTUFBaEQsQ0FIdEI7QUFBQSxRQUtJLGVBQWUsd0JBQWMsTUFBZCxHQUF1QixlQUF2QixFQUxuQjtBQUFBLFFBTUksY0FBYyxDQUFDLENBQUMsT0FBTyxzQkFOM0I7O0FBUUEscUJBQWlCLFdBQWpCLENBQTZCLFdBQTdCLEVBQTBDLFlBQTFDOztBQUVBLFFBQUksWUFBSixFQUFrQjtBQUNkO0FBQ0Esc0JBQWMsSUFBZDtBQUNBLHdCQUFnQixJQUFoQjtBQUNILEtBSkQsTUFJTztBQUNIO0FBQ0EsWUFBSSxVQUFVLElBQVYsQ0FBZSxVQUFVLFNBQXpCLEtBQXVDLENBQUMsTUFBTSxJQUFOLENBQVcsVUFBVSxTQUFyQixDQUF4QyxJQUNPLE9BQU8sSUFBUCxDQUFZLFVBQVUsU0FBdEIsQ0FEUCxJQUMyQyxTQUFTLElBQVQsQ0FBYyxVQUFVLFNBQXhCLENBRC9DLEVBQ21GO0FBQy9FLDZCQUFpQixRQUFqQixDQUEwQixlQUExQjtBQUNIOztBQUVEO0FBQ0EsWUFBSSxXQUFKLEVBQWlCO0FBQ2IsNkJBQWlCLElBQWpCO0FBQ0EsNEJBQWdCLElBQWhCO0FBQ0g7QUFDSjs7QUFFRCxrQkFBYyxXQUFkLENBQTBCLFdBQTFCLEVBQXVDLFdBQXZDO0FBQ0Esa0JBQWMsV0FBZCxDQUEwQixlQUExQixFQUEyQyxDQUFDLFdBQTVDOztBQUVBLFdBQU8sS0FBUCxDQUFhO0FBQ1QsY0FBTTtBQURHLEtBQWI7O0FBSUE7QUFDQSxXQUFPLElBQVAsQ0FBWSxVQUFaLEVBQXdCLEtBQXhCLEdBQWdDLEVBQUUsTUFBRixDQUFoQzs7QUFFQSxXQUFPLFdBQVAsQ0FBbUIsT0FBTyxDQUFQLENBQW5COztBQUVBLFNBQUssSUFBTCxHQUFZLFlBQVc7QUFDbkIsZUFBTyxLQUFQLENBQWEsTUFBYjtBQUNILEtBRkQ7QUFHSCxDLENBN0pEOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JDa0Z3QixnQjs7QUE1RHhCOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUNBOzs7Ozs7QUExQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkEsU0FBUyxxQkFBVCxDQUErQixRQUEvQixFQUF5QyxLQUF6QyxFQUFnRDtBQUM1QyxRQUNJLE1BQU0sU0FBUyxhQUFULENBQXVCLEtBQXZCLENBRFY7QUFBQSxRQUVJLFFBQVEsU0FBUyxhQUFULENBQXVCLE9BQXZCLENBRlo7O0FBSUEsUUFBSSxTQUFKLEdBQWdCLFVBQWhCOztBQUVBLFVBQU0sV0FBTixDQUFrQixRQUFsQjtBQUNBLFVBQU0sV0FBTixDQUFrQixTQUFTLGNBQVQsQ0FBd0IsS0FBeEIsQ0FBbEI7O0FBRUEsUUFBSSxXQUFKLENBQWdCLEtBQWhCOztBQUVBLFdBQU8sR0FBUDtBQUNIOztBQUVELFNBQVMsWUFBVCxDQUFzQixlQUF0QixFQUF1QyxLQUF2QyxFQUE4QyxNQUE5QyxFQUFzRCxZQUF0RCxFQUFvRSxJQUFwRSxFQUEwRTtBQUN0RSxRQUNJLE1BQU0sSUFBSSxLQUFKLEVBRFY7QUFBQSxRQUVJLFdBQVcsRUFGZjs7QUFJQSxRQUFJLE1BQUosR0FBYSxZQUFXO0FBQ3BCLFlBQ0ksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FEYjtBQUFBLFlBRUksZ0JBQWdCLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQUZwQjs7QUFJQSxlQUFPLEtBQVAsR0FBZSxJQUFJLEtBQW5CO0FBQ0EsZUFBTyxNQUFQLEdBQWdCLElBQUksTUFBcEI7O0FBRUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFlBQXBCLEVBQWtDLEdBQWxDLEVBQXVDO0FBQ25DLDBCQUFjLFNBQWQsQ0FBd0IsR0FBeEIsRUFBNkIsQ0FBN0IsRUFBZ0MsSUFBSSxNQUFwQyxFQUE0QyxLQUE1QyxFQUFtRCxNQUFuRCxFQUEyRCxDQUEzRCxFQUE4RCxDQUE5RCxFQUFpRSxLQUFqRSxFQUF3RSxNQUF4RTs7QUFFQSxnQkFBSTtBQUNBLG9CQUNJLFlBQVksY0FBYyxZQUFkLENBQTJCLENBQTNCLEVBQThCLENBQTlCLEVBQWlDLEtBQWpDLEVBQXdDLE1BQXhDLENBRGhCO0FBQUEsb0JBRUksVUFBVSx3QkFBYyxLQUFkLEVBQXFCLE1BQXJCLENBRmQ7O0FBSUE7QUFDQSxxQkFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsNEJBQVEsSUFBUixDQUFhLENBQWIsSUFBa0IsVUFBVSxJQUFWLENBQWUsSUFBSSxDQUFuQixDQUFsQjtBQUNIOztBQUVELHlCQUFTLElBQVQsQ0FBYyxPQUFkO0FBQ0gsYUFYRCxDQVdFLE9BQU8sQ0FBUCxFQUFVO0FBQ1I7QUFDQSx3QkFBUSxHQUFSLENBQVksQ0FBWjtBQUNIO0FBQ0o7O0FBRUQsYUFBSyxRQUFMO0FBQ0gsS0E3QkQ7O0FBK0JBLFFBQUksR0FBSixHQUFVLGVBQVY7QUFDSDs7QUFFYyxTQUFTLGdCQUFULENBQTBCLFVBQTFCLEVBQXNDO0FBQ2pELHdCQUFVLElBQVYsQ0FBZSxJQUFmLEVBQXFCLFVBQXJCLEVBQWlDLFVBQWpDLEVBQTZDLFVBQTdDOztBQUVBLFFBQ0ksdUJBQXVCLEVBRDNCO0FBQUEsUUFFSSw2QkFBNkIsRUFGakM7QUFBQSxRQUlJLFdBQVcsRUFKZjtBQUFBLFFBSW1CO0FBQ2YsbUJBTEo7QUFBQSxRQUtxQixnQkFMckI7QUFBQSxRQUt1Qzs7QUFFbkMsYUFBUyxLQVBiO0FBQUEsUUFPb0IsVUFBVSxLQVA5QjtBQUFBLFFBU0ksYUFBYSxHQVRqQjtBQUFBLFFBU3NCLFdBQVcsR0FUakM7QUFBQSxRQVVJLFlBVko7QUFBQSxRQVdJLGdCQUFnQixTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FYcEI7QUFBQSxRQWFJLE9BQU8sS0FBSyxjQUFMLEVBYlg7O0FBZUE7OztBQUdBLGFBQVMsV0FBVCxDQUFxQixXQUFyQixFQUFrQztBQUM5QixhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksWUFBWSxNQUFoQyxFQUF3QyxHQUF4QyxFQUE2QztBQUN6QyxnQkFDSSxVQUFVLFlBQVksQ0FBWixDQURkOztBQUdBLHFCQUFTLElBQVQsQ0FBYyxPQUFkOztBQUVBLGdCQUNJLFNBQVMsSUFBSSxlQUFKLENBQW9CLE9BQXBCLEVBQTZCLDBCQUE3QixFQUF5RCwwQkFBekQsQ0FEYjs7QUFHQSxtQkFBTyxFQUFQLENBQVUsT0FBVixFQUFtQixZQUFXO0FBQzFCLGtDQUFrQixLQUFLLE9BQXZCO0FBQ0E7QUFDSCxhQUhEOztBQUtBLDBCQUFjLFdBQWQsQ0FBMEIsT0FBTyxVQUFQLEVBQTFCO0FBQ0g7QUFDSjs7QUFFRDs7Ozs7QUFLQSxhQUFTLHNCQUFULEdBQWtDO0FBQzlCLFlBQ0ksU0FBUyxDQUFDLElBQUQsQ0FEYjs7QUFHQSxZQUNJLFVBQVUsd0JBQWMsQ0FBZCxFQUFpQixDQUFqQixDQURkO0FBRUEsZ0JBQVEsSUFBUixDQUFhLENBQWIsSUFBa0IsSUFBbEI7QUFDQSxnQkFBUSxJQUFSLENBQWEsQ0FBYixJQUFrQixJQUFsQjtBQUNBLGVBQU8sSUFBUCxDQUFZLE9BQVo7O0FBRUEsZUFBTyxJQUFQLENBQVksZUFBZSxDQUFmLENBQVo7QUFDQSxlQUFPLElBQVAsQ0FBWSxlQUFlLENBQWYsQ0FBWjtBQUNBLGVBQU8sSUFBUCxDQUFZLGVBQWUsQ0FBZixDQUFaO0FBQ0EsZUFBTyxJQUFQLENBQVksZUFBZSxDQUFmLENBQVo7QUFDQSxlQUFPLElBQVAsQ0FBWSxlQUFlLENBQWYsQ0FBWjs7QUFFQSxlQUFPLElBQVAsQ0FBWSxxQkFBcUIsQ0FBckIsRUFBd0IsQ0FBeEIsQ0FBWjtBQUNBLGVBQU8sSUFBUCxDQUFZLHFCQUFxQixDQUFyQixFQUF3QixDQUF4QixDQUFaOztBQUVBLGVBQU8sSUFBUCxDQUFZLHNCQUFzQixDQUF0QixFQUF5QixDQUF6QixDQUFaO0FBQ0EsZUFBTyxJQUFQLENBQVksc0JBQXNCLENBQXRCLEVBQXlCLENBQXpCLENBQVo7O0FBRUEsZUFBTyxJQUFQLENBQVksd0JBQXdCLENBQXhCLENBQVo7QUFDQSxlQUFPLElBQVAsQ0FBWSx3QkFBd0IsQ0FBeEIsQ0FBWjtBQUNBLGVBQU8sSUFBUCxDQUFZLHdCQUF3QixDQUF4QixDQUFaO0FBQ0EsZUFBTyxJQUFQLENBQVksd0JBQXdCLEVBQXhCLENBQVo7O0FBRUEsZUFBTyxNQUFQO0FBQ0g7O0FBRUQ7Ozs7O0FBS0EsYUFBUyxjQUFULENBQXdCLElBQXhCLEVBQThCO0FBQzFCLFlBQ0ksVUFBVSx3QkFBYyxJQUFkLEVBQW9CLElBQXBCLENBRGQ7O0FBR0EsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLE9BQU8sSUFBM0IsRUFBaUMsR0FBakMsRUFBc0M7QUFDbEMsb0JBQVEsSUFBUixDQUFhLENBQWIsSUFBa0IsSUFBbEI7QUFDSDtBQUNELGVBQU8sT0FBUDtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsYUFBUyx1QkFBVCxDQUFpQyxJQUFqQyxFQUF1QztBQUNuQyxZQUNJLGNBQWMsSUFBSSxJQUR0QjtBQUFBLFlBRUksVUFBVSx3QkFBYyxXQUFkLEVBQTJCLFdBQTNCLENBRmQ7O0FBSUEsYUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFdBQXBCLEVBQWlDLEdBQWpDLEVBQXNDO0FBQ2xDLGlCQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksV0FBcEIsRUFBaUMsR0FBakMsRUFBc0M7QUFDbEMsd0JBQVEsSUFBUixDQUFhLElBQUksSUFBSSxXQUFyQixJQUFxQyxDQUFDLENBQUMsRUFBRSxJQUFJLElBQU4sQ0FBRCxHQUFlLENBQUMsRUFBRSxJQUFJLElBQU4sQ0FBakIsSUFBZ0MsQ0FBaEMsSUFBcUMsQ0FBdEMsR0FBMkMsQ0FBM0MsR0FBK0MsSUFBbkY7QUFDSDtBQUNKOztBQUVELGVBQU8sT0FBUDtBQUNIOztBQUVBOzs7Ozs7OztBQVFBLGFBQVMsb0JBQVQsQ0FBOEIsUUFBOUIsRUFBd0MsSUFBeEMsRUFBOEM7QUFDM0MsWUFDSSxVQUFVLHdCQUFjLElBQWQsRUFBb0IsSUFBcEIsQ0FEZDs7QUFHQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxJQUEzQixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxnQkFBSSxDQUFDLEVBQUUsSUFBSSxJQUFOLENBQUQsSUFBZ0IsUUFBcEIsRUFBOEI7QUFDMUIsd0JBQVEsSUFBUixDQUFhLENBQWIsSUFBa0IsSUFBbEI7QUFDSDtBQUNKOztBQUVELGVBQU8sT0FBUDtBQUNIOztBQUVBOzs7Ozs7OztBQVFELGFBQVMscUJBQVQsQ0FBK0IsUUFBL0IsRUFBeUMsSUFBekMsRUFBK0M7QUFDM0MsWUFDSSxVQUFVLHdCQUFjLElBQWQsRUFBb0IsSUFBcEIsQ0FEZDs7QUFHQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksT0FBTyxJQUEzQixFQUFpQyxHQUFqQyxFQUFzQztBQUNsQyxnQkFBSSxJQUFJLElBQUosSUFBWSxRQUFoQixFQUEwQjtBQUN0Qix3QkFBUSxJQUFSLENBQWEsQ0FBYixJQUFrQixJQUFsQjtBQUNIO0FBQ0o7O0FBRUQsZUFBTyxPQUFQO0FBQ0g7O0FBRUQsYUFBUyxxQkFBVCxHQUFpQztBQUM3QixZQUFJLG1CQUFtQixJQUF2QixFQUE2QjtBQUN6QiwrQkFBbUIsZ0JBQWdCLEtBQWhCLEVBQW5COztBQUVBLGdCQUFJLE1BQUosRUFBWTtBQUNSLGlDQUFpQixrQkFBakI7QUFDSDs7QUFFRCxnQkFDSSxNQUFNLDZCQURWOztBQUdBLGdCQUFJLHNCQUFKLENBQTJCLFVBQTNCLEVBQXVDLFFBQXZDOztBQUVBLGdCQUFJLE9BQUosRUFBYTtBQUNULG9CQUFJLE1BQUo7QUFDSDs7QUFFRCw2QkFBaUIsUUFBakIsQ0FBMEIsR0FBMUI7QUFDSCxTQWpCRCxNQWlCTztBQUNILCtCQUFtQixJQUFuQjtBQUNIOztBQUVELG1CQUFXLFVBQVgsR0FBd0IsZUFBeEIsQ0FBd0MsZ0JBQXhDOztBQUVBLFlBQUksZ0JBQWdCLElBQXBCLEVBQTBCO0FBQ3RCLHlCQUFhLGFBQWI7QUFDSDtBQUNKOztBQUVELGFBQVMscUJBQVQsR0FBaUM7QUFDN0IsWUFDSSxRQUFRLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQURaO0FBQUEsWUFHSSxZQUFZLFNBQVMsYUFBVCxDQUF1QixPQUF2QixDQUhoQjtBQUFBLFlBSUksV0FBVyxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsQ0FKZjtBQUFBLFlBTUksZUFBZSx1QkFBYSxDQUFiLEVBQWdCLEdBQWhCLEVBQXFCLElBQXJCLENBTm5CO0FBQUEsWUFPSSxhQUFhLHVCQUFhLENBQWIsRUFBZ0IsR0FBaEIsRUFBcUIsSUFBckIsQ0FQakI7QUFBQSxZQVNJLGVBQWUsSUFBSSxlQUFKLENBQW9CLElBQXBCLEVBQTBCLG9CQUExQixFQUFnRCxvQkFBaEQsQ0FUbkI7QUFBQSxZQVVJLGVBQWUsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBVm5CO0FBQUEsWUFZSSxvQkFaSjs7QUFjQSxpQkFBUyxxQkFBVCxHQUFpQztBQUM3QixzQkFBVSxPQUFWLEdBQW9CLE9BQXBCO0FBQ0EscUJBQVMsT0FBVCxHQUFtQixNQUFuQjs7QUFFQSx5QkFBYSxRQUFiLENBQXNCLGFBQWEsR0FBYixHQUFtQixHQUF6QztBQUNBLHVCQUFXLFFBQVgsQ0FBb0IsV0FBVyxHQUFYLEdBQWlCLEdBQXJDO0FBQ0g7O0FBRUQsaUJBQVMseUJBQVQsR0FBcUM7QUFDakMsZ0JBQ0ksUUFBUSxTQUFTLGFBQVQsQ0FBdUIsS0FBdkIsQ0FEWjs7QUFHQSxzQkFBVSxJQUFWLEdBQWlCLFVBQWpCO0FBQ0Esc0JBQVUsZ0JBQVYsQ0FBMkIsT0FBM0IsRUFBb0MsVUFBUyxDQUFULEVBQVk7QUFDNUMsMEJBQVUsS0FBSyxPQUFmO0FBQ0E7QUFDSCxhQUhEOztBQUtBLGtCQUFNLFdBQU4sQ0FBa0Isc0JBQXNCLFNBQXRCLEVBQWlDLFNBQWpDLENBQWxCOztBQUVBLHFCQUFTLElBQVQsR0FBZ0IsVUFBaEI7QUFDQSxxQkFBUyxnQkFBVCxDQUEwQixPQUExQixFQUFtQyxVQUFTLENBQVQsRUFBWTtBQUMzQyx5QkFBUyxLQUFLLE9BQWQ7QUFDQTtBQUNILGFBSEQ7O0FBS0Esa0JBQU0sV0FBTixDQUFrQixzQkFBc0IsUUFBdEIsRUFBZ0MsUUFBaEMsQ0FBbEI7O0FBRUEseUJBQWEsS0FBYixHQUFxQixVQUFTLEtBQVQsRUFBZ0I7QUFDakMsdUJBQU8sa0JBQWtCLFFBQVEsR0FBMUIsSUFBaUMsR0FBeEM7QUFDSCxhQUZEOztBQUlBLHlCQUFhLEVBQWIsQ0FBZ0IsYUFBaEIsRUFBK0IsVUFBUyxLQUFULEVBQWdCO0FBQzNDLDZCQUFhLENBQUMsUUFBUSxHQUFULElBQWdCLEtBQTdCOztBQUVBO0FBQ0gsYUFKRDs7QUFNQSxrQkFBTSxXQUFOLENBQWtCLGFBQWEsVUFBYixFQUFsQjs7QUFFQSx1QkFBVyxLQUFYLEdBQW1CLFVBQVMsS0FBVCxFQUFnQjtBQUMvQix1QkFBTyxnQkFBZ0IsUUFBUSxHQUF4QixJQUErQixHQUF0QztBQUNILGFBRkQ7O0FBSUEsdUJBQVcsRUFBWCxDQUFjLGFBQWQsRUFBNkIsVUFBUyxLQUFULEVBQWdCO0FBQ3pDLDJCQUFXLENBQUMsUUFBUSxHQUFULElBQWdCLEdBQTNCOztBQUVBO0FBQ0gsYUFKRDs7QUFNQSxrQkFBTSxXQUFOLENBQWtCLFdBQVcsVUFBWCxFQUFsQjs7QUFFQSxnQkFDSSxhQUFhLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQURqQjtBQUFBLGdCQUVJLGNBQWMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBRmxCOztBQUlBLHVCQUFXLFNBQVgsR0FBdUIsSUFBdkI7QUFDQSx1QkFBVyxTQUFYLEdBQXVCLHdCQUF2QjtBQUNBLHVCQUFXLElBQVgsR0FBa0IsUUFBbEI7O0FBRUEsdUJBQVcsZ0JBQVgsQ0FBNEIsT0FBNUIsRUFBcUMsVUFBUyxDQUFULEVBQVk7QUFDN0Msa0JBQUUsWUFBRixFQUFnQixPQUFoQixDQUF3QixNQUF4QjtBQUNILGFBRkQ7O0FBSUEsa0JBQU0sV0FBTixDQUFrQixVQUFsQjtBQUNBLGtCQUFNLFdBQU4sQ0FBa0IsU0FBUyxjQUFULENBQXdCLEdBQXhCLENBQWxCOztBQUVBLHdCQUFZLFNBQVosR0FBd0IsT0FBeEI7QUFDQSx3QkFBWSxTQUFaLEdBQXdCLHdCQUF4QjtBQUNBLHdCQUFZLElBQVosR0FBbUIsUUFBbkI7O0FBRUEsd0JBQVksZ0JBQVosQ0FBNkIsT0FBN0IsRUFBc0MsVUFBUyxDQUFULEVBQVk7QUFDOUMsNkJBQWEsQ0FBYjtBQUNBLDJCQUFXLENBQVg7QUFDQSx5QkFBUyxLQUFUO0FBQ0EsMEJBQVUsS0FBVjs7QUFFQTtBQUNBO0FBQ0gsYUFSRDs7QUFVQSxrQkFBTSxXQUFOLENBQWtCLFdBQWxCOztBQUVBOztBQUVBLG1CQUFPLEtBQVA7QUFDSDs7QUFFRDtBQUNBLGFBQUssYUFBTCxHQUFxQixZQUFXO0FBQzVCLHlCQUFhLFFBQWIsR0FBeUIsb0JBQW9CLElBQTdDO0FBQ0EseUJBQWEsVUFBYixDQUF3QixnQkFBeEI7QUFDSCxTQUhEOztBQUtBLGFBQUssVUFBTCxHQUFrQixZQUFXO0FBQ3pCLG1CQUFPLEtBQVA7QUFDSCxTQUZEOztBQUlBLGNBQU0sU0FBTixHQUFrQiw4QkFBbEI7QUFDQSxjQUFNLFdBQU4sQ0FBa0IsYUFBYSxVQUFiLEVBQWxCOztBQUVBLHFCQUFhLElBQWIsR0FBb0IsUUFBcEI7QUFDQSxxQkFBYSxTQUFiLEdBQXlCLHdCQUF6QjtBQUNBLHFCQUFhLFNBQWIsR0FBeUIsV0FBekI7O0FBRUEsK0JBQXVCLDJCQUF2Qjs7QUFFQSxVQUFFLFlBQUYsRUFDSyxPQURMLENBQ2E7QUFDTCxrQkFBTSxJQUREO0FBRUwscUJBQVMsbUJBQVc7QUFDaEIsdUJBQU8sb0JBQVA7QUFDSCxhQUpJO0FBS0wscUJBQVM7QUFMSixTQURiLEVBUUksRUFSSixDQVFPLE9BUlAsRUFRZ0IsWUFBVztBQUNuQixjQUFFLElBQUYsRUFBUSxPQUFSLENBQWdCLFFBQWhCO0FBQ0gsU0FWTDs7QUFZQSxjQUFNLFdBQU4sQ0FBa0IsWUFBbEI7O0FBRUEsYUFBSyxhQUFMO0FBQ0g7O0FBRUQsYUFBUyxlQUFULENBQXlCLE9BQXpCLEVBQWtDLEtBQWxDLEVBQXlDLE1BQXpDLEVBQWlEO0FBQzdDLFlBQ0ksU0FBUyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FEYjtBQUFBLFlBRUksZ0JBQWdCLE9BQU8sVUFBUCxDQUFrQixJQUFsQixDQUZwQjtBQUFBLFlBSUksT0FBTyxJQUpYOztBQU1BLGFBQUssVUFBTCxHQUFrQixVQUFTLE9BQVQsRUFBa0I7QUFDaEMsaUJBQUssT0FBTCxHQUFlLE9BQWY7O0FBRUEsaUJBQUssS0FBTDtBQUNILFNBSkQ7O0FBTUEsYUFBSyxVQUFMLEdBQWtCLFlBQVc7QUFDekIsbUJBQU8sTUFBUDtBQUNILFNBRkQ7O0FBSUEsYUFBSyxLQUFMLEdBQWEsWUFBWTtBQUNyQixnQkFBSSxLQUFLLE9BQUwsSUFBZ0IsSUFBcEIsRUFBMEI7QUFDdEIsOEJBQWMsU0FBZCxHQUEwQixjQUFjLGFBQWQsQ0FBNEIsS0FBSyxPQUFMLENBQWEsUUFBYixFQUE1QixFQUFxRCxRQUFyRCxDQUExQjtBQUNILGFBRkQsTUFFTztBQUNILDhCQUFjLFNBQWQsR0FBMEIsT0FBMUI7QUFDSDtBQUNELDBCQUFjLFFBQWQsQ0FBdUIsQ0FBdkIsRUFBMEIsQ0FBMUIsRUFBNkIsT0FBTyxLQUFwQyxFQUEyQyxPQUFPLE1BQWxEO0FBQ0gsU0FQRDs7QUFTQSxlQUFPLGdCQUFQLENBQXdCLE9BQXhCLEVBQWlDLFlBQVc7QUFDeEMsaUJBQUssSUFBTCxDQUFVLE9BQVY7QUFDSCxTQUZEOztBQUlBLGVBQU8sS0FBUCxHQUFlLEtBQWY7QUFDQSxlQUFPLE1BQVAsR0FBZ0IsTUFBaEI7O0FBRUEsYUFBSyxVQUFMLENBQWdCLE9BQWhCO0FBQ0g7O0FBRUQsb0JBQWdCLFNBQWhCLEdBQTRCLE9BQU8sTUFBUCxDQUFjLGFBQWEsU0FBM0IsQ0FBNUI7QUFDQSxvQkFBZ0IsU0FBaEIsQ0FBMEIsV0FBMUIsR0FBd0MsZUFBeEM7O0FBRUEsbUJBQWUsSUFBSSxxQkFBSixFQUFmOztBQUVBLFNBQUssV0FBTCxDQUFpQixhQUFhLFVBQWIsRUFBakI7O0FBRUEsa0JBQWMsU0FBZCxHQUEwQiwrQkFBMUI7O0FBRUEsU0FBSyxXQUFMLENBQWlCLGFBQWpCOztBQUVBLGdCQUFZLHdCQUFaOztBQUVBLGlCQUFhLFdBQVcsZ0JBQVgsS0FBZ0Msb0JBQTdDLEVBQW1FLEVBQW5FLEVBQXVFLEVBQXZFLEVBQTJFLENBQTNFLEVBQThFLFVBQVMsY0FBVCxFQUF5QjtBQUNuRyxvQkFBWSxjQUFaO0FBQ0gsS0FGRDtBQUdIOztBQUVELGlCQUFpQixTQUFqQixHQUE2QixPQUFPLE1BQVAsQ0FBYyxvQkFBVSxTQUF4QixDQUE3QjtBQUNBLGlCQUFpQixTQUFqQixDQUEyQixXQUEzQixHQUF5QyxnQkFBekM7Ozs7Ozs7OztrQkNqYndCLGE7O0FBSHhCOzs7O0FBQ0E7Ozs7OztBQXZCQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXlCZSxTQUFTLGFBQVQsQ0FBdUIsWUFBdkIsRUFBcUM7QUFDaEQsd0JBQVUsSUFBVixDQUFlLElBQWYsRUFBcUIsWUFBckIsRUFBbUMsTUFBbkMsRUFBMkMsT0FBM0M7O0FBRUEsUUFDSSxPQUFPLElBRFg7QUFBQSxRQUdJLFVBQVUsQ0FDTjtBQUNJLG1CQUFXLGtDQURmO0FBRUksaUJBQVMsaUJBRmI7QUFHSSxpQkFBUyxTQUhiO0FBSUksa0JBQVUsR0FKZDtBQUtJLGNBQU0sdUJBQWE7QUFMdkIsS0FETSxFQVFOO0FBQ0ksbUJBQVcsd0JBRGY7QUFFSSxpQkFBUyxZQUZiO0FBR0ksaUJBQVMsV0FIYjtBQUlJLGtCQUFVLEdBSmQ7QUFLSSxjQUFNLHVCQUFhO0FBTHZCLEtBUk0sRUFlTjtBQUNJLG1CQUFXLDhCQURmO0FBRUksaUJBQVMsYUFGYjtBQUdJLGlCQUFTLFlBSGI7QUFJSSxrQkFBVSxHQUpkO0FBS0ksY0FBTSx1QkFBYTtBQUx2QixLQWZNLEVBc0JOO0FBQ0ksbUJBQVcsaUNBRGY7QUFFSSxpQkFBUyxnQkFGYjtBQUdJLGlCQUFTLGVBSGI7QUFJSSxrQkFBVSxHQUpkO0FBS0ksY0FBTSx1QkFBYTtBQUx2QixLQXRCTSxFQTZCTjtBQUNJLG1CQUFXLGdDQURmO0FBRUksaUJBQVMsZUFGYjtBQUdJLGlCQUFTLGNBSGI7QUFJSSxrQkFBVSxHQUpkO0FBS0ksY0FBTSx1QkFBYTtBQUx2QixLQTdCTSxFQW9DTjtBQUNJLG1CQUFXLGlDQURmO0FBRUksaUJBQVMsZ0JBRmI7QUFHSSw0QkFBb0IsdUJBSHhCO0FBSUksaUJBQVMsZUFKYjtBQUtJLGNBQU0sdUJBQWE7QUFMdkIsS0FwQ00sRUEyQ047QUFDSSxtQkFBVywwQkFEZjtBQUVJLGlCQUFTLFVBRmI7QUFHSSxpQkFBUyxRQUhiO0FBSUksY0FBTSx1QkFBYSxNQUp2QjtBQUtJLGNBQU0sdUJBQWE7QUFMdkIsS0EzQ00sRUFrRE47QUFDSSxtQkFBVyx1QkFEZjtBQUVJLGlCQUFTLE9BRmI7QUFHSSxpQkFBUyxLQUhiO0FBSUksa0JBQVUsSUFKZCxFQUlvQjtBQUNoQixjQUFNLHVCQUFhLE1BTHZCO0FBTUksY0FBTSx1QkFBYTtBQU52QixLQWxETSxFQTBETjtBQUNJLG1CQUFXLDRCQURmO0FBRUksaUJBQVMsWUFGYjtBQUdJLGlCQUFTLFVBSGI7QUFJSSxjQUFNLHVCQUFhLE1BSnZCO0FBS0ksY0FBTSx1QkFBYTtBQUx2QixLQTFETSxFQWlFTjtBQUNJLG1CQUFXLHlCQURmO0FBRUksaUJBQVMsU0FGYjtBQUdJLGlCQUFTLFlBSGI7QUFJSSxjQUFNLHVCQUFhLE1BSnZCO0FBS0ksY0FBTSx1QkFBYTtBQUx2QixLQWpFTSxFQXdFTjtBQUNJLG1CQUFXLDBCQURmO0FBRUksaUJBQVMsVUFGYjtBQUdJLGlCQUFTLFFBSGI7QUFJSSxrQkFBVSxHQUpkO0FBS0ksY0FBTSx1QkFBYSxNQUx2QjtBQU1JLGNBQU0sdUJBQWE7QUFOdkIsS0F4RU0sRUFnRk47QUFDSSxtQkFBVywrQkFEZjtBQUVJLGlCQUFTLGNBRmI7QUFHSSxpQkFBUyxhQUhiO0FBSUksY0FBTSx1QkFBYSxNQUp2QjtBQUtJLGNBQU0sdUJBQWE7QUFMdkIsS0FoRk0sRUF1Rk47QUFDSSxtQkFBVywwQkFEZjtBQUVJLGlCQUFTLFVBRmI7QUFHSSxpQkFBUyxRQUhiO0FBSUksY0FBTSx1QkFBYSxNQUp2QjtBQUtJLGNBQU0sdUJBQWE7QUFMdkIsS0F2Rk0sRUE4Rk47QUFDSSxtQkFBVywyQkFEZjtBQUVJLGlCQUFTLFdBRmI7QUFHSSxpQkFBUyxTQUhiO0FBSUksY0FBTSx1QkFBYSxNQUp2QjtBQUtJLGNBQU0sdUJBQWE7QUFMdkIsS0E5Rk0sRUFxR047QUFDSSxtQkFBVyx5QkFEZjtBQUVJLGlCQUFTLFNBRmI7QUFHSSxpQkFBUyxPQUhiO0FBSUksa0JBQVUsR0FKZDtBQUtJLGNBQU0sdUJBQWEsTUFMdkI7QUFNSSxjQUFNLHVCQUFhO0FBTnZCLEtBckdNLEVBNkdOO0FBQ0ksbUJBQVcsd0JBRGY7QUFFSSxpQkFBUyxRQUZiO0FBR0ksaUJBQVMsTUFIYjtBQUlJLGtCQUFVLEdBSmQ7QUFLSSxjQUFNLHVCQUFhLE1BTHZCO0FBTUksY0FBTSx1QkFBYTtBQU52QixLQTdHTSxFQXFITjtBQUNJLG1CQUFXLHdCQURmO0FBRUksaUJBQVMsUUFGYjtBQUdJLGlCQUFTLE1BSGI7QUFJSSxjQUFNLHVCQUFhLE1BSnZCO0FBS0ksY0FBTSx1QkFBYTtBQUx2QixLQXJITSxDQUhkO0FBQUEsUUFnSUksV0FBVyxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsQ0FoSWY7O0FBa0lBLGFBQVMsYUFBVCxDQUF1QixDQUF2QixFQUEwQjtBQUN0QixZQUFJLEtBQUssUUFBTCxJQUFpQixJQUFyQixFQUEyQjtBQUN2QixnQkFDSSxTQUFTLFFBQVEsU0FBUyxLQUFLLFlBQUwsQ0FBa0Isa0JBQWxCLENBQVQsRUFBZ0QsRUFBaEQsQ0FBUixDQURiOztBQUdBLHlCQUFhLGVBQWIsQ0FBNkIsRUFBQyxRQUFRLE9BQU8sT0FBaEIsRUFBN0I7QUFDSDtBQUNKOztBQUVELGFBQVMsWUFBVCxHQUF3QjtBQUNwQixZQUNJLE9BQU8sS0FBSyxjQUFMLEVBRFg7O0FBR0EsaUJBQVMsU0FBVCxHQUFxQixrQ0FBckI7O0FBRUEsYUFBSyxJQUFJLENBQVQsSUFBYyxPQUFkLEVBQXVCO0FBQ25CLGFBQUMsVUFBUyxDQUFULEVBQVk7QUFDVCxvQkFDSSxTQUFTLFFBQVEsQ0FBUixDQURiO0FBQUEsb0JBRUksYUFBYSxTQUFTLGFBQVQsQ0FBdUIsSUFBdkIsQ0FGakI7O0FBSUEsMkJBQVcsU0FBWCxHQUF1QixpQ0FBaUMsT0FBTyxTQUEvRDtBQUNBLDJCQUFXLFlBQVgsQ0FBd0Isa0JBQXhCLEVBQTRDLENBQTVDOztBQUVBLDJCQUFXLFlBQVgsQ0FBd0IsV0FBeEIsRUFBcUMsT0FBTyxJQUE1QztBQUNBLG9CQUFJLE9BQU8sSUFBUCxLQUFnQixTQUFwQixFQUErQjtBQUMzQiwrQkFBVyxZQUFYLENBQXdCLFdBQXhCLEVBQXFDLE9BQU8sSUFBNUM7QUFDSDs7QUFFRCwyQkFBVyxLQUFYLEdBQW1CLE9BQU8sT0FBMUI7O0FBRUEsb0JBQUksT0FBTyxRQUFYLEVBQXFCO0FBQ2pCLCtCQUFXLEtBQVgsSUFBb0IsT0FBTyxPQUFPLFFBQVAsQ0FBZ0IsV0FBaEIsRUFBUCxHQUF1QyxHQUEzRDs7QUFFQSx3QkFBSSxPQUFPLFFBQVgsRUFBcUIsWUFBVztBQUM1QixzQ0FBYyxJQUFkLENBQW1CLFVBQW5COztBQUVBLCtCQUFPLEtBQVA7QUFDSCxxQkFKRDtBQUtIOztBQUVELG9CQUFJLE9BQU8sUUFBWCxFQUFxQjtBQUNqQiwrQkFBVyxTQUFYLEdBQXVCLFdBQVcsU0FBWCxHQUF1QixXQUE5QztBQUNIOztBQUVELHlCQUFTLFdBQVQsQ0FBcUIsVUFBckI7QUFDSCxhQTlCRCxFQThCRyxDQTlCSDtBQStCSDs7QUFFRCxVQUFFLFFBQUYsRUFBWSxFQUFaLENBQWUsT0FBZixFQUF3QixJQUF4QixFQUE4QixhQUE5Qjs7QUFFQSxpQkFBUyxnQkFBVCxDQUEwQixVQUExQixFQUFzQyxVQUFTLENBQVQsRUFBWTtBQUM5QyxnQkFBSSxLQUFLLFFBQUwsSUFBaUIsSUFBckIsRUFBMkI7QUFDdkIsb0JBQ0ksU0FBUyxRQUFRLFNBQVMsS0FBSyxZQUFMLENBQWtCLGtCQUFsQixDQUFULEVBQWdELEVBQWhELENBQVIsQ0FEYjs7QUFHQSxvQkFBSSxPQUFPLGtCQUFYLEVBQStCO0FBQzNCLGlDQUFhLGVBQWIsQ0FBNkIsRUFBQyxRQUFRLE9BQU8sa0JBQWhCLEVBQTdCO0FBQ0g7QUFDSjtBQUNKLFNBVEQ7O0FBV0EsYUFBSyxXQUFMLENBQWlCLFFBQWpCO0FBQ0g7O0FBRUQsaUJBQWEsRUFBYixDQUFnQixZQUFoQixFQUE4QixVQUFTLE9BQVQsRUFBa0I7QUFDNUMsWUFDSSxPQUFPLEtBQUssY0FBTCxFQURYOztBQUdBLFVBQUUsSUFBRixFQUFRLElBQVIsRUFBYyxXQUFkLENBQTBCLFVBQTFCOztBQUVBLFlBQUksV0FBVyx1QkFBYSxNQUE1QixFQUFvQztBQUNoQyxjQUFFLGtCQUFrQixhQUFhLFVBQWIsRUFBbEIsR0FBOEMsR0FBaEQsRUFBcUQsSUFBckQsRUFBMkQsUUFBM0QsQ0FBb0UsVUFBcEU7QUFDSCxTQUZELE1BRU87QUFDSCxjQUFFLGtCQUFrQixPQUFsQixHQUE0QixHQUE5QixFQUFtQyxJQUFuQyxFQUF5QyxRQUF6QyxDQUFrRCxVQUFsRDtBQUNIO0FBQ0osS0FYRDs7QUFhQSxpQkFBYSxFQUFiLENBQWdCLFlBQWhCLEVBQThCLFVBQVMsT0FBVCxFQUFrQjtBQUM1QyxZQUNJLE9BQU8sS0FBSyxjQUFMLEVBRFg7O0FBR0EsWUFBSSxhQUFhLFVBQWIsTUFBNkIsdUJBQWEsTUFBOUMsRUFBc0Q7QUFDbEQsY0FBRSxJQUFGLEVBQVEsSUFBUixFQUFjLFdBQWQsQ0FBMEIsVUFBMUI7O0FBRUEsY0FBRSxrQkFBa0IsT0FBbEIsR0FBNEIsR0FBOUIsRUFBbUMsSUFBbkMsRUFBeUMsUUFBekMsQ0FBa0QsVUFBbEQ7QUFDSDtBQUNKLEtBVEQ7O0FBV0E7QUFDSDs7QUFFRCxjQUFjLFNBQWQsR0FBMEIsT0FBTyxNQUFQLENBQWMsb0JBQVUsU0FBeEIsQ0FBMUI7QUFDQSxjQUFjLFNBQWQsQ0FBd0IsV0FBeEIsR0FBc0MsYUFBdEM7Ozs7Ozs7OztrQkM1T3dCLGU7O0FBVHhCOzs7Ozs7QUFFQSxJQUNJLHFCQUFxQixDQUR6QjtBQUFBLElBRUkscUJBQXFCLENBRnpCO0FBQUEsSUFHSSxzQkFBc0IsQ0FIMUI7QUFBQSxJQUlJLHFCQUFxQixDQUp6QjtBQUFBLElBS0ksMkJBQTJCLENBTC9CLEMsQ0FSQTs7Ozs7O0FBZWUsU0FBUyxlQUFULEdBQTJCLENBQ3pDOztBQUVEOzs7Ozs7OztBQVFBLGdCQUFnQixTQUFoQixDQUEwQixJQUExQixHQUFpQyxVQUFTLEtBQVQsRUFBZ0I7QUFDN0MsUUFBSSxTQUFTLElBQWIsRUFBbUI7QUFDZixlQUFPLElBQVA7QUFDSDs7QUFFRCxRQUNJLFNBQVMsOEJBQW9CLElBQUksVUFBSixDQUFlLEtBQWYsQ0FBcEIsQ0FEYjtBQUFBLFFBRUksT0FGSjtBQUFBLFFBRWEsS0FGYjtBQUFBLFFBR0ksU0FBUyxFQUhiOztBQUtBLGNBQVUsT0FBTyxTQUFQLEVBQVY7QUFDQSxRQUFJLFdBQVcsQ0FBZixFQUFrQjtBQUNkLGVBQU8sSUFBUDtBQUNIO0FBQ0QsWUFBUSxPQUFPLFNBQVAsRUFBUjs7QUFFQSxTQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBcEIsRUFBMkIsR0FBM0IsRUFBZ0M7QUFDNUIsWUFDSSxjQUFjLE9BQU8sU0FBUCxFQURsQjs7QUFHQSxZQUFJLGVBQWUsa0JBQW5CLEVBQXVDO0FBQ25DLHFCQURtQyxDQUN6QjtBQUNiOztBQUVEO0FBQ0EsWUFDSSxJQUFLLE9BQU8sU0FBUCxLQUFxQixHQUF0QixHQUE2QixLQURyQztBQUFBLFlBRUksSUFBSyxPQUFPLFNBQVAsS0FBcUIsR0FBdEIsR0FBNkIsS0FGckM7QUFBQSxZQUdJLElBQUssT0FBTyxTQUFQLEtBQXFCLEdBQXRCLEdBQTZCLEtBSHJDOztBQUtBLGVBQU8sU0FBUCxHQWQ0QixDQWNSOztBQUVwQixlQUFPLElBQVAsQ0FBWSxLQUFLLEVBQUwsR0FBVSxLQUFLLENBQWYsR0FBbUIsQ0FBL0I7QUFDSDs7QUFFRCxXQUFPLE1BQVA7QUFDSCxDQXBDRDs7QUFzQ0E7Ozs7QUFJQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsS0FBMUIsR0FBa0MsVUFBUyxPQUFULEVBQWtCO0FBQ2hELFFBQ0ksU0FBUyxJQUFJLFVBQUosQ0FBZSxJQUFJLENBQUosR0FBUSxRQUFRLE1BQVIsR0FBaUIsRUFBeEMsQ0FEYjtBQUFBLFFBRUksU0FBUyw4QkFBb0IsTUFBcEIsQ0FGYjs7QUFJQSxXQUFPLFVBQVAsQ0FBa0IsQ0FBbEIsRUFMZ0QsQ0FLMUI7QUFDdEIsV0FBTyxVQUFQLENBQWtCLFFBQVEsTUFBMUIsRUFOZ0QsQ0FNYjs7QUFFbkMsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLFFBQVEsTUFBNUIsRUFBb0MsR0FBcEMsRUFBeUM7QUFDckMsWUFDSSxTQUFTLFFBQVEsQ0FBUixDQURiOztBQUdBLGVBQU8sVUFBUCxDQUFrQixrQkFBbEI7O0FBRUE7QUFDQSxlQUFPLFVBQVAsQ0FBa0IsQ0FBRSxVQUFVLEVBQVgsR0FBaUIsSUFBbEIsSUFBMEIsR0FBNUM7QUFDQSxlQUFPLFVBQVAsQ0FBa0IsQ0FBRSxVQUFVLENBQVgsR0FBZ0IsSUFBakIsSUFBeUIsR0FBM0M7QUFDQSxlQUFPLFVBQVAsQ0FBa0IsQ0FBQyxTQUFTLElBQVYsSUFBa0IsR0FBcEM7QUFDQSxlQUFPLFVBQVAsQ0FBa0IsQ0FBbEI7QUFDSDs7QUFFRCxXQUFPLE9BQU8sY0FBUCxFQUFQO0FBQ0gsQ0F0QkQ7Ozs7Ozs7OztrQkN6Q3dCLGU7QUEzQnhCOzs7Ozs7QUFNQSxJQUFJLE1BQU0sQ0FBQyxDQUFYOztBQUVBLFNBQVMsZUFBVCxDQUF5QixJQUF6QixFQUErQjtBQUMzQjtBQUNBLFdBQVEsT0FBTyxNQUFSLEdBQW1CLE9BQU8sVUFBMUIsR0FBd0MsSUFBL0M7QUFDSDs7QUFFRCxTQUFTLGNBQVQsQ0FBd0IsSUFBeEIsRUFBOEI7QUFDMUI7QUFDQSxXQUFRLE9BQU8sSUFBUixHQUFpQixPQUFPLFVBQXhCLEdBQXNDLElBQTdDO0FBQ0g7O0FBRUQ7Ozs7Ozs7OztBQVNlLFNBQVMsZUFBVCxDQUF5QixJQUF6QixFQUErQixLQUEvQixFQUFzQyxHQUF0QyxFQUEyQztBQUN0RCxTQUFLLElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBSyxHQUFMLEdBQVcsS0FBWDtBQUNBLFNBQUssS0FBTCxHQUFhLFVBQVUsU0FBVixHQUFzQixDQUF0QixHQUEwQixLQUF2QztBQUNBLFNBQUssR0FBTCxHQUFXLFFBQVEsU0FBUixHQUFvQixLQUFLLE1BQXpCLEdBQWtDLEdBQTdDO0FBQ0EsU0FBSyxHQUFMLEdBQVcsS0FBSyxLQUFoQjtBQUNIOztBQUVEOzs7Ozs7QUFNQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsUUFBMUIsR0FBcUMsWUFBVztBQUM1QyxRQUFJLEtBQUssR0FBTCxHQUFXLEtBQUssR0FBcEIsRUFBeUI7QUFDckIsZUFBTyxPQUFPLFlBQVAsQ0FBb0IsS0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLEVBQVYsQ0FBcEIsQ0FBUDtBQUNIOztBQUVELFNBQUssR0FBTCxHQUFXLElBQVg7QUFDQSxXQUFPLEdBQVA7QUFDSCxDQVBEOztBQVNBOzs7OztBQUtBLGdCQUFnQixTQUFoQixDQUEwQixRQUExQixHQUFxQyxZQUFXO0FBQzVDLFFBQUksS0FBSyxHQUFMLEdBQVcsS0FBSyxHQUFwQixFQUF5QjtBQUNyQixlQUFPLEtBQUssSUFBTCxDQUFVLEtBQUssR0FBTCxFQUFWLENBQVA7QUFDSDs7QUFFRCxTQUFLLEdBQUwsR0FBVyxJQUFYO0FBQ0EsV0FBTyxHQUFQO0FBQ0gsQ0FQRDs7QUFTQTtBQUNBLGdCQUFnQixTQUFoQixDQUEwQixNQUExQixHQUFtQyxnQkFBZ0IsU0FBaEIsQ0FBMEIsUUFBN0Q7O0FBRUEsZ0JBQWdCLFNBQWhCLENBQTBCLE1BQTFCLEdBQW1DLFlBQVc7QUFDMUMsV0FBTyxlQUFlLEtBQUssUUFBTCxFQUFmLENBQVA7QUFDSCxDQUZEOztBQUlBLGdCQUFnQixTQUFoQixDQUEwQixVQUExQixHQUF1QyxVQUFTLENBQVQsRUFBWTtBQUMvQyxTQUFLLEdBQUw7QUFDSCxDQUZEOztBQUlBLGdCQUFnQixTQUFoQixDQUEwQixRQUExQixHQUFxQyxZQUFXO0FBQzVDLFFBQUksS0FBSyxHQUFMLEdBQVcsS0FBSyxHQUFwQixFQUF5QjtBQUNyQixlQUFPLE9BQU8sWUFBUCxDQUFvQixLQUFLLElBQUwsQ0FBVSxLQUFLLEdBQWYsQ0FBcEIsQ0FBUDtBQUNIOztBQUVELFNBQUssR0FBTCxHQUFXLElBQVg7QUFDQSxXQUFPLEdBQVA7QUFDSCxDQVBEOztBQVNBLGdCQUFnQixTQUFoQixDQUEwQixVQUExQixHQUF1QyxVQUFTLE1BQVQsRUFBaUI7QUFDcEQsUUFDSSxRQUFRLElBQUksS0FBSixDQUFVLE1BQVYsQ0FEWjtBQUFBLFFBRUksQ0FGSjs7QUFJQSxTQUFLLElBQUksQ0FBVCxFQUFZLElBQUksTUFBaEIsRUFBd0IsR0FBeEIsRUFBNkI7QUFDekIsY0FBTSxDQUFOLElBQVcsS0FBSyxRQUFMLEVBQVg7QUFDSDs7QUFFRCxXQUFPLE1BQU0sSUFBTixDQUFXLEVBQVgsQ0FBUDtBQUNILENBVkQ7O0FBWUEsZ0JBQWdCLFNBQWhCLENBQTBCLE9BQTFCLEdBQW9DLFlBQVc7QUFDM0MsUUFDSSxLQUFLLEtBQUssUUFBTCxFQURUO0FBQUEsUUFFSSxLQUFLLEtBQUssUUFBTCxFQUZUOztBQUlBLFdBQU8sZ0JBQWlCLE1BQU0sQ0FBUCxHQUFZLEVBQTVCLENBQVA7QUFDSCxDQU5EOztBQVFBLGdCQUFnQixTQUFoQixDQUEwQixTQUExQixHQUFzQyxZQUFXO0FBQzdDLFFBQ0ksS0FBSyxLQUFLLFFBQUwsRUFEVDtBQUFBLFFBRUksS0FBSyxLQUFLLFFBQUwsRUFGVDs7QUFJQSxXQUFRLE1BQU0sQ0FBUCxHQUFZLEVBQW5CO0FBQ0gsQ0FORDs7QUFRQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsU0FBMUIsR0FBc0MsWUFBVztBQUM3QyxRQUNJLEtBQUssS0FBSyxRQUFMLEVBRFQ7QUFBQSxRQUVJLEtBQUssS0FBSyxRQUFMLEVBRlQ7O0FBSUEsV0FBUSxNQUFNLENBQVAsR0FBWSxFQUFuQjtBQUNILENBTkQ7O0FBUUEsZ0JBQWdCLFNBQWhCLENBQTBCLFNBQTFCLEdBQXNDLFlBQVc7QUFDN0MsUUFDSSxLQUFLLEtBQUssUUFBTCxFQURUO0FBQUEsUUFFSSxLQUFLLEtBQUssUUFBTCxFQUZUO0FBQUEsUUFHSSxLQUFLLEtBQUssUUFBTCxFQUhUO0FBQUEsUUFJSSxLQUFLLEtBQUssUUFBTCxFQUpUO0FBS0EsV0FBTyxDQUFFLE1BQU0sRUFBUCxHQUFjLE1BQU0sRUFBcEIsR0FBMkIsTUFBTSxDQUFqQyxHQUFzQyxFQUF2QyxNQUErQyxDQUF0RDtBQUNILENBUEQ7O0FBU0EsZ0JBQWdCLFNBQWhCLENBQTBCLFNBQTFCLEdBQXNDLFlBQVc7QUFDN0MsUUFDSSxLQUFLLEtBQUssUUFBTCxFQURUO0FBQUEsUUFFSSxLQUFLLEtBQUssUUFBTCxFQUZUO0FBQUEsUUFHSSxLQUFLLEtBQUssUUFBTCxFQUhUO0FBQUEsUUFJSSxLQUFLLEtBQUssUUFBTCxFQUpUO0FBS0EsV0FBTyxDQUFFLE1BQU0sRUFBUCxHQUFjLE1BQU0sRUFBcEIsR0FBMkIsTUFBTSxDQUFqQyxHQUFzQyxFQUF2QyxNQUErQyxDQUF0RDtBQUNILENBUEQ7O0FBU0EsZ0JBQWdCLFNBQWhCLENBQTBCLFNBQTFCLEdBQXNDLFVBQVMsS0FBVCxFQUFnQjtBQUNsRCxRQUNJLFNBQVMsS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixLQUFLLEdBQXhCLEVBQTZCLEtBQUssR0FBTCxHQUFXLEtBQXhDLENBRGI7O0FBR0EsU0FBSyxHQUFMLElBQVksS0FBWjs7QUFFQSxRQUFJLEtBQUssR0FBTCxHQUFXLEtBQUssR0FBcEIsRUFBeUI7QUFDckIsYUFBSyxHQUFMLEdBQVcsSUFBWDtBQUNIOztBQUVELFdBQU8sTUFBUDtBQUNILENBWEQ7O0FBYUEsZ0JBQWdCLFNBQWhCLENBQTBCLElBQTFCLEdBQWlDLFVBQVMsUUFBVCxFQUFtQjtBQUNoRCxTQUFLLEdBQUwsSUFBWSxRQUFaOztBQUVBLFFBQUksS0FBSyxHQUFMLEdBQVcsS0FBSyxHQUFwQixFQUF5QjtBQUNyQixhQUFLLEdBQUwsR0FBVyxJQUFYO0FBQ0g7QUFDSixDQU5EOztBQVFBLGdCQUFnQixTQUFoQixDQUEwQixJQUExQixHQUFpQyxVQUFTLE1BQVQsRUFBaUI7QUFDOUMsU0FBSyxHQUFMLEdBQVcsTUFBWDtBQUNILENBRkQ7O0FBSUEsZ0JBQWdCLFNBQWhCLENBQTBCLFVBQTFCLEdBQXVDLFVBQVMsR0FBVCxFQUFjO0FBQ2pELFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxJQUFJLE1BQXhCLEVBQWdDLEdBQWhDLEVBQXFDO0FBQ2pDLGFBQUssSUFBTCxDQUFVLEtBQUssR0FBTCxFQUFWLElBQXdCLElBQUksQ0FBSixDQUF4QjtBQUNIO0FBQ0osQ0FKRDs7QUFNQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsU0FBMUIsR0FBc0MsVUFBUyxDQUFULEVBQVk7QUFDOUMsU0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLEVBQVYsSUFBd0IsQ0FBeEI7QUFDSCxDQUZEOztBQUlBO0FBQ0EsZ0JBQWdCLFNBQWhCLENBQTBCLE9BQTFCLEdBQW9DLGdCQUFnQixTQUFoQixDQUEwQixTQUE5RDs7QUFFQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBMUIsR0FBdUMsVUFBUyxDQUFULEVBQVk7QUFDL0MsU0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLEVBQVYsSUFBd0IsQ0FBeEI7QUFDQSxTQUFLLElBQUwsQ0FBVSxLQUFLLEdBQUwsRUFBVixJQUF3QixLQUFLLENBQTdCO0FBQ0gsQ0FIRDs7QUFLQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBMUIsR0FBdUMsVUFBUyxDQUFULEVBQVk7QUFDL0MsU0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLEVBQVYsSUFBd0IsS0FBSyxDQUE3QjtBQUNBLFNBQUssSUFBTCxDQUFVLEtBQUssR0FBTCxFQUFWLElBQXdCLENBQXhCO0FBQ0gsQ0FIRDs7QUFLQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsVUFBMUIsR0FBdUMsVUFBUyxDQUFULEVBQVk7QUFDL0MsU0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLEVBQVYsSUFBd0IsS0FBSyxFQUE3QjtBQUNBLFNBQUssSUFBTCxDQUFVLEtBQUssR0FBTCxFQUFWLElBQXdCLEtBQUssRUFBN0I7QUFDQSxTQUFLLElBQUwsQ0FBVSxLQUFLLEdBQUwsRUFBVixJQUF3QixLQUFLLENBQTdCO0FBQ0EsU0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLEVBQVYsSUFBd0IsQ0FBeEI7QUFDSCxDQUxEOztBQU9BLGdCQUFnQixTQUFoQixDQUEwQixVQUExQixHQUF1QyxVQUFTLENBQVQsRUFBWTtBQUMvQyxTQUFLLElBQUwsQ0FBVSxLQUFLLEdBQUwsRUFBVixJQUF3QixDQUF4QjtBQUNBLFNBQUssSUFBTCxDQUFVLEtBQUssR0FBTCxFQUFWLElBQXdCLEtBQUssQ0FBN0I7QUFDQSxTQUFLLElBQUwsQ0FBVSxLQUFLLEdBQUwsRUFBVixJQUF3QixLQUFLLEVBQTdCO0FBQ0EsU0FBSyxJQUFMLENBQVUsS0FBSyxHQUFMLEVBQVYsSUFBd0IsS0FBSyxFQUE3QjtBQUNILENBTEQ7O0FBT0EsZ0JBQWdCLFNBQWhCLENBQTBCLGFBQTFCLEdBQTBDLFVBQVMsQ0FBVCxFQUFZO0FBQ2xELFFBQ0ksUUFBUSxJQUFJLFVBQUosQ0FBZSxJQUFJLFlBQUosQ0FBaUIsQ0FBQyxDQUFELENBQWpCLEVBQXNCLE1BQXJDLENBRFo7O0FBR0EsU0FBSyxJQUFJLElBQUksTUFBTSxNQUFOLEdBQWUsQ0FBNUIsRUFBK0IsS0FBSyxDQUFwQyxFQUF1QyxHQUF2QyxFQUE0QztBQUN4QyxhQUFLLFNBQUwsQ0FBZSxNQUFNLENBQU4sQ0FBZjtBQUNIO0FBQ0osQ0FQRDs7QUFTQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsWUFBMUIsR0FBeUMsVUFBUyxDQUFULEVBQVk7QUFDakQsUUFDSSxRQUFRLElBQUksVUFBSixDQUFlLElBQUksWUFBSixDQUFpQixDQUFDLENBQUQsQ0FBakIsRUFBc0IsTUFBckMsQ0FEWjs7QUFHQSxTQUFLLElBQUksSUFBSSxNQUFNLE1BQU4sR0FBZSxDQUE1QixFQUErQixLQUFLLENBQXBDLEVBQXVDLEdBQXZDLEVBQTRDO0FBQ3hDLGFBQUssU0FBTCxDQUFlLE1BQU0sQ0FBTixDQUFmO0FBQ0g7QUFDSixDQVBEOztBQVNBOzs7QUFHQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsV0FBMUIsR0FBd0MsVUFBUyxDQUFULEVBQVk7QUFDaEQsU0FBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEVBQUUsTUFBdEIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDL0IsYUFBSyxJQUFMLENBQVUsS0FBSyxHQUFMLEVBQVYsSUFBd0IsRUFBRSxVQUFGLENBQWEsQ0FBYixDQUF4QjtBQUNIO0FBQ0osQ0FKRDs7QUFNQTs7Ozs7Ozs7O0FBU0EsZ0JBQWdCLFNBQWhCLENBQTBCLGtCQUExQixHQUErQyxVQUFTLENBQVQsRUFBWSxLQUFaLEVBQW1CO0FBQzlELFFBQUksVUFBVSxTQUFkLEVBQXlCO0FBQ3JCLGdCQUFRLEtBQUssa0JBQUwsQ0FBd0IsQ0FBeEIsQ0FBUjtBQUNIOztBQUVEO0FBQ0EsWUFBUSxLQUFSO0FBQ0ksYUFBSyxDQUFMO0FBQ0ksaUJBQUssT0FBTCxDQUFhLEtBQUssS0FBTCxDQUFXLElBQUksVUFBZixDQUFiLEVBRlIsQ0FFa0Q7QUFDOUMsYUFBSyxDQUFMO0FBQ0ksaUJBQUssT0FBTCxDQUFhLEtBQUssRUFBbEI7QUFDSixhQUFLLENBQUw7QUFDSSxpQkFBSyxPQUFMLENBQWEsS0FBSyxFQUFsQjtBQUNKLGFBQUssQ0FBTDtBQUNJLGlCQUFLLE9BQUwsQ0FBYSxLQUFLLENBQWxCO0FBQ0osYUFBSyxDQUFMO0FBQ0ksaUJBQUssT0FBTCxDQUFhLENBQWI7QUFDSjtBQUNBO0FBQ0ksa0JBQU0sSUFBSSxnQkFBSixDQUFxQixtQkFBbUIsS0FBeEMsQ0FBTjtBQWJSO0FBZUgsQ0FyQkQ7O0FBdUJBOzs7QUFHQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsa0JBQTFCLEdBQStDLFVBQVMsR0FBVCxFQUFjO0FBQ3pEO0FBQ0EsUUFBSSxNQUFPLEtBQUssQ0FBaEIsRUFBb0I7QUFDaEIsZUFBTyxDQUFQO0FBQ0gsS0FGRCxNQUVPLElBQUksTUFBTyxLQUFLLEVBQWhCLEVBQXFCO0FBQ3hCLGVBQU8sQ0FBUDtBQUNILEtBRk0sTUFFQSxJQUFJLE1BQU8sS0FBSyxFQUFoQixFQUFxQjtBQUN4QixlQUFPLENBQVA7QUFDSCxLQUZNLE1BRUEsSUFBSSxNQUFNLFVBQVYsRUFBc0I7QUFDekIsZUFBTyxDQUFQO0FBQ0gsS0FGTSxNQUVBO0FBQ0gsZUFBTyxDQUFQO0FBQ0g7QUFDSixDQWJEOztBQWVBOzs7QUFHQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsY0FBMUIsR0FBMkMsWUFBVztBQUNsRCxRQUFJLEtBQUssR0FBTCxHQUFXLEtBQUssSUFBTCxDQUFVLFVBQXpCLEVBQXFDO0FBQ2pDLGVBQU8sS0FBSyxJQUFMLENBQVUsUUFBVixDQUFtQixDQUFuQixFQUFzQixLQUFLLEdBQTNCLENBQVA7QUFDSCxLQUZELE1BRU8sSUFBSSxLQUFLLEdBQUwsSUFBWSxLQUFLLElBQUwsQ0FBVSxVQUExQixFQUFzQztBQUN6QyxlQUFPLEtBQUssSUFBWjtBQUNILEtBRk0sTUFFQTtBQUNILGNBQU0saURBQU47QUFDQTtBQUNIO0FBQ0osQ0FURDs7QUFXQSxnQkFBZ0IsU0FBaEIsQ0FBMEIsR0FBMUIsR0FBZ0MsR0FBaEM7Ozs7Ozs7OztrQkM3UXdCLFE7QUF0QnhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JlLFNBQVMsUUFBVCxHQUFvQjs7QUFFL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFLLEVBQUwsR0FBVSxLQUFLLEVBQUwsR0FBVSxLQUFLLEVBQUwsR0FBVSxLQUFLLEVBQUwsR0FBVSxLQUFLLEVBQUwsR0FBVSxLQUFLLEVBQUwsR0FBVSxLQUFLLEVBQUwsR0FBVSxLQUFLLEVBQUwsR0FBVSxHQUFoRjs7QUFFQTtBQUNBLFFBQ0ksRUFESjtBQUFBLFFBQ1EsR0FEUjtBQUFBLFFBQ2EsSUFEYjtBQUFBLFFBQ21CLEtBRG5CO0FBQUEsUUFFSSxFQUZKO0FBQUEsUUFFUSxHQUZSO0FBQUEsUUFFYSxJQUZiO0FBQUEsUUFFbUIsS0FGbkI7QUFBQSxRQUlJLE9BQU8sSUFKWDs7QUFNQSxhQUFTLElBQVQsQ0FBYyxFQUFkLEVBQWtCO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFDSSxLQUFLLE1BQU0sRUFEZjtBQUFBLFlBRUksS0FBSyxLQUFLLEVBRmQ7QUFBQSxZQUdJLEtBQUssS0FBSyxFQUFMLEdBQVUsRUFIbkI7QUFBQSxZQUlJLEtBQUssTUFBTSxFQUpmO0FBQUEsWUFLSSxLQUFLLE1BQU0sRUFMZjtBQUFBLFlBTUksTUFBTSxLQUFLLEVBQUwsR0FBVSxNQUFNLEtBQUssRUFBckIsR0FBMEIsS0FBSyxFQU56QztBQUFBLFlBT0ksTUFBTSxLQUFLLEVBQUwsR0FBVSxNQUFNLEtBQUssRUFBckIsR0FBMEIsS0FBSyxFQVB6QztBQUFBLFlBUUksTUFBTSxPQUFPLEtBQUssRUFBTCxHQUFVLEtBQUssRUFBdEIsSUFBNEIsS0FBSyxFQUFqQyxHQUFzQyxLQUFLLEVBUnJEO0FBQUEsWUFTSSxNQUFNLE9BQU8sS0FBSyxFQUFMLEdBQVUsS0FBSyxFQUF0QixJQUE0QixLQUFLLEVBQWpDLEdBQXNDLEtBQUssRUFUckQ7O0FBV0EsYUFBSyxLQUFLLEVBQVY7QUFDQSxhQUFLLEtBQUssRUFBVjs7QUFFQSxjQUFNLENBQUMsS0FBSyxFQUFMLEdBQVUsS0FBSyxFQUFoQixJQUFzQixFQUF0QixHQUEyQixNQUFNLEVBQWpDLEdBQXNDLE1BQU0sRUFBbEQ7QUFDQSxjQUFNLENBQUMsS0FBSyxFQUFMLEdBQVUsS0FBSyxFQUFoQixJQUFzQixFQUF0QixHQUEyQixNQUFNLEVBQWpDLEdBQXNDLE1BQU0sRUFBbEQ7O0FBRUEsZUFBTyxNQUFNLEVBQU4sR0FBVyxNQUFNLEVBQXhCO0FBQ0EsZUFBTyxNQUFNLEVBQU4sR0FBVyxNQUFNLEVBQXhCOztBQUVBLGdCQUFRLE1BQU0sRUFBZDtBQUNBLGdCQUFRLE1BQU0sRUFBZDtBQUNIOztBQUVEOzs7Ozs7O0FBT0EsU0FBSyxPQUFMLEdBQWUsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlLFFBQWYsRUFBeUI7QUFDcEMsYUFBSyxNQUFNLFFBQVg7O0FBRUEsVUFBRSxDQUFGLElBQU8sQ0FBQyxDQUFDLEVBQVQ7QUFDQSxVQUFFLENBQUYsSUFBTyxDQUFDLENBQUMsRUFBVDs7QUFFQSxhQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksUUFBcEIsRUFBOEIsR0FBOUIsRUFBbUM7QUFDL0Isa0JBQU0sR0FBTjtBQUNBLGtCQUFNLEdBQU47QUFDQSxtQkFBTyxJQUFQO0FBQ0EsbUJBQU8sSUFBUDtBQUNBLG9CQUFRLEtBQVI7QUFDQSxvQkFBUSxLQUFSOztBQUVBLGNBQUUsQ0FBRixJQUFPLENBQUMsQ0FBQyxFQUFUO0FBQ0EsY0FBRSxDQUFGLElBQU8sQ0FBQyxDQUFDLEVBQVQ7QUFDSDtBQUNKLEtBakJEO0FBa0JIOzs7Ozs7Ozs7a0JDM0V1QixPO0FBdEJ4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCZSxTQUFTLE9BQVQsQ0FBaUIsR0FBakIsRUFBc0I7QUFDakMsUUFDSSxPQUFPLElBRFg7O0FBR0EsU0FBSyxHQUFMLEdBQVcsQ0FBWCxDQUppQyxDQUluQjs7QUFFZCxTQUFLLEdBQUwsR0FBVyxDQUFYO0FBQ0EsU0FBSyxVQUFMLEdBQWtCLENBQWxCO0FBQ0EsU0FBSyxLQUFMLEdBQWEsQ0FBYjs7QUFFQSxhQUFTLFFBQVQsR0FBb0I7QUFDaEIsWUFDSSxJQUFLLEtBQUssR0FBTCxJQUFZLEVBQWIsR0FBbUIsSUFEM0I7QUFBQSxZQUVJLElBQUssS0FBSyxHQUFMLElBQVksQ0FBYixHQUFrQixJQUYxQjtBQUFBLFlBR0ksSUFBSSxLQUFLLEdBQUwsR0FBVyxJQUhuQjs7QUFLQTtBQUNBLGFBQUssS0FBTCxHQUFhLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBWixDQUFaLENBQWI7O0FBRUE7QUFDQSxZQUNJLE9BQU8sS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFaLENBQVosQ0FEWDs7QUFHQSxZQUFJLEtBQUssS0FBTCxJQUFjLENBQWxCLEVBQXFCO0FBQ2pCLGlCQUFLLFVBQUwsR0FBa0IsQ0FBbEI7QUFDSCxTQUZELE1BRU87QUFDSCxpQkFBSyxVQUFMLEdBQWtCLENBQUMsRUFBRSxDQUFDLEtBQUssS0FBTCxHQUFhLElBQWQsSUFBc0IsS0FBSyxLQUEzQixHQUFtQyxHQUFyQyxDQUFuQjtBQUNIOztBQUVEO0FBQ0EsWUFBSSxLQUFLLFVBQUwsSUFBbUIsQ0FBdkIsRUFBMEI7QUFDdEIsaUJBQUssR0FBTCxHQUFXLENBQVg7QUFDSCxTQUZELE1BRU87QUFDSCxnQkFDSSxLQUFLLENBQUMsS0FBSyxLQUFMLEdBQWEsQ0FBZCxLQUFvQixLQUFLLEtBQUwsR0FBYSxJQUFqQyxDQURUO0FBQUEsZ0JBRUksS0FBSyxDQUFDLEtBQUssS0FBTCxHQUFhLENBQWQsS0FBb0IsS0FBSyxLQUFMLEdBQWEsSUFBakMsQ0FGVDtBQUFBLGdCQUdJLEtBQUssQ0FBQyxLQUFLLEtBQUwsR0FBYSxDQUFkLEtBQW9CLEtBQUssS0FBTCxHQUFhLElBQWpDLENBSFQ7O0FBS0EsZ0JBQ0ksT0FBTyxDQURYOztBQUdBLGdCQUFJLEtBQUssS0FBTCxJQUFjLENBQWxCLEVBQXFCO0FBQ2pCLHVCQUFPLEtBQUssRUFBWjtBQUNIO0FBQ0QsZ0JBQUksS0FBSyxLQUFMLElBQWMsQ0FBbEIsRUFBcUI7QUFDakIsdUJBQU8sSUFBSSxFQUFKLEdBQVMsRUFBaEI7QUFDSDtBQUNELGdCQUFJLEtBQUssS0FBTCxJQUFjLENBQWxCLEVBQXFCO0FBQ2pCLHVCQUFPLElBQUksRUFBSixHQUFTLEVBQWhCO0FBQ0g7O0FBRUQsb0JBQVEsRUFBUjtBQUNBLGdCQUFJLE9BQU8sQ0FBWCxFQUFjO0FBQ1Ysd0JBQVEsR0FBUjtBQUNIOztBQUVELGlCQUFLLEdBQUwsR0FBVyxDQUFDLENBQUMsSUFBYjtBQUNIO0FBQ0o7O0FBRUQsYUFBUyxRQUFULEdBQW9CO0FBQ2hCO0FBQ0EsWUFBSSxLQUFLLFVBQUwsSUFBbUIsQ0FBdkIsRUFBMEI7QUFDdEIsaUJBQUssR0FBTCxHQUFZLEtBQUssS0FBTCxJQUFjLEVBQWYsR0FBc0IsS0FBSyxLQUFMLElBQWMsQ0FBcEMsR0FBeUMsS0FBSyxLQUF6RDtBQUNILFNBRkQsTUFFTztBQUNILGdCQUNJLElBQUksS0FBSyxHQUFMLEdBQVcsRUFEbkI7O0FBR0EsZ0JBQUksSUFBSSxLQUFLLEtBQUwsQ0FBVyxDQUFYLENBQVI7O0FBRUEsZ0JBQ0ksSUFBSSxLQUFLLFVBQUwsR0FBa0IsR0FEMUI7QUFBQSxnQkFFSSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUwsSUFBYyxJQUFJLENBQWxCLENBQUYsQ0FGVDtBQUFBLGdCQUdJLElBQUksQ0FBQyxFQUFFLEtBQUssS0FBTCxJQUFjLElBQUksSUFBSSxDQUF0QixDQUFGLENBSFQ7QUFBQSxnQkFJSSxJQUFJLENBQUMsRUFBRSxLQUFLLEtBQUwsSUFBYyxJQUFJLEtBQUssSUFBSSxDQUFULENBQWxCLENBQUYsQ0FKVDs7QUFNQSxvQkFBUSxDQUFDLEVBQUUsS0FBSyxHQUFMLEdBQVcsRUFBYixDQUFUO0FBQ0EscUJBQUssQ0FBTDtBQUNJLHlCQUFLLEdBQUwsR0FBWSxLQUFLLEtBQUwsSUFBYyxFQUFmLEdBQXNCLEtBQUssQ0FBM0IsR0FBZ0MsQ0FBM0M7QUFDQTtBQUNKLHFCQUFLLENBQUw7QUFDSSx5QkFBSyxHQUFMLEdBQVksS0FBSyxFQUFOLEdBQWEsS0FBSyxLQUFMLElBQWMsQ0FBM0IsR0FBZ0MsQ0FBM0M7QUFDQTtBQUNKLHFCQUFLLENBQUw7QUFDSSx5QkFBSyxHQUFMLEdBQVksS0FBSyxFQUFOLEdBQWEsS0FBSyxLQUFMLElBQWMsQ0FBM0IsR0FBZ0MsQ0FBM0M7QUFDQTtBQUNKLHFCQUFLLENBQUw7QUFDSSx5QkFBSyxHQUFMLEdBQVksS0FBSyxFQUFOLEdBQWEsS0FBSyxDQUFsQixHQUF1QixLQUFLLEtBQXZDO0FBQ0E7QUFDSixxQkFBSyxDQUFMO0FBQ0kseUJBQUssR0FBTCxHQUFZLEtBQUssRUFBTixHQUFhLEtBQUssQ0FBbEIsR0FBdUIsS0FBSyxLQUF2QztBQUNBO0FBQ0oscUJBQUssQ0FBTDtBQUNJLHlCQUFLLEdBQUwsR0FBWSxLQUFLLEtBQUwsSUFBYyxFQUFmLEdBQXNCLEtBQUssQ0FBM0IsR0FBZ0MsQ0FBM0M7QUFDQTtBQUNKO0FBQ0kseUJBQUssR0FBTCxHQUFXLENBQVgsQ0FESixDQUNrQjtBQUNkO0FBckJKO0FBdUJIO0FBQ0o7O0FBRUQsU0FBSyxNQUFMLEdBQWMsWUFBVztBQUNyQixlQUFPLEtBQUssR0FBWjtBQUNILEtBRkQ7O0FBSUEsU0FBSyxhQUFMLEdBQXFCLFlBQVc7QUFDNUIsZUFBTyxLQUFLLFVBQVo7QUFDSCxLQUZEOztBQUlBLFNBQUssTUFBTCxHQUFjLFlBQVc7QUFDckIsZUFBTyxLQUFLLEdBQVo7QUFDSCxLQUZEOztBQUlBLFNBQUssUUFBTCxHQUFnQixZQUFXO0FBQ3ZCLGVBQU8sS0FBSyxLQUFaO0FBQ0gsS0FGRDs7QUFJQSxTQUFLLGdCQUFMLEdBQXdCLFVBQVMsQ0FBVCxFQUFZLENBQVosRUFBZSxDQUFmLEVBQWtCO0FBQ3RDLGFBQUssTUFBTCxDQUFhLEtBQUssRUFBTixHQUFhLEtBQUssQ0FBbEIsR0FBdUIsQ0FBbkM7QUFDSCxLQUZEOztBQUlBLFNBQUssTUFBTCxHQUFjLFVBQVMsR0FBVCxFQUFjO0FBQ3hCLGFBQUssR0FBTCxHQUFXLEdBQVg7QUFDQTtBQUNILEtBSEQ7O0FBS0EsU0FBSyxNQUFMLEdBQWMsVUFBUyxHQUFULEVBQWMsS0FBZCxFQUFxQixVQUFyQixFQUFpQztBQUMzQyxhQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0EsYUFBSyxVQUFMLEdBQWtCLFVBQWxCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsS0FBYjs7QUFFQTtBQUNILEtBTkQ7O0FBUUEsU0FBSyxNQUFMLEdBQWMsVUFBUyxHQUFULEVBQWM7QUFDeEIsYUFBSyxHQUFMLEdBQVcsR0FBWDtBQUNBO0FBQ0gsS0FIRDs7QUFLQSxTQUFLLGFBQUwsR0FBcUIsVUFBUyxVQUFULEVBQXFCO0FBQ3RDLGFBQUssVUFBTCxHQUFrQixVQUFsQjtBQUNBO0FBQ0gsS0FIRDs7QUFLQSxTQUFLLFFBQUwsR0FBZ0IsVUFBUyxLQUFULEVBQWdCO0FBQzVCLGFBQUssS0FBTCxHQUFhLEtBQWI7QUFDQTtBQUNILEtBSEQ7O0FBS0EsU0FBSyxLQUFMLEdBQWEsWUFBVztBQUNwQixZQUNJLFNBQVMsSUFBSSxPQUFKLEVBRGI7O0FBR0EsZUFBTyxRQUFQLENBQWdCLElBQWhCOztBQUVBLGVBQU8sTUFBUDtBQUNILEtBUEQ7O0FBU0EsU0FBSyxRQUFMLEdBQWdCLFVBQVMsQ0FBVCxFQUFZO0FBQ3hCLGFBQUssR0FBTCxHQUFXLEVBQUUsR0FBYjtBQUNBLGFBQUssR0FBTCxHQUFXLEVBQUUsR0FBYjtBQUNBLGFBQUssVUFBTCxHQUFrQixFQUFFLFVBQXBCO0FBQ0EsYUFBSyxLQUFMLEdBQWEsRUFBRSxLQUFmO0FBQ0gsS0FMRDs7QUFPQSxTQUFLLE9BQUwsR0FBZSxVQUFTLEtBQVQsRUFBZ0I7QUFDM0IsZUFBTyxLQUFLLEdBQUwsSUFBWSxNQUFNLEdBQWxCLElBQXlCLEtBQUssR0FBTCxJQUFZLE1BQU0sR0FBM0MsSUFBa0QsS0FBSyxVQUFMLElBQW1CLE1BQU0sVUFBM0UsSUFBeUYsS0FBSyxLQUFMLElBQWMsTUFBTSxLQUFwSDtBQUNILEtBRkQ7O0FBSUEsU0FBSyxNQUFMLENBQVksT0FBTyxDQUFuQjtBQUNIOzs7Ozs7Ozs7a0JDMUt1QixZO0FBdkJ4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCQTtBQUNlLFNBQVMsWUFBVCxDQUFzQixDQUF0QixFQUF5QixDQUF6QixFQUE0QixDQUE1QixFQUErQjtBQUMxQyxTQUFLLENBQUwsR0FBUyxDQUFUO0FBQ0EsU0FBSyxDQUFMLEdBQVMsQ0FBVDtBQUNBLFNBQUssQ0FBTCxHQUFTLENBQVQ7QUFDSDs7QUFFRCxhQUFhLFNBQWIsQ0FBdUIsS0FBdkIsR0FBK0IsWUFBVztBQUN0QyxXQUFRLEtBQUssR0FBTCxDQUFTLENBQVQsRUFBWSxLQUFLLEdBQUwsQ0FBUyxHQUFULEVBQWMsS0FBSyxLQUFMLENBQVcsS0FBSyxDQUFMLEdBQVMsR0FBcEIsQ0FBZCxDQUFaLEtBQXdELEVBQXpELEdBQ0EsS0FBSyxHQUFMLENBQVMsQ0FBVCxFQUFZLEtBQUssR0FBTCxDQUFTLEdBQVQsRUFBYyxLQUFLLEtBQUwsQ0FBVyxLQUFLLENBQUwsR0FBUyxHQUFwQixDQUFkLENBQVosS0FBd0QsQ0FEeEQsR0FFRCxLQUFLLEdBQUwsQ0FBUyxDQUFULEVBQVksS0FBSyxHQUFMLENBQVMsR0FBVCxFQUFjLEtBQUssS0FBTCxDQUFXLEtBQUssQ0FBTCxHQUFTLEdBQXBCLENBQWQsQ0FBWixDQUZOO0FBR0gsQ0FKRDs7QUFNQSxhQUFhLFNBQWIsQ0FBdUIsT0FBdkIsR0FBaUMsVUFBUyxLQUFULEVBQWdCLEtBQWhCLEVBQXVCO0FBQ3BELFNBQUssQ0FBTCxHQUFTLEtBQUssQ0FBTCxJQUFVLE1BQU0sS0FBaEIsSUFBeUIsTUFBTSxDQUFOLEdBQVUsS0FBNUM7QUFDQSxTQUFLLENBQUwsR0FBUyxLQUFLLENBQUwsSUFBVSxNQUFNLEtBQWhCLElBQXlCLE1BQU0sQ0FBTixHQUFVLEtBQTVDO0FBQ0EsU0FBSyxDQUFMLEdBQVMsS0FBSyxDQUFMLElBQVUsTUFBTSxLQUFoQixJQUF5QixNQUFNLENBQU4sR0FBVSxLQUE1QztBQUNILENBSkQ7O0FBTUEsYUFBYSxTQUFiLENBQXVCLEtBQXZCLEdBQStCLFlBQVc7QUFDdEMsV0FBTyxJQUFJLFlBQUosQ0FBaUIsS0FBSyxDQUF0QixFQUF5QixLQUFLLENBQTlCLEVBQWlDLEtBQUssQ0FBdEMsQ0FBUDtBQUNILENBRkQ7O0FBSUEsYUFBYSxhQUFiLEdBQTZCLFVBQVMsS0FBVCxFQUFnQjtBQUN6QyxXQUFPLElBQUksWUFBSixDQUNILENBQUUsVUFBVSxFQUFYLEdBQWlCLElBQWxCLElBQTBCLEdBRHZCLEVBRUgsQ0FBRSxVQUFVLENBQVgsR0FBZ0IsSUFBakIsSUFBeUIsR0FGdEIsRUFHSCxDQUFDLFFBQVEsSUFBVCxJQUFpQixHQUhkLENBQVA7QUFLSCxDQU5EOzs7Ozs7Ozs7UUNQZ0IsOEIsR0FBQSw4QjtRQVFBLHNCLEdBQUEsc0I7UUFTQSxnQixHQUFBLGdCO1FBZUEsaUIsR0FBQSxpQjtBQXRFaEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQkEsU0FBUyw4QkFBVCxDQUF3QyxhQUF4QyxFQUF1RDtBQUN0RCxLQUNDLG9CQUFvQixDQUNuQix1QkFEbUIsRUFDTSwwQkFETixFQUNrQyw2QkFEbEMsRUFFbkIseUJBRm1CLENBRHJCOztBQU1BLE1BQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxrQkFBa0IsTUFBdEMsRUFBOEMsR0FBOUMsRUFBbUQ7QUFDbEQsTUFBSSxrQkFBa0IsQ0FBbEIsS0FBd0IsYUFBNUIsRUFBMkM7QUFDMUMsVUFBTyxrQkFBa0IsQ0FBbEIsQ0FBUDtBQUNBO0FBQ0Q7O0FBRUQsUUFBTyxJQUFQO0FBQ0E7O0FBRU0sU0FBUyw4QkFBVCxHQUEwQztBQUNoRCxLQUNDLFNBQVMsU0FBUyxhQUFULENBQXVCLFFBQXZCLENBRFY7QUFBQSxLQUVDLGdCQUFnQixPQUFPLFVBQVAsQ0FBa0IsSUFBbEIsQ0FGakI7O0FBSUEsUUFBTyxDQUFDLENBQUMsK0JBQStCLGFBQS9CLENBQVQ7QUFDQTs7QUFFTSxTQUFTLHNCQUFULENBQWdDLGFBQWhDLEVBQStDLE9BQS9DLEVBQXdEO0FBQzlELEtBQ0MsV0FBVywrQkFBK0IsYUFBL0IsQ0FEWjs7QUFHQSxLQUFJLFFBQUosRUFBYztBQUNiLGdCQUFjLFFBQWQsSUFBMEIsT0FBMUI7QUFDQTtBQUNEOztBQUVNLFNBQVMsZ0JBQVQsQ0FBMEIsU0FBMUIsRUFBcUM7QUFDM0MsS0FDQyxjQUFjLGFBQWEsTUFENUI7O0FBR0EsS0FBSSxDQUFDLFdBQUwsRUFBa0I7QUFDakIsTUFDQyxLQUFLLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUROO0FBRUEsS0FBRyxZQUFILENBQWdCLFNBQWhCLEVBQTJCLFNBQTNCOztBQUVBLGdCQUFjLE9BQU8sR0FBRyxTQUFILENBQVAsSUFBd0IsVUFBdEM7QUFDQTs7QUFFRCxRQUFPLFdBQVA7QUFDQTs7QUFFTSxTQUFTLGlCQUFULEdBQTRCO0FBQ2xDLEtBQUksT0FBTyxTQUFTLGFBQVQsQ0FBdUIsUUFBdkIsQ0FBWDtBQUNBLFFBQU8sQ0FBQyxFQUFFLEtBQUssVUFBTCxJQUFtQixLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBckIsQ0FBUjtBQUNBOzs7Ozs7OztrQkNqRHVCLFM7O0FBRnhCOzs7Ozs7QUFFZSxTQUFTLFNBQVQsQ0FBbUIsTUFBbkIsRUFBMkI7QUFDekMsTUFBSyxNQUFMLEdBQWMsVUFBVSxFQUF4QjtBQUNBLEMsQ0ExQkQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUE0QkEsVUFBVSxTQUFWLENBQW9CLEtBQXBCLEdBQTRCLFlBQVc7QUFDdEMsS0FDQyxTQUFTLElBQUksU0FBSixDQUFjLElBQUksS0FBSixDQUFVLEtBQUssTUFBTCxDQUFZLE1BQXRCLENBQWQsQ0FEVjs7QUFHQSxNQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUFMLENBQVksTUFBaEMsRUFBd0MsR0FBeEMsRUFBNkM7QUFDNUM7QUFDQSxTQUFPLE1BQVAsQ0FBYyxDQUFkLElBQW1CLEVBQUMsR0FBSSxLQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBcEIsRUFBdUIsR0FBSSxLQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBMUMsRUFBbkI7QUFDQTs7QUFFRCxRQUFPLE1BQVA7QUFDQSxDQVZEOztBQVlBOzs7Ozs7QUFNQSxVQUFVLFNBQVYsQ0FBb0IsY0FBcEIsR0FBcUMsVUFBUyxlQUFULEVBQTBCO0FBQzlELEtBQ0MsU0FBUyxJQUFJLFNBQUosQ0FBYyxJQUFJLEtBQUosQ0FBVSxLQUFLLE1BQUwsQ0FBWSxNQUF0QixDQUFkLENBRFY7O0FBR0EsTUFBSyxJQUFJLElBQUksQ0FBYixFQUFnQixJQUFJLEtBQUssTUFBTCxDQUFZLE1BQWhDLEVBQXdDLEdBQXhDLEVBQTZDO0FBQzVDLFNBQU8sTUFBUCxDQUFjLENBQWQsSUFBbUIsZ0JBQWdCLG1CQUFoQixDQUFvQyxLQUFLLE1BQUwsQ0FBWSxDQUFaLENBQXBDLENBQW5CO0FBQ0E7O0FBRUQsUUFBTyxNQUFQO0FBQ0EsQ0FURDs7QUFXQSxVQUFVLFNBQVYsQ0FBb0IsU0FBcEIsR0FBZ0MsWUFBVztBQUMxQyxLQUNDLFVBQVUsS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLENBRDFCO0FBQUEsS0FFQyxVQUFVLEtBQUssTUFBTCxDQUFZLENBQVosRUFBZSxDQUYxQjs7QUFJQSxNQUFLLElBQUksSUFBSSxDQUFiLEVBQWdCLElBQUksS0FBSyxNQUFMLENBQVksTUFBaEMsRUFBd0MsR0FBeEMsRUFBNkM7QUFDNUMsYUFBVyxLQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBMUI7QUFDQSxhQUFXLEtBQUssTUFBTCxDQUFZLENBQVosRUFBZSxDQUExQjtBQUNBOztBQUVELFFBQU8sRUFBQyxHQUFHLFVBQVUsS0FBSyxNQUFMLENBQVksTUFBMUIsRUFBa0MsR0FBRyxVQUFVLEtBQUssTUFBTCxDQUFZLE1BQTNELEVBQVA7QUFDQSxDQVhEOztBQWFBOzs7Ozs7QUFNQSxVQUFVLFNBQVYsQ0FBb0IsYUFBcEIsR0FBb0MsVUFBUyxLQUFULEVBQWdCO0FBQ25ELEtBQUksQ0FBSjtBQUFBLEtBQU8sQ0FBUDtBQUFBLEtBQVUsWUFBWSxLQUF0Qjs7QUFFQSxNQUFLLElBQUksQ0FBSixFQUFPLElBQUksS0FBSyxNQUFMLENBQVksTUFBWixHQUFxQixDQUFyQyxFQUF3QyxJQUFJLEtBQUssTUFBTCxDQUFZLE1BQXhELEVBQWdFLElBQUksR0FBcEUsRUFBeUU7QUFDeEUsTUFBTSxLQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBZixHQUFtQixNQUFNLENBQTFCLElBQWlDLEtBQUssTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLEdBQW1CLE1BQU0sQ0FBM0QsSUFDRCxNQUFNLENBQU4sR0FBVSxDQUFDLEtBQUssTUFBTCxDQUFZLENBQVosRUFBZSxDQUFmLEdBQW1CLEtBQUssTUFBTCxDQUFZLENBQVosRUFBZSxDQUFuQyxLQUF5QyxNQUFNLENBQU4sR0FBVSxLQUFLLE1BQUwsQ0FBWSxDQUFaLEVBQWUsQ0FBbEUsS0FBd0UsS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsR0FBbUIsS0FBSyxNQUFMLENBQVksQ0FBWixFQUFlLENBQTFHLElBQStHLEtBQUssTUFBTCxDQUFZLENBQVosRUFBZSxDQUQzSSxFQUMrSTtBQUM5SSxlQUFZLENBQUMsU0FBYjtBQUNBO0FBQ0Q7O0FBRUQsUUFBTyxTQUFQO0FBQ0EsQ0FYRDs7Ozs7Ozs7O2tCQ3REd0IsUTtBQXRCeEI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFzQmUsU0FBUyxRQUFULEdBQW9CO0FBQy9CLFFBQ0ksZ0JBREo7QUFBQSxRQUVJLHVCQUF1QixLQUYzQjs7QUFJQTs7O0FBR0EsU0FBSyxZQUFMLEdBQW9CLFlBQVc7QUFDM0IsWUFBSSxvQkFBSixFQUEwQjtBQUN0QixtQ0FBdUIsS0FBdkI7QUFDQSxtQkFBTyxnQkFBUDtBQUNILFNBSEQsTUFHTzs7QUFFSCxnQkFDSSxFQURKLEVBQ1EsRUFEUixFQUNZLENBRFo7O0FBR0EsZUFBRztBQUNDLHFCQUFLLElBQUksS0FBSyxNQUFMLEVBQUosR0FBb0IsQ0FBekIsQ0FERCxDQUM2QjtBQUM1QixxQkFBSyxJQUFJLEtBQUssTUFBTCxFQUFKLEdBQW9CLENBQXpCLENBRkQsQ0FFNkI7QUFDNUIsb0JBQUksS0FBSyxFQUFMLEdBQVUsS0FBSyxFQUFuQjtBQUNILGFBSkQsUUFJUyxLQUFLLENBQUwsSUFBVSxLQUFLLENBSnhCOztBQU1BLGdCQUNJLGFBQWEsS0FBSyxJQUFMLENBQVUsQ0FBQyxDQUFELEdBQUssS0FBSyxHQUFMLENBQVMsQ0FBVCxDQUFMLEdBQW1CLENBQTdCLENBRGpCOztBQUdBLCtCQUFtQixLQUFLLFVBQXhCO0FBQ0EsbUNBQXVCLElBQXZCOztBQUVBLG1CQUFPLEtBQUssVUFBWjtBQUNIO0FBQ0osS0F2QkQ7QUF3Qkg7Ozs7Ozs7OztrQkNoQ3VCLE07QUF0QnhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JlLFNBQVMsTUFBVCxDQUFnQixJQUFoQixFQUFzQixHQUF0QixFQUEyQixLQUEzQixFQUFrQyxNQUFsQyxFQUEwQztBQUNyRDs7Ozs7Ozs7OztBQVVBLFNBQUssSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLLEdBQUwsR0FBVyxHQUFYO0FBQ0EsU0FBSyxLQUFMLEdBQWEsS0FBYjtBQUNBLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDSDs7QUFFRCxPQUFPLFNBQVAsQ0FBaUIsU0FBakIsR0FBNkIsWUFBVztBQUNwQyxTQUFLLElBQUwsR0FBWSxDQUFaO0FBQ0EsU0FBSyxHQUFMLEdBQVcsQ0FBWDtBQUNBLFNBQUssS0FBTCxHQUFhLENBQWI7QUFDQSxTQUFLLE1BQUwsR0FBYyxDQUFkO0FBQ0gsQ0FMRDs7QUFPQSxPQUFPLFNBQVAsQ0FBaUIsS0FBakIsR0FBeUIsVUFBUyxJQUFULEVBQWU7QUFDcEMsUUFBSSxLQUFLLE9BQUwsRUFBSixFQUFvQjtBQUNoQixhQUFLLEdBQUwsQ0FBUyxJQUFUO0FBQ0gsS0FGRCxNQUVPO0FBQ0gsYUFBSyxJQUFMLEdBQVksS0FBSyxHQUFMLENBQVMsS0FBSyxJQUFkLEVBQW9CLEtBQUssSUFBekIsQ0FBWjtBQUNBLGFBQUssR0FBTCxHQUFXLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBZCxFQUFtQixLQUFLLEdBQXhCLENBQVg7QUFDQSxhQUFLLEtBQUwsR0FBYSxLQUFLLEdBQUwsQ0FBUyxLQUFLLEtBQWQsRUFBcUIsS0FBSyxLQUExQixDQUFiO0FBQ0EsYUFBSyxNQUFMLEdBQWMsS0FBSyxHQUFMLENBQVMsS0FBSyxNQUFkLEVBQXNCLEtBQUssTUFBM0IsQ0FBZDtBQUNIO0FBQ0osQ0FURDs7QUFXQSxPQUFPLFNBQVAsQ0FBaUIsUUFBakIsR0FBNEIsVUFBUyxJQUFULEVBQWU7QUFDdkMsUUFDSSxTQUFTLEtBQUssS0FBTCxFQURiOztBQUdBLFdBQU8sS0FBUCxDQUFhLElBQWI7O0FBRUEsV0FBTyxNQUFQO0FBQ0gsQ0FQRDs7QUFTQTs7Ozs7QUFLQSxPQUFPLFNBQVAsQ0FBaUIsSUFBakIsR0FBd0IsVUFBUyxJQUFULEVBQWU7QUFDbkMsUUFBSSxDQUFDLEtBQUssT0FBTCxFQUFMLEVBQXFCO0FBQ2pCLFlBQUksS0FBSyxPQUFMLEVBQUosRUFBb0I7QUFDaEIsaUJBQUssU0FBTDtBQUNILFNBRkQsTUFFTztBQUNILGlCQUFLLElBQUwsR0FBWSxLQUFLLEdBQUwsQ0FBUyxLQUFLLElBQWQsRUFBb0IsS0FBSyxJQUF6QixDQUFaO0FBQ0EsaUJBQUssR0FBTCxHQUFXLEtBQUssR0FBTCxDQUFTLEtBQUssR0FBZCxFQUFtQixLQUFLLEdBQXhCLENBQVg7QUFDQSxpQkFBSyxLQUFMLEdBQWEsS0FBSyxHQUFMLENBQVMsS0FBSyxLQUFkLEVBQXFCLEtBQUssS0FBMUIsQ0FBYjtBQUNBLGlCQUFLLE1BQUwsR0FBYyxLQUFLLEdBQUwsQ0FBUyxLQUFLLE1BQWQsRUFBc0IsS0FBSyxNQUEzQixDQUFkO0FBQ0g7QUFDSjs7QUFFRCxXQUFPLElBQVA7QUFDSCxDQWJEOztBQWVBLE9BQU8sU0FBUCxDQUFpQixhQUFqQixHQUFpQyxVQUFTLENBQVQsRUFBWTtBQUN6QyxXQUFPLEVBQUUsRUFBRSxDQUFGLEdBQU0sS0FBSyxJQUFYLElBQW1CLEVBQUUsQ0FBRixHQUFNLEtBQUssR0FBOUIsSUFBcUMsRUFBRSxDQUFGLElBQU8sS0FBSyxLQUFqRCxJQUEwRCxFQUFFLENBQUYsSUFBTyxLQUFLLE1BQXhFLENBQVA7QUFDSCxDQUZEOztBQUlBLE9BQU8sU0FBUCxDQUFpQixRQUFqQixHQUE0QixVQUFTLElBQVQsRUFBZTtBQUN2QyxXQUFPLEtBQUssSUFBTCxJQUFhLEtBQUssSUFBbEIsSUFBMEIsS0FBSyxHQUFMLElBQVksS0FBSyxHQUEzQyxJQUFrRCxLQUFLLEtBQUwsSUFBYyxLQUFLLEtBQXJFLElBQThFLEtBQUssTUFBTCxJQUFlLEtBQUssTUFBekc7QUFDSCxDQUZEOztBQUlBOzs7Ozs7O0FBT0EsT0FBTyxTQUFQLENBQWlCLGNBQWpCLEdBQWtDLFVBQVMsT0FBVCxFQUFrQixPQUFsQixFQUEyQjtBQUN6RCxZQUFRLEtBQVIsR0FBZ0IsUUFBUSxJQUFSLEdBQWUsUUFBUSxRQUFSLEVBQS9CO0FBQ0EsWUFBUSxNQUFSLEdBQWlCLFFBQVEsR0FBUixHQUFjLFFBQVEsU0FBUixFQUEvQjs7QUFFQSxRQUFJLEtBQUssT0FBTCxNQUFrQixRQUFRLElBQVIsSUFBZ0IsS0FBSyxLQUF2QyxJQUFnRCxRQUFRLEdBQVIsSUFBZSxLQUFLLE1BQXBFLElBQThFLFFBQVEsS0FBUixJQUFpQixLQUFLLElBQXBHLElBQTRHLFFBQVEsTUFBUixJQUFrQixLQUFLLEdBQXZJLEVBQTRJO0FBQ3hJLGdCQUFRLFNBQVI7QUFDQSxnQkFBUSxTQUFSO0FBQ0gsS0FIRCxNQUdPO0FBQ0g7QUFDQSxZQUFJLFFBQVEsS0FBUixHQUFnQixLQUFLLEtBQXpCLEVBQWdDO0FBQzVCLG9CQUFRLEtBQVIsSUFBaUIsUUFBUSxLQUFSLEdBQWdCLEtBQUssS0FBdEM7QUFDQSxvQkFBUSxLQUFSLEdBQWdCLEtBQUssS0FBckI7QUFDSDs7QUFFRCxZQUFJLFFBQVEsTUFBUixHQUFpQixLQUFLLE1BQTFCLEVBQWtDO0FBQzlCLG9CQUFRLE1BQVIsSUFBa0IsUUFBUSxNQUFSLEdBQWlCLEtBQUssTUFBeEM7QUFDQSxvQkFBUSxNQUFSLEdBQWlCLEtBQUssTUFBdEI7QUFDSDs7QUFFRDtBQUNBLFlBQUksUUFBUSxJQUFSLEdBQWUsS0FBSyxJQUF4QixFQUE4QjtBQUMxQixvQkFBUSxJQUFSLElBQWdCLEtBQUssSUFBTCxHQUFZLFFBQVEsSUFBcEM7QUFDQSxvQkFBUSxJQUFSLEdBQWUsS0FBSyxJQUFwQjtBQUNIOztBQUVELFlBQUksUUFBUSxHQUFSLEdBQWMsS0FBSyxHQUF2QixFQUE0QjtBQUN4QixvQkFBUSxHQUFSLElBQWUsS0FBSyxHQUFMLEdBQVcsUUFBUSxHQUFsQztBQUNBLG9CQUFRLEdBQVIsR0FBYyxLQUFLLEdBQW5CO0FBQ0g7QUFDSjtBQUNKLENBOUJEOztBQWdDQSxPQUFPLFNBQVAsQ0FBaUIsUUFBakIsR0FBNEIsWUFBVztBQUNuQyxXQUFPLEtBQUssS0FBTCxHQUFhLEtBQUssSUFBekI7QUFDSCxDQUZEOztBQUlBLE9BQU8sU0FBUCxDQUFpQixTQUFqQixHQUE2QixZQUFXO0FBQ3BDLFdBQU8sS0FBSyxNQUFMLEdBQWMsS0FBSyxHQUExQjtBQUNILENBRkQ7O0FBSUEsT0FBTyxTQUFQLENBQWlCLE9BQWpCLEdBQTJCLFlBQVc7QUFDbEMsV0FBTyxLQUFLLFFBQUwsS0FBa0IsS0FBSyxTQUFMLEVBQXpCO0FBQ0gsQ0FGRDs7QUFJQSxPQUFPLFNBQVAsQ0FBaUIsT0FBakIsR0FBMkIsWUFBVztBQUNsQyxXQUFPLEtBQUssS0FBTCxJQUFjLEtBQUssSUFBbkIsSUFBMkIsS0FBSyxNQUFMLElBQWUsS0FBSyxHQUF0RDtBQUNILENBRkQ7O0FBSUEsT0FBTyxTQUFQLENBQWlCLEdBQWpCLEdBQXVCLFVBQVMsQ0FBVCxFQUFZO0FBQy9CLFNBQUssSUFBTCxHQUFZLEVBQUUsSUFBZDtBQUNBLFNBQUssR0FBTCxHQUFXLEVBQUUsR0FBYjtBQUNBLFNBQUssS0FBTCxHQUFhLEVBQUUsS0FBZjtBQUNBLFNBQUssTUFBTCxHQUFjLEVBQUUsTUFBaEI7QUFDSCxDQUxEOztBQU9BLE9BQU8sU0FBUCxDQUFpQixLQUFqQixHQUF5QixZQUFXO0FBQ2hDLFdBQU8sSUFBSSxNQUFKLENBQVcsS0FBSyxJQUFoQixFQUFzQixLQUFLLEdBQTNCLEVBQWdDLEtBQUssS0FBckMsRUFBNEMsS0FBSyxNQUFqRCxDQUFQO0FBQ0gsQ0FGRDs7QUFJQSxPQUFPLFNBQVAsQ0FBaUIsU0FBakIsR0FBNkIsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQ3hDLFNBQUssSUFBTCxJQUFhLENBQWI7QUFDQSxTQUFLLEtBQUwsSUFBYyxDQUFkO0FBQ0EsU0FBSyxHQUFMLElBQVksQ0FBWjtBQUNBLFNBQUssTUFBTCxJQUFlLENBQWY7QUFDSCxDQUxEOztBQU9BLE9BQU8sU0FBUCxDQUFpQixNQUFqQixHQUEwQixVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDckMsU0FBSyxTQUFMLENBQWUsSUFBSSxLQUFLLElBQXhCLEVBQThCLElBQUksS0FBSyxHQUF2QztBQUNILENBRkQ7O0FBSUEsT0FBTyxTQUFQLENBQWlCLE1BQWpCLEdBQTBCLFVBQVMsSUFBVCxFQUFlO0FBQ3JDLFdBQU8sS0FBSyxJQUFMLElBQWEsS0FBSyxJQUFsQixJQUEwQixLQUFLLEtBQUwsSUFBYyxLQUFLLEtBQTdDLElBQXNELEtBQUssR0FBTCxJQUFZLEtBQUssR0FBdkUsSUFBOEUsS0FBSyxNQUFMLElBQWUsS0FBSyxNQUF6RztBQUNILENBRkQ7O0FBSUE7Ozs7OztBQU1BLE9BQU8sU0FBUCxDQUFpQixJQUFqQixHQUF3QixVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDbkM7QUFDQSxTQUFLLElBQUwsSUFBYSxDQUFiO0FBQ0EsU0FBSyxLQUFMLElBQWMsQ0FBZDtBQUNBLFNBQUssR0FBTCxJQUFZLENBQVo7QUFDQSxTQUFLLE1BQUwsSUFBZSxDQUFmO0FBQ0gsQ0FORDs7QUFRQSxPQUFPLFNBQVAsQ0FBaUIsUUFBakIsR0FBNEIsWUFBVztBQUNuQyxXQUFPLE1BQU0sS0FBSyxJQUFYLEdBQWtCLEdBQWxCLEdBQXdCLEtBQUssR0FBN0IsR0FBbUMsR0FBbkMsR0FBeUMsS0FBSyxLQUE5QyxHQUFzRCxHQUF0RCxHQUE0RCxLQUFLLE1BQWpFLEdBQTBFLEdBQWpGO0FBQ0gsQ0FGRDs7QUFJQTs7OztBQUlBLE9BQU8sU0FBUCxDQUFpQixRQUFqQixHQUE0QixZQUFXO0FBQ25DLFdBQU8sQ0FDSCxFQUFDLEdBQUcsS0FBSyxJQUFULEVBQWUsR0FBRyxLQUFLLEdBQXZCLEVBREcsRUFFSCxFQUFDLEdBQUcsS0FBSyxLQUFULEVBQWdCLEdBQUcsS0FBSyxHQUF4QixFQUZHLEVBR0gsRUFBQyxHQUFHLEtBQUssS0FBVCxFQUFnQixHQUFHLEtBQUssTUFBeEIsRUFIRyxFQUlILEVBQUMsR0FBRyxLQUFLLElBQVQsRUFBZSxHQUFHLEtBQUssTUFBdkIsRUFKRyxDQUFQO0FBTUgsQ0FQRDs7QUFTQTs7O0FBR0EsT0FBTyxTQUFQLENBQWlCLFlBQWpCLEdBQWdDLFlBQVc7QUFDdkMsU0FBSyxJQUFMLEdBQVksS0FBSyxLQUFMLENBQVcsS0FBSyxJQUFoQixDQUFaO0FBQ0EsU0FBSyxHQUFMLEdBQVcsS0FBSyxLQUFMLENBQVcsS0FBSyxHQUFoQixDQUFYO0FBQ0EsU0FBSyxLQUFMLEdBQWEsS0FBSyxLQUFMLENBQVcsS0FBSyxLQUFoQixDQUFiO0FBQ0EsU0FBSyxNQUFMLEdBQWMsS0FBSyxLQUFMLENBQVcsS0FBSyxNQUFoQixDQUFkO0FBQ0gsQ0FMRDs7QUFPQTs7O0FBR0EsT0FBTyxTQUFQLENBQWlCLFlBQWpCLEdBQWdDLFlBQVc7QUFDdkMsU0FBSyxJQUFMLEdBQVksS0FBSyxLQUFMLENBQVcsS0FBSyxJQUFoQixDQUFaO0FBQ0EsU0FBSyxHQUFMLEdBQVcsS0FBSyxLQUFMLENBQVcsS0FBSyxHQUFoQixDQUFYO0FBQ0EsU0FBSyxLQUFMLEdBQWEsS0FBSyxJQUFMLENBQVUsS0FBSyxLQUFmLENBQWI7QUFDQSxTQUFLLE1BQUwsR0FBYyxLQUFLLElBQUwsQ0FBVSxLQUFLLE1BQWYsQ0FBZDtBQUNILENBTEQ7O0FBT0E7OztBQUdBLE9BQU8saUJBQVAsR0FBMkIsVUFBUyxNQUFULEVBQWlCO0FBQ3hDLFFBQ0ksU0FBUyxJQUFJLE1BQUosQ0FBVyxPQUFPLENBQVAsRUFBVSxDQUFyQixFQUF3QixPQUFPLENBQVAsRUFBVSxDQUFsQyxFQUFxQyxPQUFPLENBQVAsRUFBVSxDQUEvQyxFQUFrRCxPQUFPLENBQVAsRUFBVSxDQUE1RCxDQURiOztBQUdBLFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQTNCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLGVBQU8sSUFBUCxHQUFjLEtBQUssR0FBTCxDQUFTLE9BQU8sSUFBaEIsRUFBc0IsT0FBTyxDQUFQLEVBQVUsQ0FBaEMsQ0FBZDtBQUNBLGVBQU8sR0FBUCxHQUFhLEtBQUssR0FBTCxDQUFTLE9BQU8sR0FBaEIsRUFBcUIsT0FBTyxDQUFQLEVBQVUsQ0FBL0IsQ0FBYjtBQUNBLGVBQU8sS0FBUCxHQUFlLEtBQUssR0FBTCxDQUFTLE9BQU8sS0FBaEIsRUFBdUIsT0FBTyxDQUFQLEVBQVUsQ0FBakMsQ0FBZjtBQUNBLGVBQU8sTUFBUCxHQUFnQixLQUFLLEdBQUwsQ0FBUyxPQUFPLE1BQWhCLEVBQXdCLE9BQU8sQ0FBUCxFQUFVLENBQWxDLENBQWhCO0FBQ0g7O0FBRUQsV0FBTyxNQUFQO0FBQ0gsQ0FaRDs7QUFjQTs7Ozs7OztBQU9BLE9BQU8sYUFBUCxHQUF1QixJQUFJLE1BQUosQ0FBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLEVBQTBCLEdBQTFCLENBQXZCOzs7Ozs7Ozs7a0JDak93QixXO0FBekJ4Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRWUsU0FBUyxXQUFULEdBQXVCO0FBQ2xDLFNBQUssYUFBTDtBQUNIOztBQUVELFlBQVksU0FBWixDQUFzQixhQUF0QixHQUFzQyxZQUFXO0FBQzdDOzs7Ozs7O0FBT0EsU0FBSyxDQUFMLEdBQVMsQ0FBRSxDQUFGLEVBQUssQ0FBTCxFQUFRLENBQVIsRUFBVyxDQUFYLEVBQWMsQ0FBZCxFQUFpQixDQUFqQixDQUFUO0FBQ0gsQ0FURDs7QUFXQTs7Ozs7OztBQU9BLFlBQVksU0FBWixDQUFzQixRQUF0QixHQUFpQyxVQUFTLE1BQVQsRUFBaUI7QUFDOUMsUUFDSSxNQUFNLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxPQUFPLENBQVAsQ0FBUyxDQUFULENBQVosR0FBMEIsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLE9BQU8sQ0FBUCxDQUFTLENBQVQsQ0FEaEQ7QUFBQSxRQUVJLE1BQU0sS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLE9BQU8sQ0FBUCxDQUFTLENBQVQsQ0FBWixHQUEwQixLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksT0FBTyxDQUFQLENBQVMsQ0FBVCxDQUZoRDtBQUFBLFFBSUksTUFBTSxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksT0FBTyxDQUFQLENBQVMsQ0FBVCxDQUFaLEdBQTBCLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxPQUFPLENBQVAsQ0FBUyxDQUFULENBSmhEO0FBQUEsUUFLSSxNQUFNLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxPQUFPLENBQVAsQ0FBUyxDQUFULENBQVosR0FBMEIsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLE9BQU8sQ0FBUCxDQUFTLENBQVQsQ0FMaEQ7QUFBQSxRQU9JLEtBQUssS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLE9BQU8sQ0FBUCxDQUFTLENBQVQsQ0FBWixHQUEwQixLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksT0FBTyxDQUFQLENBQVMsQ0FBVCxDQUF0QyxHQUFvRCxLQUFLLENBQUwsQ0FBTyxDQUFQLENBUDdEO0FBQUEsUUFRSSxLQUFLLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxPQUFPLENBQVAsQ0FBUyxDQUFULENBQVosR0FBMEIsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLE9BQU8sQ0FBUCxDQUFTLENBQVQsQ0FBdEMsR0FBb0QsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQVI3RDs7QUFVQSxTQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksR0FBWjtBQUNBLFNBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxHQUFaO0FBQ0EsU0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEdBQVo7QUFDQSxTQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksR0FBWjtBQUNBLFNBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxFQUFaO0FBQ0EsU0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEVBQVo7QUFDSCxDQWpCRDs7QUFtQkE7Ozs7Ozs7QUFPQSxZQUFZLFNBQVosQ0FBc0IsV0FBdEIsR0FBb0MsVUFBUyxNQUFULEVBQWlCO0FBQ2pELFFBQ0ksTUFBTSxPQUFPLENBQVAsQ0FBUyxDQUFULElBQWMsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFkLEdBQTBCLE9BQU8sQ0FBUCxDQUFTLENBQVQsSUFBYyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBRGxEO0FBQUEsUUFFSSxNQUFNLE9BQU8sQ0FBUCxDQUFTLENBQVQsSUFBYyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQWQsR0FBMEIsT0FBTyxDQUFQLENBQVMsQ0FBVCxJQUFjLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FGbEQ7QUFBQSxRQUlJLE1BQU0sT0FBTyxDQUFQLENBQVMsQ0FBVCxJQUFjLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBZCxHQUEwQixPQUFPLENBQVAsQ0FBUyxDQUFULElBQWMsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUpsRDtBQUFBLFFBS0ksTUFBTSxPQUFPLENBQVAsQ0FBUyxDQUFULElBQWMsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFkLEdBQTBCLE9BQU8sQ0FBUCxDQUFTLENBQVQsSUFBYyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBTGxEO0FBQUEsUUFPSSxLQUFLLE9BQU8sQ0FBUCxDQUFTLENBQVQsSUFBYyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQWQsR0FBMEIsT0FBTyxDQUFQLENBQVMsQ0FBVCxJQUFjLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBeEMsR0FBb0QsT0FBTyxDQUFQLENBQVMsQ0FBVCxDQVA3RDtBQUFBLFFBUUksS0FBSyxPQUFPLENBQVAsQ0FBUyxDQUFULElBQWMsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFkLEdBQTBCLE9BQU8sQ0FBUCxDQUFTLENBQVQsSUFBYyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQXhDLEdBQW9ELE9BQU8sQ0FBUCxDQUFTLENBQVQsQ0FSN0Q7O0FBVUEsU0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEdBQVo7QUFDQSxTQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksR0FBWjtBQUNBLFNBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxHQUFaO0FBQ0EsU0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEdBQVo7QUFDQSxTQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksRUFBWjtBQUNBLFNBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxFQUFaO0FBQ0gsQ0FqQkQ7O0FBbUJBLFlBQVksU0FBWixDQUFzQixNQUF0QixHQUErQixZQUFXO0FBQ3RDLFFBQ0ksSUFBSSxLQUFLLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQVosR0FBd0IsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBekMsQ0FEUjtBQUFBLFFBRUksS0FBSyxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksQ0FGckI7QUFBQSxRQUdJLEtBQUssQ0FBQyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQUQsR0FBYSxDQUh0QjtBQUFBLFFBSUksS0FBSyxDQUFDLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBRCxHQUFhLENBSnRCO0FBQUEsUUFLSSxLQUFLLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxDQUxyQjtBQUFBLFFBTUksS0FBSyxLQUFLLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQVosR0FBd0IsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBekMsQ0FOVDtBQUFBLFFBT0ksS0FBSyxLQUFLLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQVosR0FBd0IsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBekMsQ0FQVDs7QUFTQSxTQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksRUFBWjtBQUNBLFNBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxFQUFaO0FBQ0EsU0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEVBQVo7QUFDQSxTQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksRUFBWjtBQUNBLFNBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxFQUFaO0FBQ0EsU0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEVBQVo7QUFDSCxDQWhCRDs7QUFrQkEsWUFBWSxTQUFaLENBQXNCLFdBQXRCLEdBQW9DLFlBQVc7QUFDM0MsUUFDSSxTQUFTLElBQUksV0FBSixFQURiOztBQUdBLFdBQU8sQ0FBUCxDQUFTLENBQVQsSUFBYyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQWQ7QUFDQSxXQUFPLENBQVAsQ0FBUyxDQUFULElBQWMsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFkO0FBQ0EsV0FBTyxDQUFQLENBQVMsQ0FBVCxJQUFjLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBZDtBQUNBLFdBQU8sQ0FBUCxDQUFTLENBQVQsSUFBYyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQWQ7QUFDQSxXQUFPLENBQVAsQ0FBUyxDQUFULElBQWMsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFkO0FBQ0EsV0FBTyxDQUFQLENBQVMsQ0FBVCxJQUFjLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBZDs7QUFFQSxXQUFPLE1BQVA7O0FBRUEsV0FBTyxNQUFQO0FBQ0gsQ0FkRDs7QUFnQkE7Ozs7Ozs7QUFPQSxZQUFZLFNBQVosQ0FBc0IsTUFBdEIsR0FBK0IsVUFBUyxHQUFULEVBQWM7QUFDekMsUUFDSSxJQUFJLEtBQUssR0FBTCxDQUFTLEdBQVQsQ0FEUjtBQUFBLFFBRUksSUFBSSxLQUFLLEdBQUwsQ0FBUyxHQUFULENBRlI7QUFBQSxRQUlJLE1BQU0sS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLENBQVosR0FBZ0IsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLENBSnRDO0FBQUEsUUFLSSxNQUFNLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxDQUFaLEdBQWdCLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxDQUx0QztBQUFBLFFBTUksTUFBTSxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksQ0FBQyxDQUFiLEdBQWlCLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxDQU52QztBQUFBLFFBT0ksTUFBTSxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksQ0FBQyxDQUFiLEdBQWlCLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxDQVB2Qzs7QUFTQSxTQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksR0FBWjtBQUNBLFNBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxHQUFaO0FBQ0EsU0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEdBQVo7QUFDQSxTQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksR0FBWjtBQUNILENBZEQ7O0FBZ0JBLFlBQVksU0FBWixDQUFzQixpQkFBdEIsR0FBMEMsVUFBUyxHQUFULEVBQWMsQ0FBZCxFQUFpQixDQUFqQixFQUFvQjtBQUMxRCxTQUFLLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLENBQWxCO0FBQ0EsU0FBSyxNQUFMLENBQVksR0FBWjtBQUNBLFNBQUssU0FBTCxDQUFlLENBQUMsQ0FBaEIsRUFBbUIsQ0FBQyxDQUFwQjtBQUNILENBSkQ7O0FBTUE7Ozs7Ozs7Ozs7QUFVQSxZQUFZLFNBQVosQ0FBc0IsU0FBdEIsR0FBa0MsVUFBUyxDQUFULEVBQVksQ0FBWixFQUFlO0FBQzdDLFNBQUssQ0FBTCxDQUFPLENBQVAsS0FBYSxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksQ0FBWixHQUFnQixLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksQ0FBekM7QUFDQSxTQUFLLENBQUwsQ0FBTyxDQUFQLEtBQWEsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLENBQVosR0FBZ0IsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLENBQXpDO0FBQ0gsQ0FIRDs7QUFLQTs7Ozs7Ozs7OztBQVVBLFlBQVksU0FBWixDQUFzQixLQUF0QixHQUE4QixVQUFTLEVBQVQsRUFBYSxFQUFiLEVBQWlCO0FBQzNDLFNBQUssQ0FBTCxDQUFPLENBQVAsS0FBYSxFQUFiO0FBQ0EsU0FBSyxDQUFMLENBQU8sQ0FBUCxLQUFhLEVBQWI7QUFDQSxTQUFLLENBQUwsQ0FBTyxDQUFQLEtBQWEsRUFBYjtBQUNBLFNBQUssQ0FBTCxDQUFPLENBQVAsS0FBYSxFQUFiO0FBQ0gsQ0FMRDs7QUFPQSxZQUFZLFNBQVosQ0FBc0IsZ0JBQXRCLEdBQXlDLFVBQVMsRUFBVCxFQUFhLEVBQWIsRUFBaUIsRUFBakIsRUFBcUIsRUFBckIsRUFBeUI7QUFDOUQsU0FBSyxTQUFMLENBQWUsRUFBZixFQUFtQixFQUFuQjtBQUNBLFNBQUssS0FBTCxDQUFXLEVBQVgsRUFBZSxFQUFmO0FBQ0EsU0FBSyxTQUFMLENBQWUsQ0FBQyxFQUFoQixFQUFvQixDQUFDLEVBQXJCO0FBQ0gsQ0FKRDs7QUFNQTs7Ozs7Ozs7OztBQVVBLFlBQVksU0FBWixDQUFzQixLQUF0QixHQUE4QixVQUFTLENBQVQsRUFBWSxDQUFaLEVBQWU7QUFDM0MsUUFDSSxNQUFNLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksQ0FEbEM7QUFBQSxRQUVJLE1BQU0sS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxDQUZsQztBQUFBLFFBR0ksTUFBTSxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLENBSGxDO0FBQUEsUUFJSSxNQUFNLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksQ0FKbEM7O0FBTUUsU0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEdBQVo7QUFDQSxTQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksR0FBWjtBQUNBLFNBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxHQUFaO0FBQ0EsU0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEdBQVo7QUFDSCxDQVhEOztBQWFBLFlBQVksU0FBWixDQUFzQixtQkFBdEIsR0FBNEMsVUFBUyxDQUFULEVBQVk7QUFDcEQsV0FBTztBQUNILFdBQUcsRUFBRSxDQUFGLEdBQU0sS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFOLEdBQWtCLEVBQUUsQ0FBRixHQUFNLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBeEIsR0FBb0MsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQURwQztBQUVILFdBQUcsRUFBRSxDQUFGLEdBQU0sS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFOLEdBQWtCLEVBQUUsQ0FBRixHQUFNLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBeEIsR0FBb0MsS0FBSyxDQUFMLENBQU8sQ0FBUDtBQUZwQyxLQUFQO0FBSUgsQ0FMRDs7QUFPQSxZQUFZLFNBQVosQ0FBc0IsZUFBdEIsR0FBd0MsVUFBUyxNQUFULEVBQWlCO0FBQ3JELFNBQUssSUFBSSxJQUFJLENBQWIsRUFBZ0IsSUFBSSxPQUFPLE1BQTNCLEVBQW1DLEdBQW5DLEVBQXdDO0FBQ3BDLGVBQU8sQ0FBUCxJQUFZLEtBQUssbUJBQUwsQ0FBeUIsT0FBTyxDQUFQLENBQXpCLENBQVo7QUFDSDtBQUNKLENBSkQ7O0FBTUEsWUFBWSxTQUFaLENBQXNCLGFBQXRCLEdBQXNDLFlBQVc7QUFDN0MsV0FBTyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQVA7QUFDSCxDQUZEOztBQUlBLFlBQVksU0FBWixDQUFzQixhQUF0QixHQUFzQyxZQUFXO0FBQzdDLFdBQU8sS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFQO0FBQ0gsQ0FGRDs7QUFJQSxZQUFZLFNBQVosQ0FBc0IsS0FBdEIsR0FBOEIsWUFBVztBQUNyQyxRQUNJLFNBQVMsSUFBSSxXQUFKLEVBRGI7O0FBR0EsV0FBTyxDQUFQLENBQVMsQ0FBVCxJQUFjLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBZDtBQUNBLFdBQU8sQ0FBUCxDQUFTLENBQVQsSUFBYyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQWQ7QUFDQSxXQUFPLENBQVAsQ0FBUyxDQUFULElBQWMsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFkO0FBQ0EsV0FBTyxDQUFQLENBQVMsQ0FBVCxJQUFjLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBZDtBQUNBLFdBQU8sQ0FBUCxDQUFTLENBQVQsSUFBYyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQWQ7QUFDQSxXQUFPLENBQVAsQ0FBUyxDQUFULElBQWMsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFkOztBQUVBLFdBQU8sTUFBUDtBQUNILENBWkQ7O0FBY0EsWUFBWSxTQUFaLENBQXNCLGNBQXRCLEdBQXVDLFlBQVc7QUFDOUMsV0FBTyxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFaLEdBQXdCLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQTNDO0FBQ0gsQ0FGRDs7QUFJQTs7Ozs7OztBQU9BLFlBQVksU0FBWixDQUFzQixTQUF0QixHQUFrQyxZQUFXO0FBQ3pDLFFBQ0ksY0FBYyxLQUFLLGNBQUwsRUFEbEI7QUFBQSxRQUVJLElBQUksS0FBSyxJQUFMLENBQVUsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLEtBQUssQ0FBTCxDQUFPLENBQVAsQ0FBWixHQUF3QixLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUE5QyxDQUZSOztBQUlBLFdBQU87QUFDSCxtQkFBVyxFQUFDLEdBQUcsS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFKLEVBQWUsR0FBRyxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQWxCLEVBRFI7QUFFSCxnQkFBUSxLQUFLLElBQUwsQ0FBVSxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQVYsSUFBdUIsS0FBSyxJQUFMLENBQVUsS0FBSyxDQUFMLENBQU8sQ0FBUCxJQUFZLENBQXRCLENBRjVCO0FBR0gsZUFBTyxFQUFDLEdBQUcsQ0FBSixFQUFPLEdBQUcsY0FBYyxDQUF4QixFQUhKO0FBSUgsZUFBTyxFQUFDLEdBQUcsS0FBSyxJQUFMLENBQVUsQ0FBQyxLQUFLLENBQUwsQ0FBTyxDQUFQLElBQVksS0FBSyxDQUFMLENBQU8sQ0FBUCxDQUFaLEdBQXdCLEtBQUssQ0FBTCxDQUFPLENBQVAsSUFBWSxLQUFLLENBQUwsQ0FBTyxDQUFQLENBQXJDLEtBQW1ELElBQUksQ0FBdkQsQ0FBVixDQUFKLEVBQTBFLEdBQUcsQ0FBN0U7QUFKSixLQUFQO0FBTUgsQ0FYRDs7QUFhQSxZQUFZLFNBQVosQ0FBc0IsUUFBdEIsR0FBaUMsWUFBVztBQUN4QyxRQUNJLFNBQVMsQ0FEYjs7QUFHQSxXQUFRLE1BQU0sS0FBSyxDQUFMLENBQU8sQ0FBUCxFQUFVLE9BQVYsQ0FBa0IsTUFBbEIsQ0FBTixHQUFrQyxHQUFsQyxHQUF3QyxLQUFLLENBQUwsQ0FBTyxDQUFQLEVBQVUsT0FBVixDQUFrQixNQUFsQixDQUF4QyxHQUFvRSxHQUFwRSxHQUEwRSxLQUFLLENBQUwsQ0FBTyxDQUFQLEVBQVUsT0FBVixDQUFrQixNQUFsQixDQUExRSxHQUFzRyxLQUF0RyxHQUNELEdBREMsR0FDSyxLQUFLLENBQUwsQ0FBTyxDQUFQLEVBQVUsT0FBVixDQUFrQixNQUFsQixDQURMLEdBQ2lDLEdBRGpDLEdBQ3VDLEtBQUssQ0FBTCxDQUFPLENBQVAsRUFBVSxPQUFWLENBQWtCLE1BQWxCLENBRHZDLEdBQ21FLEdBRG5FLEdBQ3lFLEtBQUssQ0FBTCxDQUFPLENBQVAsRUFBVSxPQUFWLENBQWtCLE1BQWxCLENBRHpFLEdBQ3FHLEtBRHJHLEdBRUQsa0JBRlA7QUFHSCxDQVBEOztBQVNBLEtBQUssSUFBTCxHQUFZLEtBQUssSUFBTCxJQUFhLFVBQVMsQ0FBVCxFQUFZO0FBQ2pDLFFBQUksQ0FBQyxDQUFMLENBRGlDLENBQ3pCO0FBQ1IsUUFBSSxNQUFNLENBQU4sSUFBVyxNQUFNLENBQU4sQ0FBZixFQUF5QjtBQUNyQixlQUFPLENBQVA7QUFDSDtBQUNELFdBQU8sSUFBSSxDQUFKLEdBQVEsQ0FBUixHQUFZLENBQUMsQ0FBcEI7QUFDSCxDQU5EOzs7Ozs7Ozs7a0JDdFF3QixRO0FBdEJ4Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQXNCZSxTQUFTLFFBQVQsQ0FBa0IsQ0FBbEIsRUFBcUIsQ0FBckIsRUFBd0I7QUFDdEMsTUFBSyxDQUFMLEdBQVMsQ0FBVDtBQUNBLE1BQUssQ0FBTCxHQUFTLENBQVQ7QUFDQTs7QUFFRCxTQUFTLFNBQVQsQ0FBbUIsU0FBbkIsR0FBK0IsWUFBVztBQUN6QyxRQUFPLEtBQUssSUFBTCxDQUFVLEtBQUssQ0FBTCxHQUFTLEtBQUssQ0FBZCxHQUFrQixLQUFLLENBQUwsR0FBUyxLQUFLLENBQTFDLENBQVA7QUFDQSxDQUZEOztBQUlBOzs7O0FBSUEsU0FBUyxTQUFULENBQW1CLFNBQW5CLEdBQStCLFlBQVc7QUFDekMsS0FDQyxTQUFTLEtBQUssU0FBTCxFQURWOztBQUdBLE1BQUssQ0FBTCxJQUFVLE1BQVY7QUFDQSxNQUFLLENBQUwsSUFBVSxNQUFWOztBQUVBLFFBQU8sSUFBUDtBQUNBLENBUkQ7O0FBVUE7Ozs7QUFJQSxTQUFTLFNBQVQsQ0FBbUIsYUFBbkIsR0FBbUMsVUFBUyxJQUFULEVBQWU7QUFDakQsUUFBTyxLQUFLLENBQUwsR0FBUyxLQUFLLENBQWQsR0FBa0IsS0FBSyxDQUFMLEdBQVMsS0FBSyxDQUF2QztBQUNBLENBRkQ7O0FBSUE7Ozs7O0FBS0EsU0FBUyxTQUFULENBQW1CLEtBQW5CLEdBQTJCLFVBQVMsV0FBVCxFQUFzQjtBQUNoRCxNQUFLLENBQUwsSUFBVSxXQUFWO0FBQ0EsTUFBSyxDQUFMLElBQVUsV0FBVjs7QUFFQSxRQUFPLElBQVA7QUFDQSxDQUxEOztBQU9BLFNBQVMsU0FBVCxDQUFtQixTQUFuQixHQUErQixVQUFTLFdBQVQsRUFBc0I7QUFDcEQsS0FDQyxTQUFTLElBQUksUUFBSixDQUFhLEtBQUssQ0FBbEIsRUFBcUIsS0FBSyxDQUExQixDQURWOztBQUdBLFFBQU8sS0FBUCxDQUFhLFdBQWI7O0FBRUEsUUFBTyxNQUFQO0FBQ0EsQ0FQRDs7QUFTQSxTQUFTLFNBQVQsQ0FBbUIsVUFBbkIsR0FBZ0MsWUFBVztBQUMxQyxRQUFPLElBQUksUUFBSixDQUFhLEtBQUssS0FBTCxDQUFXLEtBQUssQ0FBaEIsQ0FBYixFQUFpQyxLQUFLLEtBQUwsQ0FBVyxLQUFLLENBQWhCLENBQWpDLENBQVA7QUFDQSxDQUZEOztBQUlBLFNBQVMsU0FBVCxDQUFtQixZQUFuQixHQUFrQyxZQUFXO0FBQzVDLFFBQU8sSUFBSSxRQUFKLENBQWEsQ0FBQyxDQUFDLEtBQUssQ0FBcEIsRUFBdUIsQ0FBQyxDQUFDLEtBQUssQ0FBOUIsQ0FBUDtBQUNBLENBRkQ7O0FBSUEsU0FBUyxTQUFULENBQW1CLGdCQUFuQixHQUFzQyxZQUFXO0FBQ2hELFFBQU8sSUFBSSxRQUFKLENBQWEsQ0FBQyxLQUFLLENBQW5CLEVBQXNCLEtBQUssQ0FBM0IsQ0FBUDtBQUNBLENBRkQ7O0FBSUE7Ozs7OztBQU1BLFNBQVMsU0FBVCxDQUFtQixHQUFuQixHQUF5QixVQUFTLElBQVQsRUFBZTtBQUN2QyxNQUFLLENBQUwsSUFBVSxLQUFLLENBQWY7QUFDQSxNQUFLLENBQUwsSUFBVSxLQUFLLENBQWY7O0FBRUEsUUFBTyxJQUFQO0FBQ0EsQ0FMRDs7QUFPQTs7Ozs7O0FBTUEsU0FBUyxTQUFULENBQW1CLFFBQW5CLEdBQThCLFVBQVMsSUFBVCxFQUFlO0FBQzVDLE1BQUssQ0FBTCxJQUFVLEtBQUssQ0FBZjtBQUNBLE1BQUssQ0FBTCxJQUFVLEtBQUssQ0FBZjs7QUFFQSxRQUFPLElBQVA7QUFDQSxDQUxEOztBQVFBOzs7Ozs7QUFNQSxTQUFTLFNBQVQsQ0FBbUIsTUFBbkIsR0FBNEIsVUFBUyxJQUFULEVBQWU7QUFDMUMsUUFBTyxJQUFJLFFBQUosQ0FBYSxLQUFLLENBQUwsR0FBUyxLQUFLLENBQTNCLEVBQThCLEtBQUssQ0FBTCxHQUFTLEtBQUssQ0FBNUMsQ0FBUDtBQUNBLENBRkQ7O0FBSUE7Ozs7Ozs7O0FBUUEsU0FBUyxjQUFULEdBQTBCLFVBQVMsRUFBVCxFQUFhLEVBQWIsRUFBaUI7QUFDMUMsUUFBTyxJQUFJLFFBQUosQ0FBYSxHQUFHLENBQUgsR0FBTyxHQUFHLENBQXZCLEVBQTBCLEdBQUcsQ0FBSCxHQUFPLEdBQUcsQ0FBcEMsQ0FBUDtBQUNBLENBRkQ7Ozs7Ozs7OztrQkM3R3dCLGE7QUF0QnhCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBc0JlLFNBQVMsYUFBVCxHQUF5QjtBQUNwQyxRQUNJLFNBQVMsSUFEYjtBQUFBLFFBRUksWUFGSjtBQUFBLFFBSUksT0FBTyxJQUpYOztBQU1BOzs7QUFHQSxTQUFLLEtBQUwsR0FBYSxZQUFXO0FBQ3BCLFlBQ0ksV0FESjs7QUFHQSxZQUFJLE1BQUosRUFBWTtBQUNSLDBCQUFjLE9BQU8sV0FBckI7O0FBRUEsbUJBQU8sZUFBZSxDQUFmLENBQWlCLFNBQWpCLElBQThCLGVBQWUsQ0FBcEQsQ0FBc0QsWUFBdEQ7QUFDSDs7QUFFRCxlQUFPLEtBQVA7QUFDSCxLQVhEOztBQWFBLFNBQUssV0FBTCxHQUFtQixZQUFXO0FBQzFCLFlBQUksTUFBSixFQUFZO0FBQ1IsbUJBQU8sT0FBTyxRQUFkO0FBQ0g7O0FBRUQsZUFBTyxHQUFQO0FBQ0gsS0FORDs7QUFRQSxTQUFLLFlBQUwsR0FBb0IsWUFBVztBQUMzQixnQkFBUSxHQUFSLENBQVksOEJBQVo7O0FBRUEsaUJBQVMsYUFBYSxNQUF0QjtBQUNILEtBSkQ7O0FBTUEsU0FBSyxlQUFMLEdBQXVCLFlBQVc7QUFDOUIsZUFBTyxDQUFDLENBQUMsTUFBVDtBQUNILEtBRkQ7O0FBSUE7OztBQUdBLFNBQUssWUFBTCxHQUFvQixZQUFXO0FBQzNCO0FBQ0EsWUFBSSxVQUFVLElBQVYsQ0FBZSxVQUFVLFNBQXpCLEtBQXVDLENBQUMsTUFBTSxJQUFOLENBQVcsVUFBVSxTQUFyQixDQUE1QyxFQUE2RTtBQUN6RTtBQUNBLG9CQUFRLEdBQVIsQ0FBWSxrRUFBWjtBQUNBO0FBQ0g7O0FBRUQsZ0JBQVEsR0FBUixDQUFZLDRDQUFaOztBQUVBLHVCQUFlLFNBQVMsYUFBVCxDQUF1QixRQUF2QixDQUFmOztBQUVBLFlBQUksYUFBYSxZQUFqQixFQUErQjtBQUFFO0FBQzdCLHlCQUFhLE9BQWIsR0FBdUIsNENBQXZCO0FBQ0gsU0FGRCxNQUVPO0FBQ0gsZ0JBQ0ksUUFBUSxTQUFTLGFBQVQsQ0FBdUIsT0FBdkIsQ0FEWjs7QUFHQSxrQkFBTSxJQUFOLEdBQWEsUUFBYjtBQUNBLGtCQUFNLEtBQU4sR0FBYyxxQkFBZDs7QUFFQSx5QkFBYSxXQUFiLENBQXlCLEtBQXpCOztBQUVBLHlCQUFhLElBQWIsR0FBb0IsaUNBQXBCO0FBQ0g7O0FBRUQscUJBQWEsS0FBYixDQUFtQixRQUFuQixHQUE4QixVQUE5QjtBQUNBLHFCQUFhLEtBQWIsQ0FBbUIsVUFBbkIsR0FBZ0MsUUFBaEM7QUFDQSxxQkFBYSxNQUFiLEdBQXNCLHFCQUF0Qjs7QUFFQSxpQkFBUyxJQUFULENBQWMsV0FBZCxDQUEwQixZQUExQjs7QUFFQSxtQkFBVyxZQUFXO0FBQ2xCLGdCQUFJLENBQUMsS0FBSyxlQUFMLEVBQUwsRUFBNkI7QUFDekIsd0JBQVEsR0FBUixDQUFZLGlFQUFaO0FBQ0g7QUFDSixTQUpELEVBSUcsSUFKSDtBQUtILEtBckNEO0FBc0NIOztBQUVELGNBQWMsTUFBZCxHQUF1QixZQUFXO0FBQzlCLFFBQUksY0FBYyxRQUFkLElBQTBCLElBQTlCLEVBQW9DO0FBQ2hDLHNCQUFjLFFBQWQsR0FBeUIsSUFBSSxhQUFKLEVBQXpCO0FBQ0g7QUFDRCxXQUFPLGNBQWMsUUFBckI7QUFDSCxDQUxEOztBQU9BLE9BQU8sbUJBQVAsR0FBNkIsWUFBVztBQUNwQyxrQkFBYyxNQUFkLEdBQXVCLFlBQXZCO0FBQ0gsQ0FGRDs7Ozs7Ozs7O1FDZGdCLFEsR0FBQSxRO1FBcUhBLFEsR0FBQSxRO0FBeE5oQjs7Ozs7Ozs7O0FBU0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVPLFNBQVMsUUFBVCxDQUFrQixLQUFsQixFQUF5QixXQUF6QixFQUFzQyxRQUF0QyxFQUFnRCxhQUFoRCxFQUErRDtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxLQUFJLFVBQUo7OztBQUVBO0FBQ0MsYUFBWSxDQUhiOztBQUtBO0FBQ0EsS0FBSSxPQUFPLFdBQVAsS0FBdUIsU0FBM0IsRUFBc0M7QUFDckMsa0JBQWdCLFFBQWhCO0FBQ0EsYUFBVyxXQUFYO0FBQ0EsZ0JBQWMsU0FBZDtBQUNBOztBQUVEO0FBQ0E7QUFDQTtBQUNBLFVBQVMsT0FBVCxHQUFtQjtBQUNsQixNQUFJLE9BQU8sSUFBWDtBQUFBLE1BQ0MsVUFBVSxDQUFDLElBQUksSUFBSixFQUFELEdBQWMsU0FEekI7QUFBQSxNQUVDLE9BQU8sU0FGUjs7QUFJQTtBQUNBLFdBQVMsSUFBVCxHQUFnQjtBQUNmLGVBQVksQ0FBQyxJQUFJLElBQUosRUFBYjtBQUNBLFlBQVMsS0FBVCxDQUFlLElBQWYsRUFBcUIsSUFBckI7QUFDQTs7QUFFRDtBQUNBO0FBQ0EsV0FBUyxLQUFULEdBQWlCO0FBQ2hCLGdCQUFhLFNBQWI7QUFDQTs7QUFFRCxNQUFJLGlCQUFpQixDQUFDLFVBQXRCLEVBQWtDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBOztBQUVEO0FBQ0EsZ0JBQWMsYUFBYSxVQUFiLENBQWQ7O0FBRUEsTUFBSSxrQkFBa0IsU0FBbEIsSUFBK0IsVUFBVSxLQUE3QyxFQUFvRDtBQUNuRDtBQUNBO0FBQ0E7QUFFQSxHQUxELE1BS08sSUFBSSxnQkFBZ0IsSUFBcEIsRUFBMEI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWEsV0FBVyxnQkFBZ0IsS0FBaEIsR0FBd0IsSUFBbkMsRUFBeUMsa0JBQWtCLFNBQWxCLEdBQThCLFFBQVEsT0FBdEMsR0FBZ0QsS0FBekYsQ0FBYjtBQUNBO0FBQ0Q7O0FBRUQ7QUFDQSxRQUFPLE9BQVA7QUFDQTs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRU8sU0FBUyxRQUFULENBQWtCLEtBQWxCLEVBQXlCLFFBQXpCLEVBQW1DLFFBQW5DLEVBQTZDO0FBQ25ELFFBQU8sYUFBYSxTQUFiLEdBQ0osU0FBUyxLQUFULEVBQWdCLFFBQWhCLEVBQTBCLEtBQTFCLENBREksR0FFSixTQUFTLEtBQVQsRUFBZ0IsUUFBaEIsRUFBMEIsYUFBYSxLQUF2QyxDQUZIO0FBR0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLypcbiAgICBDaGlja2VuUGFpbnRcblxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG5cbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ1BCcnVzaEluZm8gZnJvbSBcIi4vZW5naW5lL0NQQnJ1c2hJbmZvXCI7XG5pbXBvcnQgQ1BBcnR3b3JrIGZyb20gXCIuL2VuZ2luZS9DUEFydHdvcmtcIjtcbmltcG9ydCBDUFJlc291cmNlTG9hZGVyIGZyb20gXCIuL2VuZ2luZS9DUFJlc291cmNlTG9hZGVyXCI7XG5pbXBvcnQgQ1BSZXNvdXJjZVNhdmVyIGZyb20gXCIuL2VuZ2luZS9DUFJlc291cmNlU2F2ZXJcIjtcblxuaW1wb3J0IENQU3Bhc2hTY3JlZW4gZnJvbSBcIi4vZ3VpL0NQU3BsYXNoU2NyZWVuLmpzXCI7XG5cbmltcG9ydCBDUE1haW5HVUkgZnJvbSBcIi4vZ3VpL0NQTWFpbkdVSVwiO1xuXG5pbXBvcnQgQ1BBYm91dERpYWxvZyBmcm9tIFwiLi9ndWkvQ1BBYm91dERpYWxvZ1wiO1xuaW1wb3J0IENQQ29uZmlybVRyYW5zZm9ybURpYWxvZyBmcm9tIFwiLi9ndWkvQ1BDb25maXJtVHJhbnNmb3JtRGlhbG9nXCI7XG5pbXBvcnQgQ1BTaG9ydGN1dHNEaWFsb2cgZnJvbSBcIi4vZ3VpL0NQU2hvcnRjdXRzRGlhbG9nXCI7XG5pbXBvcnQgQ1BCb3hCbHVyRGlhbG9nIGZyb20gXCIuL2d1aS9DUEJveEJsdXJEaWFsb2dcIjtcbmltcG9ydCBDUFRhYmxldERpYWxvZyBmcm9tIFwiLi9ndWkvQ1BUYWJsZXREaWFsb2dcIjtcbmltcG9ydCBDUEdyaWREaWFsb2cgZnJvbSBcIi4vZ3VpL0NQR3JpZERpYWxvZ1wiO1xuaW1wb3J0IENQU2VuZERpYWxvZyBmcm9tIFwiLi9ndWkvQ1BTZW5kRGlhbG9nXCI7XG5cblxuaW1wb3J0IHtpc0NhbnZhc0ludGVycG9sYXRpb25TdXBwb3J0ZWQsIGlzRXZlbnRTdXBwb3J0ZWQsIGlzQ2FudmFzU3VwcG9ydGVkfSBmcm9tIFwiLi91dGlsL0NQUG9seWZpbGxcIjtcbmltcG9ydCBDUENvbG9yIGZyb20gXCIuL3V0aWwvQ1BDb2xvclwiO1xuaW1wb3J0IENQV2Fjb21UYWJsZXQgZnJvbSBcIi4vdXRpbC9DUFdhY29tVGFibGV0XCI7XG5pbXBvcnQgQ1BSZWN0IGZyb20gXCIuL3V0aWwvQ1BSZWN0XCI7XG5cbmZ1bmN0aW9uIGlzQnJvd3NlclN1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gaXNDYW52YXNTdXBwb3J0ZWQoKSAmJiBcIlVpbnQ4QXJyYXlcIiBpbiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURyYXdpbmdUb29scygpIHtcbiAgICB2YXJcbiAgICAgICAgdG9vbHMgPSBuZXcgQXJyYXkoQ2hpY2tlblBhaW50LlRfTUFYKTtcblxuICAgIHRvb2xzW0NoaWNrZW5QYWludC5UX1BFTkNJTF0gPSBuZXcgQ1BCcnVzaEluZm8oe1xuICAgICAgICB0b29sTmI6IENoaWNrZW5QYWludC5UX1BFTkNJTCxcbiAgICAgICAgc2l6ZTogMTYsXG4gICAgICAgIGFscGhhOiAyNTUsXG4gICAgICAgIGlzQUE6IHRydWUsXG4gICAgICAgIG1pblNwYWNpbmc6IDAuNSxcbiAgICAgICAgc3BhY2luZzogMC4wNSxcbiAgICAgICAgcHJlc3N1cmVTaXplOiBmYWxzZSxcbiAgICAgICAgcHJlc3N1cmVBbHBoYTogdHJ1ZSxcbiAgICAgICAgdHlwZTogQ1BCcnVzaEluZm8uQl9ST1VORF9BQSxcbiAgICAgICAgcGFpbnRNb2RlOiBDUEJydXNoSW5mby5NX1BBSU5UXG4gICAgfSk7XG5cbiAgICB0b29sc1tDaGlja2VuUGFpbnQuVF9FUkFTRVJdID0gbmV3IENQQnJ1c2hJbmZvKHtcbiAgICAgICAgdG9vbE5iOiBDaGlja2VuUGFpbnQuVF9FUkFTRVIsXG4gICAgICAgIHNpemU6IDE2LFxuICAgICAgICBhbHBoYTogMjU1LFxuICAgICAgICBpc0FBOiB0cnVlLFxuICAgICAgICBtaW5TcGFjaW5nOiAwLjUsXG4gICAgICAgIHNwYWNpbmc6IDAuMDUsXG4gICAgICAgIHByZXNzdXJlU2l6ZTogZmFsc2UsXG4gICAgICAgIHByZXNzdXJlQWxwaGE6IGZhbHNlLFxuICAgICAgICB0eXBlOiBDUEJydXNoSW5mby5CX1JPVU5EX0FBLFxuICAgICAgICBwYWludE1vZGU6IENQQnJ1c2hJbmZvLk1fRVJBU0VcbiAgICB9KTtcblxuICAgIHRvb2xzW0NoaWNrZW5QYWludC5UX1BFTl0gPSBuZXcgQ1BCcnVzaEluZm8oe1xuICAgICAgICB0b29sTmI6IENoaWNrZW5QYWludC5UX1BFTixcbiAgICAgICAgc2l6ZTogMixcbiAgICAgICAgYWxwaGE6IDEyOCxcbiAgICAgICAgaXNBQTogdHJ1ZSxcbiAgICAgICAgbWluU3BhY2luZzogMC41LFxuICAgICAgICBzcGFjaW5nOiAwLjA1LFxuICAgICAgICBwcmVzc3VyZVNpemU6IHRydWUsXG4gICAgICAgIHByZXNzdXJlQWxwaGE6IGZhbHNlLFxuICAgICAgICB0eXBlOiBDUEJydXNoSW5mby5CX1JPVU5EX0FBLFxuICAgICAgICBwYWludE1vZGU6IENQQnJ1c2hJbmZvLk1fUEFJTlRcbiAgICB9KTtcblxuICAgIHRvb2xzW0NoaWNrZW5QYWludC5UX1NPRlRFUkFTRVJdID0gbmV3IENQQnJ1c2hJbmZvKHtcbiAgICAgICAgdG9vbE5iOiBDaGlja2VuUGFpbnQuVF9TT0ZURVJBU0VSLFxuICAgICAgICBzaXplOiAxNixcbiAgICAgICAgYWxwaGE6IDY0LFxuICAgICAgICBpc0FBOiBmYWxzZSxcbiAgICAgICAgaXNBaXJicnVzaDogdHJ1ZSxcbiAgICAgICAgbWluU3BhY2luZzogMC41LFxuICAgICAgICBzcGFjaW5nOiAwLjA1LFxuICAgICAgICBwcmVzc3VyZVNpemU6IGZhbHNlLFxuICAgICAgICBwcmVzc3VyZUFscGhhOiB0cnVlLFxuICAgICAgICB0eXBlOiBDUEJydXNoSW5mby5CX1JPVU5EX0FJUkJSVVNILFxuICAgICAgICBwYWludE1vZGU6IENQQnJ1c2hJbmZvLk1fRVJBU0VcbiAgICB9KTtcblxuICAgIHRvb2xzW0NoaWNrZW5QYWludC5UX0FJUkJSVVNIXSA9IG5ldyBDUEJydXNoSW5mbyh7XG4gICAgICAgIHRvb2xOYjogQ2hpY2tlblBhaW50LlRfQUlSQlJVU0gsXG4gICAgICAgIHNpemU6IDUwLFxuICAgICAgICBhbHBoYTogMzIsXG4gICAgICAgIGlzQUE6IGZhbHNlLFxuICAgICAgICBpc0FpcmJydXNoOiB0cnVlLFxuICAgICAgICBtaW5TcGFjaW5nOiAwLjUsXG4gICAgICAgIHNwYWNpbmc6IDAuMDUsXG4gICAgICAgIHByZXNzdXJlU2l6ZTogZmFsc2UsXG4gICAgICAgIHByZXNzdXJlQWxwaGE6IHRydWUsXG4gICAgICAgIHR5cGU6IENQQnJ1c2hJbmZvLkJfUk9VTkRfQUlSQlJVU0gsXG4gICAgICAgIHBhaW50TW9kZTogQ1BCcnVzaEluZm8uTV9QQUlOVFxuICAgIH0pO1xuXG4gICAgdG9vbHNbQ2hpY2tlblBhaW50LlRfRE9ER0VdID0gbmV3IENQQnJ1c2hJbmZvKHtcbiAgICAgICAgdG9vbE5iOiBDaGlja2VuUGFpbnQuVF9ET0RHRSxcbiAgICAgICAgc2l6ZTogMzAsXG4gICAgICAgIGFscGhhOiAzMixcbiAgICAgICAgaXNBQTogZmFsc2UsXG4gICAgICAgIGlzQWlyYnJ1c2g6IHRydWUsXG4gICAgICAgIG1pblNwYWNpbmc6IDAuNSxcbiAgICAgICAgc3BhY2luZzogMC4wNSxcbiAgICAgICAgcHJlc3N1cmVTaXplOiBmYWxzZSxcbiAgICAgICAgcHJlc3N1cmVBbHBoYTogdHJ1ZSxcbiAgICAgICAgdHlwZTogQ1BCcnVzaEluZm8uQl9ST1VORF9BSVJCUlVTSCxcbiAgICAgICAgcGFpbnRNb2RlOiBDUEJydXNoSW5mby5NX0RPREdFXG4gICAgfSk7XG5cbiAgICB0b29sc1tDaGlja2VuUGFpbnQuVF9CVVJOXSA9IG5ldyBDUEJydXNoSW5mbyh7XG4gICAgICAgIHRvb2xOYjogQ2hpY2tlblBhaW50LlRfQlVSTixcbiAgICAgICAgc2l6ZTogMzAsXG4gICAgICAgIGFscGhhOiAzMixcbiAgICAgICAgaXNBQTogZmFsc2UsXG4gICAgICAgIGlzQWlyYnJ1c2g6IHRydWUsXG4gICAgICAgIG1pblNwYWNpbmc6IDAuNSxcbiAgICAgICAgc3BhY2luZzogMC4wNSxcbiAgICAgICAgcHJlc3N1cmVTaXplOiBmYWxzZSxcbiAgICAgICAgcHJlc3N1cmVBbHBoYTogdHJ1ZSxcbiAgICAgICAgdHlwZTogQ1BCcnVzaEluZm8uQl9ST1VORF9BSVJCUlVTSCxcbiAgICAgICAgcGFpbnRNb2RlOiBDUEJydXNoSW5mby5NX0JVUk5cbiAgICB9KTtcblxuICAgIHRvb2xzW0NoaWNrZW5QYWludC5UX1dBVEVSXSA9IG5ldyBDUEJydXNoSW5mbyh7XG4gICAgICAgIHRvb2xOYjogQ2hpY2tlblBhaW50LlRfV0FURVIsXG4gICAgICAgIHNpemU6IDMwLFxuICAgICAgICBhbHBoYTogNzAsXG4gICAgICAgIGlzQUE6IGZhbHNlLFxuICAgICAgICBpc0FpcmJydXNoOiB0cnVlLFxuICAgICAgICBtaW5TcGFjaW5nOiAwLjUsXG4gICAgICAgIHNwYWNpbmc6IDAuMDIsXG4gICAgICAgIHByZXNzdXJlU2l6ZTogZmFsc2UsXG4gICAgICAgIHByZXNzdXJlQWxwaGE6IHRydWUsXG4gICAgICAgIHR5cGU6IENQQnJ1c2hJbmZvLkJfUk9VTkRfQUEsXG4gICAgICAgIHBhaW50TW9kZTogQ1BCcnVzaEluZm8uTV9XQVRFUixcbiAgICAgICAgcmVzYXQ6IDAuMyxcbiAgICAgICAgYmxlZWQ6IDAuNlxuICAgIH0pO1xuXG4gICAgdG9vbHNbQ2hpY2tlblBhaW50LlRfQkxVUl0gPSBuZXcgQ1BCcnVzaEluZm8oe1xuICAgICAgICB0b29sTmI6IENoaWNrZW5QYWludC5UX0JMVVIsXG4gICAgICAgIHNpemU6IDIwLFxuICAgICAgICBhbHBoYTogMjU1LFxuICAgICAgICBpc0FBOiBmYWxzZSxcbiAgICAgICAgaXNBaXJicnVzaDogdHJ1ZSxcbiAgICAgICAgbWluU3BhY2luZzogMC41LFxuICAgICAgICBzcGFjaW5nOiAwLjA1LFxuICAgICAgICBwcmVzc3VyZVNpemU6IGZhbHNlLFxuICAgICAgICBwcmVzc3VyZUFscGhhOiB0cnVlLFxuICAgICAgICB0eXBlOiBDUEJydXNoSW5mby5CX1JPVU5EX1BJWEVMLFxuICAgICAgICBwYWludE1vZGU6IENQQnJ1c2hJbmZvLk1fQkxVUlxuICAgIH0pO1xuXG4gICAgdG9vbHNbQ2hpY2tlblBhaW50LlRfU01VREdFXSA9IG5ldyBDUEJydXNoSW5mbyh7XG4gICAgICAgIHRvb2xOYjogQ2hpY2tlblBhaW50LlRfU01VREdFLFxuICAgICAgICBzaXplOiAyMCxcbiAgICAgICAgYWxwaGE6IDEyOCxcbiAgICAgICAgaXNBQTogZmFsc2UsXG4gICAgICAgIGlzQWlyYnJ1c2g6IHRydWUsXG4gICAgICAgIG1pblNwYWNpbmc6IDAuNSxcbiAgICAgICAgc3BhY2luZzogMC4wMSxcbiAgICAgICAgcHJlc3N1cmVTaXplOiBmYWxzZSxcbiAgICAgICAgcHJlc3N1cmVBbHBoYTogdHJ1ZSxcbiAgICAgICAgdHlwZTogQ1BCcnVzaEluZm8uQl9ST1VORF9BSVJCUlVTSCxcbiAgICAgICAgcGFpbnRNb2RlOiBDUEJydXNoSW5mby5NX1NNVURHRSxcbiAgICAgICAgcmVzYXQ6IDAuMCxcbiAgICAgICAgYmxlZWQ6IDEuMFxuICAgIH0pO1xuXG4gICAgdG9vbHNbQ2hpY2tlblBhaW50LlRfQkxFTkRFUl0gPSBuZXcgQ1BCcnVzaEluZm8oe1xuICAgICAgICB0b29sTmI6IENoaWNrZW5QYWludC5UX0JMRU5ERVIsXG4gICAgICAgIHNpemU6IDIwLFxuICAgICAgICBhbHBoYTogNjAsXG4gICAgICAgIGlzQUE6IGZhbHNlLFxuICAgICAgICBpc0FpcmJydXNoOiB0cnVlLFxuICAgICAgICBtaW5TcGFjaW5nOiAwLjUsXG4gICAgICAgIHNwYWNpbmc6IDAuMSxcbiAgICAgICAgcHJlc3N1cmVTaXplOiBmYWxzZSxcbiAgICAgICAgcHJlc3N1cmVBbHBoYTogdHJ1ZSxcbiAgICAgICAgdHlwZTogQ1BCcnVzaEluZm8uQl9ST1VORF9BSVJCUlVTSCxcbiAgICAgICAgcGFpbnRNb2RlOiBDUEJydXNoSW5mby5NX09JTCxcbiAgICAgICAgcmVzYXQ6IDAuMCxcbiAgICAgICAgYmxlZWQ6IDAuMDdcbiAgICB9KTtcblxuICAgIHJldHVybiB0b29scztcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGluc3RhbmNlIG9mIHRoZSBDaGlja2VuUGFpbnQgZHJhd2luZyBhcHAuIE9wdGlvbnMgaXMgYW4gb2JqZWN0IHdpdGggdGhlc2Uga2V5czpcbiAqXG4gKiB1aUVsZW0gICAgICAgLSBET00gZWxlbWVudCB0byBpbnNlcnQgQ2hpY2tlblBhaW50IGludG8gKHJlcXVpcmVkKVxuICogY2FudmFzV2lkdGggIC0gV2lkdGggaW4gcGl4ZWxzIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGJsYW5rIGNhbnZhc2VzIChkZWZhdWx0cyB0byA4MDApXG4gKiBjYW52YXNIZWlnaHQgLSBIZWlnaHQgaW4gcGl4ZWxzIHRvIHVzZSB3aGVuIGNyZWF0aW5nIGJsYW5rIGNhbnZhc2VzIChkZWZhdWx0cyB0byA2MDApXG4gKiByb3RhdGlvbiAgICAgLSBJbnRlZ2VyIGZyb20gWzAuLjNdLCBudW1iZXIgb2YgOTAgZGVncmVlIHJpZ2h0IHJvdGF0aW9ucyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIHRoZSBjYW52YXMgYWZ0ZXJcbiAqICAgICAgICAgICAgICAgIGxvYWRpbmdcbiAqXG4gKiBzYXZlVXJsICAgLSBVUkwgdG8gUE9TVCB0aGUgZHJhd2luZyB0byB0byBzYXZlIGl0XG4gKiBwb3N0VXJsICAgLSBVUkwgdG8gbmF2aWdhdGUgdG8gYWZ0ZXIgc2F2aW5nIGlzIHN1Y2Nlc3NmdWwgYW5kIHRoZSB1c2VyIGNob29zZXMgdG8gc2VlL3B1Ymxpc2ggdGhlaXIgZmluaXNoZWQgcHJvZHVjdFxuICogZXhpdFVybCAgIC0gVVJMIHRvIG5hdmlnYXRlIHRvIGFmdGVyIHNhdmluZyBpcyBzdWNjZXNzZnVsIGFuZCB0aGUgdXNlciBjaG9vc2VzIHRvIGV4aXQgKG9wdGlvbmFsKVxuICogdGVzdFVybCAgIC0gVVJMIHRoYXQgQ2hpY2tlblBhaW50IGNhbiBzaW11bGF0ZSBhIGRyYXdpbmcgdXBsb2FkIHRvIHRvIHRlc3QgdGhlIHVzZXIncyBwZXJtaXNzaW9ucy9jb25uZWN0aW9uIChvcHRpb25hbClcbiAqXG4gKiBsb2FkSW1hZ2VVcmwgICAgIC0gVVJMIG9mIFBORy9KUEVHIGltYWdlIHRvIGxvYWQgZm9yIGVkaXRpbmcgKG9wdGlvbmFsKVxuICogbG9hZENoaWJpRmlsZVVybCAtIFVSTCBvZiAuY2hpIGZpbGUgdG8gbG9hZCBmb3IgZWRpdGluZyAob3B0aW9uYWwpLiBVc2VkIGluIHByZWZlcmVuY2UgdG8gbG9hZEltYWdlLlxuICogbG9hZFN3YXRjaGVzVXJsICAtIFVSTCBvZiBhbiAuYWNvIHBhbGV0dGUgdG8gbG9hZCAob3B0aW9uYWwpXG4gKlxuICogYWxsb3dNdWx0aXBsZVNlbmRzIC0gQWxsb3cgdGhlIGRyYXdpbmcgdG8gYmUgc2VudCB0byB0aGUgc2VydmVyIG11bHRpcGxlIHRpbWVzIChzYXZpbmcgZG9lcyBub3QgaW1tZWRpYXRlbHkgZW5kIGRyYXdpbmcgc2Vzc2lvbikuXG4gKiBhbGxvd0Rvd25sb2FkIC0gQWxsb3cgdGhlIGRyYXdpbmcgdG8gYmUgc2F2ZWQgdG8gdGhlIHVzZXIncyBjb21wdXRlclxuICogYWxsb3dGdWxsU2NyZWVuIC0gQWxsb3cgdGhlIGRyYXdpbmcgdG9vbCB0byBlbnRlciBcImZ1bGwgc2NyZWVuXCIgbW9kZSwgd2hlcmUgdGhlIHJlc3Qgb2YgdGhlIHBhZ2UgY29udGVudHMgd2lsbCBiZSBoaWRkZW5cbiAqXG4gKiBkaXNhYmxlQm9vdHN0cmFwQVBJIC0gRGlzYWJsZSBCb290c3RyYXAncyBkYXRhIEFQSSBvbiB0aGUgcm9vdCBvZiB0aGUgZG9jdW1lbnQuIFRoaXMgc3BlZWRzIHVwIHRoaW5ncyBjb25zaWRlcmFibHkuXG4gKiBcbiAqIHJlc291cmNlc1Jvb3QgLSBVUkwgdG8gdGhlIGRpcmVjdG9yeSB0aGF0IGNvbnRhaW5zIHRoZSBnZngvY3NzIGV0YyBkaXJlY3RvcmllcyAocmVsYXRpdmUgdG8gdGhlIHBhZ2UgdGhhdCBcbiAqICAgICAgICAgICAgICAgICBDaGlja2VuUGFpbnQgaXMgbG9hZGVkIG9uKVxuICpcbiAqIEB0aHJvd3MgQ2hpY2tlblBhaW50LlVuc3VwcG9ydGVkQnJvd3NlckV4Y2VwdGlvbiBpZiB0aGUgd2ViIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBDaGlja2VuUGFpbnRcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ2hpY2tlblBhaW50KG9wdGlvbnMpIHtcbiAgICB2YXJcbiAgICAgICAgdGhhdCA9IHRoaXMsXG5cbiAgICAgICAgdWlFbGVtID0gb3B0aW9ucy51aUVsZW0sXG5cbiAgICAgICAgY2FudmFzLFxuICAgICAgICBtYWluR1VJLFxuXG4gICAgICAgIGN1ckNvbG9yID0gbmV3IENQQ29sb3IoMCksXG4gICAgICAgIGN1ckJydXNoID0gQ2hpY2tlblBhaW50LlRfUEVOQ0lMLFxuICAgICAgICBjdXJNb2RlID0gQ2hpY2tlblBhaW50Lk1fRFJBVyxcbiAgICAgICAgcHJlVHJhbnNmb3JtTW9kZSA9IGN1ck1vZGUsXG4gICAgICAgIGN1ckdyYWRpZW50ID0gWzB4RkYwMDAwMDAsIDB4RkZGRkZGRkZdLFxuXG4gICAgICAgIGZ1bGxTY3JlZW5Nb2RlID0gZmFsc2UsXG5cbiAgICAgICAgdG9vbHMgPSBjcmVhdGVEcmF3aW5nVG9vbHMoKSxcblxuICAgICAgICBib3hCbHVyRGlhbG9nLCBncmlkRGlhbG9nLFxuXG4gICAgICAgIGFjdGlvbnMgPSB7XG4gICAgICAgICAgICAvLyBHVUkgYWN0aW9uc1xuXG4gICAgICAgICAgICBDUEZ1bGxTY3JlZW46IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZnVsbFNjcmVlbk1vZGUgPSAhZnVsbFNjcmVlbk1vZGU7XG5cbiAgICAgICAgICAgICAgICAgICAgJChcImJvZHlcIikudG9nZ2xlQ2xhc3MoXCJjaGlja2VucGFpbnQtZnVsbC1zY3JlZW5cIiwgZnVsbFNjcmVlbk1vZGUpO1xuICAgICAgICAgICAgICAgICAgICAkKHVpRWxlbSkudG9nZ2xlQ2xhc3MoXCJjaGlja2VucGFpbnQtZnVsbC1zY3JlZW5cIiwgZnVsbFNjcmVlbk1vZGUpO1xuXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbkdVSS5zZXRGdWxsU2NyZWVuTW9kZShmdWxsU2NyZWVuTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH0sIDIwMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmFsbG93RnVsbFNjcmVlbiAhPT0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2d1aTogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUFpvb21Jbjoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuem9vbUluKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2d1aTogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUFpvb21PdXQ6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnpvb21PdXQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7Z3VpOiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQWm9vbTEwMDoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuem9vbTEwMCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtndWk6IHRydWV9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBIaXN0b3J5IGFjdGlvbnNcblxuICAgICAgICAgICAgQ1BVbmRvOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay51bmRvKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQUmVkbzoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsucmVkbygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUENsZWFySGlzdG9yeToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybShcIllvdSdyZSBhYm91dCB0byBjbGVhciB0aGUgY3VycmVudCBVbmRvL1JlZG8gaGlzdG9yeS5cXG5UaGlzIG9wZXJhdGlvbiBjYW5ub3QgYmUgdW5kb25lLCBhcmUgeW91IHN1cmUgeW91IHdhbnQgdG8gZG8gdGhhdD9cIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay5jbGVhckhpc3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIERyYXdpbmcgdG9vbHNcblxuICAgICAgICAgICAgQ1BQZW5jaWw6ICAgICBuZXcgVG9vbENoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuVF9QRU5DSUwpLFxuICAgICAgICAgICAgQ1BQZW46ICAgICAgICBuZXcgVG9vbENoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuVF9QRU4pLFxuICAgICAgICAgICAgQ1BFcmFzZXI6ICAgICBuZXcgVG9vbENoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuVF9FUkFTRVIpLFxuICAgICAgICAgICAgQ1BTb2Z0RXJhc2VyOiBuZXcgVG9vbENoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuVF9TT0ZURVJBU0VSKSxcbiAgICAgICAgICAgIENQQWlyYnJ1c2ggIDogbmV3IFRvb2xDaGFuZ2VBY3Rpb24oQ2hpY2tlblBhaW50LlRfQUlSQlJVU0gpLFxuICAgICAgICAgICAgQ1BEb2RnZTogICAgICBuZXcgVG9vbENoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuVF9ET0RHRSksXG4gICAgICAgICAgICBDUEJ1cm46ICAgICAgIG5ldyBUb29sQ2hhbmdlQWN0aW9uKENoaWNrZW5QYWludC5UX0JVUk4pLFxuICAgICAgICAgICAgQ1BXYXRlcjogICAgICBuZXcgVG9vbENoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuVF9XQVRFUiksXG4gICAgICAgICAgICBDUEJsdXI6ICAgICAgIG5ldyBUb29sQ2hhbmdlQWN0aW9uKENoaWNrZW5QYWludC5UX0JMVVIpLFxuICAgICAgICAgICAgQ1BTbXVkZ2U6ICAgICBuZXcgVG9vbENoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuVF9TTVVER0UpLFxuICAgICAgICAgICAgQ1BCbGVuZGVyOiAgICBuZXcgVG9vbENoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuVF9CTEVOREVSKSxcblxuICAgICAgICAgICAgLy8gTW9kZXNcblxuICAgICAgICAgICAgQ1BGbG9vZEZpbGw6ICAgICBuZXcgTW9kZUNoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuTV9GTE9PREZJTEwpLFxuICAgICAgICAgICAgQ1BHcmFkaWVudEZpbGw6ICBuZXcgTW9kZUNoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuTV9HUkFESUVOVEZJTEwpLFxuICAgICAgICAgICAgQ1BSZWN0U2VsZWN0aW9uOiBuZXcgTW9kZUNoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuTV9SRUNUX1NFTEVDVElPTiksXG4gICAgICAgICAgICBDUE1vdmVUb29sOiAgICAgIG5ldyBNb2RlQ2hhbmdlQWN0aW9uKENoaWNrZW5QYWludC5NX01PVkVfVE9PTCksXG4gICAgICAgICAgICBDUFJvdGF0ZUNhbnZhczogIG5ldyBNb2RlQ2hhbmdlQWN0aW9uKENoaWNrZW5QYWludC5NX1JPVEFURV9DQU5WQVMpLFxuICAgICAgICAgICAgQ1BDb2xvclBpY2tlcjogICBuZXcgTW9kZUNoYW5nZUFjdGlvbihDaGlja2VuUGFpbnQuTV9DT0xPUl9QSUNLRVIpLFxuXG4gICAgICAgICAgICAvLyBMYXllciB0cmFuc2Zvcm1cblxuICAgICAgICAgICAgQ1BUcmFuc2Zvcm06IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllciA9IHRoYXQuYXJ0d29yay5nZXRBY3RpdmVMYXllcigpLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJJbmRleCA9IHRoYXQuYXJ0d29yay5nZXRBY3RpdmVMYXllckluZGV4KCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoIWxheWVyLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2hvd0xheWVyTm90aWZpY2F0aW9uKGxheWVySW5kZXgsIFwiV2hvb3BzISBUaGlzIGxheWVyIGlzIGN1cnJlbnRseSBoaWRkZW5cIiwgXCJsYXllclwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXllci5hbHBoYSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNob3dMYXllck5vdGlmaWNhdGlvbihsYXllckluZGV4LCBcIldob29wcyEgVGhpcyBsYXllcidzIG9wYWNpdHkgaXMgY3VycmVudGx5IDAlXCIsIFwib3BhY2l0eVwiKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGF0LmFydHdvcmsudHJhbnNmb3JtQWZmaW5lQmVnaW4oKSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNob3dMYXllck5vdGlmaWNhdGlvbihsYXllckluZGV4LCBcIldob29wcyEgQWxsIG9mIHRoZSBzZWxlY3RlZCBwaXhlbHMgYXJlIHRyYW5zcGFyZW50IVwiLCBcImxheWVyXCIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0TW9kZShDaGlja2VuUGFpbnQuTV9UUkFOU0ZPUk0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge21vZGU6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BUcmFuc2Zvcm1BY2NlcHQ6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ck1vZGUgPT0gQ2hpY2tlblBhaW50Lk1fVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsudHJhbnNmb3JtQWZmaW5lRmluaXNoKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRNb2RlKHByZVRyYW5zZm9ybU1vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge21vZGU6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BUcmFuc2Zvcm1SZWplY3Q6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGN1ck1vZGUgPT0gQ2hpY2tlblBhaW50Lk1fVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsudHJhbnNmb3JtQWZmaW5lQWJvcnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldE1vZGUocHJlVHJhbnNmb3JtTW9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7ZG9jdW1lbnQ6IHRydWUsIG1vZGU6IHRydWV9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBTdHJva2UgbW9kZXNcblxuICAgICAgICAgICAgQ1BGcmVlSGFuZDoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sc1tjdXJCcnVzaF0uc3Ryb2tlTW9kZSA9IENQQnJ1c2hJbmZvLlNNX0ZSRUVIQU5EO1xuICAgICAgICAgICAgICAgICAgICBjYWxsVG9vbExpc3RlbmVycygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHt0b29sOiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQTGluZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0b29sc1tjdXJCcnVzaF0uc3Ryb2tlTW9kZSA9IENQQnJ1c2hJbmZvLlNNX0xJTkU7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxUb29sTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge3Rvb2w6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BCZXppZXI6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHNbY3VyQnJ1c2hdLnN0cm9rZU1vZGUgPSBDUEJydXNoSW5mby5TTV9CRVpJRVI7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxUb29sTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge3Rvb2w6IHRydWV9XG4gICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAvLyBIZWxwIGRpYWxvZ3NcblxuICAgICAgICAgICAgQ1BBYm91dDoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgQ1BBYm91dERpYWxvZyh1aUVsZW0pLnNob3coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQU2hvcnRjdXRzOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBDUFNob3J0Y3V0c0RpYWxvZyh1aUVsZW0pLnNob3coKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7fVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQVGFibGV0U3VwcG9ydDoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBuZXcgQ1BUYWJsZXREaWFsb2codWlFbGVtKS5zaG93KCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge31cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIExheWVyIGFjdGlvbnNcblxuICAgICAgICAgICAgQ1BMYXllckR1cGxpY2F0ZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsuZHVwbGljYXRlTGF5ZXIoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7ZG9jdW1lbnQ6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BMYXllck1lcmdlRG93bjoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsubWVyZ2VEb3duKHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUExheWVyTWVyZ2VBbGw6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hcnR3b3JrLm1lcmdlQWxsTGF5ZXJzKHRydWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUEZpbGw6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hcnR3b3JrLmZpbGwodGhhdC5nZXRDdXJDb2xvclJnYigpIHwgMHhmZjAwMDAwMCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQQ2xlYXI6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hcnR3b3JrLmNsZWFyKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQU2VsZWN0QWxsOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay5yZWN0YW5nbGVTZWxlY3Rpb24odGhhdC5hcnR3b3JrLmdldEJvdW5kcygpKTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzLnJlcGFpbnRBbGwoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7ZG9jdW1lbnQ6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BEZXNlbGVjdEFsbDoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsucmVjdGFuZ2xlU2VsZWN0aW9uKG5ldyBDUFJlY3QoMCwgMCwgMCwgMCkpO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMucmVwYWludEFsbCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUEhGbGlwOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay5oRmxpcCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUFZGbGlwOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay52RmxpcCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUE1Ob2lzZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsubW9ub2Nocm9tYXRpY05vaXNlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQQ05vaXNlOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay5jb2xvck5vaXNlKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQRlhCb3hCbHVyOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dCb3hCbHVyRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQRlhJbnZlcnQ6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hcnR3b3JrLmludmVydCgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIENQQ3V0OiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay5jdXRTZWxlY3Rpb24odHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQQ29weToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsuY29weVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUENvcHlNZXJnZWQ6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hcnR3b3JrLmNvcHlTZWxlY3Rpb25NZXJnZWQoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7ZG9jdW1lbnQ6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BQYXN0ZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsucGFzdGVDbGlwYm9hcmQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgQ1BUb2dnbGVHcmlkOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5zaG93R3JpZChlLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7Z3VpOiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQR3JpZE9wdGlvbnM6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0dyaWRPcHRpb25zRGlhbG9nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2d1aTogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIENQTGluZWFySW50ZXJwb2xhdGlvbjoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICBjYW52YXMuc2V0SW50ZXJwb2xhdGlvbihlLnNlbGVjdGVkKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7Z3VpOiB0cnVlfSxcbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc0NhbnZhc0ludGVycG9sYXRpb25TdXBwb3J0ZWQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BSZXNldENhbnZhc1JvdGF0aW9uOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhcy5yZXNldFJvdGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2d1aTogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIC8vIExheWVyIHBhbGV0dGVcblxuICAgICAgICAgICAgQ1BBZGRMYXllcjoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay5hZGRMYXllcigpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUFJlbW92ZUxheWVyOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGF0LmFydHdvcmsucmVtb3ZlTGF5ZXIoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxlcnQoXCJTb3JyeSwgeW91IGNhbid0IHJlbW92ZSB0aGUgbGFzdCByZW1haW5pbmcgbGF5ZXIgaW4gdGhlIGRyYXdpbmcuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQTW92ZUxheWVyOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay5tb3ZlTGF5ZXIoZS5mcm9tSW5kZXgsIGUudG9JbmRleCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2RvY3VtZW50OiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQU2V0QWN0aXZlTGF5ZXJJbmRleDoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsuc2V0QWN0aXZlTGF5ZXJJbmRleChlLmxheWVySW5kZXgpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNpbmNlIHRoaXMgaXMgYSBzbG93IEdVSSBvcGVyYXRpb24sIHRoaXMgaXMgYSBnb29kIGNoYW5jZSB0byBnZXQgdGhlIGNhbnZhcyByZWFkeSBmb3IgZHJhd2luZ1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsucGVyZm9ybUlkbGVUYXNrcygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUFNldExheWVyVmlzaWJpbGl0eToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsuc2V0TGF5ZXJWaXNpYmlsaXR5KGUubGF5ZXJJbmRleCwgZS52aXNpYmxlKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7bGF5ZXJQcm9wOiB0cnVlfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQU2V0TGF5ZXJOYW1lOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYXJ0d29yay5zZXRMYXllck5hbWUoZS5sYXllckluZGV4LCBlLm5hbWUpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtsYXllclByb3A6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BTZXRMYXllckJsZW5kTW9kZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGF0LmFydHdvcmsuc2V0TGF5ZXJCbGVuZE1vZGUoZS5sYXllckluZGV4LCBlLmJsZW5kTW9kZSk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBtb2RpZmllczoge2xheWVyUHJvcDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUFNldExheWVyQWxwaGE6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5hcnR3b3JrLnNldExheWVyQWxwaGEoZS5sYXllckluZGV4LCBlLmFscGhhKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7bGF5ZXJQcm9wOiB0cnVlfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gUGFsZXR0ZXNcblxuICAgICAgICAgICAgQ1BQYWxDb2xvcjogbmV3IFBhbGV0dGVUb2dnbGVBY3Rpb24oXCJjb2xvclwiKSxcbiAgICAgICAgICAgIENQUGFsQnJ1c2g6IG5ldyBQYWxldHRlVG9nZ2xlQWN0aW9uKFwiYnJ1c2hcIiksXG4gICAgICAgICAgICBDUFBhbExheWVyczogbmV3IFBhbGV0dGVUb2dnbGVBY3Rpb24oXCJsYXllcnNcIiksXG4gICAgICAgICAgICBDUFBhbFN0cm9rZTogbmV3IFBhbGV0dGVUb2dnbGVBY3Rpb24oXCJzdHJva2VcIiksXG4gICAgICAgICAgICBDUFBhbFN3YXRjaGVzOiBuZXcgUGFsZXR0ZVRvZ2dsZUFjdGlvbihcInN3YXRjaGVzXCIpLFxuICAgICAgICAgICAgQ1BQYWxUb29sOiBuZXcgUGFsZXR0ZVRvZ2dsZUFjdGlvbihcInRvb2xcIiksXG4gICAgICAgICAgICBDUFBhbE1pc2M6IG5ldyBQYWxldHRlVG9nZ2xlQWN0aW9uKFwibWlzY1wiKSxcbiAgICAgICAgICAgIENQUGFsVGV4dHVyZXM6IG5ldyBQYWxldHRlVG9nZ2xlQWN0aW9uKFwidGV4dHVyZXNcIiksXG5cbiAgICAgICAgICAgIENQVG9nZ2xlUGFsZXR0ZXM6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbkdVSS50b2dnbGVQYWxldHRlcygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtndWk6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BBcnJhbmdlUGFsZXR0ZXM6IHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbWFpbkdVSS5hcnJhbmdlUGFsZXR0ZXMoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7Z3VpOiB0cnVlfVxuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgLy8gU2F2aW5nXG5cbiAgICAgICAgICAgIENQU2F2ZToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzYXZlRHJhd2luZygpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNTdXBwb3J0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gb3B0aW9ucy5hbGxvd0Rvd25sb2FkICE9PSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7ZG9jdW1lbnQ6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BTZW5kOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbmREcmF3aW5nKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIW9wdGlvbnMuc2F2ZVVybDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7ZG9jdW1lbnQ6IHRydWV9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgQ1BQb3N0OiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbiA9IG9wdGlvbnMucG9zdFVybDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhb3B0aW9ucy5wb3N0VXJsO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbW9kaWZpZXM6IHtkb2N1bWVudDogdHJ1ZX1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBDUENvbnRpbnVlOiB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGlzU3VwcG9ydGVkOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhb3B0aW9ucy5hbGxvd011bHRpcGxlU2VuZHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIENQRXhpdDoge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBFeGl0IHRoZSBkcmF3aW5nIHNlc3Npb24gd2l0aG91dCBwb3N0aW5nIHRoZSBkcmF3aW5nIHRvIHRoZSBmb3J1bVxuICAgICAgICAgICAgICAgICAgICB3aW5kb3cubG9jYXRpb24gPSBvcHRpb25zLmV4aXRVcmw7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBpc1N1cHBvcnRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAhIW9wdGlvbnMuZXhpdFVybDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIG1vZGlmaWVzOiB7fVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgZnVuY3Rpb24gUGFsZXR0ZVRvZ2dsZUFjdGlvbihwYWxOYW1lKSB7XG4gICAgICAgIHRoaXMucGFsTmFtZSA9IHBhbE5hbWU7XG4gICAgfVxuXG4gICAgUGFsZXR0ZVRvZ2dsZUFjdGlvbi5wcm90b3R5cGUuYWN0aW9uID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBtYWluR1VJLnNob3dQYWxldHRlKHRoaXMucGFsTmFtZSwgZS5zZWxlY3RlZCk7XG4gICAgfTtcbiAgICBQYWxldHRlVG9nZ2xlQWN0aW9uLnByb3RvdHlwZS5tb2RpZmllcyA9IHtndWk6IHRydWV9O1xuXG4gICAgZnVuY3Rpb24gVG9vbENoYW5nZUFjdGlvbih0b29sTnVtKSB7XG4gICAgICAgIHRoaXMudG9vbE51bSA9IHRvb2xOdW07XG4gICAgfVxuXG4gICAgVG9vbENoYW5nZUFjdGlvbi5wcm90b3R5cGUuYWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldFRvb2wodGhpcy50b29sTnVtKTtcbiAgICB9O1xuXG4gICAgVG9vbENoYW5nZUFjdGlvbi5wcm90b3R5cGUubW9kaWZpZXMgPSB7bW9kZTogdHJ1ZSwgdG9vbDogdHJ1ZX07XG5cbiAgICBmdW5jdGlvbiBNb2RlQ2hhbmdlQWN0aW9uKG1vZGVOdW0pIHtcbiAgICAgICAgdGhpcy5tb2RlTnVtID0gbW9kZU51bTtcbiAgICB9XG5cbiAgICBNb2RlQ2hhbmdlQWN0aW9uLnByb3RvdHlwZS5hY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgc2V0TW9kZSh0aGlzLm1vZGVOdW0pO1xuICAgIH07XG4gICAgTW9kZUNoYW5nZUFjdGlvbi5wcm90b3R5cGUubW9kaWZpZXMgPSB7bW9kZTogdHJ1ZX07XG5cbiAgICBmdW5jdGlvbiBzaG93Qm94Qmx1ckRpYWxvZygpIHtcbiAgICAgICAgaWYgKCFib3hCbHVyRGlhbG9nKSB7XG4gICAgICAgICAgICBib3hCbHVyRGlhbG9nID0gbmV3IENQQm94Qmx1ckRpYWxvZyh1aUVsZW0sIHRoYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgYm94Qmx1ckRpYWxvZy5zaG93KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2hvd0dyaWRPcHRpb25zRGlhbG9nKCkge1xuICAgICAgICBpZiAoIWdyaWREaWFsb2cpIHtcbiAgICAgICAgICAgIGdyaWREaWFsb2cgPSBuZXcgQ1BHcmlkRGlhbG9nKHVpRWxlbSwgY2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGdyaWREaWFsb2cuc2hvdygpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhbGxUb29sTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGF0LmVtaXRFdmVudCgndG9vbENoYW5nZScsIFtjdXJCcnVzaCwgdG9vbHNbY3VyQnJ1c2hdXSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyBtYWtlIG1lIHByaXZhdGVcbiAgICB0aGlzLmNhbGxUb29sTGlzdGVuZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbGxUb29sTGlzdGVuZXJzKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIGNhbGxNb2RlTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGF0LmVtaXRFdmVudCgnbW9kZUNoYW5nZScsIFtjdXJNb2RlXSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FsbFZpZXdMaXN0ZW5lcnModmlld0luZm8pIHtcbiAgICAgICAgdGhhdC5lbWl0RXZlbnQoJ3ZpZXdDaGFuZ2UnLCBbdmlld0luZm9dKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5nZXRNYWluR1VJID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBtYWluR1VJO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEFydHdvcmsgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXJ0d29yaztcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRDYW52YXMgPSBmdW5jdGlvbihfY2FudmFzKSB7XG4gICAgICAgIGNhbnZhcyA9IF9jYW52YXM7XG4gICAgfTtcblx0XG5cdC8qKlxuICAgICAqIENoYW5nZSB0aGUgaW50ZXJwb2xhdGlvbiBtb2RlIHVzZWQgYnkgRnJlZSBUcmFuc2Zvcm0gb3BlcmF0aW9uc1xuICAgICAqIFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcnBvbGF0aW9uIC0gRWl0aGVyIFwic2hhcnBcIiBvciBcInNtb290aFwiXG4gICAgICovXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24oaW50ZXJwb2xhdGlvbikge1xuICAgICAgICB0aGlzLmFydHdvcmsuc2V0VHJhbnNmb3JtSW50ZXJwb2xhdGlvbihpbnRlcnBvbGF0aW9uKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0Q3VyQ29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICBpZiAoIWN1ckNvbG9yLmlzRXF1YWwoY29sb3IpKSB7XG4gICAgICAgICAgICB0aGlzLmFydHdvcmsuc2V0Rm9yZWdyb3VuZENvbG9yKGNvbG9yLmdldFJnYigpKTtcblxuICAgICAgICAgICAgY3VyQ29sb3IuY29weUZyb20oY29sb3IpO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudCgnY29sb3JDaGFuZ2UnLCBbY29sb3JdKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmdldEN1ckNvbG9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjdXJDb2xvci5jbG9uZSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmdldEN1ckNvbG9yUmdiID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjdXJDb2xvci5nZXRSZ2IoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRDdXJDb2xvclJnYiA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgIHRoaXMuc2V0Q3VyQ29sb3IobmV3IENQQ29sb3IoY29sb3IpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRDdXJHcmFkaWVudCA9IGZ1bmN0aW9uKGdyYWRpZW50KSB7XG4gICAgICAgIGN1ckdyYWRpZW50ID0gZ3JhZGllbnQuc2xpY2UoMCk7IC8vIENsb25lXG5cbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoJ2dyYWRpZW50Q2hhbmdlJywgW2N1ckdyYWRpZW50XSk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Q3VyR3JhZGllbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGN1ckdyYWRpZW50LnNsaWNlKDApOyAvLyBDbG9uZVxuICAgIH07XG5cbiAgICB0aGlzLnNldEJydXNoU2l6ZSA9IGZ1bmN0aW9uKHNpemUpIHtcbiAgICAgICAgdG9vbHNbY3VyQnJ1c2hdLnNpemUgPSBNYXRoLm1heCgxLCBNYXRoLm1pbigyMDAsIHNpemUpKTtcbiAgICAgICAgY2FsbFRvb2xMaXN0ZW5lcnMoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRCcnVzaFNpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRvb2xzW2N1ckJydXNoXS5zaXplO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICAgICAgdG9vbHNbY3VyQnJ1c2hdLmFscGhhID0gYWxwaGE7XG4gICAgICAgIGNhbGxUb29sTGlzdGVuZXJzKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0QWxwaGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRvb2xzW2N1ckJydXNoXS5hbHBoYTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRDdXJNb2RlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjdXJNb2RlO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRNb2RlKG5ld01vZGUpIHtcbiAgICAgICAgaWYgKGN1ck1vZGUgIT0gbmV3TW9kZSkge1xuICAgICAgICAgICAgaWYgKG5ld01vZGUgPT0gQ2hpY2tlblBhaW50Lk1fVFJBTlNGT1JNKSB7XG4gICAgICAgICAgICAgICAgcHJlVHJhbnNmb3JtTW9kZSA9IGN1ck1vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJNb2RlID0gbmV3TW9kZTtcbiAgICAgICAgICAgIGNhbGxNb2RlTGlzdGVuZXJzKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmdldEN1clRvb2wgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGN1ckJydXNoO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRUb29sKHRvb2wpIHtcbiAgICAgICAgc2V0TW9kZShDaGlja2VuUGFpbnQuTV9EUkFXKTtcbiAgICAgICAgY3VyQnJ1c2ggPSB0b29sO1xuICAgICAgICB0aGF0LmFydHdvcmsuc2V0QnJ1c2godG9vbHNbdG9vbF0pO1xuICAgICAgICBjYWxsVG9vbExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0QnJ1c2hJbmZvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0b29sc1tjdXJCcnVzaF07XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiBzYXZlRHJhd2luZygpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBzYXZlciA9IG5ldyBDUFJlc291cmNlU2F2ZXIoe1xuICAgICAgICAgICAgICAgIGFydHdvcms6IHRoYXQuZ2V0QXJ0d29yaygpLFxuICAgICAgICAgICAgICAgIHJvdGF0aW9uOiBjYW52YXMuZ2V0Um90YXRpb245MCgpLFxuICAgICAgICAgICAgICAgIHN3YXRjaGVzOiBtYWluR1VJLmdldFN3YXRjaGVzKClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2F2ZXIub24oXCJzYXZpbmdDb21wbGV0ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQuYXJ0d29yay5zZXRIYXNVbnNhdmVkQ2hhbmdlcyhmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2F2ZXIub24oXCJzYXZpbmdGYWlsdXJlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYWxlcnQoXCJBbiBlcnJvciBvY2N1cmVkIHdoaWxlIHRyeWluZyB0byBzYXZlIHlvdXIgZHJhd2luZyEgUGxlYXNlIHRyeSBhZ2FpbiFcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc2F2ZXIuc2F2ZSgpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBzZW5kRHJhd2luZygpIHtcbiAgICAgICAgaWYgKCF0aGF0LmlzQWN0aW9uU3VwcG9ydGVkKFwiQ1BDb250aW51ZVwiKSAmJiAhY29uZmlybSgnQXJlIHlvdSBzdXJlIHlvdSB3YW50IHRvIHNlbmQgeW91ciBkcmF3aW5nIHRvIHRoZSBzZXJ2ZXIgYW5kIGZpbmlzaCBkcmF3aW5nIG5vdz8nKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXJcbiAgICAgICAgICAgIHNhdmVyID0gbmV3IENQUmVzb3VyY2VTYXZlcih7XG4gICAgICAgICAgICAgICAgYXJ0d29yazogdGhhdC5nZXRBcnR3b3JrKCksXG4gICAgICAgICAgICAgICAgcm90YXRpb246IGNhbnZhcy5nZXRSb3RhdGlvbjkwKCksXG4gICAgICAgICAgICAgICAgc3dhdGNoZXM6IG1haW5HVUkuZ2V0U3dhdGNoZXMoKSxcbiAgICAgICAgICAgICAgICB1cmw6IG9wdGlvbnMuc2F2ZVVybFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBzZW5kRGlhbG9nID0gbmV3IENQU2VuZERpYWxvZyh0aGF0LCB1aUVsZW0sIHNhdmVyKTtcbiAgICAgICAgXG4gICAgICAgIHNhdmVyLm9uKFwic2F2aW5nQ29tcGxldGVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB0aGF0LmFydHdvcmsuc2V0SGFzVW5zYXZlZENoYW5nZXMoZmFsc2UpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgYWxsb3dlZCB0byBrZWVwIGVkaXRpbmcsIHdlIGNhbiBvbmx5IGdvIHN0cmFpZ2h0IHRvIHZpZXdpbmcgdGhlIG5ldyBwb3N0XG4gICAgICAgICAgICBpZiAoIXRoYXQuaXNBY3Rpb25TdXBwb3J0ZWQoXCJDUENvbnRpbnVlXCIpICYmIHRoYXQuaXNBY3Rpb25TdXBwb3J0ZWQoXCJDUFBvc3RcIikpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmFjdGlvblBlcmZvcm1lZCh7YWN0aW9uOiBcIkNQUG9zdFwifSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIEFsbG93IHRoZSBkaWFsb2cgdG8gc2hvdyBiZWZvcmUgd2UgYmVnaW4gc2VyaWFsaXphdGlvblxuICAgICAgICBzZW5kRGlhbG9nLm9uKFwic2hvd25cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzYXZlci5zYXZlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHNlbmREaWFsb2cuc2hvdygpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE5vdCBhbGwgc2F2aW5nIGFjdGlvbnMgd2lsbCBiZSBzdXBwb3J0ZWQgKGRlcGVuZGluZyBvbiB3aGF0IG9wdGlvbnMgd2UncmUgY29uZmlndXJlZCB3aXRoKS4gVXNlIHRoaXMgZnVuY3Rpb25cbiAgICAgKiB0byBjaGVjayBmb3Igc3VwcG9ydCBmb3IgYSBnaXZlbiBhY3Rpb24uXG4gICAgICovXG4gICAgdGhpcy5pc0FjdGlvblN1cHBvcnRlZCA9IGZ1bmN0aW9uKGFjdGlvbk5hbWUpIHtcbiAgICAgICAgaWYgKGFjdGlvbnNbYWN0aW9uTmFtZV0pIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHN1cHBvcnRlZFR5cGUgPSB0eXBlb2YgYWN0aW9uc1thY3Rpb25OYW1lXS5pc1N1cHBvcnRlZDtcblxuICAgICAgICAgICAgaWYgKHN1cHBvcnRlZFR5cGUgPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnNbYWN0aW9uTmFtZV0uaXNTdXBwb3J0ZWQoKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3VwcG9ydGVkVHlwZSA9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgbm90IG90aGVyd2lzZSBzcGVjaWZpZWQsIGFuIGFjdGlvbiBkZWZhdWx0cyB0byBzdXBwb3J0ZWRcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjdGlvbnNbYWN0aW9uTmFtZV0uaXNTdXBwb3J0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIHRoaXMuc2hvd0xheWVyTm90aWZpY2F0aW9uID0gZnVuY3Rpb24obGF5ZXJJbmRleCwgbWVzc2FnZSwgd2hlcmUpIHtcbiAgICAgICAgdGhpcy5lbWl0RXZlbnQoXCJsYXllck5vdGlmaWNhdGlvblwiLCBbbGF5ZXJJbmRleCwgbWVzc2FnZSwgd2hlcmVdKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuYWN0aW9uUGVyZm9ybWVkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAodGhpcy5hcnR3b3JrID09IG51bGwgfHwgY2FudmFzID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjsgLy8gdGhpcyBzaG91bGRuJ3QgaGFwcGVuLCBidXQganVzdCBpbiBjYXNlXG4gICAgICAgIH1cblxuICAgICAgICB2YXJcbiAgICAgICAgICAgIGFjdGlvbiA9IGFjdGlvbnNbZS5hY3Rpb25dO1xuXG4gICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChjdXJNb2RlID09IENoaWNrZW5QYWludC5NX1RSQU5TRk9STSAmJiAoYWN0aW9uLm1vZGlmaWVzLmRvY3VtZW50IHx8IGFjdGlvbi5tb2RpZmllcy5tb2RlKVxuICAgICAgICAgICAgICAgICAgICAmJiBbXCJDUFRyYW5zZm9ybUFjY2VwdFwiLCBcIkNQVHJhbnNmb3JtUmVqZWN0XCJdLmluZGV4T2YoZS5hY3Rpb24pID09IC0xKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUuYWN0aW9uID09IFwiQ1BVbmRvXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9ucy5DUFRyYW5zZm9ybVJlamVjdC5hY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGUuYWN0aW9uID09IFwiQ1BUcmFuc2Zvcm1cIikge1xuICAgICAgICAgICAgICAgICAgICAvLyBZb3UncmUgYWxyZWFkeSB0cmFuc2Zvcm1pbmcgdGhlIHNlbGVjdGlvbiFcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBQcm9tcHQgdGhlIHVzZXIgdG8gZmluaXNoIHRoZWlyIHRyYW5zZm9ybSBiZWZvcmUgc3RhcnRpbmcgc29tZXRoaW5nIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaWFsb2cgPSBuZXcgQ1BDb25maXJtVHJhbnNmb3JtRGlhbG9nKHVpRWxlbSwgdGhpcyk7XG5cbiAgICAgICAgICAgICAgICAgICAgLyogSWYgdGhleSBkZWNpZGUgdG8gZmluaXNoIHVwIHdpdGggdGhlIHRyYW5zZm9ybSwgd2UgY2FuIGFwcGx5IHRoZSBvcmlnaW5hbCBhY3Rpb24gdGhleVxuICAgICAgICAgICAgICAgICAgICAgKiBhdHRlbXB0ZWQgYWZ0ZXJ3YXJkcy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5vbihcImFjY2VwdFwiLCB0aGlzLmFjdGlvblBlcmZvcm1lZC5iaW5kKHRoaXMsIGUpKTtcbiAgICAgICAgICAgICAgICAgICAgZGlhbG9nLm9uKFwicmVqZWN0XCIsIHRoaXMuYWN0aW9uUGVyZm9ybWVkLmJpbmQodGhpcywgZSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRpYWxvZy5zaG93KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhY3Rpb24uYWN0aW9uKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2FsbENQRXZlbnRMaXN0ZW5lcnMoKTsgVE9ET1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsVW5zYXZlZFdhcm5pbmcoKSB7XG4gICAgICAgIGlmIChpc0V2ZW50U3VwcG9ydGVkKFwib25iZWZvcmV1bmxvYWRcIikpIHtcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmVmb3JldW5sb2FkXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhhdC5hcnR3b3JrLmdldEhhc1Vuc2F2ZWRDaGFuZ2VzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtTWVzc2FnZSA9IFwiWW91ciBkcmF3aW5nIGhhcyB1bnNhdmVkIGNoYW5nZXMhXCI7XG4gICAgICAgICAgICAgICAgICAgIGUucmV0dXJuVmFsdWUgPSBjb25maXJtTWVzc2FnZTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbmZpcm1NZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRmFsbCBiYWNrIHRvIGp1c3QgY2F0Y2hpbmcgbGlua3NcbiAgICAgICAgICAgICQoXCJhXCIpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpICE9IFwiI1wiICYmIHRoYXQuYXJ0d29yay5nZXRIYXNVbnNhdmVkQ2hhbmdlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb25maXJtKFwiWW91ciBkcmF3aW5nIGhhcyB1bnNhdmVkIGNoYW5nZXMhIEFyZSB5b3Ugc3VyZSB0byB3YW50IHRvIG5hdmlnYXRlIGF3YXk/XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHN0YXJ0TWFpbkdVSShzd2F0Y2hlcywgaW5pdGlhbFJvdGF0aW9uOTApIHtcbiAgICAgICAgbWFpbkdVSSA9IG5ldyBDUE1haW5HVUkodGhhdCwgdWlFbGVtKTtcblxuICAgICAgICBzZXRUb29sKENoaWNrZW5QYWludC5UX1BFTik7XG4gICAgICAgIG1haW5HVUkuYXJyYW5nZVBhbGV0dGVzKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc3dhdGNoZXMpIHtcbiAgICAgICAgICAgIG1haW5HVUkuc2V0U3dhdGNoZXMoc3dhdGNoZXMpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoaW5pdGlhbFJvdGF0aW9uOTApIHtcbiAgICAgICAgICAgIG1haW5HVUkuc2V0Um90YXRpb24oaW5pdGlhbFJvdGF0aW9uOTAgKiBNYXRoLlBJIC8gMik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIENQV2Fjb21UYWJsZXQuZ2V0UmVmKCkuZGV0ZWN0VGFibGV0KCk7XG4gICAgICAgIFxuICAgICAgICBpbnN0YWxsVW5zYXZlZFdhcm5pbmcoKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5nZXRSZXNvdXJjZXNSb290ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnJlc291cmNlc1Jvb3Q7XG4gICAgfTtcblxuICAgIGlmICghaXNCcm93c2VyU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IENoaWNrZW5QYWludC5VbnN1cHBvcnRlZEJyb3dzZXJFeGNlcHRpb24oKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGUuZmxleEJhc2lzICE9IFwic3RyaW5nXCIgJiYgdHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGUubXNGbGV4RGlyZWN0aW9uICE9IFwic3RyaW5nXCIgfHwgL1ByZXN0by8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICB1aUVsZW0uY2xhc3NOYW1lICs9IFwiIG5vLWZsZXhib3hcIjtcbiAgICB9XG5cbiAgICB1aUVsZW0uY2xhc3NOYW1lICs9IFwiIGNoaWNrZW5wYWludFwiO1xuXG4gICAgb3B0aW9ucy5yZXNvdXJjZXNSb290ID0gb3B0aW9ucy5yZXNvdXJjZXNSb290IHx8IFwiY2hpY2tlbnBhaW50L1wiO1xuXG4gICAgaWYgKG9wdGlvbnMuZGlzYWJsZUJvb3RzdHJhcEFQSSkge1xuICAgICAgICAkKGRvY3VtZW50KS5vZmYoJy5kYXRhLWFwaScpO1xuICAgIH1cblxuICAgIGlmIChvcHRpb25zLmxvYWRJbWFnZVVybCB8fCBvcHRpb25zLmxvYWRDaGliaUZpbGVVcmwpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBsb2FkZXIgPSBuZXcgQ1BSZXNvdXJjZUxvYWRlcihvcHRpb25zKTtcbiAgICAgICAgXG4gICAgICAgIG5ldyBDUFNwYXNoU2NyZWVuKHVpRWxlbSwgbG9hZGVyLCBvcHRpb25zLnJlc291cmNlc1Jvb3QpO1xuXG4gICAgICAgIGxvYWRlci5vbihcImxvYWRpbmdDb21wbGV0ZVwiLCBmdW5jdGlvbihyZXNvdXJjZXMpIHtcbiAgICAgICAgICAgIHRoYXQuYXJ0d29yayA9IHJlc291cmNlcy5sYXllcnMgfHwgcmVzb3VyY2VzLmZsYXQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN0YXJ0TWFpbkdVSShyZXNvdXJjZXMuc3dhdGNoZXMsIG9wdGlvbnMucm90YXRpb24pO1xuICAgICAgICB9KTtcblxuICAgICAgICBsb2FkZXIubG9hZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuYXJ0d29yayA9IG5ldyBDUEFydHdvcmsob3B0aW9ucy5jYW52YXNXaWR0aCB8fCA4MDAsIG9wdGlvbnMuY2FudmFzSGVpZ2h0IHx8IDYwMCk7XG4gICAgICAgIHRoaXMuYXJ0d29yay5hZGRCYWNrZ3JvdW5kTGF5ZXIoKTtcbiAgICAgICAgXG4gICAgICAgIHN0YXJ0TWFpbkdVSSgpO1xuICAgIH1cbn1cblxuQ2hpY2tlblBhaW50LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5DaGlja2VuUGFpbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ2hpY2tlblBhaW50O1xuXG5DaGlja2VuUGFpbnQuVW5zdXBwb3J0ZWRCcm93c2VyRXhjZXB0aW9uID0gZnVuY3Rpb24oKSB7XG59O1xuXG5DaGlja2VuUGFpbnQuVW5zdXBwb3J0ZWRCcm93c2VyRXhjZXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBcIlNvcnJ5LCB5b3VyIHdlYiBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgQ2hpY2tlblBhaW50LiBQbGVhc2UgdHJ5IGEgbW9kZXJuIGJyb3dzZXIgbGlrZSBDaHJvbWUsIFNhZmFyaSwgRmlyZWZveCwgb3IgRWRnZVwiO1xufTtcblxuLy9cbi8vIERlZmluaXRpb24gb2YgYWxsIHRoZSBtb2RlcyBhdmFpbGFibGVcbi8vXG5cbkNoaWNrZW5QYWludC5NX0RSQVcgPSAwO1xuQ2hpY2tlblBhaW50Lk1fRkxPT0RGSUxMID0gMTtcbkNoaWNrZW5QYWludC5NX1JFQ1RfU0VMRUNUSU9OID0gMjtcbkNoaWNrZW5QYWludC5NX01PVkVfVE9PTCA9IDM7XG5DaGlja2VuUGFpbnQuTV9ST1RBVEVfQ0FOVkFTID0gNDtcbkNoaWNrZW5QYWludC5NX0NPTE9SX1BJQ0tFUiA9IDU7XG5DaGlja2VuUGFpbnQuTV9HUkFESUVOVEZJTEwgPSA2O1xuQ2hpY2tlblBhaW50Lk1fVFJBTlNGT1JNID0gNztcblxuLy9cbi8vIERlZmluaXRpb24gb2YgYWxsIHRoZSBzdGFuZGFyZCB0b29scyBhdmFpbGFibGVcbi8vXG5DaGlja2VuUGFpbnQuVF9QRU5DSUwgPSAwO1xuQ2hpY2tlblBhaW50LlRfRVJBU0VSID0gMTtcbkNoaWNrZW5QYWludC5UX1BFTiA9IDI7XG5DaGlja2VuUGFpbnQuVF9TT0ZURVJBU0VSID0gMztcbkNoaWNrZW5QYWludC5UX0FJUkJSVVNIID0gNDtcbkNoaWNrZW5QYWludC5UX0RPREdFID0gNTtcbkNoaWNrZW5QYWludC5UX0JVUk4gPSA2O1xuQ2hpY2tlblBhaW50LlRfV0FURVIgPSA3O1xuQ2hpY2tlblBhaW50LlRfQkxVUiA9IDg7XG5DaGlja2VuUGFpbnQuVF9TTVVER0UgPSA5O1xuQ2hpY2tlblBhaW50LlRfQkxFTkRFUiA9IDEwO1xuQ2hpY2tlblBhaW50LlRfTUFYID0gMTE7XG4iLCIvKlxuICAgIENoaWNrZW5QYWludFxuICAgIFxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG4gICAgXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IENQTGF5ZXIgZnJvbSBcIi4vQ1BMYXllclwiO1xuaW1wb3J0IENQQmxlbmQgZnJvbSBcIi4vQ1BCbGVuZFwiO1xuaW1wb3J0IENQR3JleUJtcCBmcm9tIFwiLi9DUEdyZXlCbXBcIjtcbmltcG9ydCBDUENvbG9yQm1wIGZyb20gXCIuL0NQQ29sb3JCbXBcIjtcbmltcG9ydCBDUEJydXNoTWFuYWdlciBmcm9tIFwiLi9DUEJydXNoTWFuYWdlclwiO1xuaW1wb3J0IENQQnJ1c2hJbmZvIGZyb20gXCIuL0NQQnJ1c2hJbmZvXCI7XG5pbXBvcnQgQ1BVbmRvIGZyb20gXCIuL0NQVW5kb1wiO1xuaW1wb3J0IENQQ2xpcCBmcm9tIFwiLi9DUENsaXBcIjtcblxuaW1wb3J0IENQQ29sb3JGbG9hdCBmcm9tIFwiLi4vdXRpbC9DUENvbG9yRmxvYXRcIjtcbmltcG9ydCBDUFJlY3QgZnJvbSBcIi4uL3V0aWwvQ1BSZWN0XCI7XG5pbXBvcnQgQ1BSYW5kb20gZnJvbSBcIi4uL3V0aWwvQ1BSYW5kb21cIjtcbmltcG9ydCBDUFRyYW5zZm9ybSBmcm9tIFwiLi4vdXRpbC9DUFRyYW5zZm9ybVwiO1xuaW1wb3J0IHtzZXRDYW52YXNJbnRlcnBvbGF0aW9ufSBmcm9tIFwiLi4vdXRpbC9DUFBvbHlmaWxsXCI7XG5cbi8vIFBvbHlmaWxsLCB1c2VkIGluIGR1cGxpY2F0ZUxheWVyXG5pZiAoIVN0cmluZy5wcm90b3R5cGUuZW5kc1dpdGgpIHtcbiAgICBTdHJpbmcucHJvdG90eXBlLmVuZHNXaXRoID0gZnVuY3Rpb24oc2VhcmNoU3RyaW5nLCBwb3NpdGlvbikge1xuICAgICAgICB2YXIgc3ViamVjdFN0cmluZyA9IHRoaXMudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwb3NpdGlvbiAhPT0gJ251bWJlcicgfHwgIWlzRmluaXRlKHBvc2l0aW9uKSB8fCBNYXRoLmZsb29yKHBvc2l0aW9uKSAhPT0gcG9zaXRpb24gfHwgcG9zaXRpb24gPiBzdWJqZWN0U3RyaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgcG9zaXRpb24gPSBzdWJqZWN0U3RyaW5nLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBwb3NpdGlvbiAtPSBzZWFyY2hTdHJpbmcubGVuZ3RoO1xuICAgICAgICB2YXIgbGFzdEluZGV4ID0gc3ViamVjdFN0cmluZy5pbmRleE9mKHNlYXJjaFN0cmluZywgcG9zaXRpb24pO1xuICAgICAgICByZXR1cm4gbGFzdEluZGV4ICE9PSAtMSAmJiBsYXN0SW5kZXggPT09IHBvc2l0aW9uO1xuICAgIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQXJ0d29yayhfd2lkdGgsIF9oZWlnaHQpIHtcbiAgICBcbiAgICBfd2lkdGggPSBfd2lkdGggfCAwO1xuICAgIF9oZWlnaHQgPSBfaGVpZ2h0IHwgMDtcbiAgICBcbiAgICBjb25zdFxuICAgICAgICBNQVhfVU5ETyA9IDMwLFxuICAgICAgICBFTVBUWV9CQUNLR1JPVU5EX0NPTE9SID0gMHhGRkZGRkZGRixcbiAgICAgICAgRU1QVFlfTEFZRVJfQ09MT1IgPSAweDAwRkZGRkZGLFxuICAgICAgICBcbiAgICAgICAgQlVSTl9DT05TVEFOVCA9IDI2MCxcbiAgICAgICAgQkxVUl9NSU4gPSA2NCxcbiAgICAgICAgQkxVUl9NQVggPSAxO1xuICAgIFxuICAgIHZhclxuICAgICAgICBsYXllcnMgPSBbXSxcbiAgICAgICAgY3VyTGF5ZXIsXG4gICAgICAgIFxuICAgICAgICBoYXNVbnNhdmVkQ2hhbmdlcyA9IGZhbHNlLFxuICAgICAgICBcbiAgICAgICAgY3VyU2VsZWN0aW9uID0gbmV3IENQUmVjdCgwLCAwLCAwLCAwKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogT3VyIGJ1ZmZlciBmb3Igc3RvcmluZyBhbGwgdGhlIGxheWVycyBtZXJnZWQgdG9nZXRoZXIgYWNjb3JkaW5nIHRvIHRoZWlyIGJsZW5kaW5nIG1vZGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAdHlwZSB7Q1BMYXllcn1cbiAgICAgICAgICovXG4gICAgICAgIGZ1c2lvbkJ1ZmZlciA9IG5ldyBDUExheWVyKF93aWR0aCwgX2hlaWdodCksXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBvaW50cyB0byB0aGUgYnVmZmVyIHdoaWNoIHJlcHJlc2VudHMgYWxsIHRoZSBsYXllcnMgbWVyZ2VkIHRvZ2V0aGVyIChlaXRoZXIgZnVzaW9uQnVmZmVyIG9yIGN1ckxheWVyXG4gICAgICAgICAqIGRlcGVuZGluZyBvbiBpZiB0aGUgZG9jdW1lbnQgaXMgc2luZ2xlLWxheWVyZWQgb3Igbm90KS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0NQTGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICBmdXNpb24gPSBmdXNpb25CdWZmZXIsXG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgY29weSBvZiB0aGUgY3VycmVudCBsYXllcidzIGRhdGEgdGhhdCBjYW4gYmUgdXNlZCBmb3IgdW5kbyBvcGVyYXRpb25zLlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHR5cGUge0NQTGF5ZXJ9XG4gICAgICAgICAqL1xuICAgICAgICB1bmRvQnVmZmVyID0gbmV3IENQTGF5ZXIoX3dpZHRoLCBfaGVpZ2h0KSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIHJlZ2lvbiBvZiB0aGUgdW5kb0J1ZmZlciB3aGljaCBpcyBvdXQgb2YgZGF0ZSB3aXRoIHJlc3BlY3QgdG8gdGhlIGNvbnRlbnQgb2YgdGhlIGxheWVyLCBhbmQgbmVlZHMgdXBkYXRlZFxuICAgICAgICAgKiB3aXRoIHByZXBhcmVGb3JMYXllclVuZG8oKS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHR5cGUge0NQUmVjdH1cbiAgICAgICAgICovXG4gICAgICAgIHVuZG9CdWZmZXJJbnZhbGlkUmVnaW9uID0gbmV3IENQUmVjdCgwLCAwLCBfd2lkdGgsIF9oZWlnaHQpLFxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXZSB1c2UgdGhpcyBidWZmZXIgc28gd2UgY2FuIGFjY3VyYXRlbHkgYWNjdW11bGF0ZSBzbWFsbCBjaGFuZ2VzIHRvIGxheWVyIG9wYWNpdHkgZHVyaW5nIGEgYnJ1c2ggc3Ryb2tlLlxuICAgICAgICAgKiBcbiAgICAgICAgICogTm9ybWFsbHkgd2UgdXNlIGl0IGFzIGEgMTYtYml0IG9wYWNpdHkgY2hhbm5lbCBwZXIgcGl4ZWwsIGJ1dCBzb21lIGJydXNoZXMgdXNlIHRoZSBmdWxsIDMyLWJpdHMgcGVyIHBpeGVsXG4gICAgICAgICAqIGFzIEFSR0IuXG4gICAgICAgICAqL1xuICAgICAgICBvcGFjaXR5QnVmZmVyID0gbmV3IENQR3JleUJtcChfd2lkdGgsIF9oZWlnaHQsIDMyKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFyZWEgb2YgZGlydHkgZGF0YSBjb250YWluZWQgYnkgb3BhY2l0eUJ1ZmZlciB0aGF0IHNob3VsZCBiZSBtZXJnZWQgYnkgZnVzaW9uTGF5ZXJzKClcbiAgICAgICAgICovXG4gICAgICAgIG9wYWNpdHlBcmVhID0gbmV3IENQUmVjdCgwLCAwLCAwLCAwKSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVGhlIGFyZWEgb2YgZGlydHkgbGF5ZXIgZGF0YSB0aGF0IHNob3VsZCBiZSBtZXJnZWQgaW50byB0aGUgZnVzaW9uIGJ5IGZ1c2lvbkxheWVycygpLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVzaW9uQXJlYSA9IG5ldyBDUFJlY3QoMCwgMCwgX3dpZHRoLCBfaGVpZ2h0KSxcblxuICAgICAgICAvKipcbiAgICAgICAgICogVXNlZCBieSBDUFVuZG9QYWludCB0byBrZWVwIHRyYWNrIG9mIHRoZSBhcmVhIHRoYXQgaGFzIGJlZW4gZGlydGllZCBieSBsYXllciBvcGVyYXRpb25zIGFuZCBzaG91bGQgYmVcbiAgICAgICAgICogc2F2ZWQgZm9yIHVuZG8uXG4gICAgICAgICAqL1xuICAgICAgICB1bmRvQXJlYSA9IG5ldyBDUFJlY3QoMCwgMCwgMCwgMCksXG5cbiAgICAgICAgcm5kID0gbmV3IENQUmFuZG9tKCksXG5cbiAgICAgICAgcHJldmlld09wZXJhdGlvbiA9IG51bGwsXG4gICAgICAgIFxuICAgICAgICBjbGlwYm9hcmQgPSBudWxsLCAvLyBBIENQQ2xpcFxuICAgICAgICB1bmRvTGlzdCA9IFtdLCByZWRvTGlzdCA9IFtdLFxuICAgICAgICBcbiAgICAgICAgY3VyQnJ1c2ggPSBudWxsLFxuICAgICAgICBcbiAgICAgICAgYnJ1c2hNYW5hZ2VyID0gbmV3IENQQnJ1c2hNYW5hZ2VyKCksXG4gICAgICAgIFxuICAgICAgICBsYXN0WCA9IDAuMCwgbGFzdFkgPSAwLjAsIGxhc3RQcmVzc3VyZSA9IDAuMCxcbiAgICAgICAgYnJ1c2hCdWZmZXIgPSBudWxsLFxuICAgICAgICBcbiAgICAgICAgc2FtcGxlQWxsTGF5ZXJzID0gZmFsc2UsXG4gICAgICAgIGxvY2tBbHBoYSA9IGZhbHNlLFxuICAgICAgICBcbiAgICAgICAgY3VyQ29sb3IgPSAweDAwMDAwMCwgLy8gQmxhY2tcbiAgICAgICAgdHJhbnNmb3JtSW50ZXJwb2xhdGlvbiA9IFwic21vb3RoXCIsXG5cbiAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgXG4gICAgLy8gRklYTUU6IDIwMDctMDEtMTMgSSdtIG1vdmluZyB0aGlzIHRvIHRoZSBDUFJlY3QgY2xhc3NcbiAgICAvLyBmaW5kIHdoZXJlIHRoaXMgdmVyc2lvbiBpcyB1c2VkIGFuZCBjaGFuZ2UgdGhlXG4gICAgLy8gY29kZSB0byB1c2UgdGhlIENQUmVjdCB2ZXJzaW9uXG4gICAgZnVuY3Rpb24gY2xpcFNvdXJjZURlc3Qoc3JjUmVjdCwgZHN0UmVjdCkge1xuICAgICAgICAvLyBGSVhNRTpcbiAgICAgICAgLy8gLyFcXCBkc3RSZWN0IGJvdHRvbSBhbmQgcmlnaHQgYXJlIGlnbm9yZWQgYW5kIGluc3RlYWQgd2UgY2xpcFxuICAgICAgICAvLyBhZ2FpbnN0IHRoZSB3aWR0aCwgaGVpZ2h0IG9mIHRoZSBsYXllci4gOi9cbiAgICAgICAgLy9cblxuICAgICAgICAvLyB0aGlzIHZlcnNpb24gd291bGQgYmUgZW5vdWdoIGluIG1vc3QgY2FzZXMgKHdoZW4gd2UgZG9uJ3QgbmVlZFxuICAgICAgICAvLyBzcmNSZWN0IGJvdHRvbSBhbmQgcmlnaHQgdG8gYmUgY2xpcHBlZClcbiAgICAgICAgLy8gaXQncyBsZWZ0IGhlcmUgaW4gY2FzZSBpdCdzIG5lZWRlZCB0byBtYWtlIGEgZmFzdGVyIHZlcnNpb25cbiAgICAgICAgLy8gb2YgdGhpcyBmdW5jdGlvblxuICAgICAgICAvLyBkc3RSZWN0LnJpZ2h0ID0gTWF0aC5taW4od2lkdGgsIGRzdFJlY3QubGVmdCArIHNyY1JlY3QuZ2V0V2lkdGgoKSk7XG4gICAgICAgIC8vIGRzdFJlY3QuYm90dG9tID0gTWF0aC5taW4oaGVpZ2h0LCBkc3RSZWN0LnRvcCArIHNyY1JlY3QuZ2V0SGVpZ2h0KCkpO1xuXG4gICAgICAgIC8vIG5ldyBkZXN0IGJvdHRvbS9yaWdodFxuICAgICAgICBkc3RSZWN0LnJpZ2h0ID0gZHN0UmVjdC5sZWZ0ICsgc3JjUmVjdC5nZXRXaWR0aCgpO1xuICAgICAgICBpZiAoZHN0UmVjdC5yaWdodCA+IHRoYXQud2lkdGgpIHtcbiAgICAgICAgICAgIHNyY1JlY3QucmlnaHQgLT0gZHN0UmVjdC5yaWdodCAtIHRoYXQud2lkdGg7XG4gICAgICAgICAgICBkc3RSZWN0LnJpZ2h0ID0gdGhhdC53aWR0aDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRzdFJlY3QuYm90dG9tID0gZHN0UmVjdC50b3AgKyBzcmNSZWN0LmdldEhlaWdodCgpO1xuICAgICAgICBpZiAoZHN0UmVjdC5ib3R0b20gPiB0aGF0LmhlaWdodCkge1xuICAgICAgICAgICAgc3JjUmVjdC5ib3R0b20gLT0gZHN0UmVjdC5ib3R0b20gLSB0aGF0LmhlaWdodDtcbiAgICAgICAgICAgIGRzdFJlY3QuYm90dG9tID0gdGhhdC5oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBuZXcgc3JjIHRvcC9sZWZ0XG4gICAgICAgIGlmIChkc3RSZWN0LmxlZnQgPCAwKSB7XG4gICAgICAgICAgICBzcmNSZWN0LmxlZnQgLT0gZHN0UmVjdC5sZWZ0O1xuICAgICAgICAgICAgZHN0UmVjdC5sZWZ0ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkc3RSZWN0LnRvcCA8IDApIHtcbiAgICAgICAgICAgIHNyY1JlY3QudG9wIC09IGRzdFJlY3QudG9wO1xuICAgICAgICAgICAgZHN0UmVjdC50b3AgPSAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGNhbGxMaXN0ZW5lcnNVcGRhdGVSZWdpb24ocmVnaW9uKSB7XG4gICAgICAgIHRoYXQuZW1pdEV2ZW50KFwidXBkYXRlUmVnaW9uXCIsIFtyZWdpb25dKTtcbiAgICB9XG5cbiAgICAvLyBsYXllckluZGV4IGlzIG9wdGlvbmFsLCBwcm92aWRlIHdoZW4gb25seSBvbmUgbGF5ZXIgaGFzIGJlZW4gdXBkYXRlZFxuICAgIGZ1bmN0aW9uIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZShsYXllckluZGV4KSB7XG4gICAgICAgIHRoYXQuZW1pdEV2ZW50KFwiY2hhbmdlTGF5ZXJcIiwgW2xheWVySW5kZXhdKTtcbiAgICB9XG5cbiAgICAvLyBXaGVuIHRoZSBzZWxlY3RlZCByZWN0YW5nbGUgY2hhbmdlc1xuICAgIGZ1bmN0aW9uIGNhbGxMaXN0ZW5lcnNTZWxlY3Rpb25DaGFuZ2UoKSB7XG4gICAgICAgIHRoYXQuZW1pdEV2ZW50KFwiY2hhbmdlU2VsZWN0aW9uXCIsIFtdKTtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5nZXRMYXllcnMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGxheWVycztcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRMYXllckNvdW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBsYXllcnMubGVuZ3RoO1xuICAgIH07XG4gICAgXG4gICAgLy9cbiAgICAvLyBTZWxlY3Rpb24gbWV0aG9kc1xuICAgIC8vXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBjdXJyZW50IHNlbGVjdGlvbiByZWN0IG9yIGEgcmVjdGFuZ2xlIGNvdmVyaW5nIHRoZSB3aG9sZSBjYW52YXMgaWYgdGhlcmUgYXJlIG5vIHNlbGVjdGlvbnNcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBDUFJlY3RcbiAgICAgKi9cbiAgICB0aGlzLmdldFNlbGVjdGlvbkF1dG9TZWxlY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICByO1xuXG4gICAgICAgIGlmICghY3VyU2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgciA9IGN1clNlbGVjdGlvbi5jbG9uZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgciA9IHRoaXMuZ2V0Qm91bmRzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcjtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0U2VsZWN0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjdXJTZWxlY3Rpb24uY2xvbmUoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFyayB0aGUgZ2l2ZW4gcmVjdGFuZ2xlIG9uIHRoZSBjYW52YXMgYXMgbmVlZGluZyB0byBiZSByZS1mdXNlZCAoaS5lLiB3ZSd2ZSBkcmF3biBpbiB0aGlzIHJlZ2lvbikuXG4gICAgICogTGlzdGVuZXJzIGFyZSBub3RpZmllZCBhYm91dCBvdXIgdXBkYXRlZCBjYW52YXMgcmVnaW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlY3QgQ1BSZWN0IFJlY3QgdG8gaW52YWxpZGF0ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmFsaWRhdGVGdXNpb25SZWN0KHJlY3QpIHtcbiAgICAgICAgZnVzaW9uQXJlYS51bmlvbihyZWN0KTtcblxuICAgICAgICAvLyBUaGlzIHVwZGF0ZWQgYXJlYSB3aWxsIG5lZWQgdG8gYmUgdXBkYXRlZCBpbiBvdXIgdW5kbyBidWZmZXIgbGF0ZXJcbiAgICAgICAgdW5kb0J1ZmZlckludmFsaWRSZWdpb24udW5pb24ocmVjdCk7XG5cbiAgICAgICAgY2FsbExpc3RlbmVyc1VwZGF0ZVJlZ2lvbihyZWN0KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWFyayB0aGUgZW50aXJlIGNhbnZhcyBhcyBuZWVkaW5nIHRvIGJlIHJlLWZ1c2VkICh3ZSd2ZSBkcmF3biB0byB0aGUgd2hvbGUgY2FudmFzKVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmFsaWRhdGVGdXNpb24oKSB7XG4gICAgICAgIGludmFsaWRhdGVGdXNpb25SZWN0KG5ldyBDUFJlY3QoMCwgMCwgdGhhdC53aWR0aCwgdGhhdC5oZWlnaHQpKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0SGFzVW5zYXZlZENoYW5nZXMgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBoYXNVbnNhdmVkQ2hhbmdlcyA9IHZhbHVlO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRIYXNVbnNhdmVkQ2hhbmdlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gaGFzVW5zYXZlZENoYW5nZXM7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldExheWVyVmlzaWJpbGl0eSA9IGZ1bmN0aW9uKGxheWVySW5kZXgsIHZpc2libGUpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBsYXllciA9IHRoaXMuZ2V0TGF5ZXIobGF5ZXJJbmRleCk7XG4gICAgICAgIFxuICAgICAgICBhZGRVbmRvKG5ldyBDUFVuZG9MYXllclZpc2libGUobGF5ZXJJbmRleCwgbGF5ZXIudmlzaWJsZSwgdmlzaWJsZSkpO1xuICAgICAgICBsYXllci52aXNpYmxlID0gdmlzaWJsZTtcbiAgICAgICAgXG4gICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgY2FsbExpc3RlbmVyc0xheWVyQ2hhbmdlKGxheWVySW5kZXgpO1xuICAgIH07XG5cbiAgICB0aGlzLmFkZExheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbmV3TGF5ZXIgPSBuZXcgQ1BMYXllcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcy5nZXREZWZhdWx0TGF5ZXJOYW1lKCkpLFxuICAgICAgICAgICAgYWN0aXZlTGF5ZXJJbmRleCA9IHRoaXMuZ2V0QWN0aXZlTGF5ZXJJbmRleCgpO1xuICAgICAgICBcbiAgICAgICAgbmV3TGF5ZXIuY2xlYXJBbGwoRU1QVFlfTEFZRVJfQ09MT1IpOyAvLyBUcmFuc3BhcmVudCB3aGl0ZVxuICAgICAgICBcbiAgICAgICAgYWRkVW5kbyhuZXcgQ1BVbmRvQWRkTGF5ZXIoYWN0aXZlTGF5ZXJJbmRleCkpO1xuXG4gICAgICAgIGxheWVycy5zcGxpY2UoYWN0aXZlTGF5ZXJJbmRleCArIDEsIDAsIG5ld0xheWVyKTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVMYXllckluZGV4KGFjdGl2ZUxheWVySW5kZXggKyAxKTtcblxuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5hZGRMYXllck9iamVjdCA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgICAgIGxheWVycy5wdXNoKGxheWVyKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChsYXllcnMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgIGN1ckxheWVyID0gbGF5ZXJzWzBdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbGF5ZXIuXG4gICAgICogXG4gICAgICogUmV0dXJucyB0cnVlIGlmIHRoZSBsYXllciB3YXMgcmVtb3ZlZCwgb3IgZmFsc2Ugd2hlbiByZW1vdmFsIGZhaWxlZCBiZWNhdXNlIHRoZXJlIGlzIGN1cnJlbnRseSBvbmx5IG9uZSBsYXllciBpbiBcbiAgICAgKiB0aGUgZG9jdW1lbnQuXG4gICAgICovXG4gICAgdGhpcy5yZW1vdmVMYXllciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAobGF5ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGFjdGl2ZUxheWVySW5kZXggPSB0aGlzLmdldEFjdGl2ZUxheWVySW5kZXgoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYWRkVW5kbyhuZXcgQ1BVbmRvUmVtb3ZlTGF5ZXIoYWN0aXZlTGF5ZXJJbmRleCwgY3VyTGF5ZXIpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGF5ZXJzLnNwbGljZShhY3RpdmVMYXllckluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlTGF5ZXJJbmRleChhY3RpdmVMYXllckluZGV4IDwgbGF5ZXJzLmxlbmd0aCA/IGFjdGl2ZUxheWVySW5kZXggOiBhY3RpdmVMYXllckluZGV4IC0gMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG5cbiAgICB0aGlzLmR1cGxpY2F0ZUxheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIGNvcHlTdWZmaXggPSBcIiBDb3B5XCIsXG4gICAgICAgICAgICBuZXdMYXllciA9IG5ldyBDUExheWVyKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSxcbiAgICAgICAgICAgIGFjdGl2ZUxheWVySW5kZXggPSB0aGlzLmdldEFjdGl2ZUxheWVySW5kZXgoKTtcblxuICAgICAgICBhZGRVbmRvKG5ldyBDUFVuZG9EdXBsaWNhdGVMYXllcihhY3RpdmVMYXllckluZGV4KSk7XG4gICAgICAgIFxuICAgICAgICBuZXdMYXllci5jb3B5RnJvbShsYXllcnNbYWN0aXZlTGF5ZXJJbmRleF0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFuZXdMYXllci5uYW1lLmVuZHNXaXRoKGNvcHlTdWZmaXgpKSB7XG4gICAgICAgICAgICBuZXdMYXllci5uYW1lICs9IGNvcHlTdWZmaXg7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGxheWVycy5zcGxpY2UoYWN0aXZlTGF5ZXJJbmRleCArIDEsIDAsIG5ld0xheWVyKTtcbiAgICAgICAgdGhpcy5zZXRBY3RpdmVMYXllckluZGV4KGFjdGl2ZUxheWVySW5kZXggKyAxKTtcbiAgICAgICAgXG4gICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgY2FsbExpc3RlbmVyc0xheWVyQ2hhbmdlKCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLm1lcmdlRG93biA9IGZ1bmN0aW9uKGNyZWF0ZVVuZG8pIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBhY3RpdmVMYXllckluZGV4ID0gdGhpcy5nZXRBY3RpdmVMYXllckluZGV4KCk7XG4gICAgICAgIFxuICAgICAgICBpZiAobGF5ZXJzLmxlbmd0aCA+IDEgJiYgYWN0aXZlTGF5ZXJJbmRleCA+IDApIHtcbiAgICAgICAgICAgIGlmIChjcmVhdGVVbmRvKSB7XG4gICAgICAgICAgICAgICAgYWRkVW5kbyhuZXcgQ1BVbmRvTWVyZ2VEb3duTGF5ZXIoYWN0aXZlTGF5ZXJJbmRleCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBDUEJsZW5kLmZ1c2VMYXllcihsYXllcnNbYWN0aXZlTGF5ZXJJbmRleCAtIDFdLCB0cnVlLCBsYXllcnNbYWN0aXZlTGF5ZXJJbmRleF0sIHRoaXMuZ2V0Qm91bmRzKCkpO1xuICAgICAgICAgICAgbGF5ZXJzLnNwbGljZShhY3RpdmVMYXllckluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoaXMuc2V0QWN0aXZlTGF5ZXJJbmRleChhY3RpdmVMYXllckluZGV4IC0gMSk7XG5cbiAgICAgICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMubWVyZ2VBbGxMYXllcnMgPSBmdW5jdGlvbihjcmVhdGVVbmRvKSB7XG4gICAgICAgIGlmIChsYXllcnMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgaWYgKGNyZWF0ZVVuZG8pIHtcbiAgICAgICAgICAgICAgICBhZGRVbmRvKG5ldyBDUFVuZG9NZXJnZUFsbExheWVycygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5mdXNpb25MYXllcnMoKTtcbiAgICAgICAgICAgIGxheWVycyA9IFtdO1xuXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBsYXllciA9IG5ldyBDUExheWVyKHRoYXQud2lkdGgsIHRoYXQuaGVpZ2h0LCB0aGlzLmdldERlZmF1bHRMYXllck5hbWUoKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxheWVyLmNvcHlEYXRhRnJvbShmdXNpb24pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsYXllcnMucHVzaChsYXllcik7XG4gICAgICAgICAgICB0aGlzLnNldEFjdGl2ZUxheWVySW5kZXgoMCk7XG5cbiAgICAgICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiBtb3ZlTGF5ZXJSZWFsKGZyb20sIHRvKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbGF5ZXIgPSBsYXllcnMuc3BsaWNlKGZyb20sIDEpWzBdO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRvIDw9IGZyb20pIHtcbiAgICAgICAgICAgIGxheWVycy5zcGxpY2UodG8sIDAsIGxheWVyKTtcbiAgICAgICAgICAgIHRoYXQuc2V0QWN0aXZlTGF5ZXJJbmRleCh0byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsYXllcnMuc3BsaWNlKHRvIC0gMSwgMCwgbGF5ZXIpO1xuICAgICAgICAgICAgdGhhdC5zZXRBY3RpdmVMYXllckluZGV4KHRvIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBNb3ZlIGEgbGF5ZXIgaW4gdGhlIHN0YWNrIGZyb20gb25lIGluZGV4IHRvIGFub3RoZXIuXG4gICAgICogXG4gICAgICogQHBhcmFtIGZyb20gaW50XG4gICAgICogQHBhcmFtIHRvIGludFxuICAgICAqL1xuICAgIHRoaXMubW92ZUxheWVyID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgICAgICAgaWYgKGZyb20gPCAwIHx8IGZyb20gPj0gdGhpcy5nZXRMYXllckNvdW50KCkgfHwgdG8gPCAwIHx8IHRvID4gdGhpcy5nZXRMYXllckNvdW50KCkgfHwgZnJvbSA9PSB0bykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBhZGRVbmRvKG5ldyBDUFVuZG9Nb3ZlTGF5ZXIoZnJvbSwgdG8pKTtcbiAgICAgICAgbW92ZUxheWVyUmVhbChmcm9tLCB0byk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2V0TGF5ZXJBbHBoYSA9IGZ1bmN0aW9uKGxheWVySW5kZXgsIGFscGhhKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKGxheWVySW5kZXgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxheWVyLmdldEFscGhhKCkgIT0gYWxwaGEpIHtcbiAgICAgICAgICAgIGFkZFVuZG8obmV3IENQVW5kb0xheWVyQWxwaGEobGF5ZXJJbmRleCwgYWxwaGEpKTtcbiAgICAgICAgICAgIGxheWVyLnNldEFscGhhKGFscGhhKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaW52YWxpZGF0ZUZ1c2lvbigpO1xuICAgICAgICAgICAgY2FsbExpc3RlbmVyc0xheWVyQ2hhbmdlKGxheWVySW5kZXgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2V0TGF5ZXJCbGVuZE1vZGUgPSBmdW5jdGlvbihsYXllckluZGV4LCBibGVuZE1vZGUpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBsYXllciA9IHRoaXMuZ2V0TGF5ZXIobGF5ZXJJbmRleCk7XG4gICAgXG4gICAgICAgIGlmIChsYXllci5nZXRCbGVuZE1vZGUoKSAhPSBibGVuZE1vZGUpIHtcbiAgICAgICAgICAgIGFkZFVuZG8obmV3IENQVW5kb0xheWVyTW9kZShsYXllckluZGV4LCBibGVuZE1vZGUpKTtcbiAgICAgICAgICAgIGxheWVyLnNldEJsZW5kTW9kZShibGVuZE1vZGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgICAgICBjYWxsTGlzdGVuZXJzTGF5ZXJDaGFuZ2UobGF5ZXJJbmRleCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5zZXRMYXllck5hbWUgPSBmdW5jdGlvbihsYXllckluZGV4LCBuYW1lKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbGF5ZXIgPSB0aGlzLmdldExheWVyKGxheWVySW5kZXgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGxheWVyICYmIGxheWVyLm5hbWUgIT0gbmFtZSkge1xuICAgICAgICAgICAgYWRkVW5kbyhuZXcgQ1BVbmRvTGF5ZXJSZW5hbWUobGF5ZXJJbmRleCwgbmFtZSkpO1xuICAgICAgICAgICAgbGF5ZXIubmFtZSA9IG5hbWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZShsYXllckluZGV4KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gQ1BCcnVzaFRvb2xCYXNlKCkge1xuICAgIH1cbiAgICBcbiAgICBDUEJydXNoVG9vbEJhc2UucHJvdG90eXBlLmJlZ2luU3Ryb2tlID0gZnVuY3Rpb24oeCwgeSwgcHJlc3N1cmUpIHtcbiAgICAgICAgcHJlcGFyZUZvckxheWVyVW5kbygpO1xuICAgICAgICB1bmRvQXJlYS5tYWtlRW1wdHkoKTtcblxuICAgICAgICBvcGFjaXR5QnVmZmVyLmNsZWFyQWxsKDApO1xuICAgICAgICBvcGFjaXR5QXJlYS5tYWtlRW1wdHkoKTtcblxuICAgICAgICBsYXN0WCA9IHg7XG4gICAgICAgIGxhc3RZID0geTtcbiAgICAgICAgbGFzdFByZXNzdXJlID0gcHJlc3N1cmU7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmNyZWF0ZUFuZFBhaW50RGFiKHgsIHksIHByZXNzdXJlKTtcbiAgICB9O1xuXG4gICAgQ1BCcnVzaFRvb2xCYXNlLnByb3RvdHlwZS5jb250aW51ZVN0cm9rZSA9IGZ1bmN0aW9uKHgsIHksIHByZXNzdXJlKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIGRpc3QgPSBNYXRoLnNxcnQoKChsYXN0WCAtIHgpICogKGxhc3RYIC0geCkgKyAobGFzdFkgLSB5KSAqIChsYXN0WSAtIHkpKSksXG4gICAgICAgICAgICBzcGFjaW5nID0gTWF0aC5tYXgoY3VyQnJ1c2gubWluU3BhY2luZywgY3VyQnJ1c2guY3VyU2l6ZSAqIGN1ckJydXNoLnNwYWNpbmcpO1xuXG4gICAgICAgIGlmIChkaXN0ID4gc3BhY2luZykge1xuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgIG54ID0gbGFzdFgsIG55ID0gbGFzdFksIG5wID0gbGFzdFByZXNzdXJlLFxuICAgICAgICAgICAgICAgIGRmID0gKHNwYWNpbmcgLSAwLjAwMSkgLyBkaXN0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBmID0gZGY7IGYgPD0gMS4wOyBmICs9IGRmKSB7XG4gICAgICAgICAgICAgICAgbnggPSBmICogeCArICgxLjAgLSBmKSAqIGxhc3RYO1xuICAgICAgICAgICAgICAgIG55ID0gZiAqIHkgKyAoMS4wIC0gZikgKiBsYXN0WTtcbiAgICAgICAgICAgICAgICBucCA9IGYgKiBwcmVzc3VyZSArICgxLjAgLSBmKSAqIGxhc3RQcmVzc3VyZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUFuZFBhaW50RGFiKG54LCBueSwgbnApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFggPSBueDtcbiAgICAgICAgICAgIGxhc3RZID0gbnk7XG4gICAgICAgICAgICBsYXN0UHJlc3N1cmUgPSBucDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDUEJydXNoVG9vbEJhc2UucHJvdG90eXBlLmVuZFN0cm9rZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB1bmRvQXJlYS5jbGlwKHRoYXQuZ2V0Qm91bmRzKCkpO1xuXG4gICAgICAgIC8vIERpZCB3ZSBlbmQgdXAgcGFpbnRpbmcgYW55dGhpbmc/XG4gICAgICAgIGlmICghdW5kb0FyZWEuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICBtZXJnZU9wYWNpdHlCdWZmZXIoY3VyQ29sb3IsIGZhbHNlKTtcbiAgICAgICAgICAgIGFkZFVuZG8obmV3IENQVW5kb1BhaW50KCkpO1xuXG4gICAgICAgICAgICAvKiBFYWdlcmx5IHVwZGF0ZSB0aGUgdW5kbyBidWZmZXIgZm9yIG5leHQgdGltZSBzbyB3ZSBjYW4gYXZvaWQgdGhpcyBsZW5ndGh5XG4gICAgICAgICAgICAgKiBwcmVwYXJlIGF0IHRoZSBiZWdpbm5pbmcgb2YgYSBwYWludCBzdHJva2VcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHJlcGFyZUZvckxheWVyVW5kbygpOyBcbiAgICAgICAgfVxuICAgICAgICBicnVzaEJ1ZmZlciA9IG51bGw7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIHBhaW50IGRhYiBhdCB0aGUgZ2l2ZW4gcG9zaXRpb24gdXNpbmcgdGhlIGN1cnJlbnQgYnJ1c2gsIGFuZCBwYWludCBpdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB4IGZsb2F0XG4gICAgICogQHBhcmFtIHkgZmxvYXRcbiAgICAgKiBAcGFyYW0gcHJlc3N1cmUgZmxvYXRcbiAgICAgKi9cbiAgICBDUEJydXNoVG9vbEJhc2UucHJvdG90eXBlLmNyZWF0ZUFuZFBhaW50RGFiID0gZnVuY3Rpb24oeCwgeSwgcHJlc3N1cmUpIHtcbiAgICAgICAgY3VyQnJ1c2guYXBwbHlQcmVzc3VyZShwcmVzc3VyZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY3VyQnJ1c2guc2NhdHRlcmluZyA+IDAuMCkge1xuICAgICAgICAgICAgeCArPSBybmQubmV4dEdhdXNzaWFuKCkgKiBjdXJCcnVzaC5jdXJTY2F0dGVyaW5nIC8gNC4wO1xuICAgICAgICAgICAgeSArPSBybmQubmV4dEdhdXNzaWFuKCkgKiBjdXJCcnVzaC5jdXJTY2F0dGVyaW5nIC8gNC4wO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB2YXIgXG4gICAgICAgICAgICBkYWIgPSBicnVzaE1hbmFnZXIuZ2V0RGFiKHgsIHksIGN1ckJydXNoKTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucGFpbnREYWIoZGFiKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUGFpbnQgYSBkYWIgcmV0dXJuZWQgYnkgYnJ1c2hNYW5hZ2VyLmdldERhYigpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGFiIHtieXRlW10gYnJ1c2g7IGludCB4LCB5LCBhbHBoYSwgd2lkdGgsIGhlaWdodH1cbiAgICAgKi9cbiAgICBDUEJydXNoVG9vbEJhc2UucHJvdG90eXBlLnBhaW50RGFiID0gZnVuY3Rpb24oZGFiKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgc3JjUmVjdCA9IG5ldyBDUFJlY3QoMCwgMCwgZGFiLndpZHRoLCBkYWIuaGVpZ2h0KSxcbiAgICAgICAgICAgIGRzdFJlY3QgPSBuZXcgQ1BSZWN0KDAsIDAsIGRhYi53aWR0aCwgZGFiLmhlaWdodCk7XG4gICAgICAgIFxuICAgICAgICBkc3RSZWN0LnRyYW5zbGF0ZShkYWIueCwgZGFiLnkpO1xuXG4gICAgICAgIGNsaXBTb3VyY2VEZXN0KHNyY1JlY3QsIGRzdFJlY3QpO1xuXG4gICAgICAgIC8vIGRyYXdpbmcgZW50aXJlbHkgb3V0c2lkZSB0aGUgY2FudmFzXG4gICAgICAgIGlmIChkc3RSZWN0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdW5kb0FyZWEudW5pb24oZHN0UmVjdCk7XG4gICAgICAgIG9wYWNpdHlBcmVhLnVuaW9uKGRzdFJlY3QpO1xuXG4gICAgICAgIHRoaXMucGFpbnREYWJJbXBsZW1lbnRhdGlvbihzcmNSZWN0LCBkc3RSZWN0LCBkYWIpO1xuICAgICAgICBcbiAgICAgICAgaW52YWxpZGF0ZUZ1c2lvblJlY3QoZHN0UmVjdCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ1BCcnVzaFRvb2xTaW1wbGVCcnVzaCgpIHtcbiAgICB9XG5cbiAgICBDUEJydXNoVG9vbFNpbXBsZUJydXNoLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BCcnVzaFRvb2xCYXNlLnByb3RvdHlwZSk7XG4gICAgQ1BCcnVzaFRvb2xTaW1wbGVCcnVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUEJydXNoVG9vbFNpbXBsZUJydXNoOyBcbiAgICBcbiAgICBDUEJydXNoVG9vbFNpbXBsZUJydXNoLnByb3RvdHlwZS5wYWludERhYkltcGxlbWVudGF0aW9uID0gZnVuY3Rpb24oc3JjUmVjdCwgZHN0UmVjdCwgZGFiKSB7XG4gICAgICAgIC8vIEZJWE1FOiB0aGVyZSBzaG91bGQgYmUgbm8gcmVmZXJlbmNlIHRvIGEgc3BlY2lmaWMgdG9vbCBoZXJlXG4gICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBicnVzaCBwYXJhbWV0ZXIgaW5zdGVhZFxuICAgICAgICBpZiAoY3VyQnJ1c2guaXNBaXJicnVzaCkge1xuICAgICAgICAgICAgdGhpcy5wYWludEZsb3coc3JjUmVjdCwgZHN0UmVjdCwgZGFiLmJydXNoLCBkYWIud2lkdGgsIE1hdGgubWF4KDEsIGRhYi5hbHBoYSAvIDgpKTtcbiAgICAgICAgfSBlbHNlIGlmIChjdXJCcnVzaC50b29sTmIgPT0gQ2hpY2tlblBhaW50LlRfUEVOKSB7XG4gICAgICAgICAgICB0aGlzLnBhaW50RmxvdyhzcmNSZWN0LCBkc3RSZWN0LCBkYWIuYnJ1c2gsIGRhYi53aWR0aCwgTWF0aC5tYXgoMSwgZGFiLmFscGhhIC8gMikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWludE9wYWNpdHkoc3JjUmVjdCwgZHN0UmVjdCwgZGFiLmJydXNoLCBkYWIud2lkdGgsIGRhYi5hbHBoYSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ1BCcnVzaFRvb2xTaW1wbGVCcnVzaC5wcm90b3R5cGUubWVyZ2VPcGFjaXR5QnVmID0gZnVuY3Rpb24oZHN0UmVjdCwgY29sb3IgLyogaW50ICovKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIG9wYWNpdHlEYXRhID0gb3BhY2l0eUJ1ZmZlci5kYXRhLFxuICAgICAgICAgICAgdW5kb0RhdGEgPSB1bmRvQnVmZmVyLmRhdGEsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlZCA9IChjb2xvciA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgZ3JlZW4gPSAoY29sb3IgPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgYmx1ZSA9IGNvbG9yICYgMHhGRixcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgd2lkdGggPSBkc3RSZWN0LmdldFdpZHRoKCkgfCAwLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZHN0UmVjdC5nZXRIZWlnaHQoKSB8IDAsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGRzdE9mZnNldCA9IGN1ckxheWVyLm9mZnNldE9mUGl4ZWwoZHN0UmVjdC5sZWZ0LCBkc3RSZWN0LnRvcCksXG4gICAgICAgICAgICBzcmNPZmZzZXQgPSBvcGFjaXR5QnVmZmVyLm9mZnNldE9mUGl4ZWwoZHN0UmVjdC5sZWZ0LCBkc3RSZWN0LnRvcCksXG4gICAgICAgIFxuICAgICAgICAgICAgc3JjWVN0cmlkZSA9IChvcGFjaXR5QnVmZmVyLndpZHRoIC0gd2lkdGgpIHwgMCxcbiAgICAgICAgICAgIGRzdFlTdHJpZGUgPSAoKGN1ckxheWVyLndpZHRoIC0gd2lkdGgpICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpIHwgMDtcblxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGhlaWdodDsgeSsrLCBzcmNPZmZzZXQgKz0gc3JjWVN0cmlkZSwgZHN0T2Zmc2V0ICs9IGRzdFlTdHJpZGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGg7IHgrKywgc3JjT2Zmc2V0KyssIGRzdE9mZnNldCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5QWxwaGEgPSAob3BhY2l0eURhdGFbc3JjT2Zmc2V0XSAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChvcGFjaXR5QWxwaGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdEFscGhhID0gdW5kb0RhdGFbZHN0T2Zmc2V0ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0sXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGF5ZXJBbHBoYSA9IChvcGFjaXR5QWxwaGEgKyBkZXN0QWxwaGEgKiAoMjU1IC0gb3BhY2l0eUFscGhhKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVhbEFscGhhID0gKDI1NSAqIG9wYWNpdHlBbHBoYSAvIG5ld0xheWVyQWxwaGEpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhID0gMjU1IC0gcmVhbEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY3VyTGF5ZXIuZGF0YVtkc3RPZmZzZXRdID0gKChyZWQgKiByZWFsQWxwaGEgKyB1bmRvRGF0YVtkc3RPZmZzZXRdICogaW52QWxwaGEpIC8gMjU1KSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgMV0gPSAoKGdyZWVuICogcmVhbEFscGhhICsgdW5kb0RhdGFbZHN0T2Zmc2V0ICsgMV0gKiBpbnZBbHBoYSkgLyAyNTUpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgY3VyTGF5ZXIuZGF0YVtkc3RPZmZzZXQgKyAyXSA9ICgoYmx1ZSAqIHJlYWxBbHBoYSArIHVuZG9EYXRhW2RzdE9mZnNldCArIDJdICogaW52QWxwaGEpIC8gMjU1KSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgM10gPSBuZXdMYXllckFscGhhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcmNSZWN0IENQUmVjdFxuICAgICAqIEBwYXJhbSBkc3RSZWN0IENQUmVjdFxuICAgICAqIEBwYXJhbSBicnVzaCBpbnRbXVxuICAgICAqIEBwYXJhbSBicnVzaFdpZHRoIGludFxuICAgICAqIEBwYXJhbSBhbHBoYSBmbG9hdFxuICAgICAqL1xuICAgIENQQnJ1c2hUb29sU2ltcGxlQnJ1c2gucHJvdG90eXBlLnBhaW50T3BhY2l0eSA9IGZ1bmN0aW9uKHNyY1JlY3QsIGRzdFJlY3QsIGJydXNoLCBicnVzaFdpZHRoLCBhbHBoYSkge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBvcGFjaXR5RGF0YSA9IG9wYWNpdHlCdWZmZXIuZGF0YSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3JjT2Zmc2V0ID0gc3JjUmVjdC5sZWZ0ICsgc3JjUmVjdC50b3AgKiBicnVzaFdpZHRoLFxuICAgICAgICAgICAgZHN0T2Zmc2V0ID0gb3BhY2l0eUJ1ZmZlci5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgZHN0UmVjdC50b3ApLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBkc3RXaWR0aCA9IGRzdFJlY3QuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3JjWVN0cmlkZSA9IGJydXNoV2lkdGggLSBkc3RXaWR0aCxcbiAgICAgICAgICAgIGRzdFlTdHJpZGUgPSB0aGF0LndpZHRoIC0gZHN0V2lkdGg7XG5cbiAgICAgICAgYWxwaGEgPSBNYXRoLm1pbigyNTUsIGFscGhhKTtcblxuICAgICAgICBmb3IgKHZhciB5ID0gZHN0UmVjdC50b3A7IHkgPCBkc3RSZWN0LmJvdHRvbTsgeSsrLCBzcmNPZmZzZXQgKz0gc3JjWVN0cmlkZSwgZHN0T2Zmc2V0ICs9IGRzdFlTdHJpZGUpIHtcbiAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZHN0V2lkdGg7IHgrKywgc3JjT2Zmc2V0KyssIGRzdE9mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgb3BhY2l0eURhdGFbZHN0T2Zmc2V0XSA9IE1hdGgubWF4KGJydXNoW3NyY09mZnNldF0gKiBhbHBoYSwgb3BhY2l0eURhdGFbZHN0T2Zmc2V0XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ1BCcnVzaFRvb2xTaW1wbGVCcnVzaC5wcm90b3R5cGUucGFpbnRGbG93ID0gZnVuY3Rpb24oc3JjUmVjdCwgZHN0UmVjdCwgYnJ1c2gsIGJydXNoV2lkdGgsIGFscGhhKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIG9wYWNpdHlEYXRhID0gb3BhY2l0eUJ1ZmZlci5kYXRhLFxuXG4gICAgICAgICAgICBzcmNPZmZzZXQgPSBzcmNSZWN0LmxlZnQgKyBzcmNSZWN0LnRvcCAqIGJydXNoV2lkdGgsXG4gICAgICAgICAgICBkc3RPZmZzZXQgPSBvcGFjaXR5QnVmZmVyLm9mZnNldE9mUGl4ZWwoZHN0UmVjdC5sZWZ0LCBkc3RSZWN0LnRvcCksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGRzdFdpZHRoID0gZHN0UmVjdC5nZXRXaWR0aCgpLFxuXG4gICAgICAgICAgICBzcmNZU3RyaWRlID0gYnJ1c2hXaWR0aCAtIGRzdFdpZHRoLFxuICAgICAgICAgICAgZHN0WVN0cmlkZSA9IHRoYXQud2lkdGggLSBkc3RXaWR0aDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIHkgPSBkc3RSZWN0LnRvcDsgeSA8IGRzdFJlY3QuYm90dG9tOyB5KyssIHNyY09mZnNldCArPSBzcmNZU3RyaWRlLCBkc3RPZmZzZXQgKz0gZHN0WVN0cmlkZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBkc3RXaWR0aDsgeCsrLCBzcmNPZmZzZXQrKywgZHN0T2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgYnJ1c2hBbHBoYSA9IGJydXNoW3NyY09mZnNldF0gKiBhbHBoYTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYnJ1c2hBbHBoYSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eUFscGhhID0gTWF0aC5taW4oMjU1ICogMjU1LCBvcGFjaXR5RGF0YVtkc3RPZmZzZXRdICsgKDI1NSAtIG9wYWNpdHlEYXRhW2RzdE9mZnNldF0gLyAyNTUpICogYnJ1c2hBbHBoYSAvIDI1NSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5RGF0YVtkc3RPZmZzZXRdID0gb3BhY2l0eUFscGhhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKkNQQnJ1c2hUb29sU2ltcGxlQnJ1c2gucHJvdG90eXBlLnBhaW50T3BhY2l0eUZsb3cgPSBmdW5jdGlvbihzcmNSZWN0LCBkc3RSZWN0LCBicnVzaCwgYnJ1c2hXaWR0aCwgb3BhY2l0eSwgZmxvdykge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBvcGFjaXR5RGF0YSA9IG9wYWNpdHlCdWZmZXIuZGF0YSxcblxuICAgICAgICAgICAgYnkgPSBzcmNSZWN0LnRvcDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIHkgPSBkc3RSZWN0LnRvcDsgeSA8IGRzdFJlY3QuYm90dG9tOyB5KyssIGJ5KyspIHtcbiAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICBzcmNPZmZzZXQgPSBzcmNSZWN0LmxlZnQgKyBieSAqIGJydXNoV2lkdGgsXG4gICAgICAgICAgICAgICAgZHN0T2Zmc2V0ID0gZHN0UmVjdC5sZWZ0ICsgeSAqIHdpZHRoO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gZHN0UmVjdC5sZWZ0OyB4IDwgZHN0UmVjdC5yaWdodDsgeCsrLCBzcmNPZmZzZXQrKywgZHN0T2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgIGJydXNoQWxwaGEgPSBicnVzaFtzcmNPZmZzZXRdICogZmxvdztcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYnJ1c2hBbHBoYSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eUFscGhhID0gb3BhY2l0eURhdGFbZHN0T2Zmc2V0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gTWF0aC5taW4oMjU1ICogMjU1LCBvcGFjaXR5QWxwaGEgKyAob3BhY2l0eSAtIG9wYWNpdHlBbHBoYSAvIDI1NSkgKiBicnVzaEFscGhhIC8gMjU1KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gTWF0aC5taW4ob3BhY2l0eSAqIGJydXNoW3NyY09mZnNldF0sIG5ld0FscGhhKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdBbHBoYSA+IG9wYWNpdHlBbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eURhdGFbZHN0T2Zmc2V0XSA9IG5ld0FscGhhO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTsqL1xuXG4gICAgZnVuY3Rpb24gQ1BCcnVzaFRvb2xFcmFzZXIoKSB7XG4gICAgfVxuICAgIFxuICAgIENQQnJ1c2hUb29sRXJhc2VyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BCcnVzaFRvb2xTaW1wbGVCcnVzaC5wcm90b3R5cGUpO1xuICAgIENQQnJ1c2hUb29sRXJhc2VyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQQnJ1c2hUb29sRXJhc2VyO1xuICAgIFxuICAgIENQQnJ1c2hUb29sRXJhc2VyLnByb3RvdHlwZS5tZXJnZU9wYWNpdHlCdWYgPSBmdW5jdGlvbihkc3RSZWN0LCBjb2xvcikge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBvcGFjaXR5RGF0YSA9IG9wYWNpdHlCdWZmZXIuZGF0YSxcbiAgICAgICAgICAgIHVuZG9EYXRhID0gdW5kb0J1ZmZlci5kYXRhO1xuICAgIFxuICAgICAgICBmb3IgKHZhciB5ID0gZHN0UmVjdC50b3A7IHkgPCBkc3RSZWN0LmJvdHRvbTsgeSsrKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBkc3RPZmZzZXQgPSBjdXJMYXllci5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgeSkgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VULFxuICAgICAgICAgICAgICAgIHNyY09mZnNldCA9IG9wYWNpdHlCdWZmZXIub2Zmc2V0T2ZQaXhlbChkc3RSZWN0LmxlZnQsIHkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gZHN0UmVjdC5sZWZ0OyB4IDwgZHN0UmVjdC5yaWdodDsgeCsrLCBkc3RPZmZzZXQgKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eUFscGhhID0gKG9wYWNpdHlEYXRhW3NyY09mZnNldCsrXSAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChvcGFjaXR5QWxwaGEgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzdEFscGhhID0gdW5kb0RhdGFbZHN0T2Zmc2V0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxBbHBoYSA9IGRlc3RBbHBoYSAqICgyNTUgLSBvcGFjaXR5QWxwaGEpIC8gMjU1O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY3VyTGF5ZXIuZGF0YVtkc3RPZmZzZXRdID0gcmVhbEFscGhhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDUEJydXNoVG9vbERvZGdlKCkge1xuICAgIH1cbiAgICBcbiAgICBDUEJydXNoVG9vbERvZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BCcnVzaFRvb2xTaW1wbGVCcnVzaC5wcm90b3R5cGUpO1xuICAgIENQQnJ1c2hUb29sRG9kZ2UucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BCcnVzaFRvb2xEb2RnZTtcbiAgICBcbiAgICBDUEJydXNoVG9vbERvZGdlLnByb3RvdHlwZS5tZXJnZU9wYWNpdHlCdWYgPSBmdW5jdGlvbihkc3RSZWN0LCBjb2xvcikge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBvcGFjaXR5RGF0YSA9IG9wYWNpdHlCdWZmZXIuZGF0YSxcbiAgICAgICAgICAgIHVuZG9EYXRhID0gdW5kb0J1ZmZlci5kYXRhO1xuICAgIFxuICAgICAgICBmb3IgKHZhciB5ID0gZHN0UmVjdC50b3A7IHkgPCBkc3RSZWN0LmJvdHRvbTsgeSsrKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBkc3RPZmZzZXQgPSBjdXJMYXllci5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgeSksXG4gICAgICAgICAgICAgICAgc3JjT2Zmc2V0ID0gb3BhY2l0eUJ1ZmZlci5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgeSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIHggPSBkc3RSZWN0LmxlZnQ7IHggPCBkc3RSZWN0LnJpZ2h0OyB4KyssIHNyY09mZnNldCsrLCBkc3RPZmZzZXQgKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eUFscGhhID0gKG9wYWNpdHlEYXRhW3NyY09mZnNldF0gLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAob3BhY2l0eUFscGhhID4gMCAmJiB1bmRvRGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHlBbHBoYSArPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSAodW5kb0RhdGFbZHN0T2Zmc2V0ICsgaV0gKiBvcGFjaXR5QWxwaGEgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbCA+IDI1NSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoYW5uZWwgPSAyNTU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgaV0gPSBjaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIENQQnJ1c2hUb29sQnVybigpIHtcbiAgICB9XG4gICAgXG4gICAgQ1BCcnVzaFRvb2xCdXJuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BCcnVzaFRvb2xTaW1wbGVCcnVzaC5wcm90b3R5cGUpO1xuICAgIENQQnJ1c2hUb29sQnVybi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUEJydXNoVG9vbEJ1cm47XG4gICAgXG4gICAgQ1BCcnVzaFRvb2xCdXJuLnByb3RvdHlwZS5tZXJnZU9wYWNpdHlCdWYgPSBmdW5jdGlvbihkc3RSZWN0LCBjb2xvcikge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBvcGFjaXR5RGF0YSA9IG9wYWNpdHlCdWZmZXIuZGF0YSxcbiAgICAgICAgICAgIHVuZG9EYXRhID0gdW5kb0J1ZmZlci5kYXRhO1xuICAgIFxuICAgICAgICBmb3IgKHZhciB5ID0gZHN0UmVjdC50b3A7IHkgPCBkc3RSZWN0LmJvdHRvbTsgeSsrKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBkc3RPZmZzZXQgPSBjdXJMYXllci5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgeSksXG4gICAgICAgICAgICAgICAgc3JjT2Zmc2V0ID0gb3BhY2l0eUJ1ZmZlci5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgeSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIHggPSBkc3RSZWN0LmxlZnQ7IHggPCBkc3RSZWN0LnJpZ2h0OyB4KyssIHNyY09mZnNldCsrLCBkc3RPZmZzZXQgKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eUFscGhhID0gKG9wYWNpdHlEYXRhW3NyY09mZnNldF0gLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAob3BhY2l0eUFscGhhID4gMCAmJiB1bmRvRGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHVuZG9EYXRhW2RzdE9mZnNldCArIGldO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFubmVsID0gKGNoYW5uZWwgLSAoQlVSTl9DT05TVEFOVCAtIGNoYW5uZWwpICogb3BhY2l0eUFscGhhIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoYW5uZWwgPCAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hhbm5lbCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgaV0gPSBjaGFubmVsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiBDUEJydXNoVG9vbEJsdXIoKSB7XG4gICAgfVxuICAgIFxuICAgIENQQnJ1c2hUb29sQmx1ci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQQnJ1c2hUb29sU2ltcGxlQnJ1c2gucHJvdG90eXBlKTtcbiAgICBDUEJydXNoVG9vbEJsdXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BCcnVzaFRvb2xCbHVyO1xuXG4gICAgQ1BCcnVzaFRvb2xCbHVyLnByb3RvdHlwZS5tZXJnZU9wYWNpdHlCdWYgPSBmdW5jdGlvbihkc3RSZWN0LCBjb2xvcikge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBvcGFjaXR5RGF0YSA9IG9wYWNpdHlCdWZmZXIuZGF0YSxcbiAgICAgICAgICAgIHVuZG9EYXRhID0gdW5kb0J1ZmZlci5kYXRhLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBkc3RZU3RyaWRlID0gdW5kb0J1ZmZlci53aWR0aCAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICByLCBnLCBiLCBhO1xuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFNhbXBsZShzYW1wbGVPZmZzZXQpIHtcbiAgICAgICAgICAgIHIgKz0gdW5kb0RhdGFbc2FtcGxlT2Zmc2V0ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgZyArPSB1bmRvRGF0YVtzYW1wbGVPZmZzZXQgKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgIGIgKz0gdW5kb0RhdGFbc2FtcGxlT2Zmc2V0ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgIGEgKz0gdW5kb0RhdGFbc2FtcGxlT2Zmc2V0ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIHkgPSBkc3RSZWN0LnRvcDsgeSA8IGRzdFJlY3QuYm90dG9tOyB5KyspIHtcbiAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICBkc3RPZmZzZXQgPSB1bmRvQnVmZmVyLm9mZnNldE9mUGl4ZWwoZHN0UmVjdC5sZWZ0LCB5KSxcbiAgICAgICAgICAgICAgICBzcmNPZmZzZXQgPSBvcGFjaXR5QnVmZmVyLm9mZnNldE9mUGl4ZWwoZHN0UmVjdC5sZWZ0LCB5KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IGRzdFJlY3QubGVmdDsgeCA8IGRzdFJlY3QucmlnaHQ7IHgrKywgZHN0T2Zmc2V0ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLCBzcmNPZmZzZXQrKykge1xuICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eUFscGhhID0gKG9wYWNpdHlEYXRhW3NyY09mZnNldF0gLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAob3BhY2l0eUFscGhhID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsdXIgPSAoQkxVUl9NSU4gKyAoQkxVUl9NQVggLSBCTFVSX01JTikgKiBvcGFjaXR5QWxwaGEgLyAyNTUpIHwgMCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgc3VtID0gYmx1ciArIDQ7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByID0gYmx1ciAqIHVuZG9EYXRhW2RzdE9mZnNldCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICAgICAgZyA9IGJsdXIgKiB1bmRvRGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICAgICAgYiA9IGJsdXIgKiB1bmRvRGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICBhID0gYmx1ciAqIHVuZG9EYXRhW2RzdE9mZnNldCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdO1xuXG4gICAgICAgICAgICAgICAgICAgIGFkZFNhbXBsZSh5ID4gMCA/IGRzdE9mZnNldCAtIGRzdFlTdHJpZGUgOiBkc3RPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBhZGRTYW1wbGUoeSA8IHVuZG9CdWZmZXIuaGVpZ2h0IC0gMSA/IGRzdE9mZnNldCArIGRzdFlTdHJpZGUgOiBkc3RPZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICBhZGRTYW1wbGUoeCA+IDAgPyBkc3RPZmZzZXQgLSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCA6IGRzdE9mZnNldCk7XG4gICAgICAgICAgICAgICAgICAgIGFkZFNhbXBsZSh4IDwgdW5kb0J1ZmZlci53aWR0aCAtIDEgPyBkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCA6IGRzdE9mZnNldCk7XG5cbiAgICAgICAgICAgICAgICAgICAgYSAvPSBzdW07XG4gICAgICAgICAgICAgICAgICAgIHIgLz0gc3VtO1xuICAgICAgICAgICAgICAgICAgICBnIC89IHN1bTtcbiAgICAgICAgICAgICAgICAgICAgYiAvPSBzdW07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjdXJMYXllci5kYXRhW2RzdE9mZnNldCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9IHIgfCAwO1xuICAgICAgICAgICAgICAgICAgICBjdXJMYXllci5kYXRhW2RzdE9mZnNldCArIENQQ29sb3JCbXAuR1JFRU5fQllURV9PRkZTRVRdID0gZyB8IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSA9IGIgfCAwO1xuICAgICAgICAgICAgICAgICAgICBjdXJMYXllci5kYXRhW2RzdE9mZnNldCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID0gYSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qIEJydXNoZXMgZGVyaXZlZCBmcm9tIHRoaXMgY2xhc3MgdXNlIHRoZSBvcGFjaXR5IGJ1ZmZlciBhcyBhIHNpbXBsZSBhbHBoYSBsYXllciAoMzItYml0IHBpeGVscyBpbiBBUkdCIG9yZGVyKSAqL1xuICAgIGZ1bmN0aW9uIENQQnJ1c2hUb29sRGlyZWN0QnJ1c2goKSB7XG4gICAgfVxuICAgIFxuICAgIENQQnJ1c2hUb29sRGlyZWN0QnJ1c2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUEJydXNoVG9vbFNpbXBsZUJydXNoLnByb3RvdHlwZSk7XG4gICAgQ1BCcnVzaFRvb2xEaXJlY3RCcnVzaC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUEJydXNoVG9vbERpcmVjdEJydXNoO1xuXG4gICAgQ1BCcnVzaFRvb2xEaXJlY3RCcnVzaC5wcm90b3R5cGUubWVyZ2VPcGFjaXR5QnVmID0gZnVuY3Rpb24oZHN0UmVjdCwgY29sb3IpIHtcbiAgICAgICAgdmFyIFxuICAgICAgICAgICAgb3BhY2l0eURhdGEgPSBvcGFjaXR5QnVmZmVyLmRhdGEsXG4gICAgICAgICAgICB1bmRvRGF0YSA9IHVuZG9CdWZmZXIuZGF0YSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3JjT2Zmc2V0ID0gb3BhY2l0eUJ1ZmZlci5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgZHN0UmVjdC50b3ApLFxuICAgICAgICAgICAgZHN0T2Zmc2V0ID0gY3VyTGF5ZXIub2Zmc2V0T2ZQaXhlbChkc3RSZWN0LmxlZnQsIGRzdFJlY3QudG9wKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgd2lkdGggPSBkc3RSZWN0LmdldFdpZHRoKCkgfCAwLFxuICAgICAgICAgICAgaGVpZ2h0ID0gZHN0UmVjdC5nZXRIZWlnaHQoKSB8IDAsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNyY1lTdHJpZGUgPSAob3BhY2l0eUJ1ZmZlci53aWR0aCAtIHdpZHRoKSB8IDAsXG4gICAgICAgICAgICBkc3RZU3RyaWRlID0gKChjdXJMYXllci53aWR0aCAtIHdpZHRoKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMKSB8IDA7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKywgc3JjT2Zmc2V0ICs9IHNyY1lTdHJpZGUsIGRzdE9mZnNldCArPSBkc3RZU3RyaWRlKSB7XG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoOyB4KyssIHNyY09mZnNldCsrLCBkc3RPZmZzZXQgKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gb3BhY2l0eURhdGFbc3JjT2Zmc2V0XSxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gY29sb3IxID4+PiAyNDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYWxwaGExID09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAvLyBQcmV0dHkgc3VyZSBmdXNpb24uYWxwaGEgaXMgYWx3YXlzIDEwMCBhbmQgdGhlIGNvbW1lbnRlZCBzZWN0aW9uIGlzIGEgY29weS9wYXN0ZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSB1bmRvRGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSAvKiAqIGZ1c2lvbi5hbHBoYSAvIDEwMCAqLywgXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChuZXdBbHBoYSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFsQWxwaGEgPSAoYWxwaGExICogMjU1IC8gbmV3QWxwaGEpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhID0gMjU1IC0gcmVhbEFscGhhO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgY3VyTGF5ZXIuZGF0YVtkc3RPZmZzZXRdID0gKCgoKGNvbG9yMSA+PiAxNikgJiAweEZGKSAqIHJlYWxBbHBoYSArIHVuZG9EYXRhW2RzdE9mZnNldF0gKiBpbnZBbHBoYSkgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgY3VyTGF5ZXIuZGF0YVtkc3RPZmZzZXQgKyAxXSA9ICgoKChjb2xvcjEgPj4gOCkgJiAweEZGKSAqIHJlYWxBbHBoYSArIHVuZG9EYXRhW2RzdE9mZnNldCArIDFdICogaW52QWxwaGEpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgMl0gPSAoKChjb2xvcjEgJiAweEZGKSAqIHJlYWxBbHBoYSArIHVuZG9EYXRhW2RzdE9mZnNldCArIDJdICogaW52QWxwaGEpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgM10gPSBuZXdBbHBoYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIGZ1bmN0aW9uIENQQnJ1c2hUb29sV2F0ZXJjb2xvcigpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIFdDTUVNT1JZID0gNTAsXG4gICAgICAgICAgICBXWE1BWFNBTVBMRVJBRElVUyA9IDY0O1xuXG4gICAgICAgIHZhclxuICAgICAgICAgICAgcHJldmlvdXNTYW1wbGVzID0gW107XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF2ZXJhZ2Ugb3V0IGEgYnVuY2ggb2Ygc2FtcGxlcyBhcm91bmQgdGhlIGdpdmVuIHBpeGVsICh4LCB5KS5cbiAgICAgICAgICogXG4gICAgICAgICAqIGR4LCBkeSBjb250cm9scyB0aGUgc3ByZWFkIG9mIHRoZSBzYW1wbGVzLlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHJldHVybnMgQ1BDb2xvckZsb2F0XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBzYW1wbGVDb2xvcih4LCB5LCBkeCwgZHkpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHNhbXBsZXMgPSBbXSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsYXllclRvU2FtcGxlID0gc2FtcGxlQWxsTGF5ZXJzID8gZnVzaW9uIDogdGhhdC5nZXRBY3RpdmVMYXllcigpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB4ID0geCB8IDA7XG4gICAgICAgICAgICB5ID0geSB8IDA7XG5cbiAgICAgICAgICAgIHNhbXBsZXMucHVzaChDUENvbG9yRmxvYXQuY3JlYXRlRnJvbUludChsYXllclRvU2FtcGxlLmdldFBpeGVsKHgsIHkpKSk7XG5cbiAgICAgICAgICAgIGZvciAodmFyIHIgPSAwLjI1OyByIDwgMS4wMDE7IHIgKz0gLjI1KSB7XG4gICAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKENQQ29sb3JGbG9hdC5jcmVhdGVGcm9tSW50KGxheWVyVG9TYW1wbGUuZ2V0UGl4ZWwofn4oeCArIHIgKiBkeCksIHkpKSk7XG4gICAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKENQQ29sb3JGbG9hdC5jcmVhdGVGcm9tSW50KGxheWVyVG9TYW1wbGUuZ2V0UGl4ZWwofn4oeCAtIHIgKiBkeCksIHkpKSk7XG4gICAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKENQQ29sb3JGbG9hdC5jcmVhdGVGcm9tSW50KGxheWVyVG9TYW1wbGUuZ2V0UGl4ZWwoeCwgfn4oeSArIHIgKiBkeSkpKSk7XG4gICAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKENQQ29sb3JGbG9hdC5jcmVhdGVGcm9tSW50KGxheWVyVG9TYW1wbGUuZ2V0UGl4ZWwoeCwgfn4oeSAtIHIgKiBkeSkpKSk7XG5cbiAgICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goQ1BDb2xvckZsb2F0LmNyZWF0ZUZyb21JbnQobGF5ZXJUb1NhbXBsZS5nZXRQaXhlbCh+fih4ICsgciAqIDAuNyAqIGR4KSwgfn4oeSArIHIgKiAwLjcgKiBkeSkpKSk7XG4gICAgICAgICAgICAgICAgc2FtcGxlcy5wdXNoKENQQ29sb3JGbG9hdC5jcmVhdGVGcm9tSW50KGxheWVyVG9TYW1wbGUuZ2V0UGl4ZWwofn4oeCArIHIgKiAwLjcgKiBkeCksIH5+KHkgLSByICogMC43ICogZHkpKSkpO1xuICAgICAgICAgICAgICAgIHNhbXBsZXMucHVzaChDUENvbG9yRmxvYXQuY3JlYXRlRnJvbUludChsYXllclRvU2FtcGxlLmdldFBpeGVsKH5+KHggLSByICogMC43ICogZHgpLCB+fih5ICsgciAqIDAuNyAqIGR5KSkpKTtcbiAgICAgICAgICAgICAgICBzYW1wbGVzLnB1c2goQ1BDb2xvckZsb2F0LmNyZWF0ZUZyb21JbnQobGF5ZXJUb1NhbXBsZS5nZXRQaXhlbCh+fih4IC0gciAqIDAuNyAqIGR4KSwgfn4oeSAtIHIgKiAwLjcgKiBkeSkpKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGF2ZXJhZ2UgPSBuZXcgQ1BDb2xvckZsb2F0KDAsIDAsIDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlID0gc2FtcGxlc1tpXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBhdmVyYWdlLnIgKz0gc2FtcGxlLnI7XG4gICAgICAgICAgICAgICAgYXZlcmFnZS5nICs9IHNhbXBsZS5nO1xuICAgICAgICAgICAgICAgIGF2ZXJhZ2UuYiArPSBzYW1wbGUuYjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXZlcmFnZS5yIC89IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgICAgICAgYXZlcmFnZS5nIC89IHNhbXBsZXMubGVuZ3RoO1xuICAgICAgICAgICAgYXZlcmFnZS5iIC89IHNhbXBsZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICByZXR1cm4gYXZlcmFnZTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQmxlbmQgdGhlIGJydXNoIHN0cm9rZSB3aXRoIGZ1bGwgY29sb3IgaW50byB0aGUgb3BhY2l0eUJ1ZmZlclxuICAgICAgICBmdW5jdGlvbiBwYWludERpcmVjdChzcmNSZWN0LCBkc3RSZWN0LCBicnVzaCwgYnJ1c2hXaWR0aCwgYWxwaGEsIGNvbG9yMSkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgb3BhY2l0eURhdGEgPSBvcGFjaXR5QnVmZmVyLmRhdGEsXG5cbiAgICAgICAgICAgICAgICBieSA9IHNyY1JlY3QudG9wO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gZHN0UmVjdC50b3A7IHkgPCBkc3RSZWN0LmJvdHRvbTsgeSsrLCBieSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIHNyY09mZnNldCA9IHNyY1JlY3QubGVmdCArIGJ5ICogYnJ1c2hXaWR0aCxcbiAgICAgICAgICAgICAgICAgICAgZHN0T2Zmc2V0ID0gb3BhY2l0eUJ1ZmZlci5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgeSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IGRzdFJlY3QubGVmdDsgeCA8IGRzdFJlY3QucmlnaHQ7IHgrKywgc3JjT2Zmc2V0KyssIGRzdE9mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoYnJ1c2hbc3JjT2Zmc2V0XSAmIDB4ZmYpICogYWxwaGEgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEgPD0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IG9wYWNpdHlEYXRhW2RzdE9mZnNldF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBjb2xvcjIgPj4+IDI0LFxuXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdBbHBoYSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFsQWxwaGEgPSAoYWxwaGExICogMjU1IC8gbmV3QWxwaGEpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYSA9IDI1NSAtIHJlYWxBbHBoYTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIHVzdWFsIGFscGhhIGJsZW5kaW5nIGZvcm11bGEgQyA9IEEgKiBhbHBoYSArIEIgKiAoMSAtIGFscGhhKVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFzIHRvIHJld3JpdHRlbiBpbiB0aGUgZm9ybSBDID0gQSArICgxIC0gYWxwaGEpICogQiAtICgxIC0gYWxwaGEpICpBXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGF0IHdheSB0aGUgcm91bmRpbmcgdXAgZXJyb3JzIHdvbid0IGNhdXNlIHByb2JsZW1zXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2xvciA9IG5ld0FscGhhIDw8IDI0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKChjb2xvcjEgPj4+IDE2ICYgMHhmZikgKyAoKChjb2xvcjIgPj4+IDE2ICYgMHhmZikgKiBpbnZBbHBoYSAtIChjb2xvcjEgPj4+IDE2ICYgMHhmZikgKiBpbnZBbHBoYSkgLyAyNTUpKSA8PCAxNlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgoY29sb3IxID4+PiA4ICYgMHhmZikgKyAoKChjb2xvcjIgPj4+IDggJiAweGZmKSAqIGludkFscGhhIC0gKGNvbG9yMSA+Pj4gOCAmIDB4ZmYpICogaW52QWxwaGEpIC8gMjU1KSkgPDwgOFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgoY29sb3IxICYgMHhmZikgKyAoKChjb2xvcjIgJiAweGZmKSAqIGludkFscGhhIC0gKGNvbG9yMSAmIDB4ZmYpICogaW52QWxwaGEpIC8gMjU1KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHlEYXRhW2RzdE9mZnNldF0gPSBuZXdDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdGhpcy5iZWdpblN0cm9rZSA9IGZ1bmN0aW9uKHgsIHksIHByZXNzdXJlKSB7XG4gICAgICAgICAgICBwcmV2aW91c1NhbXBsZXMgPSBudWxsO1xuXG4gICAgICAgICAgICBDUEJydXNoVG9vbERpcmVjdEJydXNoLnByb3RvdHlwZS5iZWdpblN0cm9rZS5jYWxsKHRoaXMsIHgsIHksIHByZXNzdXJlKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBhaW50RGFiSW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbihzcmNSZWN0LCBkc3RSZWN0LCBkYWIpIHtcbiAgICAgICAgICAgIGlmIChwcmV2aW91c1NhbXBsZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIC8vIFNlZWQgdGhlIHByZXZpb3VzU2FtcGxlcyBsaXN0IHRvIGNhcGFjaXR5IHdpdGggYSBidW5jaCBvZiBjb3BpZXMgb2Ygb25lIHNhbXBsZSB0byBnZXQgdXMgc3RhcnRlZFxuICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRDb2xvciA9IHNhbXBsZUNvbG9yKFxuICAgICAgICAgICAgICAgICAgICAgICAgfn4oKGRzdFJlY3QubGVmdCArIGRzdFJlY3QucmlnaHQpIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICB+figoZHN0UmVjdC50b3AgKyBkc3RSZWN0LmJvdHRvbSkgLyAyKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgxLCBNYXRoLm1pbihXWE1BWFNBTVBMRVJBRElVUywgZHN0UmVjdC5nZXRXaWR0aCgpICogMiAvIDYpKSwgXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heCgxLCBNYXRoLm1pbihXWE1BWFNBTVBMRVJBRElVUywgZHN0UmVjdC5nZXRIZWlnaHQoKSAqIDIgLyA2KSlcbiAgICAgICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHByZXZpb3VzU2FtcGxlcyA9IFtdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgV0NNRU1PUlk7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1NhbXBsZXMucHVzaChzdGFydENvbG9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICB3Y0NvbG9yID0gbmV3IENQQ29sb3JGbG9hdCgwLCAwLCAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcmV2aW91c1NhbXBsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgc2FtcGxlID0gcHJldmlvdXNTYW1wbGVzW2ldO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHdjQ29sb3IuciArPSBzYW1wbGUucjtcbiAgICAgICAgICAgICAgICB3Y0NvbG9yLmcgKz0gc2FtcGxlLmc7XG4gICAgICAgICAgICAgICAgd2NDb2xvci5iICs9IHNhbXBsZS5iO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2NDb2xvci5yIC89IHByZXZpb3VzU2FtcGxlcy5sZW5ndGg7XG4gICAgICAgICAgICB3Y0NvbG9yLmcgLz0gcHJldmlvdXNTYW1wbGVzLmxlbmd0aDtcbiAgICAgICAgICAgIHdjQ29sb3IuYiAvPSBwcmV2aW91c1NhbXBsZXMubGVuZ3RoO1xuXG4gICAgICAgICAgICAvLyByZXNhdHVyYXRpb25cbiAgICAgICAgICAgIHdjQ29sb3IubWl4V2l0aChDUENvbG9yRmxvYXQuY3JlYXRlRnJvbUludChjdXJDb2xvciksIGN1ckJydXNoLnJlc2F0ICogY3VyQnJ1c2gucmVzYXQpO1xuXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBuZXdDb2xvciA9IHdjQ29sb3IudG9JbnQoKTtcblxuICAgICAgICAgICAgLy8gYmxlZWRcbiAgICAgICAgICAgIHdjQ29sb3IubWl4V2l0aChcbiAgICAgICAgICAgICAgICBzYW1wbGVDb2xvcihcbiAgICAgICAgICAgICAgICAgICAgKGRzdFJlY3QubGVmdCArIGRzdFJlY3QucmlnaHQpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgKGRzdFJlY3QudG9wICsgZHN0UmVjdC5ib3R0b20pIC8gMixcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoMSwgTWF0aC5taW4oV1hNQVhTQU1QTEVSQURJVVMsIGRzdFJlY3QuZ2V0V2lkdGgoKSAqIDIgLyA2KSksXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KDEsIE1hdGgubWluKFdYTUFYU0FNUExFUkFESVVTLCBkc3RSZWN0LmdldEhlaWdodCgpICogMiAvIDYpKVxuICAgICAgICAgICAgICAgICksIFxuICAgICAgICAgICAgICAgIGN1ckJydXNoLmJsZWVkXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBwcmV2aW91c1NhbXBsZXMucHVzaCh3Y0NvbG9yKTtcbiAgICAgICAgICAgIHByZXZpb3VzU2FtcGxlcy5zaGlmdCgpO1xuXG4gICAgICAgICAgICBwYWludERpcmVjdChzcmNSZWN0LCBkc3RSZWN0LCBkYWIuYnJ1c2gsIGRhYi53aWR0aCwgTWF0aC5tYXgoMSwgZGFiLmFscGhhIC8gNCksIG5ld0NvbG9yKTtcbiAgICAgICAgICAgIG1lcmdlT3BhY2l0eUJ1ZmZlcigwLCBmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzYW1wbGVBbGxMYXllcnMpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmZ1c2lvbkxheWVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBDUEJydXNoVG9vbFdhdGVyY29sb3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUEJydXNoVG9vbERpcmVjdEJydXNoLnByb3RvdHlwZSk7XG4gICAgQ1BCcnVzaFRvb2xXYXRlcmNvbG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQQnJ1c2hUb29sV2F0ZXJjb2xvcjtcbiAgICBcbiAgICBmdW5jdGlvbiBDUEJydXNoVG9vbE9pbCgpIHtcblxuICAgICAgICBmdW5jdGlvbiBvaWxBY2N1bUJ1ZmZlcihzcmNSZWN0LCBkc3RSZWN0LCBidWZmZXIsIHcsIGFscGhhKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBsYXllclRvU2FtcGxlID0gc2FtcGxlQWxsTGF5ZXJzID8gZnVzaW9uIDogdGhhdC5nZXRBY3RpdmVMYXllcigpLFxuXG4gICAgICAgICAgICAgICAgYnkgPSBzcmNSZWN0LnRvcDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IGRzdFJlY3QudG9wOyB5IDwgZHN0UmVjdC5ib3R0b207IHkrKywgYnkrKykge1xuICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgc3JjT2Zmc2V0ID0gc3JjUmVjdC5sZWZ0ICsgYnkgKiB3LFxuICAgICAgICAgICAgICAgICAgICBkc3RPZmZzZXQgPSBsYXllclRvU2FtcGxlLm9mZnNldE9mUGl4ZWwoZHN0UmVjdC5sZWZ0LCB5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gZHN0UmVjdC5sZWZ0OyB4IDwgZHN0UmVjdC5yaWdodDsgeCsrLCBzcmNPZmZzZXQrKywgZHN0T2Zmc2V0ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKGxheWVyVG9TYW1wbGUuZGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSAqIGFscGhhIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBidWZmZXJbc3JjT2Zmc2V0XSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGNvbG9yMiA+Pj4gMjQsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0FscGhhID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxBbHBoYSA9IChhbHBoYTEgKiAyNTUgLyBuZXdBbHBoYSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhID0gMjU1IC0gcmVhbEFscGhhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMVJlZCA9IGxheWVyVG9TYW1wbGUuZGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLlJFRF9CWVRFX09GRlNFVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxR3JlZW4gPSBsYXllclRvU2FtcGxlLmRhdGFbZHN0T2Zmc2V0ICsgQ1BDb2xvckJtcC5HUkVFTl9CWVRFX09GRlNFVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxQmx1ZSA9IGxheWVyVG9TYW1wbGUuZGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3IgPSBuZXdBbHBoYSA8PCAyNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IChjb2xvcjFSZWQgKyAoKChjb2xvcjIgPj4+IDE2ICYgMHhmZikgKiBpbnZBbHBoYSAtIGNvbG9yMVJlZCAqIGludkFscGhhKSAvIDI1NSkpIDw8IDE2XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKGNvbG9yMUdyZWVuICsgKCgoY29sb3IyID4+PiA4ICYgMHhmZikgKiBpbnZBbHBoYSAtIGNvbG9yMUdyZWVuICogaW52QWxwaGEpIC8gMjU1KSkgPDwgOFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8IChjb2xvcjFCbHVlICsgKCgoY29sb3IyICYgMHhmZikgKiBpbnZBbHBoYSAtIGNvbG9yMUJsdWUgKiBpbnZBbHBoYSkgLyAyNTUpKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyW3NyY09mZnNldF0gPSBuZXdDb2xvcjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIG9pbFJlc2F0QnVmZmVyKHNyY1JlY3QsIGRzdFJlY3QsIGJ1ZmZlciwgdywgYWxwaGExLCBjb2xvcjEpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGJ5ID0gc3JjUmVjdC50b3A7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChhbHBoYTEgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IGRzdFJlY3QudG9wOyB5IDwgZHN0UmVjdC5ib3R0b207IHkrKywgYnkrKykge1xuICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgc3JjT2Zmc2V0ID0gc3JjUmVjdC5sZWZ0ICsgYnkgKiB3O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSBkc3RSZWN0LmxlZnQ7IHggPCBkc3RSZWN0LnJpZ2h0OyB4KyssIHNyY09mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gYnVmZmVyW3NyY09mZnNldF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSAoY29sb3IyID4+PiAyNCksXG4gICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdBbHBoYSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFsQWxwaGEgPSAoYWxwaGExICogMjU1IC8gbmV3QWxwaGEpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYSA9IDI1NSAtIHJlYWxBbHBoYSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2xvciA9IG5ld0FscGhhIDw8IDI0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKChjb2xvcjEgPj4+IDE2ICYgMHhmZikgKyAoKChjb2xvcjIgPj4+IDE2ICYgMHhmZikgKiBpbnZBbHBoYSAtIChjb2xvcjEgPj4+IDE2ICYgMHhmZikgKiBpbnZBbHBoYSkgLyAyNTUpKSA8PCAxNlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgoY29sb3IxID4+PiA4ICYgMHhmZikgKyAoKChjb2xvcjIgPj4+IDggJiAweGZmKSAqIGludkFscGhhIC0gKGNvbG9yMSA+Pj4gOCAmIDB4ZmYpICogaW52QWxwaGEpIC8gMjU1KSkgPDwgOFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgoY29sb3IxICYgMHhmZikgKyAoKChjb2xvcjIgJiAweGZmKSAqIGludkFscGhhIC0gKGNvbG9yMSAmIDB4ZmYpICogaW52QWxwaGEpIC8gMjU1KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltzcmNPZmZzZXRdID0gbmV3Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBvaWxQYXN0ZUJ1ZmZlcihzcmNSZWN0LCBkc3RSZWN0LCBidWZmZXIsIGJydXNoLCB3LCBhbHBoYSkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgb3BhY2l0eURhdGEgPSBvcGFjaXR5QnVmZmVyLmRhdGEsXG4gICAgXG4gICAgICAgICAgICAgICAgYnkgPSBzcmNSZWN0LnRvcDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IGRzdFJlY3QudG9wOyB5IDwgZHN0UmVjdC5ib3R0b207IHkrKywgYnkrKykge1xuICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyT2Zmc2V0ID0gc3JjUmVjdC5sZWZ0ICsgYnkgKiB3LCAvLyBCcnVzaCBidWZmZXIgaXMgMSBpbnRlZ2VyIHBlciBwaXhlbFxuICAgICAgICAgICAgICAgICAgICBvcGFjaXR5T2Zmc2V0ID0gZHN0UmVjdC5sZWZ0ICsgeSAqIHRoYXQud2lkdGgsIC8vIE9wYWNpdHkgYnVmZmVyIGlzIDEgaW50ZWdlciBwZXIgcGl4ZWxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJPZmZzZXQgPSBjdXJMYXllci5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgeSk7IC8vIDQgYnl0ZXMgcGVyIHBpeGVsIFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSBkc3RSZWN0LmxlZnQ7IHggPCBkc3RSZWN0LnJpZ2h0OyB4KyssIGJ1ZmZlck9mZnNldCsrLCBsYXllck9mZnNldCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCwgb3BhY2l0eU9mZnNldCsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGJ1ZmZlcltidWZmZXJPZmZzZXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKChjb2xvcjEgPj4+IDI0KSAqIChicnVzaFtidWZmZXJPZmZzZXRdICYgMHhmZikgKiBhbHBoYSAvICgyNTUgKiAyNTUpKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBjdXJMYXllci5kYXRhW2xheWVyT2Zmc2V0ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0FscGhhID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMlJlZCA9IGN1ckxheWVyLmRhdGFbbGF5ZXJPZmZzZXQgKyBDUENvbG9yQm1wLlJFRF9CWVRFX09GRlNFVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyR3JlZW4gPSBjdXJMYXllci5kYXRhW2xheWVyT2Zmc2V0ICsgQ1BDb2xvckJtcC5HUkVFTl9CWVRFX09GRlNFVF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyQmx1ZSA9IGN1ckxheWVyLmRhdGFbbGF5ZXJPZmZzZXQgKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxBbHBoYSA9IChhbHBoYTEgKiAyNTUgLyBuZXdBbHBoYSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhID0gMjU1IC0gcmVhbEFscGhhLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3IgPSBuZXdBbHBoYSA8PCAyNFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgoY29sb3IxID4+PiAxNiAmIDB4ZmYpICsgKChjb2xvcjJSZWQgKiBpbnZBbHBoYSAtIChjb2xvcjEgPj4+IDE2ICYgMHhmZikgKiBpbnZBbHBoYSkgLyAyNTUpKSA8PCAxNlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgoY29sb3IxID4+PiA4ICYgMHhmZikgKyAoKGNvbG9yMkdyZWVuICogaW52QWxwaGEgLSAoY29sb3IxID4+PiA4ICYgMHhmZikgKiBpbnZBbHBoYSkgLyAyNTUpKSA8PCA4XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHwgKChjb2xvcjEgJiAweGZmKSArICgoY29sb3IyQmx1ZSAqIGludkFscGhhIC0gKGNvbG9yMSAmIDB4ZmYpICogaW52QWxwaGEpIC8gMjU1KSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHlEYXRhW29wYWNpdHlPZmZzZXRdID0gbmV3Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMucGFpbnREYWJJbXBsZW1lbnRhdGlvbiA9IGZ1bmN0aW9uKHNyY1JlY3QsIGRzdFJlY3QsIGRhYikge1xuICAgICAgICAgICAgaWYgKGJydXNoQnVmZmVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBicnVzaEJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheShkYWIud2lkdGggKiBkYWIuaGVpZ2h0KTsgLy8gSW5pdGlhbGl6ZWQgdG8gMCBmb3IgdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBvaWxBY2N1bUJ1ZmZlcihzcmNSZWN0LCBkc3RSZWN0LCBicnVzaEJ1ZmZlciwgZGFiLndpZHRoLCAyNTUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvaWxSZXNhdEJ1ZmZlcihzcmNSZWN0LCBkc3RSZWN0LCBicnVzaEJ1ZmZlciwgZGFiLndpZHRoLCB+figoY3VyQnJ1c2gucmVzYXQgPD0gMC4wKSA/IDAgOiBNYXRoLm1heCgxLCAoY3VyQnJ1c2gucmVzYXQgKiBjdXJCcnVzaC5yZXNhdCkgKiAyNTUpKSwgY3VyQ29sb3IgJiAweEZGRkZGRik7XG4gICAgICAgICAgICAgICAgb2lsUGFzdGVCdWZmZXIoc3JjUmVjdCwgZHN0UmVjdCwgYnJ1c2hCdWZmZXIsIGRhYi5icnVzaCwgZGFiLndpZHRoLCBkYWIuYWxwaGEpO1xuICAgICAgICAgICAgICAgIG9pbEFjY3VtQnVmZmVyKHNyY1JlY3QsIGRzdFJlY3QsIGJydXNoQnVmZmVyLCBkYWIud2lkdGgsIH5+KGN1ckJydXNoLmJsZWVkICogMjU1KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1lcmdlT3BhY2l0eUJ1ZmZlcigwLCBmYWxzZSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChzYW1wbGVBbGxMYXllcnMpIHtcbiAgICAgICAgICAgICAgICB0aGF0LmZ1c2lvbkxheWVycygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBDUEJydXNoVG9vbE9pbC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQQnJ1c2hUb29sRGlyZWN0QnJ1c2gucHJvdG90eXBlKTtcbiAgICBDUEJydXNoVG9vbE9pbC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUEJydXNoVG9vbE9pbDtcbiAgICBcbiAgICBmdW5jdGlvbiBDUEJydXNoVG9vbFNtdWRnZSgpIHtcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBcbiAgICAgICAgICogQHBhcmFtIHNyY1JlY3RcbiAgICAgICAgICogQHBhcmFtIGRzdFJlY3RcbiAgICAgICAgICogQHBhcmFtIGJ1ZmZlciBVaW50MzJBcnJheVxuICAgICAgICAgKiBAcGFyYW0gdyBpbnRcbiAgICAgICAgICogQHBhcmFtIGFscGhhIGludFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc211ZGdlQWNjdW1CdWZmZXIoc3JjUmVjdCwgZHN0UmVjdCwgYnVmZmVyLCB3LCBhbHBoYSkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgbGF5ZXJUb1NhbXBsZSA9IHNhbXBsZUFsbExheWVycyA/IGZ1c2lvbiA6IHRoYXQuZ2V0QWN0aXZlTGF5ZXIoKSxcblxuICAgICAgICAgICAgICAgIGJ5ID0gc3JjUmVjdC50b3A7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSBkc3RSZWN0LnRvcDsgeSA8IGRzdFJlY3QuYm90dG9tOyB5KyssIGJ5KyspIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgc3JjT2Zmc2V0ID0gc3JjUmVjdC5sZWZ0ICsgYnkgKiB3LFxuICAgICAgICAgICAgICAgICAgICBkc3RPZmZzZXQgPSBsYXllclRvU2FtcGxlLm9mZnNldE9mUGl4ZWwoZHN0UmVjdC5sZWZ0LCB5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gZHN0UmVjdC5sZWZ0OyB4IDwgZHN0UmVjdC5yaWdodDsgeCsrLCBzcmNPZmZzZXQrKywgZHN0T2Zmc2V0ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJSZWQgPSBsYXllclRvU2FtcGxlLmRhdGFbZHN0T2Zmc2V0ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJHcmVlbiA9IGxheWVyVG9TYW1wbGUuZGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQmx1ZSA9IGxheWVyVG9TYW1wbGUuZGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXJBbHBoYSA9IGxheWVyVG9TYW1wbGUuZGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eUFscGhhID0gMjU1IC0gYWxwaGE7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAob3BhY2l0eUFscGhhID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVzdENvbG9yID0gYnVmZmVyW3NyY09mZnNldF0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXN0QWxwaGEgPSAyNTUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGF5ZXJBbHBoYSA9IChvcGFjaXR5QWxwaGEgKyBkZXN0QWxwaGEgKiAoMjU1IC0gb3BhY2l0eUFscGhhKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWxBbHBoYSA9ICgyNTUgKiBvcGFjaXR5QWxwaGEgLyBuZXdMYXllckFscGhhKSB8IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGEgPSAyNTUgLSByZWFsQWxwaGEsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdDb2xvciA9IFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGxheWVyQWxwaGEgKiByZWFsQWxwaGEgKyAoZGVzdENvbG9yID4+PiAyNCAmIDB4ZmYpICogaW52QWxwaGEpIC8gMjU1KSA8PCAyNCAmIDB4ZmYwMDAwMDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfCAoKGxheWVyUmVkICogcmVhbEFscGhhICsgKGRlc3RDb2xvciA+Pj4gMTYgJiAweGZmKSAqIGludkFscGhhKSAvIDI1NSkgPDwgMTYgJiAweGZmMDAwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgobGF5ZXJHcmVlbiAqIHJlYWxBbHBoYSArIChkZXN0Q29sb3IgPj4+IDggJiAweGZmKSAqIGludkFscGhhKSAvIDI1NSkgPDwgOCAmIDB4ZmYwMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICgobGF5ZXJCbHVlICogcmVhbEFscGhhICsgKGRlc3RDb2xvciAmIDB4ZmYpICogaW52QWxwaGEpIC8gMjU1KSAmIDB4ZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChuZXdDb2xvciA9PSBkZXN0Q29sb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXJSZWQgPiAoZGVzdENvbG9yICYgMHhmZjAwMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yICs9IDEgPDwgMTY7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXllclJlZCA8IChkZXN0Q29sb3IgJiAweGZmMDAwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3IgLT0gMSA8PCAxNjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXJHcmVlbj4gKGRlc3RDb2xvciAmIDB4ZmYwMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3IgKz0gMSA8PCA4O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobGF5ZXJHcmVlbiA8IChkZXN0Q29sb3IgJiAweGZmMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yIC09IDEgPDwgODtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXJCbHVlID4gKGRlc3RDb2xvciAmIDB4ZmYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0NvbG9yICs9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXllckJsdWUgPCAoZGVzdENvbG9yICYgMHhmZikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3Q29sb3IgLT0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltzcmNPZmZzZXRdID0gbmV3Q29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzcmNSZWN0LmxlZnQgPiAwKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGZpbGwgPSBzcmNSZWN0LmxlZnQ7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IHNyY1JlY3QudG9wOyB5IDwgc3JjUmVjdC5ib3R0b207IHkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSB5ICogdyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvciA9IGJ1ZmZlcltvZmZzZXQgKyBzcmNSZWN0LmxlZnRdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBmaWxsOyB4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXQrK10gPSBmaWxsQ29sb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzcmNSZWN0LnJpZ2h0IDwgdykge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBmaWxsID0gdyAtIHNyY1JlY3QucmlnaHQ7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IHNyY1JlY3QudG9wOyB5IDwgc3JjUmVjdC5ib3R0b207IHkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IHkgKiB3ICsgc3JjUmVjdC5yaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGxDb2xvciA9IGJ1ZmZlcltvZmZzZXQgLSAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgZmlsbDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJbb2Zmc2V0KytdID0gZmlsbENvbG9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IHNyY1JlY3QudG9wOyB5KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgIHNyY09mZnNldCA9IHNyY1JlY3QudG9wICogdyxcbiAgICAgICAgICAgICAgICAgICAgZHN0T2Zmc2V0ID0geSAqIHc7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHNyY09mZnNldCsrLCBkc3RPZmZzZXQrKykge1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJbZHN0T2Zmc2V0XSA9IGJ1ZmZlcltzcmNPZmZzZXRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgeSA9IHNyY1JlY3QuYm90dG9tOyB5IDwgdzsgeSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgICAgICBzcmNPZmZzZXQgPSAoc3JjUmVjdC5ib3R0b20gLSAxKSAqIHcsXG4gICAgICAgICAgICAgICAgICAgIGRzdE9mZnNldCA9IHkgKiB3O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBzcmNPZmZzZXQrKywgZHN0T2Zmc2V0KyspIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVyW2RzdE9mZnNldF0gPSBidWZmZXJbc3JjT2Zmc2V0XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogXG4gICAgICAgICAqIEBwYXJhbSBzcmNSZWN0IENQUmVjdFxuICAgICAgICAgKiBAcGFyYW0gZHN0UmVjdCBDUFJlY3RcbiAgICAgICAgICogQHBhcmFtIGJ1ZmZlciBVaW50MzJBcnJheVxuICAgICAgICAgKiBAcGFyYW0gYnJ1c2ggVWludDhBcnJheVxuICAgICAgICAgKiBAcGFyYW0gdyBpbnRcbiAgICAgICAgICogQHBhcmFtIGFscGhhIGludFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc211ZGdlUGFzdGVCdWZmZXIoc3JjUmVjdCwgZHN0UmVjdCwgYnVmZmVyLCBicnVzaCwgdywgYWxwaGEpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGJ5ID0gc3JjUmVjdC50b3A7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIHkgPSBkc3RSZWN0LnRvcDsgeSA8IGRzdFJlY3QuYm90dG9tOyB5KyssIGJ5KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgIHNyY09mZnNldCA9IHNyY1JlY3QubGVmdCArIGJ5ICogdyxcbiAgICAgICAgICAgICAgICAgICAgZHN0T2Zmc2V0ID0gY3VyTGF5ZXIub2Zmc2V0T2ZQaXhlbChkc3RSZWN0LmxlZnQsIHkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSBkc3RSZWN0LmxlZnQ7IHggPCBkc3RSZWN0LnJpZ2h0OyB4KyssIHNyY09mZnNldCsrLCBkc3RPZmZzZXQgKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJDb2xvciA9IGJ1ZmZlcltzcmNPZmZzZXRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgb3BhY2l0eUFscGhhID0gKGJ1ZmZlckNvbG9yID4+PiAyNCkgKiAoYnJ1c2hbc3JjT2Zmc2V0XSAmIDB4ZmYpIC8gMjU1O1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wYWNpdHlBbHBoYSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdID0gKGJ1ZmZlckNvbG9yID4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJMYXllci5kYXRhW2RzdE9mZnNldCArIENQQ29sb3JCbXAuR1JFRU5fQllURV9PRkZTRVRdID0gKGJ1ZmZlckNvbG9yID4+IDgpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSA9IGJ1ZmZlckNvbG9yICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1ckxheWVyLmRhdGFbZHN0T2Zmc2V0ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0gPSAoYnVmZmVyQ29sb3IgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwYXJhbSBzcmNSZWN0IENQUmVjdFxuICAgICAgICAgKiBAcGFyYW0gZHN0UmVjdCBDUFJlY3RcbiAgICAgICAgICogQHBhcmFtIGRhYiBDUEJydXNoRGFiXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhaW50RGFiSW1wbGVtZW50YXRpb24gPSBmdW5jdGlvbihzcmNSZWN0LCBkc3RSZWN0LCBkYWIpIHtcbiAgICAgICAgICAgIGlmIChicnVzaEJ1ZmZlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYnJ1c2hCdWZmZXIgPSBuZXcgVWludDMyQXJyYXkoZGFiLndpZHRoICogZGFiLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgc211ZGdlQWNjdW1CdWZmZXIoc3JjUmVjdCwgZHN0UmVjdCwgYnJ1c2hCdWZmZXIsIGRhYi53aWR0aCwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNtdWRnZUFjY3VtQnVmZmVyKHNyY1JlY3QsIGRzdFJlY3QsIGJydXNoQnVmZmVyLCBkYWIud2lkdGgsIGRhYi5hbHBoYSk7XG4gICAgICAgICAgICAgICAgc211ZGdlUGFzdGVCdWZmZXIoc3JjUmVjdCwgZHN0UmVjdCwgYnJ1c2hCdWZmZXIsIGRhYi5icnVzaCwgZGFiLndpZHRoLCBkYWIuYWxwaGEpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGxvY2tBbHBoYSkge1xuICAgICAgICAgICAgICAgICAgICByZXN0b3JlQWxwaGEoZHN0UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBvcGFjaXR5QXJlYS5tYWtlRW1wdHkoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKHNhbXBsZUFsbExheWVycykge1xuICAgICAgICAgICAgICAgIHRoYXQuZnVzaW9uTGF5ZXJzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIENQQnJ1c2hUb29sU211ZGdlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BCcnVzaFRvb2xEaXJlY3RCcnVzaC5wcm90b3R5cGUpO1xuICAgIENQQnJ1c2hUb29sU211ZGdlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQQnJ1c2hUb29sU211ZGdlO1xuXG4gICAgQ1BCcnVzaFRvb2xTbXVkZ2UucHJvdG90eXBlLm1lcmdlT3BhY2l0eUJ1ZiA9IGZ1bmN0aW9uKGRzdFJlY3QsIGNvbG9yKSB7XG4gICAgfTtcbiAgICBcbiAgICB2YXIgcGFpbnRpbmdNb2RlcyA9IFtcbiAgICAgICAgbmV3IENQQnJ1c2hUb29sU2ltcGxlQnJ1c2goKSwgbmV3IENQQnJ1c2hUb29sRXJhc2VyKCksIG5ldyBDUEJydXNoVG9vbERvZGdlKCksXG4gICAgICAgIG5ldyBDUEJydXNoVG9vbEJ1cm4oKSwgbmV3IENQQnJ1c2hUb29sV2F0ZXJjb2xvcigpLCBuZXcgQ1BCcnVzaFRvb2xCbHVyKCksIG5ldyBDUEJydXNoVG9vbFNtdWRnZSgpLFxuICAgICAgICBuZXcgQ1BCcnVzaFRvb2xPaWwoKVxuICAgIF07XG4gICAgXG4gICAgdGhpcy53aWR0aCA9IF93aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IF9oZWlnaHQ7XG5cbiAgICB0aGlzLmdldERlZmF1bHRMYXllck5hbWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBwcmVmaXggPSBcIkxheWVyIFwiLFxuICAgICAgICAgICAgaGlnaGVzdExheWVyTmIgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGxheWVyID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoL15MYXllciBbMC05XSskLy50ZXN0KGxheWVyLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgaGlnaGVzdExheWVyTmIgPSBNYXRoLm1heChoaWdoZXN0TGF5ZXJOYiwgcGFyc2VJbnQobGF5ZXIubmFtZS5zdWJzdHJpbmcocHJlZml4Lmxlbmd0aCksIDEwKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByZWZpeCArIChoaWdoZXN0TGF5ZXJOYiArIDEpO1xuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gcmVzdG9yZUFscGhhKHJlY3QpIHtcbiAgICAgICAgdGhhdC5nZXRBY3RpdmVMYXllcigpLmNvcHlBbHBoYUZyb20odW5kb0J1ZmZlciwgcmVjdCk7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIE1lcmdlIHRoZSBvcGFjaXR5IGJ1ZmZlciBmcm9tIHRoZSBjdXJyZW50IGRyYXdpbmcgb3BlcmF0aW9uIHRvIHRoZSBhY3RpdmUgbGF5ZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVyZ2VPcGFjaXR5QnVmZmVyKGNvbG9yLCBjbGVhcikge1xuICAgICAgICBpZiAoIW9wYWNpdHlBcmVhLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgaWYgKGN1ckJydXNoLnBhaW50TW9kZSAhPSBDUEJydXNoSW5mby5NX0VSQVNFIHx8ICFsb2NrQWxwaGEpIHtcbiAgICAgICAgICAgICAgICBwYWludGluZ01vZGVzW2N1ckJydXNoLnBhaW50TW9kZV0ubWVyZ2VPcGFjaXR5QnVmKG9wYWNpdHlBcmVhLCBjb2xvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBpdCB3b3VsZCBiZSBuaWNlIHRvIGJlIGFibGUgdG8gc2V0IHRoZSBwYXBlciBjb2xvclxuICAgICAgICAgICAgICAgIHBhaW50aW5nTW9kZXNbQ1BCcnVzaEluZm8uTV9QQUlOVF0ubWVyZ2VPcGFjaXR5QnVmKG9wYWNpdHlBcmVhLCBFTVBUWV9MQVlFUl9DT0xPUik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChsb2NrQWxwaGEpIHtcbiAgICAgICAgICAgICAgICByZXN0b3JlQWxwaGEob3BhY2l0eUFyZWEpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoY2xlYXIpIHtcbiAgICAgICAgICAgICAgICBvcGFjaXR5QnVmZmVyLmNsZWFyUmVjdChvcGFjaXR5QXJlYSwgMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG9wYWNpdHlBcmVhLm1ha2VFbXB0eSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHRoaXMuYWRkQmFja2dyb3VuZExheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbGF5ZXIgPSBuZXcgQ1BMYXllcih0aGF0LndpZHRoLCB0aGF0LmhlaWdodCwgdGhpcy5nZXREZWZhdWx0TGF5ZXJOYW1lKCkpO1xuICAgICAgICBcbiAgICAgICAgbGF5ZXIuY2xlYXJBbGwoRU1QVFlfQkFDS0dST1VORF9DT0xPUik7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmFkZExheWVyT2JqZWN0KGxheWVyKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogTWVyZ2UgdG9nZXRoZXIgdGhlIHZpc2libGUgbGF5ZXJzIGFuZCByZXR1cm4gdGhlIHJlc3VsdGluZyBJbWFnZURhdGEgZm9yIGRpc3BsYXkgdG8gdGhlIHNjcmVlbi5cbiAgICAgKiBcbiAgICAgKiBUaGUgaW1hZ2UgaXMgY2FjaGVkLCBzbyByZXBlYXQgY2FsbHMgYXJlIGNoZWFwLlxuICAgICAqL1xuICAgIHRoaXMuZnVzaW9uTGF5ZXJzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIElzIHRoZXJlIGFueXRoaW5nIHRvIHVwZGF0ZSBmcm9tIGxhc3QgY2FsbD9cbiAgICAgICAgaWYgKCFmdXNpb25BcmVhLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgLy8gVGhlIGN1cnJlbnQgYnJ1c2ggcmVuZGVycyBvdXQgaXRzIGJ1ZmZlcnMgdG8gdGhlIGxheWVyIHN0YWNrIGZvciB1c1xuICAgICAgICAgICAgbWVyZ2VPcGFjaXR5QnVmZmVyKGN1ckNvbG9yLCBmYWxzZSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSBkcmF3aW5nIGlzIHNpbmdsZS1sYXllcmVkIGFuZCBvcGFxdWUsIGp1c3QgdXNlIHRoZSBib3R0b20tbW9zdCBsYXllciBhcyBvdXIgZnVzaW9uLCB3ZSBkb24ndCBuZWVkIHRvIGJsZW5kIGFueXRoaW5nIVxuICAgICAgICAgICAgaWYgKGxheWVycy5sZW5ndGggPT0gMSAmJiBsYXllcnNbMF0uYWxwaGEgPj0gMTAwICYmIGxheWVyc1swXS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgZnVzaW9uID0gbGF5ZXJzWzBdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBGdXNlIGludG8gdGhlIGFjdHVhbCBmdXNpb24gYnVmZmVyIHNpbmNlIHdlIG5lZWQgdG8gYmxlbmRcbiAgICAgICAgICAgICAgICBmdXNpb24gPSBmdXNpb25CdWZmZXI7XG5cbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uSXNTZW1pVHJhbnNwYXJlbnQgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBsYXllcnMuZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZnVzaW9uSXNTZW1pVHJhbnNwYXJlbnQgPSBmdXNpb25Jc1NlbWlUcmFuc3BhcmVudCAmJiBmdXNpb24uaGFzQWxwaGFJblJlY3QoZnVzaW9uQXJlYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIudmlzaWJsZSAmJiBsYXllci5hbHBoYSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0ID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXIuYWxwaGEgPT0gMTAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIEluc3RlYWQgb2YgYmxlbmRpbmcgdGhlIGxheWVyIG9udG8gdGhlIGVtcHR5IHRyYW5zcGFyZW50IGZ1c2lvbiwgd2UgY2FuIGp1c3QgY29weSB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogbGF5ZXIgZGF0YSByaWdodCBpbnRvIHRoZSBmdXNpb24uIFRoaXMgd29ya3MgZm9yIGFsbCBvZiBvdXIgYmxlbmRpbmcgbW9kZXMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5jb3B5Qml0bWFwUmVjdChsYXllciwgZnVzaW9uQXJlYS5sZWZ0LCBmdXNpb25BcmVhLnRvcCwgZnVzaW9uQXJlYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdXNpb24uY2xlYXJSZWN0KGZ1c2lvbkFyZWEsIDB4MDBGRkZGRkYpOyAvLyBUcmFuc3BhcmVudCB3aGl0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBDUEJsZW5kLmZ1c2VMYXllcihmdXNpb24sIGZ1c2lvbklzU2VtaVRyYW5zcGFyZW50LCBsYXllciwgZnVzaW9uQXJlYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEaWRuJ3QgZHJhdyBhbnkgbGF5ZXJzPyBXZSBoYXZlIHRvIGNsZWFyIHRoZSBhcmVhLCB0aGVuXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5jbGVhclJlY3QoZnVzaW9uQXJlYSwgMHgwMEZGRkZGRik7IC8vIFRyYW5zcGFyZW50IHdoaXRlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdXNpb25BcmVhLm1ha2VFbXB0eSgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZnVzaW9uLmdldEltYWdlRGF0YSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNldEFjdGl2ZUxheWVySW5kZXggPSBmdW5jdGlvbihuZXdJbmRleCkge1xuICAgICAgICBpZiAobmV3SW5kZXggPCAwIHx8IG5ld0luZGV4ID49IGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJMYXllciAhPSBsYXllcnNbbmV3SW5kZXhdKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBvbGRJbmRleCA9IHRoaXMuZ2V0QWN0aXZlTGF5ZXJJbmRleCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjdXJMYXllciA9IGxheWVyc1tuZXdJbmRleF07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFdhcyB0aGUgb2xkIGxheWVyIGRlbGV0ZWQ/XG4gICAgICAgICAgICBpZiAob2xkSW5kZXggPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjYWxsTGlzdGVuZXJzTGF5ZXJDaGFuZ2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbExpc3RlbmVyc0xheWVyQ2hhbmdlKG9sZEluZGV4KTsgLy8gT2xkIGxheWVyIGhhcyBub3cgYmVlbiBkZXNlbGVjdGVkXG4gICAgICAgICAgICAgICAgY2FsbExpc3RlbmVyc0xheWVyQ2hhbmdlKG5ld0luZGV4KTsgLy8gTmV3IGxheWVyIGhhcyBub3cgYmVlbiBzZWxlY3RlZFxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnZhbGlkYXRlTGF5ZXJVbmRvKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0QWN0aXZlTGF5ZXJJbmRleCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGxheWVyc1tpXSA9PSBjdXJMYXllcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICBcbiAgICAvKlxuICAgICAqIEdldCB0aGUgaW5kZXggb2YgdGhlIHRvcG1vc3QgdmlzaWJsZSBsYXllciwgb3IgMC5cbiAgICAgKi9cbiAgICB0aGlzLmdldFRvcG1vc3RWaXNpYmxlTGF5ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IGxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKGxheWVyc1tpXS52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiAwO1xuICAgIH07XG5cblx0LyoqXG4gICAgICogR2V0IHRoZSBsYXllciB3aXRoIHRoZSBzcGVjaWZpZWQgaW5kZXggKG5vIGJvdW5kcyBjaGVja2luZylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aW50fSBpXG4gICAgICogQHJldHVybnMge0NQTGF5ZXJ9XG4gICAgICovXG4gICAgdGhpcy5nZXRMYXllciA9IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIGxheWVyc1tpXTtcbiAgICB9O1xuXG5cdC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudGx5IGFjdGl2ZSBsYXllciAodGhlIGxheWVyIHRoYXQgZHJhd2luZyBvcGVyYXRpb25zIHdpbGwgYmUgYXBwbGllZCB0bykpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Q1BMYXllcn1cbiAgICAgKi9cbiAgICB0aGlzLmdldEFjdGl2ZUxheWVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjdXJMYXllcjtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXREb2NNZW1vcnlVc2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgdG90YWwgPSBmdXNpb25CdWZmZXIuZ2V0TWVtb3J5U2l6ZSgpICogKDMgKyBsYXllcnMubGVuZ3RoKTtcblxuICAgICAgICBpZiAoY2xpcGJvYXJkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRvdGFsICs9IGNsaXBib2FyZC5ibXAuZ2V0TWVtb3J5U2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH07XG5cbiAgICB0aGlzLmdldFVuZG9NZW1vcnlVc2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgdG90YWwgPSAwO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmVkb0xpc3QubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHVuZG8gPSByZWRvTGlzdFtpXTtcblxuICAgICAgICAgICAgdG90YWwgKz0gdW5kby5nZXRNZW1vcnlVc2VkKHRydWUsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmRvTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgdW5kbyA9IHVuZG9MaXN0W2ldO1xuXG4gICAgICAgICAgICB0b3RhbCArPSB1bmRvLmdldE1lbW9yeVVzZWQoZmFsc2UsIG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsO1xuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gY2FuVW5kbygpIHtcbiAgICAgICAgcmV0dXJuIHVuZG9MaXN0Lmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2FuUmVkbygpIHtcbiAgICAgICAgcmV0dXJuIHJlZG9MaXN0Lmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBVbmRvIC8gUmVkb1xuICAgIC8vXG5cbiAgICB0aGlzLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFjYW5VbmRvKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYXNVbnNhdmVkQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICB2YXJcbiAgICAgICAgICAgIHVuZG8gPSB1bmRvTGlzdC5wb3AoKTtcbiAgICAgICAgXG4gICAgICAgIHVuZG8udW5kbygpO1xuICAgICAgICBcbiAgICAgICAgcmVkb0xpc3QucHVzaCh1bmRvKTtcbiAgICB9XG5cbiAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCFjYW5SZWRvKCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBoYXNVbnNhdmVkQ2hhbmdlcyA9IHRydWU7XG5cbiAgICAgICAgdmFyXG4gICAgICAgICAgICByZWRvID0gcmVkb0xpc3QucG9wKCk7XG4gICAgICAgIFxuICAgICAgICByZWRvLnJlZG8oKTtcbiAgICAgICAgXG4gICAgICAgIHVuZG9MaXN0LnB1c2gocmVkbyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRW5zdXJlcyB0aGF0IHRoZSBzdGF0ZSBvZiB0aGUgY3VycmVudCBsYXllciBoYXMgYmVlbiBzdG9yZWQgaW4gdW5kb0J1ZmZlciBzbyBpdCBjYW4gYmUgdW5kb25lIGxhdGVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByZXBhcmVGb3JMYXllclVuZG8oKSB7XG4gICAgICAgIGlmICghdW5kb0J1ZmZlckludmFsaWRSZWdpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiQ29weWluZyBcIiArIHVuZG9CdWZmZXJJbnZhbGlkUmVnaW9uICsgXCIgdG8gdGhlIHVuZG8gYnVmZmVyXCIpO1xuICAgICAgICAgICAgdW5kb0J1ZmZlci5jb3B5Qml0bWFwUmVjdChjdXJMYXllciwgdW5kb0J1ZmZlckludmFsaWRSZWdpb24ubGVmdCwgdW5kb0J1ZmZlckludmFsaWRSZWdpb24udG9wLCB1bmRvQnVmZmVySW52YWxpZFJlZ2lvbik7XG4gICAgICAgICAgICB1bmRvQnVmZmVySW52YWxpZFJlZ2lvbi5tYWtlRW1wdHkoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhbGwgd2hlbiB0aGUgdW5kbyBidWZmZXIgaGFzIGJlY29tZSBjb21wbGV0ZWx5IHdvcnRobGVzcyAoZS5nLiBhZnRlciB0aGUgYWN0aXZlIGxheWVyIGluZGV4IGNoYW5nZXMsIHRoZSB1bmRvXG4gICAgICogYnVmZmVyIHdvbid0IGNvbnRhaW4gYW55IGRhdGEgZnJvbSB0aGUgbmV3IGxheWVyIHRvIGJlZ2luIHdpdGgpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGludmFsaWRhdGVMYXllclVuZG8oKSB7XG4gICAgICAgIHVuZG9CdWZmZXJJbnZhbGlkUmVnaW9uID0gdGhhdC5nZXRCb3VuZHMoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgcmVzdWx0IG9mIHNvbWUgb2Ygb3VyIG9wZXJhdGlvbnMgYXJlbid0IG5lZWRlZCB1bnRpbCBsYXRlciwgc28gd2UgY2FuIGRlZmVyIHRoZW0gdW50aWwgdGhlIHVzZXIgaXMgaWRsZS5cbiAgICAgKlxuICAgICAqIFlvdSBtYXkgY2FsbCB0aGlzIHJvdXRpbmUgYXQgYW55IHRpbWUgKG9yIG5ldmVyLCBpZiB5b3UgbGlrZSkgYXMgYSBoaW50IHRoYXQgdGhlIHVzZXIgaXMgaWRsZSBhbmQgd2Ugc2hvdWxkXG4gICAgICogdHJ5IHRvIHBlcmZvcm0gcGVuZGluZyBvcGVyYXRpb25zIGJlZm9yZSB3ZSB3aWxsIG5lZWQgdG8gYmxvY2sgb24gdGhlaXIgcmVzdWx0cy5cbiAgICAgKi9cbiAgICB0aGlzLnBlcmZvcm1JZGxlVGFza3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcHJlcGFyZUZvckxheWVyVW5kbygpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBhZGRVbmRvKHVuZG8pIHtcbiAgICAgICAgaGFzVW5zYXZlZENoYW5nZXMgPSB0cnVlO1xuXG4gICAgICAgIGlmIChyZWRvTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZWRvTGlzdCA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVuZG9MaXN0Lmxlbmd0aCA9PSAwIHx8ICF1bmRvTGlzdFt1bmRvTGlzdC5sZW5ndGggLSAxXS5tZXJnZSh1bmRvKSkge1xuICAgICAgICAgICAgaWYgKHVuZG9MaXN0Lmxlbmd0aCA+PSBNQVhfVU5ETykge1xuICAgICAgICAgICAgICAgIHVuZG9MaXN0LnVuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh1bmRvTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdW5kb0xpc3RbdW5kb0xpc3QubGVuZ3RoIC0gMV0uY29tcGFjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdW5kb0xpc3QucHVzaCh1bmRvKTtcbiAgICAgICAgfSBlbHNlIGlmICh1bmRvTGlzdFt1bmRvTGlzdC5sZW5ndGggLSAxXS5ub0NoYW5nZSgpKSB7XG4gICAgICAgICAgICAvLyBUd28gbWVyZ2VkIGNoYW5nZXMgY2FuIG1lYW4gbm8gY2hhbmdlIGF0IGFsbFxuICAgICAgICAgICAgLy8gZG9uJ3QgbGVhdmUgYSB1c2VsZXNzIHVuZG8gaW4gdGhlIGxpc3RcbiAgICAgICAgICAgIHVuZG9MaXN0LnBvcCgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhckhpc3RvcnkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdW5kb0xpc3QgPSBbXTtcbiAgICAgICAgcmVkb0xpc3QgPSBbXTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuY29sb3JQaWNrZXIgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIC8vIG5vdCByZWFsbHkgbmVjZXNzYXJ5IGFuZCBjb3VsZCBwb3RlbnRpYWxseSB0aGUgcmVwYWludFxuICAgICAgICAvLyBvZiB0aGUgY2FudmFzIHRvIG1pc3MgdGhhdCBhcmVhXG4gICAgICAgIC8vIHRoaXMuZnVzaW9uTGF5ZXJzKCk7XG5cbiAgICAgICAgcmV0dXJuIGZ1c2lvbi5nZXRQaXhlbCh+fngsIH5+eSkgJiAweEZGRkZGRjtcbiAgICB9XG5cbiAgICB0aGlzLnNldFNlbGVjdGlvbiA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICAgICAgY3VyU2VsZWN0aW9uLnNldChyZWN0KTtcbiAgICAgICAgY3VyU2VsZWN0aW9uLmNsaXAodGhpcy5nZXRCb3VuZHMoKSk7XG4gICAgfTtcblxuICAgIHRoaXMuZW1wdHlTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY3VyU2VsZWN0aW9uLm1ha2VFbXB0eSgpO1xuICAgIH07XG5cbiAgICB0aGlzLmZsb29kRmlsbCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgICAgcHJlcGFyZUZvckxheWVyVW5kbygpO1xuICAgICAgICB1bmRvQXJlYSA9IHRoaXMuZ2V0Qm91bmRzKCk7XG5cbiAgICAgICAgY3VyTGF5ZXIuZmxvb2RGaWxsKH5+eCwgfn55LCBjdXJDb2xvciB8IDB4ZmYwMDAwMDApO1xuXG4gICAgICAgIGFkZFVuZG8obmV3IENQVW5kb1BhaW50KCkpO1xuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ3JhZGllbnRGaWxsID0gZnVuY3Rpb24oZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSwgZ3JhZGllbnRQb2ludHMpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICByID0gdGhpcy5nZXRTZWxlY3Rpb25BdXRvU2VsZWN0KCk7XG5cbiAgICAgICAgcHJlcGFyZUZvckxheWVyVW5kbygpO1xuICAgICAgICB1bmRvQXJlYSA9IHI7XG5cbiAgICAgICAgY3VyTGF5ZXIuZ3JhZGllbnQociwgZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSwgZ3JhZGllbnRQb2ludHMpO1xuXG4gICAgICAgIGlmIChsb2NrQWxwaGEpIHtcbiAgICAgICAgICAgIHJlc3RvcmVBbHBoYShyKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFVuZG8obmV3IENQVW5kb1BhaW50KCkpO1xuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZmlsbCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgciA9IHRoaXMuZ2V0U2VsZWN0aW9uQXV0b1NlbGVjdCgpO1xuXG4gICAgICAgIHByZXBhcmVGb3JMYXllclVuZG8oKTtcbiAgICAgICAgdW5kb0FyZWEgPSByO1xuXG4gICAgICAgIGN1ckxheWVyLmNsZWFyUmVjdChyLCBjb2xvcik7XG5cbiAgICAgICAgYWRkVW5kbyhuZXcgQ1BVbmRvUGFpbnQoKSk7XG4gICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jbGVhciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmZpbGwoMHhmZmZmZmYpO1xuICAgIH07XG5cbiAgICB0aGlzLmhGbGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgciA9IHRoaXMuZ2V0U2VsZWN0aW9uQXV0b1NlbGVjdCgpO1xuXG4gICAgICAgIHByZXBhcmVGb3JMYXllclVuZG8oKTtcbiAgICAgICAgdW5kb0FyZWEgPSByO1xuXG4gICAgICAgIGN1ckxheWVyLmNvcHlSZWdpb25IRmxpcChyLCB1bmRvQnVmZmVyKTtcblxuICAgICAgICBhZGRVbmRvKG5ldyBDUFVuZG9QYWludCgpKTtcbiAgICAgICAgaW52YWxpZGF0ZUZ1c2lvbigpO1xuICAgIH07XG5cbiAgICB0aGlzLnZGbGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgciA9IHRoaXMuZ2V0U2VsZWN0aW9uQXV0b1NlbGVjdCgpO1xuXG4gICAgICAgIHByZXBhcmVGb3JMYXllclVuZG8oKTtcbiAgICAgICAgdW5kb0FyZWEgPSByO1xuXG4gICAgICAgIGN1ckxheWVyLmNvcHlSZWdpb25WRmxpcChyLCB1bmRvQnVmZmVyKTtcblxuICAgICAgICBhZGRVbmRvKG5ldyBDUFVuZG9QYWludCgpKTtcbiAgICAgICAgaW52YWxpZGF0ZUZ1c2lvbigpO1xuICAgIH07XG5cbiAgICB0aGlzLm1vbm9jaHJvbWF0aWNOb2lzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHIgPSB0aGlzLmdldFNlbGVjdGlvbkF1dG9TZWxlY3QoKTtcblxuICAgICAgICBwcmVwYXJlRm9yTGF5ZXJVbmRvKCk7XG4gICAgICAgIHVuZG9BcmVhID0gcjtcblxuICAgICAgICBjdXJMYXllci5maWxsV2l0aE5vaXNlKHIpO1xuXG4gICAgICAgIGFkZFVuZG8obmV3IENQVW5kb1BhaW50KCkpO1xuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgfTtcblxuICAgIHRoaXMuY29sb3JOb2lzZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHIgPSB0aGlzLmdldFNlbGVjdGlvbkF1dG9TZWxlY3QoKTtcblxuICAgICAgICBwcmVwYXJlRm9yTGF5ZXJVbmRvKCk7XG4gICAgICAgIHVuZG9BcmVhID0gcjtcblxuICAgICAgICBjdXJMYXllci5maWxsV2l0aENvbG9yTm9pc2Uocik7XG5cbiAgICAgICAgYWRkVW5kbyhuZXcgQ1BVbmRvUGFpbnQoKSk7XG4gICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgciA9IHRoaXMuZ2V0U2VsZWN0aW9uQXV0b1NlbGVjdCgpO1xuXG4gICAgICAgIHByZXBhcmVGb3JMYXllclVuZG8oKTtcbiAgICAgICAgdW5kb0FyZWEgPSByO1xuXG4gICAgICAgIGN1ckxheWVyLmludmVydChyKTtcblxuICAgICAgICBhZGRVbmRvKG5ldyBDUFVuZG9QYWludCgpKTtcbiAgICAgICAgaW52YWxpZGF0ZUZ1c2lvbigpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5ib3hCbHVyID0gZnVuY3Rpb24ocmFkaXVzWCwgcmFkaXVzWSwgaXRlcmF0aW9ucykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHIgPSB0aGlzLmdldFNlbGVjdGlvbkF1dG9TZWxlY3QoKTtcblxuICAgICAgICBwcmVwYXJlRm9yTGF5ZXJVbmRvKCk7XG4gICAgICAgIHVuZG9BcmVhID0gcjtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xuICAgICAgICAgICAgY3VyTGF5ZXIuYm94Qmx1cihyLCByYWRpdXNYLCByYWRpdXNZKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGFkZFVuZG8obmV3IENQVW5kb1BhaW50KCkpO1xuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnJlY3RhbmdsZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBuZXdTZWxlY3Rpb24gPSByLmNsb25lKCk7XG4gICAgICAgIFxuICAgICAgICBuZXdTZWxlY3Rpb24uY2xpcCh0aGlzLmdldEJvdW5kcygpKTtcblxuICAgICAgICBhZGRVbmRvKG5ldyBDUFVuZG9SZWN0YW5nbGVTZWxlY3Rpb24odGhpcy5nZXRTZWxlY3Rpb24oKSwgbmV3U2VsZWN0aW9uKSk7XG5cbiAgICAgICAgdGhpcy5zZXRTZWxlY3Rpb24obmV3U2VsZWN0aW9uKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBtb3N0IHJlY2VudGx5IGNvbXBsZXRlZCBvcGVyYXRpb24gZnJvbSB0aGUgdW5kbyBsaXN0LCBvciBudWxsIGlmIHRoZSB1bmRvIGxpc3QgaXMgZW1wdHkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBY3RpdmVPcGVyYXRpb24oKSB7XG4gICAgICAgIGlmICh1bmRvTGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kb0xpc3RbdW5kb0xpc3QubGVuZ3RoIC0gMV07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNb3ZlIHRoZSBjdXJyZW50bHkgc2VsZWN0ZWQgbGF5ZXIgZGF0YSBieSB0aGUgZ2l2ZW4gb2Zmc2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtpbnR9IG9mZnNldFhcbiAgICAgKiBAcGFyYW0ge2ludH0gb2Zmc2V0WVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gY29weSAtIE1ha2UgYSBjb3B5IG9mIHRoZSBzZWxlY3Rpb24gaW5zdGVhZCBvZiBtb3ZpbmcgaXQuXG4gICAgICovXG4gICAgdGhpcy5tb3ZlID0gZnVuY3Rpb24ob2Zmc2V0WCwgb2Zmc2V0WSwgY29weSkge1xuICAgICAgICAvKlxuICAgICAgICAgKiBBZGQgcm91bmRpbmcgdG8gZW5zdXJlIHdlIGhhdmVuJ3QgYmVlbiBnaXZlbiBmbG9hdCBjb29yZGluYXRlcyAodGhhdCB3b3VsZCBjYXVzZSBob3JyaWJsZSBmbG93LW9uIGVmZmVjdHMgbGlrZVxuICAgICAgICAgKiB0aGUgYm91bmRhcnkgb2YgdGhlIHVuZG8gcmVjdGFuZ2xlIGhhdmluZyBmbG9hdCBjb29yZGluYXRlcylcbiAgICAgICAgICovXG4gICAgICAgIG9mZnNldFggfD0gMDtcbiAgICAgICAgb2Zmc2V0WSB8PSAwO1xuXG4gICAgICAgIGlmIChvZmZzZXRYID09IDAgJiYgb2Zmc2V0WSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBvcGFjaXR5QXJlYS5tYWtlRW1wdHkoKTsgLy8gUHJldmVudHMgYSBkcmF3aW5nIHRvb2wgYmVpbmcgY2FsbGVkIGR1cmluZyBsYXllciBmdXNpb24gdG8gZHJhdyBpdHNlbGYgdG8gdGhlIGxheWVyXG5cbiAgICAgICAgdmFyXG4gICAgICAgICAgICBhY3RpdmVPcCA9IGdldEFjdGl2ZU9wZXJhdGlvbigpO1xuXG4gICAgICAgIC8vIElmIHdlJ3ZlIGNoYW5nZWQgbGF5ZXJzIHNpbmNlIG91ciBsYXN0IG1vdmUsIHdlIHdhbnQgdG8gbW92ZSB0aGUgbmV3IGxheWVyLCBub3QgdGhlIG9sZCBvbmUsIHNvIGNhbid0IGFtZW5kXG4gICAgICAgIGlmICghY29weSAmJiBhY3RpdmVPcCBpbnN0YW5jZW9mIENQQWN0aW9uTW92ZVNlbGVjdGlvbiAmJiBhY3RpdmVPcC5sYXllckluZGV4ID09IHRoaXMuZ2V0QWN0aXZlTGF5ZXJJbmRleCgpKSB7XG4gICAgICAgICAgICBhY3RpdmVPcC5hbWVuZChvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgIHJlZG9MaXN0ID0gW107XG4gICAgICAgICAgICBoYXNVbnNhdmVkQ2hhbmdlcyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY3RpdmVPcCA9IG5ldyBDUEFjdGlvbk1vdmVTZWxlY3Rpb24odGhpcy5nZXRTZWxlY3Rpb25BdXRvU2VsZWN0KCksIG9mZnNldFgsIG9mZnNldFksIGNvcHkpO1xuXG4gICAgICAgICAgICBhZGRVbmRvKGFjdGl2ZU9wKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgdGhlIGludGVycG9sYXRpb24gbW9kZSB1c2VkIGJ5IEZyZWUgVHJhbnNmb3JtIG9wZXJhdGlvbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnRlcnBvbGF0aW9uIC0gRWl0aGVyIFwic2hhcnBcIiBvciBcInNtb290aFwiXG4gICAgICovXG4gICAgdGhpcy5zZXRUcmFuc2Zvcm1JbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24oaW50ZXJwb2xhdGlvbikge1xuICAgICAgICB0cmFuc2Zvcm1JbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbjtcbiAgICAgICAgaWYgKHByZXZpZXdPcGVyYXRpb24gaW5zdGFuY2VvZiBDUEFjdGlvblRyYW5zZm9ybVNlbGVjdGlvbikge1xuICAgICAgICAgICAgcHJldmlld09wZXJhdGlvbi5zZXRJbnRlcnBvbGF0aW9uKGludGVycG9sYXRpb24pO1xuICAgICAgICB9XG4gICAgfTtcblxuXHQvKipcbiAgICAgKiBJZiB0aGUgY3VycmVudCBvcGVyYXRpb24gaXMgYW4gYWZmaW5lIHRyYW5zZm9ybSwgcm9sbCBpdCBiYWNrIGFuZCByZW1vdmUgaXQgZnJvbSB0aGUgdW5kbyBoaXN0b3J5LlxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtQWZmaW5lQWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHByZXZpZXdPcGVyYXRpb24gaW5zdGFuY2VvZiBDUEFjdGlvblRyYW5zZm9ybVNlbGVjdGlvbikge1xuICAgICAgICAgICAgcHJldmlld09wZXJhdGlvbi51bmRvKCk7XG4gICAgICAgICAgICBwcmV2aWV3T3BlcmF0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cblx0LyoqXG4gICAgICogQmVnaW5zIHRyYW5zZm9ybWluZyB0aGUgY3VycmVudCBzZWxlY3Rpb24vbGF5ZXIsIGFuZCByZXR1cm5zIHRoZSBpbml0aWFsIHNvdXJjZSByZWN0YW5nbGUgYW5kIGluaXRpYWwgdHJhbnNmb3JtLlxuICAgICAqIFlvdSBjYW4gdXBkYXRlIHRoZSB0cmFuc2Zvcm0gYnkgY2FsbGluZyB0cmFuc2Zvcm1BZmZpbmUoKS5cbiAgICAgKiBcbiAgICAgKiBZb3UgbXVzdCBjYWxsIHRyYW5zZm9ybUFmZmluZUZpbmlzaCgpIG9yIHRyYW5zZm9ybUFmZmluZUFib3J0KCkgdG8gZmluaXNoIHRoZSB0cmFuc2Zvcm1hdGlvbi5cbiAgICAgKiBcbiAgICAgKiBSZXR1cm5zIG51bGwgaWYgdGhlIGN1cnJlbnQgc2VsZWN0aW9uL2xheWVyIGRvZXNuJ3QgY29udGFpbiBhbnkgbm9uLXRyYW5zcGFyZW50IHBpeGVscywgYW5kIGRvZXNuJ3Qgc3RhcnRcbiAgICAgKiB0cmFuc2Zvcm1pbmcuXG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1BZmZpbmVCZWdpbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBBcmUgd2UgYWxyZWFkeSB0cmFuc2Zvcm1pbmc/IENvbnRpbnVlIHRoYXQgaW5zdGVhZFxuICAgICAgICBpZiAocHJldmlld09wZXJhdGlvbiBpbnN0YW5jZW9mIENQQWN0aW9uVHJhbnNmb3JtU2VsZWN0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm4ge3RyYW5zZm9ybTogcHJldmlld09wZXJhdGlvbi5nZXRUcmFuc2Zvcm0oKSwgcmVjdDogcHJldmlld09wZXJhdGlvbi5nZXRJbml0aWFsVHJhbnNmb3JtUmVjdCgpLCBzZWxlY3Rpb246IHByZXZpZXdPcGVyYXRpb24uZ2V0SW5pdGlhbFNlbGVjdGlvblJlY3QoKX07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBPbmx5IHRyYW5zZm9ybSB0aGUgbm9uLXRyYW5zcGFyZW50IHBpeGVsc1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGxheWVyID0gdGhpcy5nZXRBY3RpdmVMYXllcigpLFxuICAgICAgICAgICAgc2VsZWN0aW9uID0gdGhpcy5nZXRTZWxlY3Rpb25BdXRvU2VsZWN0KCksXG4gICAgICAgICAgICBpbml0aWFsUmVjdCA9IGxheWVyLmdldE5vblRyYW5zcGFyZW50Qm91bmRzKHNlbGVjdGlvbiksXG4gICAgICAgICAgICBpbml0aWFsVHJhbnNmb3JtID0gbmV3IENQVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgaWYgKGluaXRpYWxSZWN0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBJZiB3ZSBpbnRyb2R1Y2Ugb3RoZXIgcHJldmlld09wZXJhdGlvbnMsIHdlIG1pZ2h0IHdhbnQgdG8gY2hlY2sgd2UgYXJlbid0IG92ZXJ3cml0aW5nIHRoZW0gaGVyZS4uLlxuICAgICAgICAgKiBUaG91Z2ggcHJvYmFibHkgQ2hpY2tlblBhaW50J3MgZ2xvYmFsIGV4Y2x1c2l2ZSBtb2RlIHdpbGwgZW5mb3JjZSB0aGlzIGZvciB1cy5cbiAgICAgICAgICovXG4gICAgICAgIHByZXZpZXdPcGVyYXRpb24gPSBuZXcgQ1BBY3Rpb25UcmFuc2Zvcm1TZWxlY3Rpb24oaW5pdGlhbFJlY3QsIGluaXRpYWxUcmFuc2Zvcm0sIHRyYW5zZm9ybUludGVycG9sYXRpb24pO1xuICAgIFxuICAgICAgICBvcGFjaXR5QXJlYS5tYWtlRW1wdHkoKTsgLy8gUHJldmVudHMgYSBkcmF3aW5nIHRvb2wgYmVpbmcgY2FsbGVkIGR1cmluZyBsYXllciBmdXNpb24gdG8gZHJhdyBpdHNlbGYgdG8gdGhlIGxheWVyXG4gICAgXG4gICAgICAgIHJldHVybiB7dHJhbnNmb3JtOiBpbml0aWFsVHJhbnNmb3JtLCByZWN0OiBpbml0aWFsUmVjdCwgc2VsZWN0aW9uOiBzZWxlY3Rpb259O1xuICAgIH07XG5cblx0LyoqXG4gICAgICogRmluaXNoIGFuZCBzYXZlIHRoZSB0cmFuc2Zvcm0gdGhhdCBpcyBjdXJyZW50bHkgaW4gcHJvZ3Jlc3MuXG4gICAgICovXG4gICAgdGhpcy50cmFuc2Zvcm1BZmZpbmVGaW5pc2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHByZXZpZXdPcGVyYXRpb24gaW5zdGFuY2VvZiBDUEFjdGlvblRyYW5zZm9ybVNlbGVjdGlvbikge1xuICAgICAgICAgICAgYWRkVW5kbyhwcmV2aWV3T3BlcmF0aW9uKTtcbiAgICAgICAgICAgIHByZXZpZXdPcGVyYXRpb24gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRyYW5zZm9ybSB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGxheWVyIGRhdGEgdXNpbmcgdGhlIGdpdmVuIEFmZmluZVRyYW5zZm9ybS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Q1BUcmFuc2Zvcm19IGFmZmluZVRyYW5zZm9ybVxuICAgICAqL1xuICAgIHRoaXMudHJhbnNmb3JtQWZmaW5lQW1lbmQgPSBmdW5jdGlvbihhZmZpbmVUcmFuc2Zvcm0pIHtcbiAgICAgICAgaWYgKHByZXZpZXdPcGVyYXRpb24gaW5zdGFuY2VvZiBDUEFjdGlvblRyYW5zZm9ybVNlbGVjdGlvbikge1xuICAgICAgICAgICAgcHJldmlld09wZXJhdGlvbi5hbWVuZChhZmZpbmVUcmFuc2Zvcm0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvLyBDb3B5L1Bhc3RlIGZ1bmN0aW9uc1xuICAgIFxuICAgIHRoaXMuY3V0U2VsZWN0aW9uID0gZnVuY3Rpb24oY3JlYXRlVW5kbykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHRoaXMuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2xpcGJvYXJkID0gbmV3IENQQ2xpcChjdXJMYXllci5jbG9uZVJlY3Qoc2VsZWN0aW9uKSwgc2VsZWN0aW9uLmxlZnQsIHNlbGVjdGlvbi50b3ApO1xuXG4gICAgICAgIGlmIChjcmVhdGVVbmRvKSB7XG4gICAgICAgICAgICBhZGRVbmRvKG5ldyBDUFVuZG9DdXQoY2xpcGJvYXJkLmJtcCwgdGhpcy5nZXRBY3RpdmVMYXllckluZGV4KCksIHNlbGVjdGlvbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VyTGF5ZXIuY2xlYXJSZWN0KHNlbGVjdGlvbiwgRU1QVFlfTEFZRVJfQ09MT1IpO1xuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uUmVjdChzZWxlY3Rpb24pO1xuICAgIH07XG5cbiAgICB0aGlzLmNvcHlTZWxlY3Rpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSB0aGF0LmdldFNlbGVjdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGNsaXBib2FyZCA9IG5ldyBDUENsaXAoY3VyTGF5ZXIuY2xvbmVSZWN0KHNlbGVjdGlvbiksIHNlbGVjdGlvbi5sZWZ0LCBzZWxlY3Rpb24udG9wKTtcbiAgICB9O1xuXG4gICAgdGhpcy5jb3B5U2VsZWN0aW9uTWVyZ2VkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIHNlbGVjdGlvbiA9IHRoYXQuZ2V0U2VsZWN0aW9uKCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gbWFrZSBzdXJlIHRoZSBmdXNpb25lZCBwaWN0dXJlIGlzIHVwIHRvIGRhdGVcbiAgICAgICAgdGhpcy5mdXNpb25MYXllcnMoKTtcbiAgICAgICAgY2xpcGJvYXJkID0gbmV3IENQQ2xpcChmdXNpb24uY2xvbmVSZWN0KHNlbGVjdGlvbiksIHNlbGVjdGlvbi5sZWZ0LCBzZWxlY3Rpb24udG9wKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY3JlYXRlVW5kbyBib29sZWFuXG4gICAgICogQHBhcmFtIGNsaXAgQ1BDbGlwXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFzdGVDbGlwKGNyZWF0ZVVuZG8sIGNsaXApIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBhY3RpdmVMYXllckluZGV4ID0gdGhhdC5nZXRBY3RpdmVMYXllckluZGV4KCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoY3JlYXRlVW5kbykge1xuICAgICAgICAgICAgYWRkVW5kbyhuZXcgQ1BVbmRvUGFzdGUoY2xpcCwgYWN0aXZlTGF5ZXJJbmRleCwgdGhhdC5nZXRTZWxlY3Rpb24oKSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyXG4gICAgICAgICAgICBuZXdMYXllciA9IG5ldyBDUExheWVyKHRoYXQud2lkdGgsIHRoYXQuaGVpZ2h0LCB0aGF0LmdldERlZmF1bHRMYXllck5hbWUoKSksXG4gICAgICAgICAgICBzb3VyY2VSZWN0ID0gY2xpcC5ibXAuZ2V0Qm91bmRzKCksXG4gICAgICAgICAgICB4LCB5O1xuICAgICAgICBcbiAgICAgICAgbGF5ZXJzLnNwbGljZShhY3RpdmVMYXllckluZGV4ICsgMSwgMCwgbmV3TGF5ZXIpO1xuICAgICAgICB0aGF0LnNldEFjdGl2ZUxheWVySW5kZXgoYWN0aXZlTGF5ZXJJbmRleCArIDEpO1xuXG4gICAgICAgIGlmIChzb3VyY2VSZWN0LmlzSW5zaWRlKHRoYXQuZ2V0Qm91bmRzKCkpKSB7XG4gICAgICAgICAgICB4ID0gY2xpcC54O1xuICAgICAgICAgICAgeSA9IGNsaXAueTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHggPSAoKHRoYXQud2lkdGggLSBjbGlwLmJtcC53aWR0aCkgLyAyKSB8IDA7XG4gICAgICAgICAgICB5ID0gKCh0aGF0LmhlaWdodCAtIGNsaXAuYm1wLmhlaWdodCkgLyAyKSB8IDA7XG4gICAgICAgIH1cblxuICAgICAgICBjdXJMYXllci5jb3B5Qml0bWFwUmVjdChjbGlwLmJtcCwgeCwgeSwgc291cmNlUmVjdCk7XG4gICAgICAgIHRoYXQuZW1wdHlTZWxlY3Rpb24oKTtcblxuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnBhc3RlQ2xpcGJvYXJkID0gZnVuY3Rpb24oY3JlYXRlVW5kbykge1xuICAgICAgICBpZiAoY2xpcGJvYXJkICE9IG51bGwpIHtcbiAgICAgICAgICAgIHBhc3RlQ2xpcChjcmVhdGVVbmRvLCBjbGlwYm9hcmQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldFNhbXBsZUFsbExheWVycyA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgc2FtcGxlQWxsTGF5ZXJzID0gYjtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRMb2NrQWxwaGEgPSBmdW5jdGlvbihiKSB7XG4gICAgICAgIGxvY2tBbHBoYSA9IGI7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0Rm9yZWdyb3VuZENvbG9yID0gZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgY3VyQ29sb3IgPSBjb2xvcjtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0QnJ1c2ggPSBmdW5jdGlvbihicnVzaCkge1xuICAgICAgICBjdXJCcnVzaCA9IGJydXNoO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXRCcnVzaFRleHR1cmUgPSBmdW5jdGlvbih0ZXh0dXJlKSB7XG4gICAgICAgIGJydXNoTWFuYWdlci5zZXRUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cbiAgICBcbiAgICAvLyAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFBhaW50IGVuZ2luZVxuICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgICB0aGlzLmJlZ2luU3Ryb2tlID0gZnVuY3Rpb24oeCwgeSwgcHJlc3N1cmUpIHtcbiAgICAgICAgaWYgKGN1ckJydXNoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhaW50aW5nTW9kZXNbY3VyQnJ1c2gucGFpbnRNb2RlXS5iZWdpblN0cm9rZSh4LCB5LCBwcmVzc3VyZSk7XG4gICAgfTtcblxuICAgIHRoaXMuY29udGludWVTdHJva2UgPSBmdW5jdGlvbih4LCB5LCBwcmVzc3VyZSkge1xuICAgICAgICBpZiAoY3VyQnJ1c2ggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFpbnRpbmdNb2Rlc1tjdXJCcnVzaC5wYWludE1vZGVdLmNvbnRpbnVlU3Ryb2tlKHgsIHksIHByZXNzdXJlKTtcbiAgICB9O1xuXG4gICAgdGhpcy5lbmRTdHJva2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGN1ckJydXNoID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhaW50aW5nTW9kZXNbY3VyQnJ1c2gucGFpbnRNb2RlXS5lbmRTdHJva2UoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuaGFzQWxwaGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGZ1c2lvbi5oYXNBbHBoYSgpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhcnR3b3JrIGFzIGEgc2luZ2xlIGZsYXQgUE5HIGltYWdlLlxuICAgICAqIFxuICAgICAqIFJvdGF0aW9uIGlzIFswLi4zXSBhbmQgc2VsZWN0cyBhIG11bHRpcGxlIG9mIDkwIGRlZ3JlZXMgb2YgY2xvY2t3aXNlIHJvdGF0aW9uIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGRyYXdpbmcgYmVmb3JlXG4gICAgICogc2F2aW5nLlxuICAgICAqIFxuICAgICAqIEByZXR1cm4gQSBiaW5hcnkgc3RyaW5nIG9mIHRoZSBQTkcgZmlsZSBkYXRhLlxuICAgICAqL1xuICAgIHRoaXMuZ2V0RmxhdFBORyA9IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG4gICAgICAgIHRoaXMuZnVzaW9uTGF5ZXJzKCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZnVzaW9uLmdldEFzUE5HKHJvdGF0aW9uKTtcbiAgICB9O1xuICAgIFxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGFydHdvcmsgY2FuIGJlIGV4YWN0bHkgcmVwcmVzZW50ZWQgYXMgYSBzaW1wbGUgdHJhbnNwYXJlbnQgUE5HIChpLmUuIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBcbiAgICAgKiBsYXllcnMsIGFuZCBiYXNlIGxheWVyJ3Mgb3BhY2l0eSBpcyBzZXQgdG8gMTAwJSkuXG4gICAgICovXG4gICAgdGhpcy5pc1NpbXBsZURyYXdpbmcgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TGF5ZXJDb3VudCgpID09IDEgJiYgdGhpcy5nZXRMYXllcigwKS5nZXRBbHBoYSgpID09IDEwMDtcbiAgICB9O1xuICAgIFxuICAgIC8vIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBVbmRvIGNsYXNzZXNcblxuICAgIC8qKlxuICAgICAqIFNhdmUgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGUgY3VycmVudCBsYXllciBhbmQgdGhlIHVuZG9CdWZmZXIgKHdpdGhpbiB0aGUgdW5kb0FyZWEpIGZvciB1bmRvLCBhbmQgY2xlYXJcbiAgICAgKiB0aGUgdW5kb0FyZWEuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDUFVuZG9QYWludCgpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICByZWN0ID0gdW5kb0FyZWEuY2xvbmUoKSxcbiAgICAgICAgICAgIGRhdGEgPSB1bmRvQnVmZmVyLmNvcHlSZWN0WE9SKGN1ckxheWVyLCByZWN0KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMubGF5ZXIgPSB0aGF0LmdldEFjdGl2ZUxheWVySW5kZXgoKTtcblxuICAgICAgICB1bmRvQXJlYS5tYWtlRW1wdHkoKTtcblxuICAgICAgICB0aGlzLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQuZ2V0TGF5ZXIodGhpcy5sYXllcikuc2V0UmVjdFhPUihkYXRhLCByZWN0KTtcbiAgICAgICAgICAgIGludmFsaWRhdGVGdXNpb25SZWN0KHJlY3QpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVkbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhhdC5nZXRMYXllcih0aGlzLmxheWVyKS5zZXRSZWN0WE9SKGRhdGEsIHJlY3QpO1xuICAgICAgICAgICAgaW52YWxpZGF0ZUZ1c2lvblJlY3QocmVjdCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRNZW1vcnlVc2VkID0gZnVuY3Rpb24odW5kb25lLCBwYXJhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBDUFVuZG9QYWludC5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQVW5kby5wcm90b3R5cGUpO1xuICAgIENQVW5kb1BhaW50LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQVW5kb1BhaW50O1xuICAgIFxuICAgIGZ1bmN0aW9uIENQVW5kb0xheWVyVmlzaWJsZShfbGF5ZXJJbmRleCwgX29sZFZpcywgX25ld1Zpcykge1xuICAgICAgICB0aGlzLmxheWVySW5kZXggPSBfbGF5ZXJJbmRleDtcbiAgICAgICAgdGhpcy5vbGRWaXMgPSBfb2xkVmlzO1xuICAgICAgICB0aGlzLm5ld1ZpcyA9IF9uZXdWaXM7XG4gICAgfVxuICAgIFxuICAgIENQVW5kb0xheWVyVmlzaWJsZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQVW5kby5wcm90b3R5cGUpO1xuICAgIENQVW5kb0xheWVyVmlzaWJsZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFVuZG9MYXllclZpc2libGU7XG4gICAgXG4gICAgQ1BVbmRvTGF5ZXJWaXNpYmxlLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZ2V0TGF5ZXIodGhpcy5sYXllckluZGV4KS52aXNpYmxlID0gdGhpcy5uZXdWaXM7XG4gICAgICAgIFxuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSh0aGlzLmxheWVySW5kZXgpO1xuICAgIH07XG5cbiAgICBDUFVuZG9MYXllclZpc2libGUucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5nZXRMYXllcih0aGlzLmxheWVySW5kZXgpLnZpc2libGUgPSB0aGlzLm9sZFZpcztcbiAgICAgICAgXG4gICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgY2FsbExpc3RlbmVyc0xheWVyQ2hhbmdlKHRoaXMubGF5ZXJJbmRleCk7XG4gICAgfTtcblxuICAgIENQVW5kb0xheWVyVmlzaWJsZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIGlmICh1IGluc3RhbmNlb2YgQ1BVbmRvTGF5ZXJWaXNpYmxlICYmIHRoaXMubGF5ZXJJbmRleCA9PSB1LmxheWVySW5kZXgpIHtcbiAgICAgICAgICAgIHRoaXMubmV3VmlzID0gdS5uZXdWaXM7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIENQVW5kb0xheWVyVmlzaWJsZS5wcm90b3R5cGUubm9DaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2xkVmlzID09IHRoaXMubmV3VmlzO1xuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gQ1BVbmRvQWRkTGF5ZXIobGF5ZXJJbmRleCkge1xuICAgICAgICB0aGlzLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxheWVycy5zcGxpY2UobGF5ZXJJbmRleCArIDEsIDEpO1xuICAgICAgICAgICAgdGhhdC5zZXRBY3RpdmVMYXllckluZGV4KGxheWVySW5kZXgpO1xuICAgICAgICAgICAgaW52YWxpZGF0ZUZ1c2lvbigpO1xuICAgICAgICAgICAgY2FsbExpc3RlbmVyc0xheWVyQ2hhbmdlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIG5ld0xheWVyID0gbmV3IENQTGF5ZXIodGhhdC53aWR0aCwgdGhhdC5oZWlnaHQsIHRoYXQuZ2V0RGVmYXVsdExheWVyTmFtZSgpKTtcbiAgICAgICAgICAgIG5ld0xheWVyLmNsZWFyQWxsKEVNUFRZX0xBWUVSX0NPTE9SKTtcbiAgICAgICAgICAgIGxheWVycy5zcGxpY2UobGF5ZXJJbmRleCArIDEsIDAsIG5ld0xheWVyKTtcbiAgICAgICAgICAgIHRoYXQuc2V0QWN0aXZlTGF5ZXJJbmRleChsYXllckluZGV4ICsgMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIENQVW5kb0FkZExheWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BVbmRvLnByb3RvdHlwZSk7XG4gICAgQ1BVbmRvQWRkTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BVbmRvQWRkTGF5ZXI7XG5cbiAgICBmdW5jdGlvbiBDUFVuZG9EdXBsaWNhdGVMYXllcihsYXllckluZGV4KSB7XG4gICAgICAgIHRoaXMudW5kbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGF5ZXJzLnNwbGljZShsYXllckluZGV4ICsgMSwgMSk7XG4gICAgICAgICAgICB0aGF0LnNldEFjdGl2ZUxheWVySW5kZXgobGF5ZXJJbmRleCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVkbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgY29weVN1ZmZpeCA9IFwiIENvcHlcIixcblxuICAgICAgICAgICAgICAgIHNvdXJjZUxheWVyID0gbGF5ZXJzW2xheWVySW5kZXhdLFxuICAgICAgICAgICAgICAgIG5ld0xheWVyID0gbmV3IENQTGF5ZXIodGhhdC53aWR0aCwgdGhhdC5oZWlnaHQpLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIG5ld0xheWVyTmFtZSA9IHNvdXJjZUxheWVyLm5hbWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICghbmV3TGF5ZXJOYW1lLmVuZHNXaXRoKGNvcHlTdWZmaXgpKSB7XG4gICAgICAgICAgICAgICAgbmV3TGF5ZXJOYW1lICs9IGNvcHlTdWZmaXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5ld0xheWVyLmNvcHlGcm9tKHNvdXJjZUxheWVyKTtcbiAgICAgICAgICAgIG5ld0xheWVyLm5hbWUgPSBuZXdMYXllck5hbWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxheWVycy5zcGxpY2UobGF5ZXJJbmRleCArIDEsIDAsIG5ld0xheWVyKTtcblxuICAgICAgICAgICAgdGhhdC5zZXRBY3RpdmVMYXllckluZGV4KGxheWVySW5kZXggKyAxKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaW52YWxpZGF0ZUZ1c2lvbigpO1xuICAgICAgICAgICAgY2FsbExpc3RlbmVyc0xheWVyQ2hhbmdlKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIENQVW5kb0R1cGxpY2F0ZUxheWVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BVbmRvLnByb3RvdHlwZSk7XG4gICAgQ1BVbmRvRHVwbGljYXRlTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BVbmRvRHVwbGljYXRlTGF5ZXI7XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gbGF5ZXJJbmRleCBpbnRcbiAgICAgKiBAcGFyYW0gbGF5ZXIgQ1BMYXllclxuICAgICAqL1xuICAgIGZ1bmN0aW9uIENQVW5kb1JlbW92ZUxheWVyKGxheWVySW5kZXgsIGxheWVyKSB7XG4gICAgICAgIHRoaXMudW5kbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGF5ZXJzLnNwbGljZShsYXllckluZGV4LCAwLCBsYXllcik7XG4gICAgICAgICAgICB0aGF0LnNldEFjdGl2ZUxheWVySW5kZXgobGF5ZXJJbmRleCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVkbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGF5ZXJzLnNwbGljZShsYXllckluZGV4LCAxKTtcbiAgICAgICAgICAgIHRoYXQuc2V0QWN0aXZlTGF5ZXJJbmRleChsYXllckluZGV4IDwgbGF5ZXJzLmxlbmd0aCA/IGxheWVySW5kZXggOiBsYXllckluZGV4IC0gMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0TWVtb3J5VXNlZCA9IGZ1bmN0aW9uKHVuZG9uZSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZG9uZSA/IDAgOiBsYXllci53aWR0aCAqIGxheWVyLmhlaWdodCAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBDUFVuZG9SZW1vdmVMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQVW5kby5wcm90b3R5cGUpO1xuICAgIENQVW5kb1JlbW92ZUxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQVW5kb1JlbW92ZUxheWVyO1xuICAgIFxuICAgIGZ1bmN0aW9uIENQVW5kb01lcmdlRG93bkxheWVyKGxheWVySW5kZXgpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBsYXllckJvdHRvbSA9IG5ldyBDUExheWVyKHRoYXQud2lkdGgsIHRoYXQuaGVpZ2h0KSxcbiAgICAgICAgICAgIGxheWVyVG9wO1xuXG4gICAgICAgIGxheWVyQm90dG9tLmNvcHlGcm9tKGxheWVyc1tsYXllckluZGV4IC0gMV0pO1xuICAgICAgICBsYXllclRvcCA9IGxheWVyc1tsYXllckluZGV4XTtcblxuICAgICAgICB0aGlzLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxheWVyc1tsYXllckluZGV4IC0gMV0uY29weUZyb20obGF5ZXJCb3R0b20pO1xuICAgICAgICAgICAgbGF5ZXJzLnNwbGljZShsYXllckluZGV4LCAwLCBsYXllclRvcCk7XG4gICAgICAgICAgICB0aGF0LnNldEFjdGl2ZUxheWVySW5kZXgobGF5ZXJJbmRleCk7XG5cbiAgICAgICAgICAgIGxheWVyQm90dG9tID0gbGF5ZXJUb3AgPSBudWxsO1xuXG4gICAgICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgICAgICBjYWxsTGlzdGVuZXJzTGF5ZXJDaGFuZ2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxheWVyQm90dG9tID0gbmV3IENQTGF5ZXIodGhhdC53aWR0aCwgdGhhdC5oZWlnaHQpO1xuICAgICAgICAgICAgbGF5ZXJCb3R0b20uY29weUZyb20obGF5ZXJzW2xheWVySW5kZXggLSAxXSk7XG4gICAgICAgICAgICBsYXllclRvcCA9IGxheWVyc1tsYXllckluZGV4XTtcblxuICAgICAgICAgICAgdGhhdC5zZXRBY3RpdmVMYXllckluZGV4KGxheWVySW5kZXgpO1xuICAgICAgICAgICAgdGhhdC5tZXJnZURvd24oZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0TWVtb3J5VXNlZCA9IGZ1bmN0aW9uKHVuZG9uZSwgcGFyYW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRvbmUgPyAwIDogdGhhdC53aWR0aCAqIHRoYXQuaGVpZ2h0ICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwgKiAyO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBDUFVuZG9NZXJnZURvd25MYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQVW5kby5wcm90b3R5cGUpO1xuICAgIENQVW5kb01lcmdlRG93bkxheWVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQVW5kb01lcmdlRG93bkxheWVyO1xuXG4gICAgZnVuY3Rpb24gQ1BVbmRvTWVyZ2VBbGxMYXllcnMoKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIG9sZEFjdGl2ZUxheWVySW5kZXggPSB0aGF0LmdldEFjdGl2ZUxheWVySW5kZXgoKSxcbiAgICAgICAgICAgIG9sZExheWVycyA9IGxheWVycy5zbGljZSgwKTsgLy8gQ2xvbmUgb2xkIGxheWVycyBhcnJheVxuXG4gICAgICAgIHRoaXMudW5kbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGF5ZXJzID0gb2xkTGF5ZXJzLnNsaWNlKDApO1xuICAgICAgICAgICAgdGhhdC5zZXRBY3RpdmVMYXllckluZGV4KG9sZEFjdGl2ZUxheWVySW5kZXgpO1xuXG4gICAgICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgICAgICBjYWxsTGlzdGVuZXJzTGF5ZXJDaGFuZ2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQubWVyZ2VBbGxMYXllcnMoZmFsc2UpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0TWVtb3J5VXNlZCA9IGZ1bmN0aW9uKHVuZG9uZSwgcGFyYW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRvbmUgPyAwIDogb2xkTGF5ZXJzLmxlbmd0aCAqIHdpZHRoICogaGVpZ2h0ICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgIH07XG4gICAgfVxuICAgIFxuICAgIENQVW5kb01lcmdlQWxsTGF5ZXJzLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BVbmRvLnByb3RvdHlwZSk7XG4gICAgQ1BVbmRvTWVyZ2VBbGxMYXllcnMucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BVbmRvTWVyZ2VBbGxMYXllcnM7XG4gICAgXG4gICAgZnVuY3Rpb24gQ1BVbmRvTW92ZUxheWVyKGZyb20sIHRvKSB7XG4gICAgICAgIHRoaXMudW5kbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKHRvIDw9IGZyb20pIHtcbiAgICAgICAgICAgICAgICBtb3ZlTGF5ZXJSZWFsKHRvLCBmcm9tICsgMSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vdmVMYXllclJlYWwodG8gLSAxLCBmcm9tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIG1vdmVMYXllclJlYWwoZnJvbSwgdG8pO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBDUFVuZG9Nb3ZlTGF5ZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUFVuZG8ucHJvdG90eXBlKTtcbiAgICBDUFVuZG9Nb3ZlTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BVbmRvTW92ZUxheWVyO1xuXG4gICAgZnVuY3Rpb24gQ1BVbmRvTGF5ZXJBbHBoYShsYXllckluZGV4LCBhbHBoYSkge1xuICAgICAgICB0aGlzLmZyb20gPSB0aGF0LmdldExheWVyKGxheWVySW5kZXgpLmdldEFscGhhKCk7XG4gICAgICAgIHRoaXMudG8gPSBhbHBoYTtcbiAgICAgICAgdGhpcy5sYXllckluZGV4ID0gbGF5ZXJJbmRleDtcbiAgICB9XG4gICAgXG4gICAgQ1BVbmRvTGF5ZXJBbHBoYS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQVW5kby5wcm90b3R5cGUpO1xuICAgIENQVW5kb0xheWVyQWxwaGEucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BVbmRvTGF5ZXJBbHBoYTtcblxuICAgIENQVW5kb0xheWVyQWxwaGEucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5nZXRMYXllcih0aGlzLmxheWVySW5kZXgpLnNldEFscGhhKHRoaXMuZnJvbSk7XG4gICAgICAgIFxuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSh0aGlzLmxheWVySW5kZXgpO1xuICAgIH07XG5cbiAgICBDUFVuZG9MYXllckFscGhhLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZ2V0TGF5ZXIodGhpcy5sYXllckluZGV4KS5zZXRBbHBoYSh0aGlzLnRvKTtcbiAgICAgICAgXG4gICAgICAgIGludmFsaWRhdGVGdXNpb24oKTtcbiAgICAgICAgY2FsbExpc3RlbmVyc0xheWVyQ2hhbmdlKHRoaXMubGF5ZXJJbmRleCk7XG4gICAgfVxuXG4gICAgQ1BVbmRvTGF5ZXJBbHBoYS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIGlmICh1IGluc3RhbmNlb2YgQ1BVbmRvTGF5ZXJBbHBoYSAmJiB0aGlzLmxheWVySW5kZXggPT0gdS5sYXllckluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnRvID0gdS50bztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgQ1BVbmRvTGF5ZXJBbHBoYS5wcm90b3R5cGUubm9DaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnJvbSA9PSB0aGlzLnRvO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIENQVW5kb0xheWVyTW9kZShsYXllckluZGV4LCB0bykge1xuICAgICAgICB0aGlzLmxheWVySW5kZXggPSBsYXllckluZGV4O1xuICAgICAgICB0aGlzLmZyb20gPSB0aGF0LmdldExheWVyKGxheWVySW5kZXgpLmdldEJsZW5kTW9kZSgpO1xuICAgICAgICB0aGlzLnRvID0gdG87XG4gICAgfVxuICAgIFxuICAgIENQVW5kb0xheWVyTW9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQVW5kby5wcm90b3R5cGUpO1xuICAgIENQVW5kb0xheWVyTW9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFVuZG9MYXllck1vZGU7XG5cbiAgICBDUFVuZG9MYXllck1vZGUucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5nZXRMYXllcih0aGlzLmxheWVySW5kZXgpLnNldEJsZW5kTW9kZSh0aGlzLmZyb20pO1xuICAgICAgICBcbiAgICAgICAgaW52YWxpZGF0ZUZ1c2lvbigpO1xuICAgICAgICBjYWxsTGlzdGVuZXJzTGF5ZXJDaGFuZ2UoKTtcbiAgICB9O1xuXG4gICAgQ1BVbmRvTGF5ZXJNb2RlLnByb3RvdHlwZS5yZWRvID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZ2V0TGF5ZXIodGhpcy5sYXllckluZGV4KS5zZXRCbGVuZE1vZGUodGhpcy50byk7XG4gICAgICAgIFxuICAgICAgICBpbnZhbGlkYXRlRnVzaW9uKCk7XG4gICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSgpO1xuICAgIH07XG5cbiAgICBDUFVuZG9MYXllck1vZGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24odSkge1xuICAgICAgICBpZiAodSBpbnN0YW5jZW9mIENQVW5kb0xheWVyTW9kZSAmJiB0aGlzLmxheWVySW5kZXggPT0gdS5sYXllckluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLnRvID0gdS50bztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuXG4gICAgQ1BVbmRvTGF5ZXJNb2RlLnByb3RvdHlwZS5ub0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tID09IHRoaXMudG87XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ1BVbmRvTGF5ZXJSZW5hbWUobGF5ZXJJbmRleCwgdG8pIHtcbiAgICAgICAgdGhpcy5sYXllckluZGV4ID0gbGF5ZXJJbmRleDtcbiAgICAgICAgdGhpcy50byA9IHRvO1xuICAgICAgICB0aGlzLmZyb20gPSB0aGF0LmdldExheWVyKGxheWVySW5kZXgpLm5hbWU7XG4gICAgfVxuICAgIFxuICAgIENQVW5kb0xheWVyUmVuYW1lLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BVbmRvLnByb3RvdHlwZSk7XG4gICAgQ1BVbmRvTGF5ZXJSZW5hbWUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BVbmRvTGF5ZXJSZW5hbWU7XG4gICAgXG4gICAgQ1BVbmRvTGF5ZXJSZW5hbWUucHJvdG90eXBlLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5nZXRMYXllcih0aGlzLmxheWVySW5kZXgpLm5hbWUgPSB0aGlzLmZyb207XG4gICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSh0aGlzLmxheWVySW5kZXgpO1xuICAgIH07XG5cbiAgICBDUFVuZG9MYXllclJlbmFtZS5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LmdldExheWVyKHRoaXMubGF5ZXJJbmRleCkubmFtZSA9IHRoaXMudG87XG4gICAgICAgIGNhbGxMaXN0ZW5lcnNMYXllckNoYW5nZSh0aGlzLmxheWVySW5kZXgpO1xuICAgIH07XG5cbiAgICBDUFVuZG9MYXllclJlbmFtZS5wcm90b3R5cGUubWVyZ2UgPSBmdW5jdGlvbih1KSB7XG4gICAgICAgIGlmICh1IGluc3RhbmNlb2YgQ1BVbmRvTGF5ZXJSZW5hbWUgJiYgdGhpcy5sYXllckluZGV4ID09IHUubGF5ZXJJbmRleCkge1xuICAgICAgICAgICAgdGhpcy50byA9IHUudG87XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfTtcblxuICAgIENQVW5kb0xheWVyUmVuYW1lLnByb3RvdHlwZS5ub0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tID09IHRoaXMudG87XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZnJvbSBDUFJlY3RcbiAgICAgKiBAcGFyYW0gdG8gQ1BSZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gQ1BVbmRvUmVjdGFuZ2xlU2VsZWN0aW9uKGZyb20sIHRvKSB7XG4gICAgICAgIGZyb20gPSBmcm9tLmNsb25lKCk7XG4gICAgICAgIHRvID0gdG8uY2xvbmUoKTtcblxuICAgICAgICB0aGlzLnVuZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0aW9uKGZyb20pO1xuICAgICAgICAgICAgY2FsbExpc3RlbmVyc1VwZGF0ZVJlZ2lvbih0aGF0LmdldEJvdW5kcygpKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0aW9uKHRvKTtcbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNVcGRhdGVSZWdpb24odGhhdC5nZXRCb3VuZHMoKSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5ub0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb20uZXF1YWxzKHRvKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgQ1BVbmRvUmVjdGFuZ2xlU2VsZWN0aW9uLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BVbmRvLnByb3RvdHlwZSk7XG4gICAgQ1BVbmRvUmVjdGFuZ2xlU2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQVW5kb1JlY3RhbmdsZVNlbGVjdGlvbjtcblxuICAgIC8qKlxuICAgICAqIFVwb24gY3JlYXRpb24sIHRyYW5zZm9ybXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCByZWdpb24gb2YgdGhlIGN1cnJlbnQgbGF5ZXIgYnkgdGhlIGdpdmVuIGFmZmluZSB0cmFuc2Zvcm0uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0NQUmVjdH0gc3JjUmVjdCAtIFJlY3RhbmdsZSB0byB0cmFuc2Zvcm1cbiAgICAgKiBAcGFyYW0ge0NQVHJhbnNmb3JtfSBhZmZpbmVUcmFuc2Zvcm0gLSBUcmFuc2Zvcm0gdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaW50ZXJwb2xhdGlvbiAtIFwic21vb3RoXCIgb3IgXCJzaGFycFwiXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ1BBY3Rpb25UcmFuc2Zvcm1TZWxlY3Rpb24oc3JjUmVjdCwgYWZmaW5lVHJhbnNmb3JtLCBpbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgZnJvbVNlbGVjdGlvbiA9IHRoYXQuZ2V0U2VsZWN0aW9uKCksXG4gICAgICAgICAgICBkc3RSZWN0ID0gbnVsbCxcblxuICAgICAgICAgICAgdGVtcENhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgICAgICB0ZW1wQ2FudmFzQ29udGV4dCA9IHRlbXBDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLFxuXG4gICAgICAgICAgICB1bmRvRGF0YSwgLy8gQSBjb3B5IG9mIHRoZSBvcmlnaW5hbCBsYXllciB3aXRoaW4gdGhlIHVuZG9EYXRhUmVjdFxuICAgICAgICAgICAgdW5kb0RhdGFSZWN0LFxuXG4gICAgICAgICAgICAvLyBBIGNhbnZhcyBmb3IgY29tcG9zaW5nIHRoZSB0cmFuc2Zvcm0gb250b1xuICAgICAgICAgICAgZnVsbFVuZG9DYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICAgICAgZnVsbFVuZG9DYW52YXNDb250ZXh0ID0gZnVsbFVuZG9DYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgICAgIGFmZmluZVRyYW5zZm9ybSA9IGFmZmluZVRyYW5zZm9ybS5jbG9uZSgpO1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0gaW50ZXJwb2xhdGlvbiB8fCBcInNtb290aFwiO1xuXG4gICAgICAgIHRoaXMudW5kbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0aGF0LmdldExheWVyKHRoaXMubGF5ZXJJbmRleCksXG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZVJlZ2lvbiA9IGRzdFJlY3QuY2xvbmUoKSxcbiAgICAgICAgICAgICAgICB1bmRvU3JjUmVnaW9uO1xuXG4gICAgICAgICAgICBpbnZhbGlkYXRlUmVnaW9uLnVuaW9uKHNyY1JlY3QpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB1bmRvU3JjUmVnaW9uID0gaW52YWxpZGF0ZVJlZ2lvbi5jbG9uZSgpO1xuICAgICAgICAgICAgdW5kb1NyY1JlZ2lvbi50cmFuc2xhdGUoLXVuZG9EYXRhUmVjdC5sZWZ0LCAtdW5kb0RhdGFSZWN0LnRvcCk7XG5cbiAgICAgICAgICAgIGxheWVyLmNvcHlCaXRtYXBSZWN0KHVuZG9EYXRhLCBpbnZhbGlkYXRlUmVnaW9uLmxlZnQsIGludmFsaWRhdGVSZWdpb24udG9wLCB1bmRvU3JjUmVnaW9uKTtcblxuICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3Rpb24oZnJvbVNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGF0LnNldEFjdGl2ZUxheWVySW5kZXgodGhpcy5sYXllckluZGV4KTtcblxuICAgICAgICAgICAgaW52YWxpZGF0ZUZ1c2lvblJlY3QoaW52YWxpZGF0ZVJlZ2lvbik7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBSZXF1aXJlZCBiZWNhdXNlIGluIHRoZSBjYXNlIG9mIGEgY29weSwgd2UgZG9uJ3QgaW52YWxpZGF0ZSB0aGUgc291cmNlIHJlY3QgaW4gdGhlIGZ1c2lvbiwgc28gdGhlIGNhbnZhc1xuICAgICAgICAgICAgICogd29uJ3QgZW5kIHVwIHJlcGFpbnRpbmcgdGhlIHNlbGVjdGlvbiByZWN0YW5nbGUgdGhlcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNTZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGxheWVyID0gdGhhdC5nZXRMYXllcih0aGlzLmxheWVySW5kZXgpO1xuXG4gICAgICAgICAgICAvLyBNYWtlIGEgZnJlc2ggY29weSBvZiB0aGUgbGF5ZXIgaW50byBhIENhbnZhcyB0byBjb21wb3NlIG9udG9cbiAgICAgICAgICAgIGZ1bGxVbmRvQ2FudmFzQ29udGV4dC5wdXRJbWFnZURhdGEobGF5ZXIuZ2V0SW1hZ2VEYXRhKCksIDAsIDApO1xuXG4gICAgICAgICAgICAvLyBFcmFzZSB0aGUgcmVnaW9uIHdlIG1vdmVkIGZyb21cbiAgICAgICAgICAgIGZ1bGxVbmRvQ2FudmFzQ29udGV4dC5jbGVhclJlY3Qoc3JjUmVjdC5sZWZ0LCBzcmNSZWN0LnRvcCwgc3JjUmVjdC5nZXRXaWR0aCgpLCBzcmNSZWN0LmdldEhlaWdodCgpKTtcblxuICAgICAgICAgICAgc2V0Q2FudmFzSW50ZXJwb2xhdGlvbihmdWxsVW5kb0NhbnZhc0NvbnRleHQsIGludGVycG9sYXRpb24gPT0gXCJzbW9vdGhcIik7XG5cbiAgICAgICAgICAgIGZ1bGxVbmRvQ2FudmFzQ29udGV4dC5zYXZlKCk7XG5cbiAgICAgICAgICAgIC8vIEFwcGx5IHRoZSB0cmFuc2Zvcm0gd2hlbiBkcmF3aW5nIHRoZSB0cmFuc2Zvcm1lZCBmcmFnbWVudFxuICAgICAgICAgICAgZnVsbFVuZG9DYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybShcbiAgICAgICAgICAgICAgICBhZmZpbmVUcmFuc2Zvcm0ubVswXSwgYWZmaW5lVHJhbnNmb3JtLm1bMV0sIGFmZmluZVRyYW5zZm9ybS5tWzJdLFxuICAgICAgICAgICAgICAgIGFmZmluZVRyYW5zZm9ybS5tWzNdLCBhZmZpbmVUcmFuc2Zvcm0ubVs0XSwgYWZmaW5lVHJhbnNmb3JtLm1bNV1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBmdWxsVW5kb0NhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHRlbXBDYW52YXMsIHNyY1JlY3QubGVmdCwgc3JjUmVjdC50b3ApO1xuXG4gICAgICAgICAgICBmdWxsVW5kb0NhbnZhc0NvbnRleHQucmVzdG9yZSgpO1xuXG4gICAgICAgICAgICAvLyBDb3B5IGJhY2sgdG8gdGhlIGxheWVyIGRhdGFcbiAgICAgICAgICAgIGxheWVyLnNldEltYWdlRGF0YShmdWxsVW5kb0NhbnZhc0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIGxheWVyLndpZHRoLCBsYXllci5oZWlnaHQpKTtcblxuICAgICAgICAgICAgLy8gSW52YWxpZGF0ZSB0aGUgc291cmNlIGFuZCBkZXN0aW5hdGlvbiByZWdpb25zIHdlIHRvdWNoZWRcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGludmFsaWRhdGVSZWdpb24gPSBzcmNSZWN0LmNsb25lKCksXG4gICAgICAgICAgICAgICAgZHN0Q29ybmVycyA9IHNyY1JlY3QudG9Qb2ludHMoKTtcblxuICAgICAgICAgICAgYWZmaW5lVHJhbnNmb3JtLnRyYW5zZm9ybVBvaW50cyhkc3RDb3JuZXJzKTtcblxuICAgICAgICAgICAgZHN0UmVjdCA9IENQUmVjdC5jcmVhdGVCb3VuZGluZ0JveChkc3RDb3JuZXJzKTtcbiAgICAgICAgICAgIGRzdFJlY3Qucm91bmRDb250YWluKCk7XG4gICAgICAgICAgICBsYXllci5nZXRCb3VuZHMoKS5jbGlwKGRzdFJlY3QpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpbnZhbGlkYXRlUmVnaW9uLnVuaW9uKGRzdFJlY3QpO1xuXG4gICAgICAgICAgICBpbnZhbGlkYXRlRnVzaW9uUmVjdChpbnZhbGlkYXRlUmVnaW9uKTtcblxuICAgICAgICAgICAgLy8gVHJhbnNmb3JtIHRoZSBzZWxlY3Rpb24gcmVjdCB0byBlbmNsb3NlIHRoZSB0cmFuc2Zvcm1lZCBzZWxlY3Rpb25cbiAgICAgICAgICAgIGlmICghZnJvbVNlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgdG9TZWxlY3Rpb25Qb2ludHMgPSBmcm9tU2VsZWN0aW9uLnRvUG9pbnRzKCksXG4gICAgICAgICAgICAgICAgICAgIHRvU2VsZWN0aW9uUmVjdDtcblxuICAgICAgICAgICAgICAgIGFmZmluZVRyYW5zZm9ybS50cmFuc2Zvcm1Qb2ludHModG9TZWxlY3Rpb25Qb2ludHMpO1xuXG4gICAgICAgICAgICAgICAgdG9TZWxlY3Rpb25SZWN0ID0gQ1BSZWN0LmNyZWF0ZUJvdW5kaW5nQm94KHRvU2VsZWN0aW9uUG9pbnRzKTtcbiAgICAgICAgICAgICAgICB0b1NlbGVjdGlvblJlY3Qucm91bmROZWFyZXN0KCk7XG4gICAgICAgICAgICAgICAgbGF5ZXIuZ2V0Qm91bmRzKCkuY2xpcCh0b1NlbGVjdGlvblJlY3QpO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3Rpb24odG9TZWxlY3Rpb25SZWN0KTtcbiAgICAgICAgICAgICAgICBjYWxsTGlzdGVuZXJzU2VsZWN0aW9uQ2hhbmdlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGxhY2UgdGhlIHRyYW5zZm9ybSB3aXRoIHRoZSBnaXZlbiBvbmUuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Q1BUcmFuc2Zvcm19IF9hZmZpbmVUcmFuc2Zvcm1cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuYW1lbmQgPSBmdW5jdGlvbihfYWZmaW5lVHJhbnNmb3JtKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBsYXllciA9IHRoYXQuZ2V0TGF5ZXIodGhpcy5sYXllckluZGV4KTtcblxuICAgICAgICAgICAgdGhpcy51bmRvKCk7XG5cbiAgICAgICAgICAgIGlmICh1bmRvRGF0YVJlY3QuZ2V0V2lkdGgoKSA8IGxheWVyLndpZHRoIHx8IHVuZG9EYXRhUmVjdC5nZXRIZWlnaHQoKSA8IGxheWVyLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogV2UgbmVlZCBhIGNvbXBsZXRlIGNvcHkgb2YgdGhlIGxheWVyIGluIHVuZG9EYXRhIHRvIHN1cHBvcnQgZnVydGhlciByZWRvKCkuIChBcyB3ZSBwcm9iYWJseSBwcmV2aW91c2x5XG4gICAgICAgICAgICAgICAgICogb25seSBtYWRlIGEgYmFja3VwIGNvcHkgb2YgdGhlIGFyZWFzIHdlIGVyYXNlZCB1c2luZyB0aGUgb2xkIHRyYW5zZm9ybSkuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgdW5kb0RhdGEgPSBsYXllci5jbG9uZSgpO1xuICAgICAgICAgICAgICAgIHVuZG9EYXRhUmVjdCA9IGxheWVyLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhZmZpbmVUcmFuc2Zvcm0gPSBfYWZmaW5lVHJhbnNmb3JtLmNsb25lKCk7XG4gICAgICAgICAgICB0aGlzLnJlZG8oKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldEludGVycG9sYXRpb24gPSBmdW5jdGlvbihuZXdJbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICBpZiAobmV3SW50ZXJwb2xhdGlvbiAhPSBpbnRlcnBvbGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJwb2xhdGlvbiA9IG5ld0ludGVycG9sYXRpb247XG5cbiAgICAgICAgICAgICAgICB0aGlzLnVuZG8oKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZG8oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gd2UncmUgbm8gbG9uZ2VyIHRoZSB0b3Agb3BlcmF0aW9uIGluIHRoZSB1bmRvIHN0YWNrLCBzbyB0aGF0IHdlIGNhbiBvcHRpbWl6ZSBmb3IgbG93ZXIgbWVtb3J5XG4gICAgICAgICAqIHVzYWdlIGluc3RlYWQgb2YgZmFzdGVyIHJldmlzaW9uIHNwZWVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGxheWVyID0gdGhhdC5nZXRMYXllcih0aGlzLmxheWVySW5kZXgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgZnVsbCB1bmRvLCBhbmQgd2UgZG9uJ3QgbmVlZCB2ZXJ5IG11Y2ggYXJlYSBmb3IgdW5kbywgdHJpbSBpdCB0byBqdXN0IHRoZSBhcmVhIHdlIG5lZWRcbiAgICAgICAgICAgIGlmICh1bmRvRGF0YVJlY3QuZ2V0V2lkdGgoKSA9PSBsYXllci53aWR0aCAmJiB1bmRvRGF0YVJlY3QuZ2V0SGVpZ2h0KCkgPT0gbGF5ZXIuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGRpcnR5UmVjdCA9IHNyY1JlY3QuZ2V0VW5pb24oZHN0UmVjdCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZGlydHlSZWN0LmdldEFyZWEoKSAqIDIgPCBsYXllci53aWR0aCAqIGxheWVyLmhlaWdodCkge1xuICAgICAgICAgICAgICAgICAgICB1bmRvRGF0YVJlY3QgPSBkaXJ0eVJlY3Q7XG4gICAgICAgICAgICAgICAgICAgIHVuZG9EYXRhID0gdW5kb0RhdGEuY2xvbmVSZWN0KHVuZG9EYXRhUmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0TWVtb3J5VXNlZCA9IGZ1bmN0aW9uKHVuZG9uZSwgcGFyYW0pIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRvRGF0YS5nZXRNZW1vcnlTaXplKCk7XG4gICAgICAgIH07XG5cblx0ICAgIC8qKlxuICAgICAgICAgKiBHZXQgYSBjb3B5IG9mIHRoZSBhZmZpbmUgdHJhbnNmb3JtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRUcmFuc2Zvcm0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBhZmZpbmVUcmFuc2Zvcm0uY2xvbmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgY29weSBvZiB0aGUgaW5pdGlhbCBkb2N1bWVudCByZWN0YW5nbGUgKGJlZm9yZSB0aGUgdHJhbnNmb3JtIHdhcyBhcHBsaWVkKVxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7Q1BSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRJbml0aWFsVHJhbnNmb3JtUmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHNyY1JlY3QuY2xvbmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IGEgY29weSBvZiB0aGUgaW5pdGlhbCB1c2VyIHNlbGVjdGlvbiByZWN0YW5nbGUgKGJlZm9yZSB0aGUgdHJhbnNmb3JtIHdhcyBhcHBsaWVkKS4gQ2FuIGJlIGVtcHR5IGlmXG4gICAgICAgICAqIHRoZSB1c2VyIGRpZG4ndCBoYXZlIGFueXRoaW5nIHNlbGVjdGVkIGJlZm9yZSB0aGUgdHJhbnNmb3JtIGJlZ2FuLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7Q1BSZWN0fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5nZXRJbml0aWFsU2VsZWN0aW9uUmVjdCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZyb21TZWxlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmxheWVySW5kZXggPSB0aGF0LmdldEFjdGl2ZUxheWVySW5kZXgoKTtcblxuICAgICAgICBsZXRcbiAgICAgICAgICAgIGxheWVyID0gdGhhdC5nZXRMYXllcih0aGlzLmxheWVySW5kZXgpO1xuXG4gICAgICAgIHVuZG9EYXRhID0gbGF5ZXIuY2xvbmUoKTtcbiAgICAgICAgdW5kb0RhdGFSZWN0ID0gbGF5ZXIuZ2V0Qm91bmRzKCk7XG4gICAgICAgIGZ1bGxVbmRvQ2FudmFzLndpZHRoID0gbGF5ZXIud2lkdGg7XG4gICAgICAgIGZ1bGxVbmRvQ2FudmFzLmhlaWdodCA9IGxheWVyLmhlaWdodDtcblxuICAgICAgICAvLyBNYWtlIGEgY29weSBvZiBqdXN0IHRoZSBzb3VyY2UgcmVjdGFuZ2xlIGluIGl0cyBvd24gY2FudmFzIHNvIHdlIGhhdmUgaXQgYXMgYW4gaW1hZ2UgdG8gYmUgZHJhd24gbGF0ZXJcbiAgICAgICAgdGVtcENhbnZhcy53aWR0aCA9IHNyY1JlY3QuZ2V0V2lkdGgoKTtcbiAgICAgICAgdGVtcENhbnZhcy5oZWlnaHQgPSBzcmNSZWN0LmdldEhlaWdodCgpO1xuICAgICAgICB0ZW1wQ2FudmFzQ29udGV4dC5wdXRJbWFnZURhdGEodW5kb0RhdGEuZ2V0SW1hZ2VEYXRhKCksIC1zcmNSZWN0LmxlZnQsIC1zcmNSZWN0LnRvcCwgc3JjUmVjdC5sZWZ0LCBzcmNSZWN0LnRvcCwgc3JjUmVjdC5nZXRXaWR0aCgpLCBzcmNSZWN0LmdldEhlaWdodCgpKTtcblxuICAgICAgICB0aGlzLnJlZG8oKTtcbiAgICB9XG5cbiAgICBDUEFjdGlvblRyYW5zZm9ybVNlbGVjdGlvbi5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQVW5kby5wcm90b3R5cGUpO1xuICAgIENQQWN0aW9uVHJhbnNmb3JtU2VsZWN0aW9uLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQQWN0aW9uVHJhbnNmb3JtU2VsZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVXBvbiBjcmVhdGlvbiwgbW92ZXMgdGhlIGN1cnJlbnRseSBzZWxlY3RlZCByZWdpb24gb2YgdGhlIGN1cnJlbnQgbGF5ZXIgYnkgdGhlIGdpdmVuIG9mZnNldCAob3IgY29waWVzIGl0IGlmXG4gICAgICogJ2NvcHknIGlzIHRydWUpLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNyY1JlY3RcbiAgICAgKiBAcGFyYW0gb2Zmc2V0WFxuICAgICAqIEBwYXJhbSBvZmZzZXRZXG4gICAgICogQHBhcmFtIGNvcHlcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDUEFjdGlvbk1vdmVTZWxlY3Rpb24oc3JjUmVjdCwgb2Zmc2V0WCwgb2Zmc2V0WSwgY29weSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGZyb21TZWxlY3Rpb24gPSB0aGF0LmdldFNlbGVjdGlvbigpLFxuICAgICAgICAgICAgZHN0UmVjdCA9IG51bGwsXG5cbiAgICAgICAgICAgIGZ1bGxVbmRvLCAvLyBBIGNvcHkgb2YgdGhlIGVudGlyZSBsYXllclxuICAgICAgICAgICAgc3JjRGF0YSA9IG51bGwsIC8vIEEgY29weSBvZiB0aGUgb3JpZ2luYWwgcGl4ZWxzIGF0IHRoZSBzcmNSZWN0LCBvciBudWxsIGlmIHdlIHVzZSBhIGZ1bGxVbmRvIGluc3RlYWRcbiAgICAgICAgICAgIGRzdERhdGEgPSBudWxsIC8vIEEgY29weSBvZiB0aGUgb3JpZ2luYWwgcGl4ZWxzIGF0IHRoZSBkc3RSZWN0LCBvciBudWxsXG4gICAgICAgIDtcbiAgICAgICAgXG4gICAgICAgIHRoaXMudW5kbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0aGF0LmdldExheWVyKHRoaXMubGF5ZXJJbmRleCksXG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZVJlZ2lvbiA9IGRzdFJlY3QuY2xvbmUoKTtcblxuICAgICAgICAgICAgaWYgKCFjb3B5KSB7XG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZVJlZ2lvbi51bmlvbihzcmNSZWN0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGZ1bGxVbmRvKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXIuY29weUJpdG1hcFJlY3QoZnVsbFVuZG8sIGludmFsaWRhdGVSZWdpb24ubGVmdCwgaW52YWxpZGF0ZVJlZ2lvbi50b3AsIGludmFsaWRhdGVSZWdpb24pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBsYXllci5jb3B5Qml0bWFwUmVjdChzcmNEYXRhLCBzcmNSZWN0LmxlZnQsIHNyY1JlY3QudG9wLCBzcmNEYXRhLmdldEJvdW5kcygpKTtcblxuICAgICAgICAgICAgICAgIGlmIChkc3REYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyLmNvcHlCaXRtYXBSZWN0KGRzdERhdGEsIGRzdFJlY3QubGVmdCwgZHN0UmVjdC50b3AsIGRzdERhdGEuZ2V0Qm91bmRzKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3Rpb24oZnJvbVNlbGVjdGlvbik7XG4gICAgICAgICAgICB0aGF0LnNldEFjdGl2ZUxheWVySW5kZXgodGhpcy5sYXllckluZGV4KTtcblxuICAgICAgICAgICAgaW52YWxpZGF0ZUZ1c2lvblJlY3QoaW52YWxpZGF0ZVJlZ2lvbik7XG5cbiAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgKiBSZXF1aXJlZCBiZWNhdXNlIGluIHRoZSBjYXNlIG9mIGEgY29weSwgd2UgZG9uJ3QgaW52YWxpZGF0ZSB0aGUgc291cmNlIHJlY3QgaW4gdGhlIGZ1c2lvbiwgc28gdGhlIGNhbnZhc1xuICAgICAgICAgICAgICogd29uJ3QgZW5kIHVwIHJlcGFpbnRpbmcgdGhlIHNlbGVjdGlvbiByZWN0YW5nbGUgdGhlcmUuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNTZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGxheWVyID0gdGhhdC5nZXRMYXllcih0aGlzLmxheWVySW5kZXgpLFxuICAgICAgICAgICAgICAgIGludmFsaWRhdGVSZWdpb24gPSBuZXcgQ1BSZWN0KDAsIDAsIDAsIDApO1xuXG4gICAgICAgICAgICBpZiAoIWNvcHkpIHtcbiAgICAgICAgICAgICAgICBsYXllci5jbGVhclJlY3Qoc3JjUmVjdCwgMCk7XG4gICAgICAgICAgICAgICAgaW52YWxpZGF0ZVJlZ2lvbi5zZXQoc3JjUmVjdCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRzdFJlY3QgPSBzcmNSZWN0LmNsb25lKCk7XG4gICAgICAgICAgICBkc3RSZWN0LnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgICAgIGxheWVyLmdldEJvdW5kcygpLmNsaXAoZHN0UmVjdCk7XG5cbiAgICAgICAgICAgIC8qIE5vdGUgdGhhdCB3aGlsZSB3ZSBjb3VsZCBjb3B5IGltYWdlIGRhdGEgZnJvbSB0aGUgbGF5ZXIgaXRzZWxmIG9udG8gdGhlIGxheWVyIChpbnN0ZWFkIG9mIHNvdXJjaW5nIHRoYXRcbiAgICAgICAgICAgICAqIGRhdGEgZnJvbSB0aGUgdW5kbyBidWZmZXJzKSwgdGhpcyB3b3VsZCByZXF1aXJlIHRoYXQgcGFzdGVBbHBoYVJlY3QgZG8gdGhlIHJpZ2h0IHRoaW5nIHdoZW4gc291cmNlIGFuZFxuICAgICAgICAgICAgICogZGVzdCByZWN0cyBvdmVybGFwLCB3aGljaCBpdCBkb2Vzbid0LlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBpZiAoZnVsbFVuZG8pIHtcbiAgICAgICAgICAgICAgICBsYXllci5wYXN0ZUFscGhhUmVjdChmdWxsVW5kbywgc3JjUmVjdCwgZHN0UmVjdC5sZWZ0LCBkc3RSZWN0LnRvcCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxheWVyLnBhc3RlQWxwaGFSZWN0KHNyY0RhdGEsIHNyY0RhdGEuZ2V0Qm91bmRzKCksIGRzdFJlY3QubGVmdCwgZHN0UmVjdC50b3ApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpbnZhbGlkYXRlUmVnaW9uLnVuaW9uKGRzdFJlY3QpO1xuXG4gICAgICAgICAgICBpbnZhbGlkYXRlRnVzaW9uUmVjdChpbnZhbGlkYXRlUmVnaW9uKTtcblxuICAgICAgICAgICAgaWYgKCFmcm9tU2VsZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICB0b1NlbGVjdGlvbiA9IGZyb21TZWxlY3Rpb24uY2xvbmUoKTtcbiAgICAgICAgICAgICAgICB0b1NlbGVjdGlvbi50cmFuc2xhdGUob2Zmc2V0WCwgb2Zmc2V0WSk7XG4gICAgICAgICAgICAgICAgdGhhdC5zZXRTZWxlY3Rpb24odG9TZWxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIGNhbGxMaXN0ZW5lcnNTZWxlY3Rpb25DaGFuZ2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogTW92ZSBmdXJ0aGVyIGJ5IHRoZSBnaXZlbiBvZmZzZXQgb24gdG9wIG9mIHRoZSBjdXJyZW50IG9mZnNldC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIF9vZmZzZXRYIHtpbnR9XG4gICAgICAgICAqIEBwYXJhbSBfb2Zmc2V0WSB7aW50fVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hbWVuZCA9IGZ1bmN0aW9uKF9vZmZzZXRYLCBfb2Zmc2V0WSkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSB0aGF0LmdldExheWVyKHRoaXMubGF5ZXJJbmRleCk7XG5cbiAgICAgICAgICAgIGlmIChmdWxsVW5kbykge1xuICAgICAgICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW5kbygpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIFdlIGRvbid0IG5lZWQgdG8gcmVzdG9yZSB0aGUgaW1hZ2UgYXQgdGhlICpzb3VyY2UqIGxvY2F0aW9uIGFzIGEgZnVsbCB1bmRvIHdvdWxkIGRvLCBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAgKiB3ZSdsbCBvbmx5IGVyYXNlIHRoYXQgYXJlYSBhZ2FpbiBvbmNlIHdlIHJlZG8oKS4gU28ganVzdCByZXN0b3JlIHRoZSBkYXRhIGF0IHRoZSBkZXN0LlxuICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgbGF5ZXIuY29weUJpdG1hcFJlY3QoZnVsbFVuZG8sIGRzdFJlY3QubGVmdCwgZHN0UmVjdC50b3AsIGRzdFJlY3QpO1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlRnVzaW9uUmVjdChkc3RSZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICogV2Ugd2FudCB0byBtYWtlIGEgY29tcGxldGUgY29weSBvZiB0aGUgbGF5ZXIgaW4gZnVsbFVuZG8gdG8gc3VwcG9ydCBmYXN0IGZ1cnRoZXIgYW1lbmQoKSBjYWxscy5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICB0aGlzLnVuZG8oKTtcblxuICAgICAgICAgICAgICAgIGZ1bGxVbmRvID0gbGF5ZXIuY2xvbmUoKTtcbiAgICAgICAgICAgICAgICBzcmNEYXRhID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkc3REYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgb2Zmc2V0WCArPSBfb2Zmc2V0WDtcbiAgICAgICAgICAgIG9mZnNldFkgKz0gX29mZnNldFk7XG4gICAgICAgICAgICB0aGlzLnJlZG8oKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIHdoZW4gd2UncmUgbm8gbG9uZ2VyIHRoZSB0b3Agb3BlcmF0aW9uIGluIHRoZSB1bmRvIHN0YWNrLCBzbyB0aGF0IHdlIGNhbiBvcHRpbWl6ZSBmb3IgbG93ZXIgbWVtb3J5XG4gICAgICAgICAqIHVzYWdlIGluc3RlYWQgb2YgZmFzdGVyIHJldmlzaW9uIHNwZWVkXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmNvbXBhY3QgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChmdWxsVW5kbyAmJiBzcmNSZWN0LmdldEFyZWEoKSAqIDIgPCB0aGF0LndpZHRoICogdGhhdC5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBSZXBsYWNlIG91ciBjb3B5IG9mIHRoZSBlbnRpcmUgbGF5ZXIgd2l0aCBqdXN0IGEgY29weSBvZiB0aGUgYXJlYXMgd2UgZGFtYWdlZFxuXG4gICAgICAgICAgICAgICAgc3JjRGF0YSA9IGZ1bGxVbmRvLmNsb25lUmVjdChzcmNSZWN0KTtcblxuICAgICAgICAgICAgICAgIGlmICghY29weSAmJiBkc3RSZWN0LmlzSW5zaWRlKHNyY1JlY3QpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdERhdGEgPSBudWxsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRzdERhdGEgPSBmdWxsVW5kby5jbG9uZVJlY3QoZHN0UmVjdCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgZnVsbFVuZG8gPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZ2V0TWVtb3J5VXNlZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgc2l6ZSA9IDA7XG5cbiAgICAgICAgICAgIGlmIChmdWxsVW5kbykge1xuICAgICAgICAgICAgICAgIHNpemUgKz0gZnVsbFVuZG8uZ2V0TWVtb3J5U2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNyY0RhdGEpIHtcbiAgICAgICAgICAgICAgICBzaXplICs9IHNyY0RhdGEuZ2V0TWVtb3J5U2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRzdERhdGEpIHtcbiAgICAgICAgICAgICAgICBzaXplICs9IGRzdERhdGEuZ2V0TWVtb3J5U2l6ZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gc2l6ZTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmxheWVySW5kZXggPSB0aGF0LmdldEFjdGl2ZUxheWVySW5kZXgoKTtcbiAgICAgICAgZnVsbFVuZG8gPSB0aGF0LmdldExheWVyKHRoaXMubGF5ZXJJbmRleCkuY2xvbmUoKTtcblxuICAgICAgICB0aGlzLnJlZG8oKTtcbiAgICB9XG5cbiAgICBDUEFjdGlvbk1vdmVTZWxlY3Rpb24ucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUFVuZG8ucHJvdG90eXBlKTtcbiAgICBDUEFjdGlvbk1vdmVTZWxlY3Rpb24ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BBY3Rpb25Nb3ZlU2VsZWN0aW9uO1xuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byBlbmNhcHN1bGF0ZSBtdWx0aXBsZSB1bmRvIG9wZXJhdGlvbiBhcyBvbmVcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gdW5kb2VzIENQVW5kb1tdIExpc3Qgb2YgdW5kbyBvcGVyYXRpb25zIHRvIGVuY2Fwc3VsYXRlXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ1BNdWx0aVVuZG8odW5kb2VzKSB7XG4gICAgICAgIHRoaXMudW5kb2VzID0gdW5kb2VzO1xuICAgIH1cblxuICAgIENQTXVsdGlVbmRvLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BVbmRvLnByb3RvdHlwZSk7XG4gICAgQ1BNdWx0aVVuZG8ucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BNdWx0aVVuZG87XG5cbiAgICBDUE11bHRpVW5kby5wcm90b3R5cGUudW5kbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gdGhpcy51bmRvZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHRoaXMudW5kb2VzW2ldLnVuZG8oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICBDUE11bHRpVW5kby5wcm90b3R5cGUucmVkbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudW5kb2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLnVuZG9lc1tpXS5yZWRvKCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ1BNdWx0aVVuZG8ucHJvdG90eXBlLm5vQ2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdW5kb2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIXVuZG9lc1tpXS5ub0NoYW5nZSgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgQ1BNdWx0aVVuZG8ucHJvdG90eXBlLmdldE1lbW9yeVVzZWQgPSBmdW5jdGlvbih1bmRvbmUsIHBhcmFtKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgdG90YWwgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1bmRvZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRvdGFsICs9IHVuZG9lc1tpXS5nZXRNZW1vcnlVc2VkKHVuZG9uZSwgcGFyYW0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBTdG9yZSBkYXRhIHRvIHVuZG8gYSBjdXQgb3BlcmF0aW9uXG4gICAgICogXG4gICAgICogQHBhcmFtIGJtcCBDUENvbG9yQm1wIFRoZSByZWN0YW5nbGUgb2YgaW1hZ2UgZGF0YSB0aGF0IHdhcyBjdXRcbiAgICAgKiBAcGFyYW0gbGF5ZXJJbmRleCBpbnQgSW5kZXggb2YgdGhlIGxheWVyIHRoZSBjdXQgY2FtZSBmcm9tXG4gICAgICogQHBhcmFtIHNlbGVjdGlvbiBDUFJlY3QgVGhlIGN1dCByZWN0YW5nbGUgY28tb3JkaW5hdGVzXG4gICAgICovXG4gICAgZnVuY3Rpb24gQ1BVbmRvQ3V0KGJtcCwgbGF5ZXJJbmRleCwgc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuXG4gICAgICAgIHRoaXMudW5kbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhhdC5zZXRBY3RpdmVMYXllckluZGV4KGxheWVySW5kZXgpO1xuICAgICAgICAgICAgY3VyTGF5ZXIuY29weUJpdG1hcFJlY3QoYm1wLCBzZWxlY3Rpb24ubGVmdCwgc2VsZWN0aW9uLnRvcCwgYm1wLmdldEJvdW5kcygpKTtcbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG4gICAgICAgICAgICBpbnZhbGlkYXRlRnVzaW9uUmVjdChzZWxlY3Rpb24pO1xuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucmVkbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdGhhdC5zZXRBY3RpdmVMYXllckluZGV4KGxheWVySW5kZXgpO1xuICAgICAgICAgICAgY3VyTGF5ZXIuY2xlYXJSZWN0KHNlbGVjdGlvbiwgRU1QVFlfTEFZRVJfQ09MT1IpO1xuICAgICAgICAgICAgdGhhdC5lbXB0eVNlbGVjdGlvbigpO1xuICAgICAgICAgICAgaW52YWxpZGF0ZUZ1c2lvblJlY3Qoc2VsZWN0aW9uKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmdldE1lbW9yeVVzZWQgPSBmdW5jdGlvbih1bmRvbmUsIHBhcmFtKSB7XG4gICAgICAgICAgICByZXR1cm4gYm1wID09IHBhcmFtID8gMCA6IGJtcC53aWR0aCAqIGJtcC5oZWlnaHQgKiBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgQ1BVbmRvQ3V0LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BVbmRvLnByb3RvdHlwZSk7XG4gICAgQ1BVbmRvQ3V0LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQVW5kb0N1dDtcblxuICAgIC8qKlxuICAgICAqIFN0b3JlIGRhdGEgdG8gdW5kbyBhIHBhc3RlIG9wZXJhdGlvblxuICAgICAqIFxuICAgICAqIEBwYXJhbSBjbGlwIENQQ2xpcFxuICAgICAqIEBwYXJhbSBsYXllckluZGV4IGludFxuICAgICAqIEBwYXJhbSBzZWxlY3Rpb24gQ1BSZWN0XG4gICAgICovXG4gICAgZnVuY3Rpb24gQ1BVbmRvUGFzdGUoY2xpcCwgbGF5ZXJJbmRleCwgc2VsZWN0aW9uKSB7XG4gICAgICAgIHNlbGVjdGlvbiA9IHNlbGVjdGlvbi5jbG9uZSgpO1xuXG4gICAgICAgIHRoaXMudW5kbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbGF5ZXJzLnNwbGljZShsYXllckluZGV4ICsgMSwgMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoYXQuc2V0QWN0aXZlTGF5ZXJJbmRleChsYXllckluZGV4KTtcbiAgICAgICAgICAgIHRoYXQuc2V0U2VsZWN0aW9uKHNlbGVjdGlvbik7XG5cbiAgICAgICAgICAgIGludmFsaWRhdGVGdXNpb25SZWN0KHNlbGVjdGlvbik7XG4gICAgICAgICAgICBjYWxsTGlzdGVuZXJzTGF5ZXJDaGFuZ2UoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlZG8gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQuc2V0QWN0aXZlTGF5ZXJJbmRleChsYXllckluZGV4KTtcbiAgICAgICAgICAgIHBhc3RlQ2xpcChmYWxzZSwgY2xpcCk7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5nZXRNZW1vcnlVc2VkID0gZnVuY3Rpb24odW5kb25lLCBwYXJhbSkge1xuICAgICAgICAgICAgcmV0dXJuIGNsaXAuYm1wID09IHBhcmFtID8gMCA6IGNsaXAuYm1wLndpZHRoICogY2xpcC5ibXAuaGVpZ2h0ICogNDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgQ1BVbmRvUGFzdGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUFVuZG8ucHJvdG90eXBlKTtcbiAgICBDUFVuZG9QYXN0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFVuZG9QYXN0ZTtcbn07XG5cbkNQQXJ0d29yay5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuQ1BBcnR3b3JrLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQQXJ0d29yaztcblxuQ1BBcnR3b3JrLnByb3RvdHlwZS5nZXRCb3VuZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IENQUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG59XG5cbkNQQXJ0d29yay5wcm90b3R5cGUuaXNQb2ludFdpdGhpbiA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA+PSAwICYmIHkgPj0gMCAmJiB4IDwgdGhpcy53aWR0aCAmJiB5IDwgdGhpcy5oZWlnaHQ7XG59OyIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ1BSZWN0IGZyb20gXCIuLi91dGlsL0NQUmVjdFwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUEJpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gV2lkdGggYW5kIGhlaWdodCBmb3JjZWQgdG8gaW50ZWdlcnNcbiAgICB0aGlzLndpZHRoID0gd2lkdGggfCAwO1xuICAgIHRoaXMuaGVpZ2h0ID0gaGVpZ2h0IHwgMDtcbn1cblxuQ1BCaXRtYXAucHJvdG90eXBlLmdldEJvdW5kcyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgQ1BSZWN0KDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbn07XG5cbkNQQml0bWFwLnByb3RvdHlwZS5pc0luc2lkZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICByZXR1cm4geCA+PSAwICYmIHkgPj0gMCAmJiB4IDwgdGhpcy53aWR0aCAmJiB5IDwgdGhpcy5oZWlnaHQ7XG59OyIsIi8vIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQsIHBsZWFzZSBzZWUgY29kZWdlbmVyYXRvci9CbGVuZEdlbmVyYXRvci5qcyFcblxuICAgIGV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQmxlbmQoKSB7XG4gICAgfVxuICAgIFxuICAgIGNvbnN0XG4gICAgICAgIEJZVEVTX1BFUl9QSVhFTCA9IDQsXG4gICAgICAgIEFMUEhBX0JZVEVfT0ZGU0VUID0gMyxcbiAgICAgICAgXG4gICAgICAgIEJMRU5EX01PREVfTkFNRVMgPSBbXG4gICAgICAgICAgICBcIm5vcm1hbFwiLFxuICAgICAgICAgICAgXCJtdWx0aXBseVwiLFxuICAgICAgICAgICAgXCJhZGRcIixcbiAgICAgICAgICAgIFwic2NyZWVuXCIsXG4gICAgICAgICAgICBcImxpZ2h0ZW5cIixcbiAgICAgICAgICAgIFwiZGFya2VuXCIsXG4gICAgICAgICAgICBcInN1YnRyYWN0XCIsXG4gICAgICAgICAgICBcImRvZGdlXCIsXG4gICAgICAgICAgICBcImJ1cm5cIixcbiAgICAgICAgICAgIFwib3ZlcmxheVwiLFxuICAgICAgICAgICAgXCJoYXJkTGlnaHRcIixcbiAgICAgICAgICAgIFwic29mdExpZ2h0XCIsXG4gICAgICAgICAgICBcInZpdmlkTGlnaHRcIixcbiAgICAgICAgICAgIFwibGluZWFyTGlnaHRcIixcbiAgICAgICAgICAgIFwicGluTGlnaHRcIlxuICAgICAgICBdLFxuICAgICAgICBcbiAgICAgICAgc29mdExpZ2h0TFVUU3F1YXJlID0gbmV3IEFycmF5KDI1NiksXG4gICAgICAgIHNvZnRMaWdodExVVFNxdWFyZVJvb3QgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICBcbiAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIG11bHRpcGx5IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQubXVsdGlwbHlPbnRvT3BhcXVlRnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoY29sb3IyIC0gKGxheWVyLmRhdGFbcGl4SW5kZXhdIF4gMHhGRikgKiBjb2xvcjIgKiBhbHBoYTEgLyAoMjU1ICogMjU1KSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoY29sb3IyIC0gKGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXSBeIDB4RkYpICogY29sb3IyICogYWxwaGExIC8gKDI1NSAqIDI1NSkpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKGNvbG9yMiAtIChsYXllci5kYXRhW3BpeEluZGV4ICsgMl0gXiAweEZGKSAqIGNvbG9yMiAqIGFscGhhMSAvICgyNTUgKiAyNTUpKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgbXVsdGlwbHkgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQubXVsdGlwbHlPbnRvT3BhcXVlRnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoY29sb3IyIC0gKGxheWVyLmRhdGFbcGl4SW5kZXhdIF4gMHhGRikgKiBjb2xvcjIgKiBhbHBoYTEgLyAoMjU1ICogMjU1KSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoY29sb3IyIC0gKGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXSBeIDB4RkYpICogY29sb3IyICogYWxwaGExIC8gKDI1NSAqIDI1NSkpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKGNvbG9yMiAtIChsYXllci5kYXRhW3BpeEluZGV4ICsgMl0gXiAweEZGKSAqIGNvbG9yMiAqIGFscGhhMSAvICgyNTUgKiAyNTUpKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgbXVsdGlwbHkgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5tdWx0aXBseU9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweEZGKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhGRikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKChjb2xvcjEgKiBhbHBoYTFuMiArIGNvbG9yMiAqIGFscGhhbjEyICsgY29sb3IxICogY29sb3IyICogYWxwaGExMiAvIDI1NSkgLyBuZXdBbHBoYSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKChjb2xvcjEgKiBhbHBoYTFuMiArIGNvbG9yMiAqIGFscGhhbjEyICsgY29sb3IxICogY29sb3IyICogYWxwaGExMiAvIDI1NSkgLyBuZXdBbHBoYSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKChjb2xvcjEgKiBhbHBoYTFuMiArIGNvbG9yMiAqIGFscGhhbjEyICsgY29sb3IxICogY29sb3IyICogYWxwaGExMiAvIDI1NSkgLyBuZXdBbHBoYSkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBtdWx0aXBseSBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5tdWx0aXBseU9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweEZGKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhGRikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKChjb2xvcjEgKiBhbHBoYTFuMiArIGNvbG9yMiAqIGFscGhhbjEyICsgY29sb3IxICogY29sb3IyICogYWxwaGExMiAvIDI1NSkgLyBuZXdBbHBoYSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKChjb2xvcjEgKiBhbHBoYTFuMiArIGNvbG9yMiAqIGFscGhhbjEyICsgY29sb3IxICogY29sb3IyICogYWxwaGExMiAvIDI1NSkgLyBuZXdBbHBoYSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKChjb2xvcjEgKiBhbHBoYTFuMiArIGNvbG9yMiAqIGFscGhhbjEyICsgY29sb3IxICogY29sb3IyICogYWxwaGExMiAvIDI1NSkgLyBuZXdBbHBoYSkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBub3JtYWwgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIHBpeGVscyBtdXN0IGJlIG9wYXF1ZSwgYW5kIHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5ub3JtYWxPbnRvT3BhcXVlRnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGFscGhhMSA9PSAyNTUpIHtcblxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IDI1NSAtIGFscGhhMTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoKGNvbG9yMSAqIGFscGhhMSArIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSAqIGludkFscGhhMSkgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoKGNvbG9yMSAqIGFscGhhMSArIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gKiBpbnZBbHBoYTEpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKChjb2xvcjEgKiBhbHBoYTEgKyBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdICogaW52QWxwaGExKSAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBub3JtYWwgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQubm9ybWFsT250b09wYXF1ZUZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChhbHBoYTEgPT0gMjU1KSB7XG5cbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgPSAyNTUgLSBhbHBoYTE7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKChjb2xvcjEgKiBhbHBoYTEgKyBmdXNpb24uZGF0YVtwaXhJbmRleF0gKiBpbnZBbHBoYTEpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKChjb2xvcjEgKiBhbHBoYTEgKyBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdICogaW52QWxwaGExKSAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9ICgoY29sb3IxICogYWxwaGExICsgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSAqIGludkFscGhhMSkgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgbm9ybWFsIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBjYW4gY29udGFpbiB0cmFuc3BhcmVudCBwaXhlbHMsIGJ1dCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQubm9ybWFsT250b1RyYW5zcGFyZW50RnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlYWxBbHBoYSA9IChhbHBoYTEgKiAyNTUgLyBuZXdBbHBoYSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYSA9IDI1NSAtIHJlYWxBbHBoYTtcblxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAobGF5ZXIuZGF0YVtwaXhJbmRleF0gKiByZWFsQWxwaGEgKyBmdXNpb24uZGF0YVtwaXhJbmRleF0gKiBpbnZBbHBoYSkgLyAyNTU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAobGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdICogcmVhbEFscGhhICsgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSAqIGludkFscGhhKSAvIDI1NTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChsYXllci5kYXRhW3BpeEluZGV4ICsgMl0gKiByZWFsQWxwaGEgKyBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdICogaW52QWxwaGEpIC8gMjU1O1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBub3JtYWwgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIEZ1c2lvbiBjYW4gY29udGFpbiB0cmFuc3BhcmVudCBwaXhlbHMsIGJ1dCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQubm9ybWFsT250b1RyYW5zcGFyZW50RnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5hbHBoYTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIHJlYWxBbHBoYSA9IChhbHBoYTEgKiAyNTUgLyBuZXdBbHBoYSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYSA9IDI1NSAtIHJlYWxBbHBoYTtcblxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAobGF5ZXIuZGF0YVtwaXhJbmRleF0gKiByZWFsQWxwaGEgKyBmdXNpb24uZGF0YVtwaXhJbmRleF0gKiBpbnZBbHBoYSkgLyAyNTU7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAobGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdICogcmVhbEFscGhhICsgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSAqIGludkFscGhhKSAvIDI1NTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChsYXllci5kYXRhW3BpeEluZGV4ICsgMl0gKiByZWFsQWxwaGEgKyBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdICogaW52QWxwaGEpIC8gMjU1O1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBhZGQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIHBpeGVscyBtdXN0IGJlIG9wYXF1ZSwgYW5kIHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5hZGRPbnRvT3BhcXVlRnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChmdXNpb24uZGF0YVtwaXhJbmRleF0gKyBhbHBoYTEgKiBsYXllci5kYXRhW3BpeEluZGV4XSAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gKyBhbHBoYTEgKiBsYXllci5kYXRhW3BpeEluZGV4ICsgMV0gLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdICsgYWxwaGExICogbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgYWRkIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmFkZE9udG9PcGFxdWVGdXNpb25XaXRoVHJhbnNwYXJlbnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSAoKChsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdKSAqIGxheWVyLmFscGhhIC8gMTAwKSAgfCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKGZ1c2lvbi5kYXRhW3BpeEluZGV4XSArIGFscGhhMSAqIGxheWVyLmRhdGFbcGl4SW5kZXhdIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSArIGFscGhhMSAqIGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXSAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gKyBhbHBoYTEgKiBsYXllci5kYXRhW3BpeEluZGV4ICsgMl0gLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBhZGQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5hZGRPbnRvVHJhbnNwYXJlbnRGdXNpb25XaXRoT3BhcXVlTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5hbHBoYTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2xhbXAgdGhlIGNvbG9yIHRvIDAuLi4yNTUgc2luY2Ugd2UncmUgd3JpdGluZyB0byBhIGNsYW1wZWQgYXJyYXkgYW55d2F5XG5cbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKChhbHBoYTIgKiBmdXNpb24uZGF0YVtwaXhJbmRleF0gKyBhbHBoYTEgKiBsYXllci5kYXRhW3BpeEluZGV4XSkgLyBuZXdBbHBoYSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKChhbHBoYTIgKiBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdICsgYWxwaGExICogbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdKSAvIG5ld0FscGhhKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoKGFscGhhMiAqIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gKyBhbHBoYTEgKiBsYXllci5kYXRhW3BpeEluZGV4ICsgMl0pIC8gbmV3QWxwaGEpIHwgMDtcblxuICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgYWRkIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gY2FuIGNvbnRhaW4gdHJhbnNwYXJlbnQgcGl4ZWxzLCBidXQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmFkZE9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwO1xuXG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjbGFtcCB0aGUgY29sb3IgdG8gMC4uLjI1NSBzaW5jZSB3ZSdyZSB3cml0aW5nIHRvIGEgY2xhbXBlZCBhcnJheSBhbnl3YXlcblxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoKGFscGhhMiAqIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSArIGFscGhhMSAqIGxheWVyLmRhdGFbcGl4SW5kZXhdKSAvIG5ld0FscGhhKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoKGFscGhhMiAqIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gKyBhbHBoYTEgKiBsYXllci5kYXRhW3BpeEluZGV4ICsgMV0pIC8gbmV3QWxwaGEpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9ICgoYWxwaGEyICogZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSArIGFscGhhMSAqIGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXSkgLyBuZXdBbHBoYSkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBzdWJ0cmFjdCBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnN1YnRyYWN0T250b09wYXF1ZUZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoZnVzaW9uLmRhdGFbcGl4SW5kZXhdICsgYWxwaGExICogbGF5ZXIuZGF0YVtwaXhJbmRleF0gLyAyNTUgLSBhbHBoYTEpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdICsgYWxwaGExICogbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdIC8gMjU1IC0gYWxwaGExKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSArIGFscGhhMSAqIGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXSAvIDI1NSAtIGFscGhhMSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIHN1YnRyYWN0IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnN1YnRyYWN0T250b09wYXF1ZUZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoZnVzaW9uLmRhdGFbcGl4SW5kZXhdICsgYWxwaGExICogbGF5ZXIuZGF0YVtwaXhJbmRleF0gLyAyNTUgLSBhbHBoYTEpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdICsgYWxwaGExICogbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdIC8gMjU1IC0gYWxwaGExKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSArIGFscGhhMSAqIGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXSAvIDI1NSAtIGFscGhhMSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIHN1YnRyYWN0IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBjYW4gY29udGFpbiB0cmFuc3BhcmVudCBwaXhlbHMsIGJ1dCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQuc3VidHJhY3RPbnRvVHJhbnNwYXJlbnRGdXNpb25XaXRoT3BhcXVlTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5hbHBoYTI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExMiA9IGFscGhhMSAqIGFscGhhMjtcblxuICAgICAgICAgICAgICAgIC8vIE5vIG5lZWQgdG8gY2xhbXAgdGhlIGNvbG9yIHRvIDI1NSBzaW5jZSB3ZSdyZSB3cml0aW5nIHRvIGEgY2xhbXBlZCBhcnJheSBhbnl3YXlcblxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoKGFscGhhMiAqIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSArIGFscGhhMSAqIGxheWVyLmRhdGFbcGl4SW5kZXhdIC0gYWxwaGExMikgLyBuZXdBbHBoYSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKChhbHBoYTIgKiBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdICsgYWxwaGExICogbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdIC0gYWxwaGExMikgLyBuZXdBbHBoYSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKChhbHBoYTIgKiBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdICsgYWxwaGExICogbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdIC0gYWxwaGExMikgLyBuZXdBbHBoYSkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBzdWJ0cmFjdCBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5zdWJ0cmFjdE9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTEyID0gYWxwaGExICogYWxwaGEyO1xuXG4gICAgICAgICAgICAgICAgLy8gTm8gbmVlZCB0byBjbGFtcCB0aGUgY29sb3IgdG8gMjU1IHNpbmNlIHdlJ3JlIHdyaXRpbmcgdG8gYSBjbGFtcGVkIGFycmF5IGFueXdheVxuXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9ICgoYWxwaGEyICogZnVzaW9uLmRhdGFbcGl4SW5kZXhdICsgYWxwaGExICogbGF5ZXIuZGF0YVtwaXhJbmRleF0gLSBhbHBoYTEyKSAvIG5ld0FscGhhKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoKGFscGhhMiAqIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gKyBhbHBoYTEgKiBsYXllci5kYXRhW3BpeEluZGV4ICsgMV0gLSBhbHBoYTEyKSAvIG5ld0FscGhhKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoKGFscGhhMiAqIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gKyBhbHBoYTEgKiBsYXllci5kYXRhW3BpeEluZGV4ICsgMl0gLSBhbHBoYTEyKSAvIG5ld0FscGhhKSB8IDA7XG5cbiAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdID0gbmV3QWxwaGE7XG4gICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIHNjcmVlbiBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnNjcmVlbk9udG9PcGFxdWVGdXNpb25XaXRoT3BhcXVlTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExID0gYWxwaGExIF4gMHhGRjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gMHhGRiBeIChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbG9yMiBeIDB4RkYpICogaW52QWxwaGExXG4gICAgICAgICAgICAgICAgICAgICAgICArIChsYXllci5kYXRhW3BpeEluZGV4XSBeIDB4RkYpICogKGNvbG9yMiBeIDB4RkYpICogYWxwaGExIC8gMjU1XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLyAyNTVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAweEZGIF4gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29sb3IyIF4gMHhGRikgKiBpbnZBbHBoYTFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXSBeIDB4RkYpICogKGNvbG9yMiBeIDB4RkYpICogYWxwaGExIC8gMjU1XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLyAyNTVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAweEZGIF4gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29sb3IyIF4gMHhGRikgKiBpbnZBbHBoYTFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXSBeIDB4RkYpICogKGNvbG9yMiBeIDB4RkYpICogYWxwaGExIC8gMjU1XG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLyAyNTVcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIHNjcmVlbiBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogRnVzaW9uIHBpeGVscyBtdXN0IGJlIG9wYXF1ZSwgYW5kIHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5zY3JlZW5PbnRvT3BhcXVlRnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4RkY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IDB4RkYgXiAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb2xvcjIgXiAweEZGKSAqIGludkFscGhhMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAobGF5ZXIuZGF0YVtwaXhJbmRleF0gXiAweEZGKSAqIChjb2xvcjIgXiAweEZGKSAqIGFscGhhMSAvIDI1NVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gMjU1XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gMHhGRiBeIChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbG9yMiBeIDB4RkYpICogaW52QWxwaGExXG4gICAgICAgICAgICAgICAgICAgICAgICArIChsYXllci5kYXRhW3BpeEluZGV4ICsgMV0gXiAweEZGKSAqIChjb2xvcjIgXiAweEZGKSAqIGFscGhhMSAvIDI1NVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gMjU1XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gMHhGRiBeIChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbG9yMiBeIDB4RkYpICogaW52QWxwaGExXG4gICAgICAgICAgICAgICAgICAgICAgICArIChsYXllci5kYXRhW3BpeEluZGV4ICsgMl0gXiAweEZGKSAqIChjb2xvcjIgXiAweEZGKSAqIGFscGhhMSAvIDI1NVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gMjU1XG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBzY3JlZW4gYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5zY3JlZW5PbnRvVHJhbnNwYXJlbnRGdXNpb25XaXRoT3BhcXVlTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5hbHBoYTIsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMCxcblxuICAgICAgICAgICAgICAgICAgICBhbHBoYTEyID0gKGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiA9IChhbHBoYTEgKiAoYWxwaGEyIF4gMHhGRikgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGFuMTIgPSAoKGFscGhhMSBeIDB4RkYpICogYWxwaGEyIC8gMjU1KSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IDB4RkYgXiAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb2xvcjEgXiAweEZGKSAqIGFscGhhMW4yXG4gICAgICAgICAgICAgICAgICAgICAgICArIChjb2xvcjIgXiAweEZGKSAqIGFscGhhbjEyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChjb2xvcjEgXiAweEZGKSAqIChjb2xvcjIgXiAweEZGKSAqIGFscGhhMTIgLyAyNTVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IDB4RkYgXiAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb2xvcjEgXiAweEZGKSAqIGFscGhhMW4yXG4gICAgICAgICAgICAgICAgICAgICAgICArIChjb2xvcjIgXiAweEZGKSAqIGFscGhhbjEyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChjb2xvcjEgXiAweEZGKSAqIChjb2xvcjIgXiAweEZGKSAqIGFscGhhMTIgLyAyNTVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IDB4RkYgXiAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb2xvcjEgXiAweEZGKSAqIGFscGhhMW4yXG4gICAgICAgICAgICAgICAgICAgICAgICArIChjb2xvcjIgXiAweEZGKSAqIGFscGhhbjEyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChjb2xvcjEgXiAweEZGKSAqIChjb2xvcjIgXiAweEZGKSAqIGFscGhhMTIgLyAyNTVcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgc2NyZWVuIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gY2FuIGNvbnRhaW4gdHJhbnNwYXJlbnQgcGl4ZWxzLCBidXQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnNjcmVlbk9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweEZGKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhGRikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gMHhGRiBeIChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbG9yMSBeIDB4RkYpICogYWxwaGExbjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGNvbG9yMiBeIDB4RkYpICogYWxwaGFuMTJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGNvbG9yMSBeIDB4RkYpICogKGNvbG9yMiBeIDB4RkYpICogYWxwaGExMiAvIDI1NVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gMHhGRiBeIChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbG9yMSBeIDB4RkYpICogYWxwaGExbjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGNvbG9yMiBeIDB4RkYpICogYWxwaGFuMTJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGNvbG9yMSBeIDB4RkYpICogKGNvbG9yMiBeIDB4RkYpICogYWxwaGExMiAvIDI1NVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gMHhGRiBeIChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbG9yMSBeIDB4RkYpICogYWxwaGExbjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGNvbG9yMiBeIDB4RkYpICogYWxwaGFuMTJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGNvbG9yMSBeIDB4RkYpICogKGNvbG9yMiBeIDB4RkYpICogYWxwaGExMiAvIDI1NVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBsaWdodGVuIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQubGlnaHRlbk9udG9PcGFxdWVGdXNpb25XaXRoT3BhcXVlTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExID0gYWxwaGExIF4gMHhGRjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gY29sb3IyID49IGNvbG9yMSA/IGNvbG9yMiA6IChjb2xvcjIgKiBpbnZBbHBoYTEgKyBjb2xvcjEgKiBhbHBoYTEpIC8gMjU1O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gY29sb3IyID49IGNvbG9yMSA/IGNvbG9yMiA6IChjb2xvcjIgKiBpbnZBbHBoYTEgKyBjb2xvcjEgKiBhbHBoYTEpIC8gMjU1O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gY29sb3IyID49IGNvbG9yMSA/IGNvbG9yMiA6IChjb2xvcjIgKiBpbnZBbHBoYTEgKyBjb2xvcjEgKiBhbHBoYTEpIC8gMjU1O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIGxpZ2h0ZW4gYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQubGlnaHRlbk9udG9PcGFxdWVGdXNpb25XaXRoVHJhbnNwYXJlbnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSAoKChsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdKSAqIGxheWVyLmFscGhhIC8gMTAwKSAgfCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExID0gYWxwaGExIF4gMHhGRjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gY29sb3IyID49IGNvbG9yMSA/IGNvbG9yMiA6IChjb2xvcjIgKiBpbnZBbHBoYTEgKyBjb2xvcjEgKiBhbHBoYTEpIC8gMjU1O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gY29sb3IyID49IGNvbG9yMSA/IGNvbG9yMiA6IChjb2xvcjIgKiBpbnZBbHBoYTEgKyBjb2xvcjEgKiBhbHBoYTEpIC8gMjU1O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gY29sb3IyID49IGNvbG9yMSA/IGNvbG9yMiA6IChjb2xvcjIgKiBpbnZBbHBoYTEgKyBjb2xvcjEgKiBhbHBoYTEpIC8gMjU1O1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIGxpZ2h0ZW4gYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5saWdodGVuT250b1RyYW5zcGFyZW50RnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFscGhhIGlzIHVzZWQgd2hlbiBjb2xvcjEgPiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExMiA9IChhbHBoYTIgKiAoYWxwaGExIF4gMHhGRikgLyBuZXdBbHBoYSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEyID0gKGFscGhhMTIgXiAweEZGKSB8IDAsXG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFscGhhIGlzIHVzZWQgd2hlbiBjb2xvcjIgPiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEyMSA9IChhbHBoYTEgKiAoYWxwaGEyIF4gMHhGRikgLyBuZXdBbHBoYSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTIxID0gKGFscGhhMjEgXiAweEZGKSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9ICgoKGNvbG9yMiA+PSBjb2xvcjEpID8gKGNvbG9yMSAqIGFscGhhMjEgKyBjb2xvcjIgKiBpbnZBbHBoYTIxKSA6IChjb2xvcjIgKiBhbHBoYTEyICsgY29sb3IxICogaW52QWxwaGExMikpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoKChjb2xvcjIgPj0gY29sb3IxKSA/IChjb2xvcjEgKiBhbHBoYTIxICsgY29sb3IyICogaW52QWxwaGEyMSkgOiAoY29sb3IyICogYWxwaGExMiArIGNvbG9yMSAqIGludkFscGhhMTIpKSAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKCgoY29sb3IyID49IGNvbG9yMSkgPyAoY29sb3IxICogYWxwaGEyMSArIGNvbG9yMiAqIGludkFscGhhMjEpIDogKGNvbG9yMiAqIGFscGhhMTIgKyBjb2xvcjEgKiBpbnZBbHBoYTEyKSkgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgbGlnaHRlbiBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5saWdodGVuT250b1RyYW5zcGFyZW50RnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5hbHBoYTIsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFscGhhIGlzIHVzZWQgd2hlbiBjb2xvcjEgPiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExMiA9IChhbHBoYTIgKiAoYWxwaGExIF4gMHhGRikgLyBuZXdBbHBoYSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEyID0gKGFscGhhMTIgXiAweEZGKSB8IDAsXG5cbiAgICAgICAgICAgICAgICAvLyBUaGlzIGFscGhhIGlzIHVzZWQgd2hlbiBjb2xvcjIgPiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgYWxwaGEyMSA9IChhbHBoYTEgKiAoYWxwaGEyIF4gMHhGRikgLyBuZXdBbHBoYSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTIxID0gKGFscGhhMjEgXiAweEZGKSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9ICgoKGNvbG9yMiA+PSBjb2xvcjEpID8gKGNvbG9yMSAqIGFscGhhMjEgKyBjb2xvcjIgKiBpbnZBbHBoYTIxKSA6IChjb2xvcjIgKiBhbHBoYTEyICsgY29sb3IxICogaW52QWxwaGExMikpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoKChjb2xvcjIgPj0gY29sb3IxKSA/IChjb2xvcjEgKiBhbHBoYTIxICsgY29sb3IyICogaW52QWxwaGEyMSkgOiAoY29sb3IyICogYWxwaGExMiArIGNvbG9yMSAqIGludkFscGhhMTIpKSAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKCgoY29sb3IyID49IGNvbG9yMSkgPyAoY29sb3IxICogYWxwaGEyMSArIGNvbG9yMiAqIGludkFscGhhMjEpIDogKGNvbG9yMiAqIGFscGhhMTIgKyBjb2xvcjEgKiBpbnZBbHBoYTEyKSkgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgZGFya2VuIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQuZGFya2VuT250b09wYXF1ZUZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgPSBhbHBoYTEgXiAweEZGO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSBjb2xvcjIgPj0gY29sb3IxID8gKGNvbG9yMiAqIGludkFscGhhMSArIGNvbG9yMSAqIGFscGhhMSkgLyAyNTUgOiBjb2xvcjI7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSBjb2xvcjIgPj0gY29sb3IxID8gKGNvbG9yMiAqIGludkFscGhhMSArIGNvbG9yMSAqIGFscGhhMSkgLyAyNTUgOiBjb2xvcjI7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSBjb2xvcjIgPj0gY29sb3IxID8gKGNvbG9yMiAqIGludkFscGhhMSArIGNvbG9yMSAqIGFscGhhMSkgLyAyNTUgOiBjb2xvcjI7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgZGFya2VuIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmRhcmtlbk9udG9PcGFxdWVGdXNpb25XaXRoVHJhbnNwYXJlbnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSAoKChsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdKSAqIGxheWVyLmFscGhhIC8gMTAwKSAgfCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExID0gYWxwaGExIF4gMHhGRjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gY29sb3IyID49IGNvbG9yMSA/IChjb2xvcjIgKiBpbnZBbHBoYTEgKyBjb2xvcjEgKiBhbHBoYTEpIC8gMjU1IDogY29sb3IyO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gY29sb3IyID49IGNvbG9yMSA/IChjb2xvcjIgKiBpbnZBbHBoYTEgKyBjb2xvcjEgKiBhbHBoYTEpIC8gMjU1IDogY29sb3IyO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gY29sb3IyID49IGNvbG9yMSA/IChjb2xvcjIgKiBpbnZBbHBoYTEgKyBjb2xvcjEgKiBhbHBoYTEpIC8gMjU1IDogY29sb3IyO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIGRhcmtlbiBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gY2FuIGNvbnRhaW4gdHJhbnNwYXJlbnQgcGl4ZWxzLCBidXQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmRhcmtlbk9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhbHBoYSBpcyB1c2VkIHdoZW4gY29sb3IxID4gY29sb3IyXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogKGFscGhhMiBeIDB4RkYpIC8gbmV3QWxwaGEpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExMiA9IChhbHBoYTEyIF4gMHhGRikgfCAwLFxuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBhbHBoYSBpcyB1c2VkIHdoZW4gY29sb3IyID4gY29sb3IxXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMjEgPSAoYWxwaGEyICogKGFscGhhMSBeIDB4RkYpIC8gbmV3QWxwaGEpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgaW52QWxwaGEyMSA9IChhbHBoYTIxIF4gMHhGRikgfCAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoKChjb2xvcjIgPj0gY29sb3IxKSA/IChjb2xvcjIgKiBhbHBoYTIxICsgY29sb3IxICogaW52QWxwaGEyMSkgOiAoY29sb3IxICogYWxwaGExMiArIGNvbG9yMiAqIGludkFscGhhMTIpKSAvIDI1NSkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKCgoY29sb3IyID49IGNvbG9yMSkgPyAoY29sb3IyICogYWxwaGEyMSArIGNvbG9yMSAqIGludkFscGhhMjEpIDogKGNvbG9yMSAqIGFscGhhMTIgKyBjb2xvcjIgKiBpbnZBbHBoYTEyKSkgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9ICgoKGNvbG9yMiA+PSBjb2xvcjEpID8gKGNvbG9yMiAqIGFscGhhMjEgKyBjb2xvcjEgKiBpbnZBbHBoYTIxKSA6IChjb2xvcjEgKiBhbHBoYTEyICsgY29sb3IyICogaW52QWxwaGExMikpIC8gMjU1KSB8IDA7XG5cbiAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdID0gbmV3QWxwaGE7XG4gICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIGRhcmtlbiBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5kYXJrZW5PbnRvVHJhbnNwYXJlbnRGdXNpb25XaXRoVHJhbnNwYXJlbnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSAoKChsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdKSAqIGxheWVyLmFscGhhIC8gMTAwKSAgfCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMCxcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxwaGEgaXMgdXNlZCB3aGVuIGNvbG9yMSA+IGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICBhbHBoYTEyID0gKGFscGhhMSAqIChhbHBoYTIgXiAweEZGKSAvIG5ld0FscGhhKSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMTIgPSAoYWxwaGExMiBeIDB4RkYpIHwgMCxcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgYWxwaGEgaXMgdXNlZCB3aGVuIGNvbG9yMiA+IGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICBhbHBoYTIxID0gKGFscGhhMiAqIChhbHBoYTEgXiAweEZGKSAvIG5ld0FscGhhKSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMjEgPSAoYWxwaGEyMSBeIDB4RkYpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKCgoY29sb3IyID49IGNvbG9yMSkgPyAoY29sb3IyICogYWxwaGEyMSArIGNvbG9yMSAqIGludkFscGhhMjEpIDogKGNvbG9yMSAqIGFscGhhMTIgKyBjb2xvcjIgKiBpbnZBbHBoYTEyKSkgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9ICgoKGNvbG9yMiA+PSBjb2xvcjEpID8gKGNvbG9yMiAqIGFscGhhMjEgKyBjb2xvcjEgKiBpbnZBbHBoYTIxKSA6IChjb2xvcjEgKiBhbHBoYTEyICsgY29sb3IyICogaW52QWxwaGExMikpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoKChjb2xvcjIgPj0gY29sb3IxKSA/IChjb2xvcjIgKiBhbHBoYTIxICsgY29sb3IxICogaW52QWxwaGEyMSkgOiAoY29sb3IxICogYWxwaGExMiArIGNvbG9yMiAqIGludkFscGhhMTIpKSAvIDI1NSkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBkb2RnZSBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmRvZGdlT250b09wYXF1ZUZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgPSBhbHBoYTEgXiAweEZGO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiAqIGludkFscGhhMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiAoY29sb3IxID09IDI1NSA/IDI1NSA6IE1hdGgubWluKDI1NSwgKDI1NSAqIGNvbG9yMiAvIChjb2xvcjEgXiAweEZGKSkgfCAwKSlcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgKiBpbnZBbHBoYTFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsICgyNTUgKiBjb2xvcjIgLyAoY29sb3IxIF4gMHhGRikpIHwgMCkpXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyICogaW52QWxwaGExXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqIChjb2xvcjEgPT0gMjU1ID8gMjU1IDogTWF0aC5taW4oMjU1LCAoMjU1ICogY29sb3IyIC8gKGNvbG9yMSBeIDB4RkYpKSB8IDApKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgZG9kZ2UgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQuZG9kZ2VPbnRvT3BhcXVlRnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4RkY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyICogaW52QWxwaGExXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqIChjb2xvcjEgPT0gMjU1ID8gMjU1IDogTWF0aC5taW4oMjU1LCAoMjU1ICogY29sb3IyIC8gKGNvbG9yMSBeIDB4RkYpKSB8IDApKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiAqIGludkFscGhhMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiAoY29sb3IxID09IDI1NSA/IDI1NSA6IE1hdGgubWluKDI1NSwgKDI1NSAqIGNvbG9yMiAvIChjb2xvcjEgXiAweEZGKSkgfCAwKSlcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgKiBpbnZBbHBoYTFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsICgyNTUgKiBjb2xvcjIgLyAoY29sb3IxIF4gMHhGRikpIHwgMCkpXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBkb2RnZSBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gY2FuIGNvbnRhaW4gdHJhbnNwYXJlbnQgcGl4ZWxzLCBidXQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmRvZGdlT250b1RyYW5zcGFyZW50RnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweEZGKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhGRikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29sb3IxICogYWxwaGExbjIpXG4gICAgICAgICAgICAgICAgICAgICAgICArIChjb2xvcjIgKiBhbHBoYW4xMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExMiAqIChjb2xvcjEgPT0gMjU1ID8gMjU1IDogTWF0aC5taW4oMjU1LCAoMjU1ICogY29sb3IyIC8gKGNvbG9yMSBeIDB4RkYpKSB8IDApKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbG9yMSAqIGFscGhhMW4yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoY29sb3IyICogYWxwaGFuMTIpXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMTIgKiAoY29sb3IxID09IDI1NSA/IDI1NSA6IE1hdGgubWluKDI1NSwgKDI1NSAqIGNvbG9yMiAvIChjb2xvcjEgXiAweEZGKSkgfCAwKSlcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb2xvcjEgKiBhbHBoYTFuMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGNvbG9yMiAqIGFscGhhbjEyKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEyICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsICgyNTUgKiBjb2xvcjIgLyAoY29sb3IxIF4gMHhGRikpIHwgMCkpXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBkb2RnZSBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5kb2RnZU9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTEyID0gKGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiA9IChhbHBoYTEgKiAoYWxwaGEyIF4gMHhGRikgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGFuMTIgPSAoKGFscGhhMSBeIDB4RkYpICogYWxwaGEyIC8gMjU1KSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgKGNvbG9yMSAqIGFscGhhMW4yKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoY29sb3IyICogYWxwaGFuMTIpXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMTIgKiAoY29sb3IxID09IDI1NSA/IDI1NSA6IE1hdGgubWluKDI1NSwgKDI1NSAqIGNvbG9yMiAvIChjb2xvcjEgXiAweEZGKSkgfCAwKSlcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIChjb2xvcjEgKiBhbHBoYTFuMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKGNvbG9yMiAqIGFscGhhbjEyKVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEyICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsICgyNTUgKiBjb2xvcjIgLyAoY29sb3IxIF4gMHhGRikpIHwgMCkpXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29sb3IxICogYWxwaGExbjIpXG4gICAgICAgICAgICAgICAgICAgICAgICArIChjb2xvcjIgKiBhbHBoYW4xMilcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExMiAqIChjb2xvcjEgPT0gMjU1ID8gMjU1IDogTWF0aC5taW4oMjU1LCAoMjU1ICogY29sb3IyIC8gKGNvbG9yMSBeIDB4RkYpKSB8IDApKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcblxuICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgYnVybiBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmJ1cm5PbnRvT3BhcXVlRnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4RkY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyICogaW52QWxwaGExXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqIChjb2xvcjEgPT0gMCA/IDAgOiBNYXRoLm1pbigyNTUsIDI1NSAqIChjb2xvcjIgXiAweEZGKSAvIGNvbG9yMSkgXiAweEZGKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiAqIGludkFscGhhMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiAoY29sb3IxID09IDAgPyAwIDogTWF0aC5taW4oMjU1LCAyNTUgKiAoY29sb3IyIF4gMHhGRikgLyBjb2xvcjEpIF4gMHhGRilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgKiBpbnZBbHBoYTFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExICogKGNvbG9yMSA9PSAwID8gMCA6IE1hdGgubWluKDI1NSwgMjU1ICogKGNvbG9yMiBeIDB4RkYpIC8gY29sb3IxKSBeIDB4RkYpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBidXJuIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmJ1cm5PbnRvT3BhcXVlRnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4RkY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyICogaW52QWxwaGExXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqIChjb2xvcjEgPT0gMCA/IDAgOiBNYXRoLm1pbigyNTUsIDI1NSAqIChjb2xvcjIgXiAweEZGKSAvIGNvbG9yMSkgXiAweEZGKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiAqIGludkFscGhhMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiAoY29sb3IxID09IDAgPyAwIDogTWF0aC5taW4oMjU1LCAyNTUgKiAoY29sb3IyIF4gMHhGRikgLyBjb2xvcjEpIF4gMHhGRilcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgKiBpbnZBbHBoYTFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExICogKGNvbG9yMSA9PSAwID8gMCA6IE1hdGgubWluKDI1NSwgMjU1ICogKGNvbG9yMiBeIDB4RkYpIC8gY29sb3IxKSBeIDB4RkYpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBidXJuIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBjYW4gY29udGFpbiB0cmFuc3BhcmVudCBwaXhlbHMsIGJ1dCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQuYnVybk9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweEZGKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhGRikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgKiBhbHBoYTFuMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBjb2xvcjIgKiBhbHBoYW4xMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEyICogKGNvbG9yMSA9PSAwID8gMCA6IE1hdGgubWluKDI1NSwgMjU1ICogKGNvbG9yMiBeIDB4RkYpIC8gY29sb3IxKSBeIDB4RkYpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgKiBhbHBoYTFuMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBjb2xvcjIgKiBhbHBoYW4xMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEyICogKGNvbG9yMSA9PSAwID8gMCA6IE1hdGgubWluKDI1NSwgMjU1ICogKGNvbG9yMiBeIDB4RkYpIC8gY29sb3IxKSBeIDB4RkYpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgKiBhbHBoYTFuMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBjb2xvcjIgKiBhbHBoYW4xMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEyICogKGNvbG9yMSA9PSAwID8gMCA6IE1hdGgubWluKDI1NSwgMjU1ICogKGNvbG9yMiBeIDB4RkYpIC8gY29sb3IxKSBeIDB4RkYpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBidXJuIGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gY2FuIGNvbnRhaW4gdHJhbnNwYXJlbnQgcGl4ZWxzLCBidXQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmJ1cm5PbnRvVHJhbnNwYXJlbnRGdXNpb25XaXRoVHJhbnNwYXJlbnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSAoKChsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdKSAqIGxheWVyLmFscGhhIC8gMTAwKSAgfCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMCxcblxuICAgICAgICAgICAgICAgICAgICBhbHBoYTEyID0gKGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiA9IChhbHBoYTEgKiAoYWxwaGEyIF4gMHhGRikgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGFuMTIgPSAoKGFscGhhMSBeIDB4RkYpICogYWxwaGEyIC8gMjU1KSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxICogYWxwaGExbjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29sb3IyICogYWxwaGFuMTJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExMiAqIChjb2xvcjEgPT0gMCA/IDAgOiBNYXRoLm1pbigyNTUsIDI1NSAqIChjb2xvcjIgXiAweEZGKSAvIGNvbG9yMSkgXiAweEZGKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxICogYWxwaGExbjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29sb3IyICogYWxwaGFuMTJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExMiAqIChjb2xvcjEgPT0gMCA/IDAgOiBNYXRoLm1pbigyNTUsIDI1NSAqIChjb2xvcjIgXiAweEZGKSAvIGNvbG9yMSkgXiAweEZGKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxICogYWxwaGExbjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgY29sb3IyICogYWxwaGFuMTJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExMiAqIChjb2xvcjEgPT0gMCA/IDAgOiBNYXRoLm1pbigyNTUsIDI1NSAqIChjb2xvcjIgXiAweEZGKSAvIGNvbG9yMSkgXiAweEZGKVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcblxuICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgb3ZlcmxheSBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLm92ZXJsYXlPbnRvT3BhcXVlRnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4RkY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqIDIgKiBjb2xvcjEgKiBjb2xvcjIgLyAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGFscGhhMSAqICgoMiAqIChjb2xvcjEgXiAweGZmKSAqIChjb2xvcjIgXiAweGZmKSAvIDI1NSkgXiAweGZmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExICogMiAqIGNvbG9yMSAqIGNvbG9yMiAvIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKCgyICogKGNvbG9yMSBeIDB4ZmYpICogKGNvbG9yMiBeIDB4ZmYpIC8gMjU1KSBeIDB4ZmYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEgKiAyICogY29sb3IxICogY29sb3IyIC8gMjU1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEgKiAoKDIgKiAoY29sb3IxIF4gMHhmZikgKiAoY29sb3IyIF4gMHhmZikgLyAyNTUpIF4gMHhmZikpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBvdmVybGF5IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLm92ZXJsYXlPbnRvT3BhcXVlRnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4RkY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqIDIgKiBjb2xvcjEgKiBjb2xvcjIgLyAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGFscGhhMSAqICgoMiAqIChjb2xvcjEgXiAweGZmKSAqIChjb2xvcjIgXiAweGZmKSAvIDI1NSkgXiAweGZmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExICogMiAqIGNvbG9yMSAqIGNvbG9yMiAvIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKCgyICogKGNvbG9yMSBeIDB4ZmYpICogKGNvbG9yMiBeIDB4ZmYpIC8gMjU1KSBeIDB4ZmYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEgKiAyICogY29sb3IxICogY29sb3IyIC8gMjU1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEgKiAoKDIgKiAoY29sb3IxIF4gMHhmZikgKiAoY29sb3IyIF4gMHhmZikgLyAyNTUpIF4gMHhmZikpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBvdmVybGF5IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBjYW4gY29udGFpbiB0cmFuc3BhcmVudCBwaXhlbHMsIGJ1dCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQub3ZlcmxheU9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTEyID0gKGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiA9IChhbHBoYTEgKiAoYWxwaGEyIF4gMHhmZikgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGFuMTIgPSAoKGFscGhhMSBeIDB4ZmYpICogYWxwaGEyIC8gMjU1KSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExMiAqIDIgKiBjb2xvcjEgKiBjb2xvcjIgLyAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGFscGhhMTIgKiAoKDIgKiAoY29sb3IxIF4gMHhmZikgKiAoY29sb3IyIF4gMHhmZikgLyAyNTUpIF4gMHhmZikpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEyICogMiAqIGNvbG9yMSAqIGNvbG9yMiAvIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExMiAqICgoMiAqIChjb2xvcjEgXiAweGZmKSAqIChjb2xvcjIgXiAweGZmKSAvIDI1NSkgXiAweGZmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMTIgKiAyICogY29sb3IxICogY29sb3IyIC8gMjU1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEyICogKCgyICogKGNvbG9yMSBeIDB4ZmYpICogKGNvbG9yMiBeIDB4ZmYpIC8gMjU1KSBeIDB4ZmYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcblxuICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgb3ZlcmxheSBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5vdmVybGF5T250b1RyYW5zcGFyZW50RnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5hbHBoYTIsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweGZmKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhmZikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEyICogMiAqIGNvbG9yMSAqIGNvbG9yMiAvIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExMiAqICgoMiAqIChjb2xvcjEgXiAweGZmKSAqIChjb2xvcjIgXiAweGZmKSAvIDI1NSkgXiAweGZmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMTIgKiAyICogY29sb3IxICogY29sb3IyIC8gMjU1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEyICogKCgyICogKGNvbG9yMSBeIDB4ZmYpICogKGNvbG9yMiBeIDB4ZmYpIC8gMjU1KSBeIDB4ZmYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExMiAqIDIgKiBjb2xvcjEgKiBjb2xvcjIgLyAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGFscGhhMTIgKiAoKDIgKiAoY29sb3IxIF4gMHhmZikgKiAoY29sb3IyIF4gMHhmZikgLyAyNTUpIF4gMHhmZikpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBoYXJkTGlnaHQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIHBpeGVscyBtdXN0IGJlIG9wYXF1ZSwgYW5kIHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5oYXJkTGlnaHRPbnRvT3BhcXVlRnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4ZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqIDIgKiBjb2xvcjEgKiBjb2xvcjIgLyAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGFscGhhMSAqICgoMiAqIChjb2xvcjEgXiAweGZmKSAqIChjb2xvcjIgXiAweGZmKSAvIDI1NSkgXiAweGZmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExICogMiAqIGNvbG9yMSAqIGNvbG9yMiAvIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKCgyICogKGNvbG9yMSBeIDB4ZmYpICogKGNvbG9yMiBeIDB4ZmYpIC8gMjU1KSBeIDB4ZmYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEgKiAyICogY29sb3IxICogY29sb3IyIC8gMjU1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEgKiAoKDIgKiAoY29sb3IxIF4gMHhmZikgKiAoY29sb3IyIF4gMHhmZikgLyAyNTUpIF4gMHhmZikpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBoYXJkTGlnaHQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQuaGFyZExpZ2h0T250b09wYXF1ZUZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgPSBhbHBoYTEgXiAweGZmO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEgKiAyICogY29sb3IxICogY29sb3IyIC8gMjU1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEgKiAoKDIgKiAoY29sb3IxIF4gMHhmZikgKiAoY29sb3IyIF4gMHhmZikgLyAyNTUpIF4gMHhmZikpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqIDIgKiBjb2xvcjEgKiBjb2xvcjIgLyAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGFscGhhMSAqICgoMiAqIChjb2xvcjEgXiAweGZmKSAqIChjb2xvcjIgXiAweGZmKSAvIDI1NSkgXiAweGZmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExICogMiAqIGNvbG9yMSAqIGNvbG9yMiAvIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKCgyICogKGNvbG9yMSBeIDB4ZmYpICogKGNvbG9yMiBeIDB4ZmYpIC8gMjU1KSBeIDB4ZmYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgaGFyZExpZ2h0IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBjYW4gY29udGFpbiB0cmFuc3BhcmVudCBwaXhlbHMsIGJ1dCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQuaGFyZExpZ2h0T250b1RyYW5zcGFyZW50RnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweGZmKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhmZikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEyICogMiAqIGNvbG9yMSAqIGNvbG9yMiAvIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExMiAqICgoMiAqIChjb2xvcjEgXiAweGZmKSAqIChjb2xvcjIgXiAweGZmKSAvIDI1NSkgXiAweGZmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMTIgKiAyICogY29sb3IxICogY29sb3IyIC8gMjU1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEyICogKCgyICogKGNvbG9yMSBeIDB4ZmYpICogKGNvbG9yMiBeIDB4ZmYpIC8gMjU1KSBeIDB4ZmYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExMiAqIDIgKiBjb2xvcjEgKiBjb2xvcjIgLyAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGFscGhhMTIgKiAoKDIgKiAoY29sb3IxIF4gMHhmZikgKiAoY29sb3IyIF4gMHhmZikgLyAyNTUpIF4gMHhmZikpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBoYXJkTGlnaHQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIEZ1c2lvbiBjYW4gY29udGFpbiB0cmFuc3BhcmVudCBwaXhlbHMsIGJ1dCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQuaGFyZExpZ2h0T250b1RyYW5zcGFyZW50RnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5hbHBoYTIsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweGZmKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhmZikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEyICogMiAqIGNvbG9yMSAqIGNvbG9yMiAvIDI1NSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExMiAqICgoMiAqIChjb2xvcjEgXiAweGZmKSAqIChjb2xvcjIgXiAweGZmKSAvIDI1NSkgXiAweGZmKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMTIgKiAyICogY29sb3IxICogY29sb3IyIC8gMjU1KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEyICogKCgyICogKGNvbG9yMSBeIDB4ZmYpICogKGNvbG9yMiBeIDB4ZmYpIC8gMjU1KSBeIDB4ZmYpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExMiAqIDIgKiBjb2xvcjEgKiBjb2xvcjIgLyAyNTUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogKGFscGhhMTIgKiAoKDIgKiAoY29sb3IxIF4gMHhmZikgKiAoY29sb3IyIF4gMHhmZikgLyAyNTUpIF4gMHhmZikpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBzb2Z0TGlnaHQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIHBpeGVscyBtdXN0IGJlIG9wYXF1ZSwgYW5kIHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5zb2Z0TGlnaHRPbnRvT3BhcXVlRnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4ZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKCgyICogY29sb3IxIC0gMjU1KSAqIHNvZnRMaWdodExVVFNxdWFyZVtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICgoMiAqIGNvbG9yMSAtIDI1NSkgKiBzb2Z0TGlnaHRMVVRTcXVhcmVSb290W2NvbG9yMl0gLyAyNTUgKyBjb2xvcjIpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKCgyICogY29sb3IxIC0gMjU1KSAqIHNvZnRMaWdodExVVFNxdWFyZVtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICgoMiAqIGNvbG9yMSAtIDI1NSkgKiBzb2Z0TGlnaHRMVVRTcXVhcmVSb290W2NvbG9yMl0gLyAyNTUgKyBjb2xvcjIpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKCgyICogY29sb3IxIC0gMjU1KSAqIHNvZnRMaWdodExVVFNxdWFyZVtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICgoMiAqIGNvbG9yMSAtIDI1NSkgKiBzb2Z0TGlnaHRMVVRTcXVhcmVSb290W2NvbG9yMl0gLyAyNTUgKyBjb2xvcjIpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBzb2Z0TGlnaHQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQuc29mdExpZ2h0T250b09wYXF1ZUZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgPSBhbHBoYTEgXiAweGZmO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgoMiAqIGNvbG9yMSAtIDI1NSkgKiBzb2Z0TGlnaHRMVVRTcXVhcmVbY29sb3IyXSAvIDI1NSArIGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoKDIgKiBjb2xvcjEgLSAyNTUpICogc29mdExpZ2h0TFVUU3F1YXJlUm9vdFtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgoMiAqIGNvbG9yMSAtIDI1NSkgKiBzb2Z0TGlnaHRMVVRTcXVhcmVbY29sb3IyXSAvIDI1NSArIGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoKDIgKiBjb2xvcjEgLSAyNTUpICogc29mdExpZ2h0TFVUU3F1YXJlUm9vdFtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/ICgoMiAqIGNvbG9yMSAtIDI1NSkgKiBzb2Z0TGlnaHRMVVRTcXVhcmVbY29sb3IyXSAvIDI1NSArIGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoKDIgKiBjb2xvcjEgLSAyNTUpICogc29mdExpZ2h0TFVUU3F1YXJlUm9vdFtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgc29mdExpZ2h0IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBjYW4gY29udGFpbiB0cmFuc3BhcmVudCBwaXhlbHMsIGJ1dCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQuc29mdExpZ2h0T250b1RyYW5zcGFyZW50RnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG5cbiAgICAgICAgICAgICAgICAgICAgYWxwaGExMiA9IChhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgPSAoYWxwaGExICogKGFscGhhMiBeIDB4ZmYpIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhbjEyID0gKChhbHBoYTEgXiAweGZmKSAqIGFscGhhMiAvIDI1NSkgfCAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWxwaGExMiAqICgoMiAqIGNvbG9yMSAtIDI1NSkgKiBzb2Z0TGlnaHRMVVRTcXVhcmVbY29sb3IyXSAvIDI1NSArIGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhbHBoYTEyICogKCgyICogY29sb3IxIC0gMjU1KSAqIHNvZnRMaWdodExVVFNxdWFyZVJvb3RbY29sb3IyXSAvIDI1NSArIGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWxwaGExMiAqICgoMiAqIGNvbG9yMSAtIDI1NSkgKiBzb2Z0TGlnaHRMVVRTcXVhcmVbY29sb3IyXSAvIDI1NSArIGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhbHBoYTEyICogKCgyICogY29sb3IxIC0gMjU1KSAqIHNvZnRMaWdodExVVFNxdWFyZVJvb3RbY29sb3IyXSAvIDI1NSArIGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gYWxwaGExMiAqICgoMiAqIGNvbG9yMSAtIDI1NSkgKiBzb2Z0TGlnaHRMVVRTcXVhcmVbY29sb3IyXSAvIDI1NSArIGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBhbHBoYTEyICogKCgyICogY29sb3IxIC0gMjU1KSAqIHNvZnRMaWdodExVVFNxdWFyZVJvb3RbY29sb3IyXSAvIDI1NSArIGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG5cbiAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdID0gbmV3QWxwaGE7XG4gICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIHNvZnRMaWdodCBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5zb2Z0TGlnaHRPbnRvVHJhbnNwYXJlbnRGdXNpb25XaXRoVHJhbnNwYXJlbnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSAoKChsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdKSAqIGxheWVyLmFscGhhIC8gMTAwKSAgfCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMCxcblxuICAgICAgICAgICAgICAgICAgICBhbHBoYTEyID0gKGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiA9IChhbHBoYTEgKiAoYWxwaGEyIF4gMHhmZikgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGFuMTIgPSAoKGFscGhhMSBeIDB4ZmYpICogYWxwaGEyIC8gMjU1KSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhbHBoYTEyICogKCgyICogY29sb3IxIC0gMjU1KSAqIHNvZnRMaWdodExVVFNxdWFyZVtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFscGhhMTIgKiAoKDIgKiBjb2xvcjEgLSAyNTUpICogc29mdExpZ2h0TFVUU3F1YXJlUm9vdFtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhbHBoYTEyICogKCgyICogY29sb3IxIC0gMjU1KSAqIHNvZnRMaWdodExVVFNxdWFyZVtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFscGhhMTIgKiAoKDIgKiBjb2xvcjEgLSAyNTUpICogc29mdExpZ2h0TFVUU3F1YXJlUm9vdFtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBhbHBoYTEyICogKCgyICogY29sb3IxIC0gMjU1KSAqIHNvZnRMaWdodExVVFNxdWFyZVtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGFscGhhMTIgKiAoKDIgKiBjb2xvcjEgLSAyNTUpICogc29mdExpZ2h0TFVUU3F1YXJlUm9vdFtjb2xvcjJdIC8gMjU1ICsgY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcblxuICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgdml2aWRMaWdodCBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnZpdmlkTGlnaHRPbnRvT3BhcXVlRnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4ZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqICgoY29sb3IxID09IDApID8gMCA6IDI1NSAtIE1hdGgubWluKDI1NSwgKDI1NSAtIGNvbG9yMikgKiAyNTUgLyAoMiAqIGNvbG9yMSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsIGNvbG9yMiAqIDI1NSAvICgyICogKDI1NSAtIGNvbG9yMSkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqICgoY29sb3IxID09IDApID8gMCA6IDI1NSAtIE1hdGgubWluKDI1NSwgKDI1NSAtIGNvbG9yMikgKiAyNTUgLyAoMiAqIGNvbG9yMSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsIGNvbG9yMiAqIDI1NSAvICgyICogKDI1NSAtIGNvbG9yMSkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqICgoY29sb3IxID09IDApID8gMCA6IDI1NSAtIE1hdGgubWluKDI1NSwgKDI1NSAtIGNvbG9yMikgKiAyNTUgLyAoMiAqIGNvbG9yMSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsIGNvbG9yMiAqIDI1NSAvICgyICogKDI1NSAtIGNvbG9yMSkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSB2aXZpZExpZ2h0IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnZpdmlkTGlnaHRPbnRvT3BhcXVlRnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4ZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqICgoY29sb3IxID09IDApID8gMCA6IDI1NSAtIE1hdGgubWluKDI1NSwgKDI1NSAtIGNvbG9yMikgKiAyNTUgLyAoMiAqIGNvbG9yMSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsIGNvbG9yMiAqIDI1NSAvICgyICogKDI1NSAtIGNvbG9yMSkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqICgoY29sb3IxID09IDApID8gMCA6IDI1NSAtIE1hdGgubWluKDI1NSwgKDI1NSAtIGNvbG9yMikgKiAyNTUgLyAoMiAqIGNvbG9yMSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsIGNvbG9yMiAqIDI1NSAvICgyICogKDI1NSAtIGNvbG9yMSkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPD0gMTI3XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gKGFscGhhMSAqICgoY29sb3IxID09IDApID8gMCA6IDI1NSAtIE1hdGgubWluKDI1NSwgKDI1NSAtIGNvbG9yMikgKiAyNTUgLyAoMiAqIGNvbG9yMSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsIGNvbG9yMiAqIDI1NSAvICgyICogKDI1NSAtIGNvbG9yMSkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSB2aXZpZExpZ2h0IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBUaGUgbGF5ZXIgbXVzdCBoYXZlIGl0cyBsYXllciBhbHBoYSBzZXQgdG8gMTAwXG4gKiBcbiAqIEZ1c2lvbiBjYW4gY29udGFpbiB0cmFuc3BhcmVudCBwaXhlbHMsIGJ1dCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQudml2aWRMaWdodE9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweGZmKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhmZikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEyICogKChjb2xvcjEgPT0gMCkgPyAwIDogMjU1IC0gTWF0aC5taW4oMjU1LCAoMjU1IC0gY29sb3IyKSAqIDI1NSAvICgyICogY29sb3IxKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEyICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsIGNvbG9yMiAqIDI1NSAvICgyICogKDI1NSAtIGNvbG9yMSkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEyICogKChjb2xvcjEgPT0gMCkgPyAwIDogMjU1IC0gTWF0aC5taW4oMjU1LCAoMjU1IC0gY29sb3IyKSAqIDI1NSAvICgyICogY29sb3IxKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEyICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsIGNvbG9yMiAqIDI1NSAvICgyICogKDI1NSAtIGNvbG9yMSkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxIDw9IDEyN1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IChhbHBoYTEyICogKChjb2xvcjEgPT0gMCkgPyAwIDogMjU1IC0gTWF0aC5taW4oMjU1LCAoMjU1IC0gY29sb3IyKSAqIDI1NSAvICgyICogY29sb3IxKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IChhbHBoYTEyICogKGNvbG9yMSA9PSAyNTUgPyAyNTUgOiBNYXRoLm1pbigyNTUsIGNvbG9yMiAqIDI1NSAvICgyICogKDI1NSAtIGNvbG9yMSkpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSB2aXZpZExpZ2h0IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gY2FuIGNvbnRhaW4gdHJhbnNwYXJlbnQgcGl4ZWxzLCBidXQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnZpdmlkTGlnaHRPbnRvVHJhbnNwYXJlbnRGdXNpb25XaXRoVHJhbnNwYXJlbnRMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSAoKChsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdKSAqIGxheWVyLmFscGhhIC8gMTAwKSAgfCAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGEyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMCxcblxuICAgICAgICAgICAgICAgICAgICBhbHBoYTEyID0gKGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiA9IChhbHBoYTEgKiAoYWxwaGEyIF4gMHhmZikgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGFuMTIgPSAoKGFscGhhMSBeIDB4ZmYpICogYWxwaGEyIC8gMjU1KSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExMiAqICgoY29sb3IxID09IDApID8gMCA6IDI1NSAtIE1hdGgubWluKDI1NSwgKDI1NSAtIGNvbG9yMikgKiAyNTUgLyAoMiAqIGNvbG9yMSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExMiAqIChjb2xvcjEgPT0gMjU1ID8gMjU1IDogTWF0aC5taW4oMjU1LCBjb2xvcjIgKiAyNTUgLyAoMiAqICgyNTUgLSBjb2xvcjEpKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExMiAqICgoY29sb3IxID09IDApID8gMCA6IDI1NSAtIE1hdGgubWluKDI1NSwgKDI1NSAtIGNvbG9yMikgKiAyNTUgLyAoMiAqIGNvbG9yMSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExMiAqIChjb2xvcjEgPT0gMjU1ID8gMjU1IDogTWF0aC5taW4oMjU1LCBjb2xvcjIgKiAyNTUgLyAoMiAqICgyNTUgLSBjb2xvcjEpKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA8PSAxMjdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAoYWxwaGExMiAqICgoY29sb3IxID09IDApID8gMCA6IDI1NSAtIE1hdGgubWluKDI1NSwgKDI1NSAtIGNvbG9yMikgKiAyNTUgLyAoMiAqIGNvbG9yMSkpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiAoYWxwaGExMiAqIChjb2xvcjEgPT0gMjU1ID8gMjU1IDogTWF0aC5taW4oMjU1LCBjb2xvcjIgKiAyNTUgLyAoMiAqICgyNTUgLSBjb2xvcjEpKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcblxuICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgbGluZWFyTGlnaHQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIHBpeGVscyBtdXN0IGJlIG9wYXF1ZSwgYW5kIHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5saW5lYXJMaWdodE9udG9PcGFxdWVGdXNpb25XaXRoT3BhcXVlTGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFscGhhMSkge1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExID0gYWxwaGExIF4gMHhmZjtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExICogTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCBjb2xvcjIgKyAyICogbGF5ZXIuZGF0YVtwaXhJbmRleF0gLSAyNTUpKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqIE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgY29sb3IyICsgMiAqIGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXSAtIDI1NSkpXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExICogTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCBjb2xvcjIgKyAyICogbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdIC0gMjU1KSlcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIGxpbmVhckxpZ2h0IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLmxpbmVhckxpZ2h0T250b09wYXF1ZUZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgPSBhbHBoYTEgXiAweGZmO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIGNvbG9yMiArIDIgKiBsYXllci5kYXRhW3BpeEluZGV4XSAtIDI1NSkpXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExICogTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCBjb2xvcjIgKyAyICogbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdIC0gMjU1KSlcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIGNvbG9yMiArIDIgKiBsYXllci5kYXRhW3BpeEluZGV4ICsgMl0gLSAyNTUpKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgbGluZWFyTGlnaHQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIFRoZSBsYXllciBtdXN0IGhhdmUgaXRzIGxheWVyIGFscGhhIHNldCB0byAxMDBcbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5saW5lYXJMaWdodE9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmFscGhhMixcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweGZmKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhmZikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEyICogTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCBjb2xvcjIgKyAyICogY29sb3IxIC0gMjU1KSlcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMTIgKiBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIGNvbG9yMiArIDIgKiBjb2xvcjEgLSAyNTUpKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExMiAqIE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgY29sb3IyICsgMiAqIGNvbG9yMSAtIDI1NSkpXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBsaW5lYXJMaWdodCBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogRnVzaW9uIGNhbiBjb250YWluIHRyYW5zcGFyZW50IHBpeGVscywgYnV0IHRoZSBmdXNpb24gbGF5ZXIncyBvcGFjaXR5IG11c3QgYmUgc2V0IHRvIDEwMC5cbiAqL1xuXG4gICAgICAgICAgICAgICAgQ1BCbGVuZC5saW5lYXJMaWdodE9udG9UcmFuc3BhcmVudEZ1c2lvbldpdGhUcmFuc3BhcmVudExheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9ICgoKGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0pICogbGF5ZXIuYWxwaGEgLyAxMDApICB8IDApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIG5ld0FscGhhID0gKGFscGhhMSArIGFscGhhMiAtIGFscGhhMSAqIGFscGhhMiAvIDI1NSkgfCAwLFxuXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMTIgPSAoYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhMW4yID0gKGFscGhhMSAqIChhbHBoYTIgXiAweGZmKSAvIDI1NSkgfCAwLFxuICAgICAgICAgICAgICAgICAgICBhbHBoYW4xMiA9ICgoYWxwaGExIF4gMHhmZikgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXhdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEyICogTWF0aC5taW4oMjU1LCBNYXRoLm1heCgwLCBjb2xvcjIgKyAyICogY29sb3IxIC0gMjU1KSlcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMTIgKiBNYXRoLm1pbigyNTUsIE1hdGgubWF4KDAsIGNvbG9yMiArIDIgKiBjb2xvcjEgLSAyNTUpKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExMiAqIE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMCwgY29sb3IyICsgMiAqIGNvbG9yMSAtIDI1NSkpXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuXG4gICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSA9IG5ld0FscGhhO1xuICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBwaW5MaWdodCBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gcGl4ZWxzIG11c3QgYmUgb3BhcXVlLCBhbmQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnBpbkxpZ2h0T250b09wYXF1ZUZ1c2lvbldpdGhPcGFxdWVMYXllciA9IGZ1bmN0aW9uKGxheWVyLCBmdXNpb24sIHJlY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSB8IDAsXG53ID0gcmVjdC5nZXRXaWR0aCgpIHwgMCxcbnlTdHJpZGUgPSAoKGxheWVyLndpZHRoIC0gdykgKiBCWVRFU19QRVJfUElYRUwpIHwgMCxcbnBpeEluZGV4ID0gbGF5ZXIub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeSA9IDAgOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSxcbmNvbG9yMSxcbmNvbG9yMjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxwaGExKSB7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgPSBhbHBoYTEgXiAweGZmO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiAoKGNvbG9yMiA+PSAyICogY29sb3IxKSA/ICgyICogY29sb3IxKSA6IChjb2xvcjIgPD0gMiAqIGNvbG9yMSAtIDI1NSkgPyAoMiAqIGNvbG9yMSAtIDI1NSkgOiBjb2xvcjIpXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAxXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqICgoY29sb3IyID49IDIgKiBjb2xvcjEpID8gKDIgKiBjb2xvcjEpIDogKGNvbG9yMiA8PSAyICogY29sb3IxIC0gMjU1KSA/ICgyICogY29sb3IxIC0gMjU1KSA6IGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExICogKChjb2xvcjIgPj0gMiAqIGNvbG9yMSkgPyAoMiAqIGNvbG9yMSkgOiAoY29sb3IyIDw9IDIgKiBjb2xvcjEgLSAyNTUpID8gKDIgKiBjb2xvcjEgLSAyNTUpIDogY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8qKlxuICogQmxlbmQgdGhlIGdpdmVuIGxheWVyIG9udG8gdGhlIGZ1c2lvbiB1c2luZyB0aGUgcGluTGlnaHQgYmxlbmRpbmcgb3BlcmF0b3IuXG4gKiBcbiAqIEZ1c2lvbiBwaXhlbHMgbXVzdCBiZSBvcGFxdWUsIGFuZCB0aGUgZnVzaW9uIGxheWVyJ3Mgb3BhY2l0eSBtdXN0IGJlIHNldCB0byAxMDAuXG4gKi9cblxuICAgICAgICAgICAgICAgIENQQmxlbmQucGluTGlnaHRPbnRvT3BhcXVlRnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhMSA9IGFscGhhMSBeIDB4ZmY7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4XSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgaW52QWxwaGExICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMSAqICgoY29sb3IyID49IDIgKiBjb2xvcjEpID8gKDIgKiBjb2xvcjEpIDogKGNvbG9yMiA8PSAyICogY29sb3IxIC0gMjU1KSA/ICgyICogY29sb3IxIC0gMjU1KSA6IGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgKSAvIDI1NVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBpbnZBbHBoYTEgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExICogKChjb2xvcjIgPj0gMiAqIGNvbG9yMSkgPyAoMiAqIGNvbG9yMSkgOiAoY29sb3IyIDw9IDIgKiBjb2xvcjEgLSAyNTUpID8gKDIgKiBjb2xvcjEgLSAyNTUpIDogY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICApIC8gMjU1XG4gICAgICAgICAgICAgICAgKSB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IyID0gZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMl0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGludkFscGhhMSAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEgKiAoKGNvbG9yMiA+PSAyICogY29sb3IxKSA/ICgyICogY29sb3IxKSA6IChjb2xvcjIgPD0gMiAqIGNvbG9yMSAtIDI1NSkgPyAoMiAqIGNvbG9yMSAtIDI1NSkgOiBjb2xvcjIpXG4gICAgICAgICAgICAgICAgICAgICkgLyAyNTVcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgLyoqXG4gKiBCbGVuZCB0aGUgZ2l2ZW4gbGF5ZXIgb250byB0aGUgZnVzaW9uIHVzaW5nIHRoZSBwaW5MaWdodCBibGVuZGluZyBvcGVyYXRvci5cbiAqIFxuICogVGhlIGxheWVyIG11c3QgaGF2ZSBpdHMgbGF5ZXIgYWxwaGEgc2V0IHRvIDEwMFxuICogXG4gKiBGdXNpb24gY2FuIGNvbnRhaW4gdHJhbnNwYXJlbnQgcGl4ZWxzLCBidXQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnBpbkxpZ2h0T250b1RyYW5zcGFyZW50RnVzaW9uV2l0aE9wYXF1ZUxheWVyID0gZnVuY3Rpb24obGF5ZXIsIGZ1c2lvbiwgcmVjdCkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpIHwgMCxcbncgPSByZWN0LmdldFdpZHRoKCkgfCAwLFxueVN0cmlkZSA9ICgobGF5ZXIud2lkdGggLSB3KSAqIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxucGl4SW5kZXggPSBsYXllci5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciB5ID0gMCA7IHkgPCBoOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExLFxuYWxwaGEyLFxuY29sb3IxLFxuY29sb3IyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG5cbiAgICAgICAgICAgICAgICAgICAgYWxwaGExMiA9IChhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgPSAoYWxwaGExICogKGFscGhhMiBeIDB4ZmYpIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhbjEyID0gKChhbHBoYTEgXiAweGZmKSAqIGFscGhhMiAvIDI1NSkgfCAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMTIgKiAoKGNvbG9yMiA+PSAyICogY29sb3IxKSA/ICgyICogY29sb3IxKSA6IChjb2xvcjIgPD0gMiAqIGNvbG9yMSAtIDI1NSkgPyAoMiAqIGNvbG9yMSAtIDI1NSkgOiBjb2xvcjIpXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEyICogKChjb2xvcjIgPj0gMiAqIGNvbG9yMSkgPyAoMiAqIGNvbG9yMSkgOiAoY29sb3IyIDw9IDIgKiBjb2xvcjEgLSAyNTUpID8gKDIgKiBjb2xvcjEgLSAyNTUpIDogY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExMiAqICgoY29sb3IyID49IDIgKiBjb2xvcjEpID8gKDIgKiBjb2xvcjEpIDogKGNvbG9yMiA8PSAyICogY29sb3IxIC0gMjU1KSA/ICgyICogY29sb3IxIC0gMjU1KSA6IGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG5cbiAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdID0gbmV3QWxwaGE7XG4gICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvKipcbiAqIEJsZW5kIHRoZSBnaXZlbiBsYXllciBvbnRvIHRoZSBmdXNpb24gdXNpbmcgdGhlIHBpbkxpZ2h0IGJsZW5kaW5nIG9wZXJhdG9yLlxuICogXG4gKiBGdXNpb24gY2FuIGNvbnRhaW4gdHJhbnNwYXJlbnQgcGl4ZWxzLCBidXQgdGhlIGZ1c2lvbiBsYXllcidzIG9wYWNpdHkgbXVzdCBiZSBzZXQgdG8gMTAwLlxuICovXG5cbiAgICAgICAgICAgICAgICBDUEJsZW5kLnBpbkxpZ2h0T250b1RyYW5zcGFyZW50RnVzaW9uV2l0aFRyYW5zcGFyZW50TGF5ZXIgPSBmdW5jdGlvbihsYXllciwgZnVzaW9uLCByZWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCkgfCAwLFxudyA9IHJlY3QuZ2V0V2lkdGgoKSB8IDAsXG55U3RyaWRlID0gKChsYXllci53aWR0aCAtIHcpICogQllURVNfUEVSX1BJWEVMKSB8IDAsXG5waXhJbmRleCA9IGxheWVyLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCkgfCAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIHkgPSAwIDsgeSA8IGg7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IEJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTEsXG5hbHBoYTIsXG5jb2xvcjEsXG5jb2xvcjI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExID0gKCgobGF5ZXIuZGF0YVtwaXhJbmRleCArIEFMUEhBX0JZVEVfT0ZGU0VUXSkgKiBsYXllci5hbHBoYSAvIDEwMCkgIHwgMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmIChhbHBoYTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYWxwaGExICsgYWxwaGEyIC0gYWxwaGExICogYWxwaGEyIC8gMjU1KSB8IDAsXG5cbiAgICAgICAgICAgICAgICAgICAgYWxwaGExMiA9IChhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMCxcbiAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgPSAoYWxwaGExICogKGFscGhhMiBeIDB4ZmYpIC8gMjU1KSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGFscGhhbjEyID0gKChhbHBoYTEgXiAweGZmKSAqIGFscGhhMiAvIDI1NSkgfCAwO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjEgPSBsYXllci5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleF0gPSAoXG4gICAgICAgICAgICAgICAgICAgIChcbiAgICAgICAgICAgICAgICAgICAgICAgIGFscGhhMW4yICogY29sb3IxXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhbjEyICogY29sb3IyXG4gICAgICAgICAgICAgICAgICAgICAgICArIGFscGhhMTIgKiAoKGNvbG9yMiA+PSAyICogY29sb3IxKSA/ICgyICogY29sb3IxKSA6IChjb2xvcjIgPD0gMiAqIGNvbG9yMSAtIDI1NSkgPyAoMiAqIGNvbG9yMSAtIDI1NSkgOiBjb2xvcjIpXG4gICAgICAgICAgICAgICAgICAgICkgLyBuZXdBbHBoYVxuICAgICAgICAgICAgICAgICkgfCAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IxID0gbGF5ZXIuZGF0YVtwaXhJbmRleCArIDFdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMiA9IGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgMV07XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmdXNpb24uZGF0YVtwaXhJbmRleCArIDFdID0gKFxuICAgICAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYTFuMiAqIGNvbG9yMVxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYW4xMiAqIGNvbG9yMlxuICAgICAgICAgICAgICAgICAgICAgICAgKyBhbHBoYTEyICogKChjb2xvcjIgPj0gMiAqIGNvbG9yMSkgPyAoMiAqIGNvbG9yMSkgOiAoY29sb3IyIDw9IDIgKiBjb2xvcjEgLSAyNTUpID8gKDIgKiBjb2xvcjEgLSAyNTUpIDogY29sb3IyKVxuICAgICAgICAgICAgICAgICAgICApIC8gbmV3QWxwaGFcbiAgICAgICAgICAgICAgICApIHwgMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yMSA9IGxheWVyLmRhdGFbcGl4SW5kZXggKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xvcjIgPSBmdXNpb24uZGF0YVtwaXhJbmRleCArIDJdO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgZnVzaW9uLmRhdGFbcGl4SW5kZXggKyAyXSA9IChcbiAgICAgICAgICAgICAgICAgICAgKFxuICAgICAgICAgICAgICAgICAgICAgICAgYWxwaGExbjIgKiBjb2xvcjFcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGFuMTIgKiBjb2xvcjJcbiAgICAgICAgICAgICAgICAgICAgICAgICsgYWxwaGExMiAqICgoY29sb3IyID49IDIgKiBjb2xvcjEpID8gKDIgKiBjb2xvcjEpIDogKGNvbG9yMiA8PSAyICogY29sb3IxIC0gMjU1KSA/ICgyICogY29sb3IxIC0gMjU1KSA6IGNvbG9yMilcbiAgICAgICAgICAgICAgICAgICAgKSAvIG5ld0FscGhhXG4gICAgICAgICAgICAgICAgKSB8IDA7XG5cbiAgICAgICAgICAgIGZ1c2lvbi5kYXRhW3BpeEluZGV4ICsgQUxQSEFfQllURV9PRkZTRVRdID0gbmV3QWxwaGE7XG4gICAgICAgIFxuICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICBcbiAgICBDUEJsZW5kLkxNX05PUk1BTCA9IDA7XG4gICAgQ1BCbGVuZC5MTV9NVUxUSVBMWSA9IDE7XG4gICAgQ1BCbGVuZC5MTV9BREQgPSAyO1xuICAgIENQQmxlbmQuTE1fU0NSRUVOID0gMztcbiAgICBDUEJsZW5kLkxNX0xJR0hURU4gPSA0O1xuICAgIENQQmxlbmQuTE1fREFSS0VOID0gNTtcbiAgICBDUEJsZW5kLkxNX1NVQlRSQUNUID0gNjtcbiAgICBDUEJsZW5kLkxNX0RPREdFID0gNztcbiAgICBDUEJsZW5kLkxNX0JVUk4gPSA4O1xuICAgIENQQmxlbmQuTE1fT1ZFUkxBWSA9IDk7XG4gICAgQ1BCbGVuZC5MTV9IQVJETElHSFQgPSAxMDtcbiAgICBDUEJsZW5kLkxNX1NPRlRMSUdIVCA9IDExO1xuICAgIENQQmxlbmQuTE1fVklWSURMSUdIVCA9IDEyO1xuICAgIENQQmxlbmQuTE1fTElORUFSTElHSFQgPSAxMztcbiAgICBDUEJsZW5kLkxNX1BJTkxJR0hUID0gMTQ7XG5cbi8qKlxuICogRnVzZSB0aGUgZ2l2ZW4gbGF5ZXIgb24gdG9wIG9mIHRoZSBnaXZlbiBmdXNpb24gbGF5ZXIsIHVzaW5nIHRoZSBibGVuZGluZyBvcGVyYXRpb24gZGVmaW5lZCBpbiB0aGUgbGF5ZXIuXG4gKlxuICogQHBhcmFtIHtDUExheWVyfSBmdXNpb24gLSBMYXllciB0byBmdXNlIG9uIHRvcCBvZlxuICogQHBhcmFtIHtib29sZWFufSBmdXNpb25IYXNUcmFuc3BhcmVuY3kgLSBUcnVlIGlmIHRoZSBmdXNpb24gbGF5ZXIgaGFzIGFscGhhIDwgMTAwLCBvciBhbnkgdHJhbnNwYXJlbnQgcGl4ZWxzLlxuICogQHBhcmFtIHtDUExheWVyfSBsYXllciAtIExheWVyIHRoYXQgc2hvdWxkIGJlIGRyYXduIG9uIHRvcCBvZiB0aGUgZnVzaW9uXG4gKiBAcGFyYW0ge0NQUmVjdH0gcmVjdCAtIFRoZSByZWN0YW5nbGUgb2YgcGl4ZWxzIHRoYXQgc2hvdWxkIGJlIGZ1c2VkLlxuICovXG5DUEJsZW5kLmZ1c2VMYXllciA9IGZ1bmN0aW9uIChmdXNpb24sIGZ1c2lvbkhhc1RyYW5zcGFyZW5jeSwgbGF5ZXIsIHJlY3QpIHtcbiAgICBpZiAobGF5ZXIuYWxwaGEgPD0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyXG4gICAgICAgIGZ1bmNOYW1lID0gQkxFTkRfTU9ERV9OQU1FU1tsYXllci5ibGVuZE1vZGVdICsgXCJPbnRvXCI7XG5cbiAgICBpZiAoZnVzaW9uLmFscGhhIDwgMTAwKSB7XG4gICAgICAgIHRocm93IFwiRnVzaW9uIGxheWVyIGFscGhhIDwgMTAwIG5vdCBzdXBwb3J0ZWQuXCI7XG4gICAgfVxuXG4gICAgaWYgKGZ1c2lvbkhhc1RyYW5zcGFyZW5jeSkge1xuICAgICAgICBmdW5jTmFtZSArPSBcIlRyYW5zcGFyZW50RnVzaW9uXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY05hbWUgKz0gXCJPcGFxdWVGdXNpb25cIjtcbiAgICB9XG5cbiAgICBpZiAobGF5ZXIuYWxwaGEgPT0gMTAwKSB7XG4gICAgICAgIGZ1bmNOYW1lICs9IFwiV2l0aE9wYXF1ZUxheWVyXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZnVuY05hbWUgKz0gXCJXaXRoVHJhbnNwYXJlbnRMYXllclwiO1xuICAgIH1cblxuICAgIGZ1c2lvbi5nZXRCb3VuZHMoKS5jbGlwKHJlY3QpO1xuXG4gICAgdGhpc1tmdW5jTmFtZV0obGF5ZXIsIGZ1c2lvbiwgcmVjdCk7XG59O1xuZnVuY3Rpb24gbWFrZUxvb2t1cFRhYmxlcygpIHtcbiAgICAvLyBWIC0gVl4yIHRhYmxlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHYgPSBpIC8gMjU1O1xuXG4gICAgICAgIHNvZnRMaWdodExVVFNxdWFyZVtpXSA9ICgodiAtIHYgKiB2KSAqIDI1NSkgfCAwO1xuICAgIH1cblxuICAgIC8vIHNxcnQoVikgLSBWIHRhYmxlXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHYgPSBpIC8gMjU1O1xuXG4gICAgICAgIHNvZnRMaWdodExVVFNxdWFyZVJvb3RbaV0gPSAoKE1hdGguc3FydCh2KSAtIHYpICogMjU1KSB8IDA7XG4gICAgfVxufVxubWFrZUxvb2t1cFRhYmxlcygpO1xuIiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQnJ1c2hJbmZvKHByb3BlcnRpZXMpIHtcbiAgICAvLyBTZXQgYnJ1c2ggc2V0dGluZyBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcywgdGhlbiBhcHBseSB0aGUgc3VwcGxpZWQgJ3Byb3BlcnRpZXMnIG9uIHRvcFxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIENQQnJ1c2hJbmZvLkRFRkFVTFRTKSB7XG4gICAgICAgIGlmIChDUEJydXNoSW5mby5ERUZBVUxUUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXNbcHJvcE5hbWVdID0gQ1BCcnVzaEluZm8uREVGQVVMVFNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIHByb3BlcnRpZXMpIHtcbiAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgICAgICB0aGlzW3Byb3BOYW1lXSA9IHByb3BlcnRpZXNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vLyBTdHJva2UgbW9kZXNcbkNQQnJ1c2hJbmZvLlNNX0ZSRUVIQU5EID0gMDtcbkNQQnJ1c2hJbmZvLlNNX0xJTkUgPSAxO1xuQ1BCcnVzaEluZm8uU01fQkVaSUVSID0gMjtcblxuLy8gQnJ1c2ggZGFiIHR5cGVzXG5DUEJydXNoSW5mby5CX1JPVU5EX1BJWEVMID0gMDtcbkNQQnJ1c2hJbmZvLkJfUk9VTkRfQUEgPSAxO1xuQ1BCcnVzaEluZm8uQl9ST1VORF9BSVJCUlVTSCA9IDI7XG5DUEJydXNoSW5mby5CX1NRVUFSRV9QSVhFTCA9IDM7XG5DUEJydXNoSW5mby5CX1NRVUFSRV9BQSA9IDQ7XG5cbi8vIHBhaW50aW5nIG1vZGVzXG5DUEJydXNoSW5mby5NX1BBSU5UID0gMDtcbkNQQnJ1c2hJbmZvLk1fRVJBU0UgPSAxO1xuQ1BCcnVzaEluZm8uTV9ET0RHRSA9IDI7XG5DUEJydXNoSW5mby5NX0JVUk4gPSAzO1xuQ1BCcnVzaEluZm8uTV9XQVRFUiA9IDQ7XG5DUEJydXNoSW5mby5NX0JMVVIgPSA1O1xuQ1BCcnVzaEluZm8uTV9TTVVER0UgPSA2O1xuQ1BCcnVzaEluZm8uTV9PSUwgPSA3O1xuXG5DUEJydXNoSW5mby5ERUZBVUxUUyA9IHtcbiAgICBpc0FBOiBmYWxzZSwgaXNBaXJicnVzaDogZmFsc2UsXG4gICAgbWluU3BhY2luZzogMCwgc3BhY2luZzogMCxcbiAgICBcbiAgICBwcmVzc3VyZVNpemU6IHRydWUsXG4gICAgcHJlc3N1cmVBbHBoYTogZmFsc2UsXG4gICAgcHJlc3N1cmVTY2F0dGVyaW5nOiBmYWxzZSxcbiAgICBcbiAgICB0eXBlOiAwLCBwYWludE1vZGU6IDAsXG4gICAgc3Ryb2tlTW9kZTogQ1BCcnVzaEluZm8uU01fRlJFRUhBTkQsXG4gICAgcmVzYXQ6IDEuMCwgYmxlZWQ6IDAuMCxcblxuICAgIHRleHR1cmU6IDEuMCxcbiAgICBcbiAgICAvLyBcImN1clwiIHZhbHVlcyBhcmUgY3VycmVudCBicnVzaCBzZXR0aW5ncyAob25jZSB0YWJsZXQgcHJlc3N1cmUgYW5kIHN0dWZmIGlzIGFwcGxpZWQpXG4gICAgc2l6ZTogMCwgY3VyU2l6ZTogMCxcbiAgICBhbHBoYTogMCwgY3VyQWxwaGE6IDAsXG4gICAgc2NhdHRlcmluZzogMC4wLCBjdXJTY2F0dGVyaW5nOiAwLFxuICAgIHNxdWVlemU6IDAuMCwgY3VyU3F1ZWV6ZTogMCxcbiAgICBhbmdsZTogTWF0aC5QSSwgY3VyQW5nbGU6IDAsXG4gICAgXG4gICAgc21vb3RoaW5nOiAwLjBcbn07XG5cbkNQQnJ1c2hJbmZvLnByb3RvdHlwZS5hcHBseVByZXNzdXJlID0gZnVuY3Rpb24ocHJlc3N1cmUpIHtcbiAgICAvLyBGSVhNRTogbm8gdmFyaWFibGUgc2l6ZSBmb3Igc211ZGdlIGFuZCBvaWwgOihcbiAgICBpZiAodGhpcy5wcmVzc3VyZVNpemUgJiYgdGhpcy5wYWludE1vZGUgIT0gQ1BCcnVzaEluZm8uTV9TTVVER0UgJiYgdGhpcy5wYWludE1vZGUgIT0gQ1BCcnVzaEluZm8uTV9PSUwpIHtcbiAgICAgICAgdGhpcy5jdXJTaXplID0gTWF0aC5tYXgoMC4xLCB0aGlzLnNpemUgKiBwcmVzc3VyZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdXJTaXplID0gTWF0aC5tYXgoMC4xLCB0aGlzLnNpemUpO1xuICAgIH1cblxuICAgIC8vIEZJWE1FOiB3aGF0IGlzIHRoZSBwb2ludCBvZiBkb2luZyB0aGF0P1xuICAgIGlmICh0aGlzLmN1clNpemUgPiAxNikge1xuICAgICAgICB0aGlzLmN1clNpemUgPSBNYXRoLmZsb29yKHRoaXMuY3VyU2l6ZSk7XG4gICAgfVxuXG4gICAgdGhpcy5jdXJBbHBoYSA9IHRoaXMucHJlc3N1cmVBbHBoYSA/IE1hdGguZmxvb3IodGhpcy5hbHBoYSAqIE1hdGgubWluKHByZXNzdXJlLCAxLjApKSA6IHRoaXMuYWxwaGE7XG4gICAgdGhpcy5jdXJTcXVlZXplID0gdGhpcy5zcXVlZXplO1xuICAgIHRoaXMuY3VyQW5nbGUgPSB0aGlzLmFuZ2xlO1xuICAgIHRoaXMuY3VyU2NhdHRlcmluZyA9IHRoaXMuc2NhdHRlcmluZyAqIHRoaXMuY3VyU2l6ZSAqICh0aGlzLnByZXNzdXJlU2NhdHRlcmluZyA/IHByZXNzdXJlIDogMS4wKTtcbn07XG5cbkNQQnJ1c2hJbmZvLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgQ1BCcnVzaEluZm8odGhpcyk7XG59O1xuIiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBDUEJydXNoSW5mbyBmcm9tIFwiLi9DUEJydXNoSW5mb1wiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUEJydXNoTWFuYWdlcigpIHtcbiAgICBjb25zdFxuICAgICAgICBNQVhfU1FVRUVaRSA9IDEwLFxuICAgICAgICBCUlVTSF9NQVhfRElNID0gMjAxLFxuICAgICAgICBCUlVTSF9BQV9NQVhfRElNID0gMjAyO1xuICAgIFxuICAgIC8qQ1BCcnVzaERhYiB7XG4gICAgICAgIC8vIHRoZSBicnVzaFxuICAgICAgICBVaW50OEFycmF5IGJydXNoO1xuICAgICAgICBpbnQgd2lkdGgsIGhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIC8vIGFuZCB3aGVyZSBhbmQgaG93IHRvIGFwcGx5IGl0XG4gICAgICAgIGludCB4LCB5LCBhbHBoYTtcbiAgICB9Ki9cbiAgICBcbiAgICB2YXJcbiAgICAgICAgYnJ1c2ggPSBuZXcgVWludDhBcnJheShCUlVTSF9NQVhfRElNICogQlJVU0hfTUFYX0RJTSksXG4gICAgICAgIGJydXNoQUEgPSBuZXcgVWludDhBcnJheShCUlVTSF9BQV9NQVhfRElNICogQlJVU0hfQUFfTUFYX0RJTSksXG5cbiAgICAgICAgY2FjaGVCcnVzaCA9IG51bGwsXG4gICAgICAgIGNhY2hlU2l6ZSwgY2FjaGVTcXVlZXplLCBjYWNoZUFuZ2xlLFxuICAgICAgICBjYWNoZVR5cGUsXG5cbiAgICAgICAgdGhhdCA9IHRoaXM7IFxuXG4gICAgLyoqXG4gICAgICogU2hpZnQgYSBicnVzaCBieSBhIHBvc2l0aXZlIHN1Yi1waXhlbCBhbW91bnQgKGR4LCBkeSkgWzAuLjEpLCBhbmQgcmV0dXJuIHRoZSBuZXcgYnJ1c2guIFxuICAgICAqIFxuICAgICAqIFRoZSByZXN1bHRpbmcgYnJ1c2ggYXJyYXkgaXMgMSBwaXhlbCBsYXJnZXIgdGhhbiB0aGUgb3JpZ2luYWwgb25lIGluIGJvdGggZGltZW5zaW9ucy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRCcnVzaFdpdGhBQShicnVzaEluZm8sIGR4LCBkeSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIG5vbkFBQnJ1c2ggPSBnZXRCcnVzaChicnVzaEluZm8pLFxuXG4gICAgICAgICAgICBpbnRTaXplID0gTWF0aC5jZWlsKGJydXNoSW5mby5jdXJTaXplKSxcbiAgICAgICAgICAgIGludFNpemVBQSA9IE1hdGguY2VpbChicnVzaEluZm8uY3VyU2l6ZSkgKyAxO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBpbnRTaXplQUEgKiBpbnRTaXplQUE7IHgrKykge1xuICAgICAgICAgICAgYnJ1c2hBQVt4XSA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhclxuICAgICAgICAgICAgaW52ZHhfaW52ZHkgPSAoMSAtIGR4KSAqICgxIC0gZHkpLFxuICAgICAgICAgICAgZHhfaW52ZHkgPSBkeCAqICgxIC0gZHkpLFxuICAgICAgICAgICAgZHhfZHkgPSBkeCAqIGR5LFxuICAgICAgICAgICAgaW52ZHhfZHkgPSAoMSAtIGR4KSAqIGR5LFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzcmNJbmRleCA9IDAsXG4gICAgICAgICAgICBkc3RJbmRleCA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGludFNpemU7IHkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCBpbnRTaXplOyB4KyspIHtcbiAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgIGJydXNoQWxwaGEgPSBub25BQUJydXNoW3NyY0luZGV4XTtcblxuICAgICAgICAgICAgICAgIC8qIFxuICAgICAgICAgICAgICAgICAqIFVzZSBhIHdlaWdodGVkIHN1bSB0byBzaGlmdCB0aGUgc291cmNlIHBpeGVscydzIHBvc2l0aW9uIGJ5IGEgc3ViLXBpeGVsIGFtb3VudCBkeCwgZHkgYW5kIGFjY3VtdWxhdGVcbiAgICAgICAgICAgICAgICAgKiBpdCBpbnRvIHRoZSBmaW5hbCBicnVzaEFBIGFycmF5LlxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGJydXNoQUFbZHN0SW5kZXhdICs9IH5+KGJydXNoQWxwaGEgKiBpbnZkeF9pbnZkeSk7XG4gICAgICAgICAgICAgICAgYnJ1c2hBQVtkc3RJbmRleCArIDFdICs9IH5+KGJydXNoQWxwaGEgKiBkeF9pbnZkeSk7XG4gICAgICAgICAgICAgICAgYnJ1c2hBQVtkc3RJbmRleCArIDEgKyBpbnRTaXplQUFdICs9IH5+KGJydXNoQWxwaGEgKiBkeF9keSk7XG4gICAgICAgICAgICAgICAgYnJ1c2hBQVtkc3RJbmRleCArIGludFNpemVBQV0gKz0gfn4oYnJ1c2hBbHBoYSAqIGludmR4X2R5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzcmNJbmRleCsrO1xuICAgICAgICAgICAgICAgIGRzdEluZGV4Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkc3RJbmRleCArPSBpbnRTaXplQUEgLSBpbnRTaXplO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJydXNoQUE7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRCcnVzaChicnVzaCwgYnJ1c2hJbmZvKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgaW50U2l6ZSA9IE1hdGguY2VpbChicnVzaEluZm8uY3VyU2l6ZSksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNlbnRlciA9IGludFNpemUgLyAyLjAsXG4gICAgICAgICAgICBzcXJSYWRpdXMgPSAoYnJ1c2hJbmZvLmN1clNpemUgLyAyKSAqIChicnVzaEluZm8uY3VyU2l6ZSAvIDIpLFxuICAgIFxuICAgICAgICAgICAgeEZhY3RvciA9IDEuMCArIGJydXNoSW5mby5jdXJTcXVlZXplICogTUFYX1NRVUVFWkUsXG4gICAgICAgICAgICBjb3NBID0gTWF0aC5jb3MoYnJ1c2hJbmZvLmN1ckFuZ2xlKSxcbiAgICAgICAgICAgIHNpbkEgPSBNYXRoLnNpbihicnVzaEluZm8uY3VyQW5nbGUpLFxuICAgIFxuICAgICAgICAgICAgb2Zmc2V0ID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaW50U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludFNpemU7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgeCA9IChpICsgMC41IC0gY2VudGVyKSxcbiAgICAgICAgICAgICAgICAgICAgeSA9IChqICsgMC41IC0gY2VudGVyKSxcbiAgICAgICAgICAgICAgICAgICAgZHggPSAoeCAqIGNvc0EgLSB5ICogc2luQSkgKiB4RmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICBkeSA9ICh5ICogY29zQSArIHggKiBzaW5BKSxcblxuICAgICAgICAgICAgICAgICAgICBzcXJEaXN0ID0gZHggKiBkeCArIGR5ICogZHk7XG5cbiAgICAgICAgICAgICAgICBpZiAoc3FyRGlzdCA8PSBzcXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJ1c2hbb2Zmc2V0KytdID0gMHhGRjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicnVzaFtvZmZzZXQrK10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBicnVzaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEJydXNoQUEoYnJ1c2gsIGJydXNoSW5mbykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGludFNpemUgPSBNYXRoLmNlaWwoYnJ1c2hJbmZvLmN1clNpemUpLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjZW50ZXIgPSBpbnRTaXplIC8gMi4wLFxuICAgICAgICAgICAgc3FyUmFkaXVzID0gKGJydXNoSW5mby5jdXJTaXplIC8gMikgKiAoYnJ1c2hJbmZvLmN1clNpemUgLyAyKSxcbiAgICAgICAgICAgIHNxclJhZGl1c0lubmVyID0gKChicnVzaEluZm8uY3VyU2l6ZSAtIDIpIC8gMikgKiAoKGJydXNoSW5mby5jdXJTaXplIC0gMikgLyAyKSxcbiAgICAgICAgICAgIHNxclJhZGl1c091dGVyID0gKChicnVzaEluZm8uY3VyU2l6ZSArIDIpIC8gMikgKiAoKGJydXNoSW5mby5jdXJTaXplICsgMikgLyAyKSxcblxuICAgICAgICAgICAgeEZhY3RvciA9IDEuMCArIGJydXNoSW5mby5jdXJTcXVlZXplICogTUFYX1NRVUVFWkUsXG4gICAgICAgICAgICBjb3NBID0gTWF0aC5jb3MoYnJ1c2hJbmZvLmN1ckFuZ2xlKSxcbiAgICAgICAgICAgIHNpbkEgPSBNYXRoLnNpbihicnVzaEluZm8uY3VyQW5nbGUpLFxuXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnRTaXplOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgICAgICB4ID0gKGkgKyAwLjUgLSBjZW50ZXIpLFxuICAgICAgICAgICAgICAgICAgICB5ID0gKGogKyAwLjUgLSBjZW50ZXIpLFxuICAgICAgICAgICAgICAgICAgICBkeCA9ICh4ICogY29zQSAtIHkgKiBzaW5BKSAqIHhGYWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gKHkgKiBjb3NBICsgeCAqIHNpbkEpLFxuXG4gICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgICAgICAgICAgICAgIGlmIChzcXJEaXN0IDw9IHNxclJhZGl1c0lubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJydXNoW29mZnNldCsrXSA9IDB4RkY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChzcXJEaXN0ID4gc3FyUmFkaXVzT3V0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJ1c2hbb2Zmc2V0KytdID0gMDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBveSA9IDA7IG95IDwgNDsgb3krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgb3ggPSAwOyBveCA8IDQ7IG94KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gaSArIG94ICogKDEuMCAvIDQuMCkgLSBjZW50ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGogKyBveSAqICgxLjAgLyA0LjApIC0gY2VudGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gKHggKiBjb3NBIC0geSAqIHNpbkEpICogeEZhY3RvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkeSA9ICh5ICogY29zQSArIHggKiBzaW5BKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3FyRGlzdCA8PSBzcXJSYWRpdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJ1c2hbb2Zmc2V0KytdID0gTWF0aC5taW4oY291bnQgKiAxNiwgMjU1KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYnVpbGRCcnVzaFNxdWFyZShicnVzaCwgYnJ1c2hJbmZvKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgaW50U2l6ZSA9IE1hdGguY2VpbChicnVzaEluZm8uY3VyU2l6ZSksXG4gICAgICAgICAgICBjZW50ZXIgPSBpbnRTaXplIC8gMi4wLFxuXG4gICAgICAgICAgICBzaXplID0gYnJ1c2hJbmZvLmN1clNpemUgKiBNYXRoLnNpbihNYXRoLlBJIC8gNCksXG4gICAgICAgICAgICBzaXplWCA9IChzaXplIC8gMikgLyAoMS4wICsgYnJ1c2hJbmZvLmN1clNxdWVlemUgKiBNQVhfU1FVRUVaRSksXG4gICAgICAgICAgICBzaXplWSA9IChzaXplIC8gMiksXG5cbiAgICAgICAgICAgIGNvc0EgPSBNYXRoLmNvcyhicnVzaEluZm8uY3VyQW5nbGUpLFxuICAgICAgICAgICAgc2luQSA9IE1hdGguc2luKGJydXNoSW5mby5jdXJBbmdsZSksXG5cbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGludFNpemU7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgIHggPSAoaSArIDAuNSAtIGNlbnRlciksXG4gICAgICAgICAgICAgICAgICAgIHkgPSAoaiArIDAuNSAtIGNlbnRlciksXG4gICAgICAgICAgICAgICAgICAgIGR4ID0gTWF0aC5hYnMoeCAqIGNvc0EgLSB5ICogc2luQSksXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gTWF0aC5hYnMoeSAqIGNvc0EgKyB4ICogc2luQSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHggPD0gc2l6ZVggJiYgZHkgPD0gc2l6ZVkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJ1c2hbb2Zmc2V0KytdID0gMHhGRjtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBicnVzaFtvZmZzZXQrK10gPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBicnVzaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEJydXNoU3F1YXJlQUEoYnJ1c2gsIGJydXNoSW5mbykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGludFNpemUgPSBNYXRoLmNlaWwoYnJ1c2hJbmZvLmN1clNpemUpLFxuICAgICAgICAgICAgY2VudGVyID0gaW50U2l6ZSAvIDIuMCxcblxuICAgICAgICAgICAgc2l6ZSA9IGJydXNoSW5mby5jdXJTaXplICogTWF0aC5zaW4oTWF0aC5QSSAvIDQpLFxuICAgICAgICAgICAgc2l6ZVggPSAoc2l6ZSAvIDIpIC8gKDEuMCArIGJydXNoSW5mby5jdXJTcXVlZXplICogTUFYX1NRVUVFWkUpLFxuICAgICAgICAgICAgc2l6ZVkgPSAoc2l6ZSAvIDIpLFxuXG4gICAgICAgICAgICBzaXplWElubmVyID0gc2l6ZVggLSAxLFxuICAgICAgICAgICAgc2l6ZVlJbm5lciA9IHNpemVZIC0gMSxcblxuICAgICAgICAgICAgc2l6ZVhPdXRlciA9IHNpemVYICsgMSxcbiAgICAgICAgICAgIHNpemVZT3V0ZXIgPSBzaXplWSArIDEsXG5cbiAgICAgICAgICAgIGNvc0EgPSBNYXRoLmNvcyhicnVzaEluZm8uY3VyQW5nbGUpLFxuICAgICAgICAgICAgc2luQSA9IE1hdGguc2luKGJydXNoSW5mby5jdXJBbmdsZSksXG5cbiAgICAgICAgICAgIG9mZnNldCA9IDA7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGludFNpemU7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnRTaXplOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgIHggPSAoaSArIDAuNSAtIGNlbnRlciksXG4gICAgICAgICAgICAgICAgICAgIHkgPSAoaiArIDAuNSAtIGNlbnRlciksXG4gICAgICAgICAgICAgICAgICAgIGR4ID0gTWF0aC5hYnMoeCAqIGNvc0EgLSB5ICogc2luQSksXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gTWF0aC5hYnMoeSAqIGNvc0EgKyB4ICogc2luQSk7XG5cbiAgICAgICAgICAgICAgICBpZiAoZHggPD0gc2l6ZVhJbm5lciAmJiBkeSA8PSBzaXplWUlubmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJydXNoW29mZnNldCsrXSA9IDB4RkY7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkeCA+IHNpemVYT3V0ZXIgfHwgZHkgPiBzaXplWU91dGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJydXNoW29mZnNldCsrXSA9IDA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBveSA9IDA7IG95IDwgNDsgb3krKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgb3ggPSAwOyBveCA8IDQ7IG94KyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB4ID0gaSArIG94ICogKDEuMCAvIDQuMCkgLSBjZW50ZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeSA9IGogKyBveSAqICgxLjAgLyA0LjApIC0gY2VudGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGR4ID0gTWF0aC5hYnMoeCAqIGNvc0EgLSB5ICogc2luQSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHkgPSBNYXRoLmFicyh5ICogY29zQSArIHggKiBzaW5BKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkeCA8PSBzaXplWCAmJiBkeSA8PSBzaXplWSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicnVzaFtvZmZzZXQrK10gPSBNYXRoLm1pbihjb3VudCAqIDE2LCAyNTUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBicnVzaDtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBidWlsZEJydXNoU29mdChicnVzaCwgYnJ1c2hJbmZvKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgaW50U2l6ZSA9IE1hdGguY2VpbChicnVzaEluZm8uY3VyU2l6ZSksXG4gICAgICAgICAgICBjZW50ZXIgPSBpbnRTaXplIC8gMi4wLFxuICAgICAgICAgICAgc3FyUmFkaXVzID0gKGJydXNoSW5mby5jdXJTaXplIC8gMikgKiAoYnJ1c2hJbmZvLmN1clNpemUgLyAyKSxcblxuICAgICAgICAgICAgeEZhY3RvciA9IDEuMCArIGJydXNoSW5mby5jdXJTcXVlZXplICogTUFYX1NRVUVFWkUsXG4gICAgICAgICAgICBjb3NBID0gTWF0aC5jb3MoYnJ1c2hJbmZvLmN1ckFuZ2xlKSxcbiAgICAgICAgICAgIHNpbkEgPSBNYXRoLnNpbihicnVzaEluZm8uY3VyQW5nbGUpLFxuXG4gICAgICAgICAgICBvZmZzZXQgPSAwO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBpbnRTaXplOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW50U2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgICAgICB4ID0gKGkgKyAwLjUgLSBjZW50ZXIpLFxuICAgICAgICAgICAgICAgICAgICB5ID0gKGogKyAwLjUgLSBjZW50ZXIpLFxuICAgICAgICAgICAgICAgICAgICBkeCA9ICh4ICogY29zQSAtIHkgKiBzaW5BKSAqIHhGYWN0b3IsXG4gICAgICAgICAgICAgICAgICAgIGR5ID0gKHkgKiBjb3NBICsgeCAqIHNpbkEpLFxuXG4gICAgICAgICAgICAgICAgICAgIHNxckRpc3QgPSBkeCAqIGR4ICsgZHkgKiBkeTtcblxuICAgICAgICAgICAgICAgIGlmIChzcXJEaXN0IDw9IHNxclJhZGl1cykge1xuICAgICAgICAgICAgICAgICAgICBicnVzaFtvZmZzZXQrK10gPSB+figyNTUgKiAoMSAtIChzcXJEaXN0IC8gc3FyUmFkaXVzKSkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJydXNoW29mZnNldCsrXSA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJydXNoO1xuICAgIH0gXG4gICAgXG4gICAgLyoqXG4gICAgICogQnVpbGQgYW5kIHJldHVybiBhIGJydXNoIHRoYXQgY29uZm9ybXMgdG8gdGhlIGdpdmVuIGJydXNoIHNldHRpbmdzLlxuICAgICAqIFxuICAgICAqIEByZXR1cm5zIGEgVWludDhBcnJheVxuICAgICAqLyBcbiAgICBmdW5jdGlvbiBnZXRCcnVzaChicnVzaEluZm8pIHtcbiAgICAgICAgaWYgKGNhY2hlQnJ1c2ggIT0gbnVsbCAmJiBicnVzaEluZm8uY3VyU2l6ZSA9PSBjYWNoZVNpemUgJiYgYnJ1c2hJbmZvLmN1clNxdWVlemUgPT0gY2FjaGVTcXVlZXplXG4gICAgICAgICAgICAgICAgJiYgYnJ1c2hJbmZvLmN1ckFuZ2xlID09IGNhY2hlQW5nbGUgJiYgYnJ1c2hJbmZvLnR5cGUgPT0gY2FjaGVUeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVCcnVzaDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3dpdGNoIChicnVzaEluZm8udHlwZSkge1xuICAgICAgICAgICAgY2FzZSBDUEJydXNoSW5mby5CX1JPVU5EX0FJUkJSVVNIOlxuICAgICAgICAgICAgICAgIGJydXNoID0gYnVpbGRCcnVzaFNvZnQoYnJ1c2gsIGJydXNoSW5mbyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgQ1BCcnVzaEluZm8uQl9ST1VORF9BQTpcbiAgICAgICAgICAgICAgICBicnVzaCA9IGJ1aWxkQnJ1c2hBQShicnVzaCwgYnJ1c2hJbmZvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDUEJydXNoSW5mby5CX1JPVU5EX1BJWEVMOlxuICAgICAgICAgICAgICAgIGJydXNoID0gYnVpbGRCcnVzaChicnVzaCwgYnJ1c2hJbmZvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDUEJydXNoSW5mby5CX1NRVUFSRV9BQTpcbiAgICAgICAgICAgICAgICBicnVzaCA9IGJ1aWxkQnJ1c2hTcXVhcmVBQShicnVzaCwgYnJ1c2hJbmZvKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBDUEJydXNoSW5mby5CX1NRVUFSRV9QSVhFTDpcbiAgICAgICAgICAgICAgICBicnVzaCA9IGJ1aWxkQnJ1c2hTcXVhcmUoYnJ1c2gsIGJydXNoSW5mbyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGNhY2hlQnJ1c2ggPSBicnVzaDtcbiAgICAgICAgY2FjaGVTaXplID0gYnJ1c2hJbmZvLmN1clNpemU7XG4gICAgICAgIGNhY2hlVHlwZSA9IGJydXNoSW5mby50eXBlO1xuICAgICAgICBjYWNoZVNxdWVlemUgPSBicnVzaEluZm8uY3VyU3F1ZWV6ZTtcbiAgICAgICAgY2FjaGVBbmdsZSA9IGJydXNoSW5mby5jdXJBbmdsZTtcblxuICAgICAgICByZXR1cm4gYnJ1c2g7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGFwcGx5VGV4dHVyZShkYWIsIHRleHR1cmVBbW91bnQpIHtcbiAgICAgICAgdmFyIFxuICAgICAgICAgICAgYW1vdW50ID0gTWF0aC5mbG9vcih0ZXh0dXJlQW1vdW50ICogMjU1KSxcbiAgICAgICAgICAgIHRleHR1cmUgPSB0aGF0LnRleHR1cmUsXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRleHR1cmVYID0gZGFiLnggJSB0ZXh0dXJlLndpZHRoLFxuICAgICAgICAgICAgdGV4dHVyZVkgPSBkYWIueSAlIHRleHR1cmUuaGVpZ2h0LFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBicnVzaFBvcyA9IDAsXG4gICAgICAgICAgICB0ZXh0dXJlUG9zLCB0ZXh0dXJlRU9MO1xuXG4gICAgICAgIGlmICh0ZXh0dXJlWCA8IDApIHtcbiAgICAgICAgICAgIHRleHR1cmVYICs9IHRleHR1cmUud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGV4dHVyZVkgPCAwKSB7XG4gICAgICAgICAgICB0ZXh0dXJlWSArPSB0ZXh0dXJlLmhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBkYWIuaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIHRleHR1cmVQb3MgPSB0ZXh0dXJlWSAqIHRleHR1cmUud2lkdGggKyB0ZXh0dXJlWDtcbiAgICAgICAgICAgIHRleHR1cmVFT0wgPSB0ZXh0dXJlWSAqIHRleHR1cmUud2lkdGggKyB0ZXh0dXJlLndpZHRoO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRhYi53aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgICAgICBicnVzaFZhbHVlID0gZGFiLmJydXNoW2JydXNoUG9zXSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dHVyZVZhbHVlID0gdGV4dHVyZS5kYXRhW3RleHR1cmVQb3NdO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGRhYi5icnVzaFticnVzaFBvc10gPSB+fihicnVzaFZhbHVlICogKCh0ZXh0dXJlVmFsdWUgKiBhbW91bnQgLyAyNTUpIF4gMHhmZikgLyAyNTUpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJydXNoUG9zKys7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGV4dHVyZVBvcysrO1xuICAgICAgICAgICAgICAgIGlmICh0ZXh0dXJlUG9zID09IHRleHR1cmVFT0wpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV3JhcCB0byBsZWZ0IHNpZGUgb2YgdGV4dHVyZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlUG9zIC09IHRleHR1cmUud2lkdGg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0ZXh0dXJlWSsrO1xuICAgICAgICAgICAgaWYgKHRleHR1cmVZID09IHRleHR1cmUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAgICAgdGV4dHVyZVkgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB4IGZsb2F0XG4gICAgICogQHBhcmFtIHkgZmxvYXRcbiAgICAgKiBicnVzaEluZm8gLSBhIENQQnJ1c2hJbmZvIG9iamVjdFxuICAgICAqL1xuICAgIHRoaXMuZ2V0RGFiID0gZnVuY3Rpb24oeCwgeSwgYnJ1c2hJbmZvKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIGRhYiA9IHtcbiAgICAgICAgICAgICAgICBhbHBoYTogYnJ1c2hJbmZvLmN1ckFscGhhLFxuICAgICAgICAgICAgICAgIHdpZHRoOiBNYXRoLmNlaWwoYnJ1c2hJbmZvLmN1clNpemUpLFxuICAgICAgICAgICAgICAgIGhlaWdodDogTWF0aC5jZWlsKGJydXNoSW5mby5jdXJTaXplKVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAvLyBGSVhNRTogSSBkb24ndCBsaWtlIHRoaXMgc3BlY2lhbCBjYXNlIGZvciBST1VORF9QSVhFTFxuICAgICAgICAvLyBpdCB3b3VsZCBiZSBiZXR0ZXIgdG8gaGF2ZSBicnVzaCBwcmVzZXRzIGZvciB3b3JraW5nIHdpdGggcGl4ZWxzXG4gICAgICAgIHZhciB1c2VBQSA9IGJydXNoSW5mby5pc0FBICYmIGJydXNoSW5mby50eXBlICE9IENQQnJ1c2hJbmZvLkJfUk9VTkRfUElYRUw7XG5cbiAgICAgICAgaWYgKHVzZUFBKSB7XG4gICAgICAgICAgICBkYWIud2lkdGgrKztcbiAgICAgICAgICAgIGRhYi5oZWlnaHQrKztcbiAgICAgICAgfVxuXG4gICAgICAgIHZhclxuICAgICAgICAgICAgbnggPSB4IC0gZGFiLndpZHRoIC8gMi4wICsgMC41LFxuICAgICAgICAgICAgbnkgPSB5IC0gZGFiLmhlaWdodCAvIDIuMCArIDAuNTtcblxuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBhcyBKYXZhIHVzZXMgY29udmVydCB0b3dhcmRzIHplcm8gZmxvYXQgdG8gaW50IGNvbnZlcnNpb25cbiAgICAgICAgaWYgKG54IDwgMCkge1xuICAgICAgICAgICAgbnggLT0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobnkgPCAwKSB7XG4gICAgICAgICAgICBueSAtPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHVzZUFBKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBkeCA9IE1hdGguYWJzKG54IC0gfn5ueCksXG4gICAgICAgICAgICAgICAgZHkgPSBNYXRoLmFicyhueSAtIH5+bnkpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBkYWIuYnJ1c2ggPSBnZXRCcnVzaFdpdGhBQShicnVzaEluZm8sIGR4LCBkeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkYWIuYnJ1c2ggPSBnZXRCcnVzaChicnVzaEluZm8pO1xuICAgICAgICB9XG5cbiAgICAgICAgZGFiLnggPSB+fm54O1xuICAgICAgICBkYWIueSA9IH5+bnk7XG5cbiAgICAgICAgaWYgKGJydXNoSW5mby50ZXh0dXJlID4gMC4wICYmIHRoaXMudGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAvLyB3ZSBuZWVkIGEgYnJ1c2ggYml0bWFwIHRoYXQgY2FuIGJlIG1vZGlmaWVkIGV2ZXJ5dGltZVxuICAgICAgICAgICAgLy8gdGhlIG9uZSBpbiBcImJydXNoXCIgY2FuIGJlIGtlcHQgaW4gY2FjaGUgc28gaWYgd2UgYXJlIHVzaW5nIGl0LCBtYWtlIGEgY29weVxuICAgICAgICAgICAgaWYgKGRhYi5icnVzaCA9PSBicnVzaCkge1xuICAgICAgICAgICAgICAgIGJydXNoQUEuc2V0KGJydXNoKTtcbiAgICAgICAgICAgICAgICBkYWIuYnJ1c2ggPSBicnVzaEFBO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXBwbHlUZXh0dXJlKGRhYiwgYnJ1c2hJbmZvLnRleHR1cmUpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZGFiO1xuICAgIH1cblxuICAgIHRoaXMuc2V0VGV4dHVyZSA9IGZ1bmN0aW9uKHRleHR1cmUpIHtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcbiAgICB9XG59XG4iLCIvKlxuICAgIENoaWNrZW5QYWludFxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cblxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBDUEFydHdvcmsgZnJvbSBcIi4vQ1BBcnR3b3JrXCI7XG5pbXBvcnQgQ1BMYXllciBmcm9tIFwiLi9DUExheWVyXCI7XG5pbXBvcnQgQ1BDb2xvckJtcCBmcm9tIFwiLi9DUENvbG9yQm1wXCI7XG5pbXBvcnQgQXJyYXlEYXRhU3RyZWFtIGZyb20gXCIuLi91dGlsL0FycmF5RGF0YVN0cmVhbVwiO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUENoaWJpRmlsZSgpIHtcblxuICAgIGZ1bmN0aW9uIENQQ2hpYmlIZWFkZXIoc3RyZWFtLCBjaHVuaykge1xuICAgICAgICB0aGlzLnZlcnNpb24gPSBzdHJlYW0ucmVhZFUzMkJFKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSBzdHJlYW0ucmVhZFUzMkJFKCk7XG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gc3RyZWFtLnJlYWRVMzJCRSgpO1xuICAgICAgICB0aGlzLmxheWVyc05iID0gc3RyZWFtLnJlYWRVMzJCRSgpO1xuICAgIH1cbiAgICBcbiAgICBDUENoaWJpSGVhZGVyLkZJWEVEX0hFQURFUl9MRU5HVEggPSA0ICogNDtcblxuICAgIGZ1bmN0aW9uIENQQ2hpYmlDaHVua0hlYWRlcihzdHJlYW0pIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBjaHVua1R5cGUgPSBuZXcgQXJyYXkoNCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaHVua1R5cGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNodW5rVHlwZVtpXSA9IFN0cmluZy5mcm9tQ2hhckNvZGUoc3RyZWFtLnJlYWRCeXRlKCkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmNodW5rVHlwZSA9IGNodW5rVHlwZS5qb2luKFwiXCIpO1xuICAgICAgICB0aGlzLmNodW5rU2l6ZSA9IHN0cmVhbS5yZWFkVTMyQkUoKTtcblxuICAgICAgICBpZiAoc3RyZWFtLmVvZikge1xuICAgICAgICAgICAgdGhyb3cgXCJUcnVuY2F0ZWQgY2h1bmtcIjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBDUENoaWJpTGF5ZXJDaHVua0hlYWRlcigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBwYXlsb2FkT2Zmc2V0LFxuICAgICAgICAgICAgdGl0bGVMZW5ndGg7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnJlYWRGaXhlZEhlYWRlciA9IGZ1bmN0aW9uKHN0cmVhbSkge1xuICAgICAgICAgICAgcGF5bG9hZE9mZnNldCA9IHN0cmVhbS5yZWFkVTMyQkUoKTtcbiAgICBcbiAgICAgICAgICAgIHRoaXMuYmxlbmRNb2RlID0gc3RyZWFtLnJlYWRVMzJCRSgpO1xuICAgICAgICAgICAgdGhpcy5hbHBoYSA9IHN0cmVhbS5yZWFkVTMyQkUoKTtcbiAgICAgICAgICAgIHRoaXMudmlzaWJsZSA9IChzdHJlYW0ucmVhZFUzMkJFKCkgJiAxKSAhPSAwO1xuICAgIFxuICAgICAgICAgICAgdGl0bGVMZW5ndGggPSBzdHJlYW0ucmVhZFUzMkJFKCk7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICAvKiBcbiAgICAgICAgICogQWZ0ZXIgcmVhZGluZyB0aGUgZml4ZWQgaGVhZGVyLCB1c2UgdGhpcyBmdW5jdGlvbiB0byBmaW5kIG91dCBob3cgbWFueSBtb3JlIGJ5dGVzIG9mIGhlYWRlclxuICAgICAgICAgKiBuZWVkIHRvIGJlIHJlYWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldFZhcmlhYmxlSGVhZGVyTGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF5bG9hZE9mZnNldCAtIENQQ2hpYmlMYXllckNodW5rSGVhZGVyLkZJWEVEX0hFQURFUl9MRU5HVEg7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLmdldFRvdGFsSGVhZGVyTGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gQ1BDaGliaUxheWVyQ2h1bmtIZWFkZXIuRklYRURfSEVBREVSX0xFTkdUSCArIHRoaXMuZ2V0VmFyaWFibGVIZWFkZXJMZW4oKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMucmVhZFZhcmlhYmxlSGVhZGVyID0gZnVuY3Rpb24oc3RyZWFtKSB7XG4gICAgICAgICAgICB0aGlzLm5hbWUgPSBzdHJlYW0ucmVhZFN0cmluZyh0aXRsZUxlbmd0aCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFNraXAgdG8gdGhlIHBpeGVsIGRhdGEgKGFsbG93cyBhZGRpdGlvbmFsIGhlYWRlciBmaWVsZHMgdG8gYmUgYWRkZWQgdGhhdCB3ZSBkb24ndCB5ZXQgc3VwcG9ydClcbiAgICAgICAgICAgIHN0cmVhbS5za2lwKHBheWxvYWRPZmZzZXQgLSB0aXRsZUxlbmd0aCAtIENQQ2hpYmlMYXllckNodW5rSGVhZGVyLkZJWEVEX0hFQURFUl9MRU5HVEgpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICAvLyBUaGUgc2l6ZSBvZiB0aGUgaW5pdGlhbCwgZml4ZWQtbGVuZ3RoIHBvcnRpb24gb2YgdGhlIGhlYWRlclxuICAgIENQQ2hpYmlMYXllckNodW5rSGVhZGVyLkZJWEVEX0hFQURFUl9MRU5HVEggPSA0ICogNTtcblxuICAgIGNvbnN0XG4gICAgICAgIENISV9NQUdJQyA9IFwiQ0hJQklPRUtcIixcblxuICAgICAgICBDSFVOS19UQUdfSEVBRCA9IFwiSEVBRFwiLFxuICAgICAgICBDSFVOS19UQUdfTEFZRVIgPSBcIkxBWVJcIixcbiAgICAgICAgQ0hVTktfVEFHX0VORCA9IFwiWkVORFwiLFxuICAgICAgICBcbiAgICAgICAgQllURVNfUEVSX1BJWEVMID0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwsXG4gICAgICAgIEFMUEhBX0JZVEVfT0ZGU0VUID0gQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVCxcbiAgICAgICAgUkVEX0JZVEVfT0ZGU0VUID0gQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVQsXG4gICAgICAgIEdSRUVOX0JZVEVfT0ZGU0VUID0gQ1BDb2xvckJtcC5HUkVFTl9CWVRFX09GRlNFVCxcbiAgICAgICAgQkxVRV9CWVRFX09GRlNFVCA9IENQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVDtcblxuICAgIGZ1bmN0aW9uIHNlcmlhbGl6ZUVuZENodW5rKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KENIVU5LX1RBR19FTkQubGVuZ3RoICsgNCksXG4gICAgICAgICAgICBzdHJlYW0gPSBuZXcgQXJyYXlEYXRhU3RyZWFtKGJ1ZmZlcik7XG5cbiAgICAgICAgc3RyZWFtLndyaXRlU3RyaW5nKENIVU5LX1RBR19FTkQpO1xuICAgICAgICBzdHJlYW0ud3JpdGVVMzJCRSgwKTtcblxuICAgICAgICByZXR1cm4gc3RyZWFtLmdldEFzRGF0YUFycmF5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplSGVhZGVyQ2h1bmsoYXJ0d29yaykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KENIVU5LX1RBR19IRUFELmxlbmd0aCArIDQgKiA1KSxcbiAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBBcnJheURhdGFTdHJlYW0oYnVmZmVyKTtcblxuICAgICAgICBzdHJlYW0ud3JpdGVTdHJpbmcoQ0hVTktfVEFHX0hFQUQpO1xuICAgICAgICBzdHJlYW0ud3JpdGVVMzJCRSgxNik7IC8vIENodW5rU2l6ZVxuXG4gICAgICAgIHN0cmVhbS53cml0ZVUzMkJFKDApOyAvLyBDdXJyZW50IFZlcnNpb246IE1ham9yOiAwIE1pbm9yOiAwXG4gICAgICAgIHN0cmVhbS53cml0ZVUzMkJFKGFydHdvcmsud2lkdGgpO1xuICAgICAgICBzdHJlYW0ud3JpdGVVMzJCRShhcnR3b3JrLmhlaWdodCk7XG4gICAgICAgIHN0cmVhbS53cml0ZVUzMkJFKGFydHdvcmsuZ2V0TGF5ZXJDb3VudCgpKTtcblxuICAgICAgICByZXR1cm4gc3RyZWFtLmdldEFzRGF0YUFycmF5KCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VyaWFsaXplTGF5ZXJDaHVuayhsYXllcikge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGNodW5rU2l6ZSA9IDIwICsgbGF5ZXIubmFtZS5sZW5ndGggKyBsYXllci5kYXRhLmxlbmd0aCxcblxuICAgICAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoQ0hVTktfVEFHX0xBWUVSLmxlbmd0aCArIDQgKyBjaHVua1NpemUpLFxuICAgICAgICAgICAgc3RyZWFtID0gbmV3IEFycmF5RGF0YVN0cmVhbShidWZmZXIpLFxuICAgICAgICAgICAgcG9zO1xuXG4gICAgICAgIHN0cmVhbS53cml0ZVN0cmluZyhDSFVOS19UQUdfTEFZRVIpOyAvLyBDaHVuayBJRFxuICAgICAgICBzdHJlYW0ud3JpdGVVMzJCRShjaHVua1NpemUpOyAvLyBDaHVua1NpemVcblxuICAgICAgICBzdHJlYW0ud3JpdGVVMzJCRSgyMCArIGxheWVyLm5hbWUubGVuZ3RoKTsgLy8gT2Zmc2V0IHRvIGxheWVyIGRhdGEgZnJvbSBzdGFydCBvZiBoZWFkZXJcblxuICAgICAgICBzdHJlYW0ud3JpdGVVMzJCRShsYXllci5ibGVuZE1vZGUpO1xuICAgICAgICBzdHJlYW0ud3JpdGVVMzJCRShsYXllci5hbHBoYSk7XG4gICAgICAgIHN0cmVhbS53cml0ZVUzMkJFKGxheWVyLnZpc2libGUgPyAxIDogMCk7IC8vIGxheWVyIHZpc2liaWxpdHkgYW5kIGZ1dHVyZSBmbGFnc1xuXG4gICAgICAgIHN0cmVhbS53cml0ZVUzMkJFKGxheWVyLm5hbWUubGVuZ3RoKTtcbiAgICAgICAgc3RyZWFtLndyaXRlU3RyaW5nKGxheWVyLm5hbWUpO1xuXG4gICAgICAgIC8vIENvbnZlcnQgbGF5ZXIgYnl0ZXMgZnJvbSBSR0JBIHRvIEFSR0Igb3JkZXIgdG8gbWF0Y2ggdGhlIENoaWJpIHNwZWNzXG4gICAgICAgIHBvcyA9IHN0cmVhbS5wb3M7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIuZGF0YS5sZW5ndGg7IGkgKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICBidWZmZXJbcG9zKytdID0gbGF5ZXIuZGF0YVtpICsgQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgYnVmZmVyW3BvcysrXSA9IGxheWVyLmRhdGFbaSArIFJFRF9CWVRFX09GRlNFVF07XG4gICAgICAgICAgICBidWZmZXJbcG9zKytdID0gbGF5ZXIuZGF0YVtpICsgR1JFRU5fQllURV9PRkZTRVRdO1xuICAgICAgICAgICAgYnVmZmVyW3BvcysrXSA9IGxheWVyLmRhdGFbaSArIEJMVUVfQllURV9PRkZTRVRdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGJ1ZmZlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXJpYWxpemUgdGhlIGdpdmVuIGFydHdvcmsgdG8gQ2hpYmlmaWxlIGZvcm1hdC4gUmV0dXJucyBhIHByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdGhlIHNlcmlhbGl6ZWQgQmxvYi5cbiAgICAgKi9cbiAgICB0aGlzLnNlcmlhbGl6ZSA9IGZ1bmN0aW9uKGFydHdvcmspIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgZGVmbGF0b3IgPSBuZXcgd2luZG93LnBha28uRGVmbGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIGxldmVsOiA3XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgYmxvYlBhcnRzID0gW10sXG4gICAgICAgICAgICAgICAgbWFnaWMgPSBuZXcgVWludDhBcnJheShDSElfTUFHSUMubGVuZ3RoKTtcbiAgICBcbiAgICAgICAgICAgIC8vIFRoZSBtYWdpYyBmaWxlIHNpZ25hdHVyZSBpcyBub3QgWkxJQiBjb21wcmVzc2VkOlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDSElfTUFHSUMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBtYWdpY1tpXSA9IENISV9NQUdJQy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvYlBhcnRzLnB1c2gobWFnaWMpO1xuICAgIFxuICAgICAgICAgICAgLy8gVGhlIHJlc3QgZ2V0cyBjb21wcmVzc2VkXG4gICAgICAgICAgICBkZWZsYXRvci5wdXNoKHNlcmlhbGl6ZUhlYWRlckNodW5rKGFydHdvcmspLCBmYWxzZSk7XG4gICAgXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBsYXllcnMgPSBhcnR3b3JrLmdldExheWVycygpLFxuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBJbnNlcnQgYSBzZXR0aW1lb3V0IGJldHdlZW4gZWFjaCBzZXJpYWxpemVkIGxheWVyLCBzbyB3ZSBjYW4gbWFpbnRhaW4gYnJvd3NlciByZXNwb25zaXZlbmVzc1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmdW5jdGlvbiBzZXJpYWxpemVMYXllcigpIHtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PSBsYXllcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlZmxhdG9yLnB1c2goc2VyaWFsaXplRW5kQ2h1bmsoYXJ0d29yayksIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgYmxvYlBhcnRzLnB1c2goZGVmbGF0b3IucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV3IEJsb2IoYmxvYlBhcnRzLCB7dHlwZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIn0pKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWZsYXRvci5wdXNoKHNlcmlhbGl6ZUxheWVyQ2h1bmsobGF5ZXJzW2krK10pLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KHNlcmlhbGl6ZUxheWVyLCAxMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHNlcmlhbGl6ZUxheWVyLCAxMCk7XG4gICAgICAgIH0pO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBoYXNDaGliaU1hZ2ljTWFya2VyKGFycmF5KSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQ0hJX01BR0lDLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyYXlbaV0gIT0gQ0hJX01BR0lDLmNoYXJDb2RlQXQoaSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb25jYXQgdHdvIFVpbnQ4QXJyYXlzIHRvIG1ha2UgYSBuZXcgb25lIGFuZCByZXR1cm4gaXQuXG4gICAgICogXG4gICAgICogRWl0aGVyIG9uZSBtYXkgYmUgc2V0IHRvIG51bGwuIElmIGVpdGhlciBvbmUgaXMgbnVsbCwgdGhlIG90aGVyIGlzIHJldHVybmVkLiBJZiBib3RoIGFyZSBudWxsLCBudWxsIGlzXG4gICAgICogcmV0dXJuZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0QnVmZmVycyhvbmUsIHR3bykge1xuICAgICAgICBpZiAob25lID09IG51bGwgfHwgb25lLmxlbmd0aCA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdHdvO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0d28gPT0gbnVsbCB8fCB0d28ubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBvbmU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHZhclxuICAgICAgICAgICAgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkob25lLmxlbmd0aCArIHR3by5sZW5ndGgpO1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0LnNldChvbmUsIDApO1xuICAgICAgICByZXN1bHQuc2V0KHR3bywgb25lLmxlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBBdHRlbXB0IHRvIGxvYWQgYSBjaGliaWZpbGUgZnJvbSB0aGUgZ2l2ZW4gYXJyYXlidWZmZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIENQQXJ0d29yayBvbiBzdWNjZXNzLCBvciBudWxsIG9uIGZhaWx1cmUuXG4gICAgICovXG4gICAgdGhpcy5yZWFkID0gZnVuY3Rpb24oYXJyYXlCdWZmZXIpIHtcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIFNUQVRFX1dBSVRfRk9SX0NIVU5LICAgICAgICAgICAgICAgPSAwLFxuICAgICAgICAgICAgU1RBVEVfREVDT0RFX0lNQUdFX0hFQURFUiAgICAgICAgICA9IDEsXG4gICAgICAgICAgICBTVEFURV9ERUNPREVfTEFZRVJfSEVBREVSX0ZJWEVEICAgID0gMixcbiAgICAgICAgICAgIFNUQVRFX0RFQ09ERV9MQVlFUl9IRUFERVJfVkFSSUFCTEUgPSAzLFxuICAgICAgICAgICAgU1RBVEVfREVDT0RFX0xBWUVSICAgICAgICAgICAgICAgICA9IDQsXG4gICAgICAgICAgICBTVEFURV9TS0lQX1RSQUlMSU5HX0NIVU5LX0JZVEVTICAgID0gNSxcbiAgICAgICAgICAgIFNUQVRFX1NVQ0NFU1MgICAgICAgICAgICAgICAgICAgICAgPSA2LFxuICAgICAgICAgICAgU1RBVEVfRkFUQUwgICAgICAgICAgICAgICAgICAgICAgICA9IDEwO1xuICAgICAgICBcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBwYWtvID0gbmV3IHdpbmRvdy5wYWtvLkluZmxhdGUoe30pLFxuICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9XQUlUX0ZPUl9DSFVOSyxcbiAgICAgICAgICAgIGFydHdvcmsgPSBudWxsLFxuICAgICAgICAgICAgbGF5ZXJIZWFkZXIsIGxheWVyLCBcbiAgICAgICAgICAgIGxheWVyQnl0ZXNSZWFkLCBsYXllckJ5dGVzVG90YWwsIHNraXBDb3VudCxcbiAgICAgICAgICAgIGhlYWRlckNodW5rID0gbnVsbCwgaGVhZGVyID0gbnVsbCxcbiAgICAgICAgICAgIGNodW5rID0gbnVsbCxcbiAgICAgICAgICAgIGJ1ZmZlciA9IG51bGw7XG4gICAgICAgIFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVjb2RlIEEsUixHLEIgcGl4ZWxzIGZyb20gdGhlIGdpdmVuIGJ1ZmZlciBpbnRvIHRoZSBSLEcsQixBIHBpeGVsIGFycmF5IGdpdmVuIGJ5IGxheWVyUGl4LlxuICAgICAgICAgKiBcbiAgICAgICAgICogVGhlIGxheWVyQnl0ZXNSZWFkIGFuZCBsYXllckJ5dGVzVG90YWwgdmFyaWFibGVzIGFyZSB1c2VkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIGRlY29kZSBwcm9jZXNzIGFuZCB0byBcbiAgICAgICAgICogbGltaXQgdGhlIG51bWJlciBvZiBieXRlcyByZWFkLCByZXNwZWN0aXZlbHkuXG4gICAgICAgICAqIFxuICAgICAgICAgKiBSZXR1cm5zIHRoZSBidWZmZXIgd2l0aCB0aGUgcmVhZCBieXRlcyByZW1vdmVkIGZyb20gdGhlIGZyb250LCBvciBudWxsIGlmIHRoZSBidWZmZXIgd2FzIHJlYWQgaW4gaXRzIGVudGlyZXR5LlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZGVjb2RlUGl4ZWxzKGJ1ZmZlciwgbGF5ZXJQaXgpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHN1YnBpeGVsID0gbGF5ZXJCeXRlc1JlYWQgJSBCWVRFU19QRVJfUElYRUwsXG4gICAgICAgICAgICAgICAgZHN0UGl4ZWxTdGFydE9mZnNldCA9IGxheWVyQnl0ZXNSZWFkIC0gc3VicGl4ZWwsXG4gICAgICAgICAgICAgICAgYnVmZmVyUG9zID0gMCxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBNYXAgZnJvbSBzb3VyY2UgY2hhbm5lbCBvcmRlciB0byBDUExheWVyJ3MgZGVzdCBvcmRlclxuICAgICAgICAgICAgICAgIGNoYW5uZWxNYXAgPSBbXG4gICAgICAgICAgICAgICAgICAgIEFMUEhBX0JZVEVfT0ZGU0VULCBSRURfQllURV9PRkZTRVQsIEdSRUVOX0JZVEVfT0ZGU0VULCBCTFVFX0JZVEVfT0ZGU0VUXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gVGhlIGZpcnN0IHBpeGVsIG1pZ2h0IGJlIGEgcGFydGlhbCBvbmUgc2luY2Ugd2UgbWlnaHQgYmUgY29udGludWluZyBhIHBpeGVsIHNwbGl0IG92ZXIgYnVmZmVyc1xuICAgICAgICAgICAgZm9yICg7IHN1YnBpeGVsIDwgQllURVNfUEVSX1BJWEVMICYmIGJ1ZmZlclBvcyA8IGJ1ZmZlci5sZW5ndGg7IHN1YnBpeGVsKyspIHtcbiAgICAgICAgICAgICAgICBsYXllclBpeFtkc3RQaXhlbFN0YXJ0T2Zmc2V0ICsgY2hhbm5lbE1hcFtzdWJwaXhlbF1dID0gYnVmZmVyW2J1ZmZlclBvc107XG4gICAgICAgICAgICAgICAgbGF5ZXJCeXRlc1JlYWQrKztcbiAgICAgICAgICAgICAgICBidWZmZXJQb3MrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSG93IG1hbnkgbW9yZSBwaXhlbHMgYXJlIHdlIHRvIHJlYWQgaW4gdGhpcyBidWZmZXI/XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBieXRlc1JlbWFpbiA9IE1hdGgubWluKGJ1ZmZlci5sZW5ndGggLSBidWZmZXJQb3MsIGxheWVyQnl0ZXNUb3RhbCAtIGxheWVyQnl0ZXNSZWFkKSB8IDAsXG4gICAgICAgICAgICAgICAgZnVsbFBpeGVsc1JlbWFpbiA9IChieXRlc1JlbWFpbiAvIEJZVEVTX1BFUl9QSVhFTCkgfCAwLFxuICAgICAgICAgICAgICAgIHN1YnBpeGVsc1JlbWFpbiA9IGJ5dGVzUmVtYWluICUgQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGZ1bGxQaXhlbHNSZW1haW47IGkrKykge1xuICAgICAgICAgICAgICAgIGxheWVyUGl4W2xheWVyQnl0ZXNSZWFkICsgQUxQSEFfQllURV9PRkZTRVRdID0gYnVmZmVyW2J1ZmZlclBvc107XG4gICAgICAgICAgICAgICAgbGF5ZXJQaXhbbGF5ZXJCeXRlc1JlYWQgKyBSRURfQllURV9PRkZTRVRdID0gYnVmZmVyW2J1ZmZlclBvcyArIDFdO1xuICAgICAgICAgICAgICAgIGxheWVyUGl4W2xheWVyQnl0ZXNSZWFkICsgR1JFRU5fQllURV9PRkZTRVRdID0gYnVmZmVyW2J1ZmZlclBvcyArIDJdO1xuICAgICAgICAgICAgICAgIGxheWVyUGl4W2xheWVyQnl0ZXNSZWFkICsgQkxVRV9CWVRFX09GRlNFVF0gPSBidWZmZXJbYnVmZmVyUG9zICsgM107XG4gICAgICAgICAgICAgICAgbGF5ZXJCeXRlc1JlYWQgKz0gQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgICAgIGJ1ZmZlclBvcyArPSBCWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIFJlYWQgYSBmcmFjdGlvbmFsIHBpeGVsIGF0IHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICAgICAgICAgICAgZHN0UGl4ZWxTdGFydE9mZnNldCA9IGxheWVyQnl0ZXNSZWFkO1xuICAgICAgICAgICAgZm9yIChzdWJwaXhlbCA9IDA7IHN1YnBpeGVsIDwgc3VicGl4ZWxzUmVtYWluOyBzdWJwaXhlbCsrKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJQaXhbZHN0UGl4ZWxTdGFydE9mZnNldCArIGNoYW5uZWxNYXBbc3VicGl4ZWxdXSA9IGJ1ZmZlcltidWZmZXJQb3NdO1xuICAgICAgICAgICAgICAgIGxheWVyQnl0ZXNSZWFkKys7XG4gICAgICAgICAgICAgICAgYnVmZmVyUG9zKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChidWZmZXJQb3MgPCBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgLy8gTGF5ZXIgd2FzIGNvbXBsZXRlZCBiZWZvcmUgdGhlIGVuZCBvZiB0aGUgYnVmZmVyLCB0aGVyZSBpcyBidWZmZXIgbGVmdCBvdmVyIGZvciBzb21lb25lIGVsc2UgdG8gdXNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zdWJhcnJheShidWZmZXJQb3MpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBCdWZmZXIgZXhoYXVzdGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIHByb2Nlc3NCbG9jayhibG9jaykge1xuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgIHN0cmVhbTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQWRkIGEgbG9vcCBoZXJlIHNvIHdlIGNhbiByZS1lbnRlciB0aGUgc3dpdGNoIHdpdGggJ2NvbnRpbnVlJ1xuICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU1RBVEVfV0FJVF9GT1JfQ0hVTks6XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBjb25jYXRCdWZmZXJzKGJ1ZmZlciwgYmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBXYWl0IGZvciB3aG9sZSBjaHVuayBoZWFkZXIgdG8gYmVjb21lIGF2YWlsYWJsZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFidWZmZXIgfHwgYnVmZmVyLmxlbmd0aCA8IDgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gRGVjb2RlIGNodW5rIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtID0gbmV3IEFycmF5RGF0YVN0cmVhbShidWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmsgPSBuZXcgQ1BDaGliaUNodW5rSGVhZGVyKHN0cmVhbSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgY2h1bmsgaGVhZGVyIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlciA9IGJ1ZmZlci5zdWJhcnJheShzdHJlYW0ucG9zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhlYWRlckNodW5rKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNodW5rLmNodW5rVHlwZSA9PSBDSFVOS19UQUdfRU5EKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEVfU1VDQ0VTUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaHVuay5jaHVua1R5cGUgPT0gQ0hVTktfVEFHX0xBWUVSKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEVfREVDT0RFX0xBWUVSX0hFQURFUl9GSVhFRDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlVua25vd24gY2h1bmsgdHlwZSAnXCIgKyBjaHVuay5jaHVua1R5cGUgKyBcIicsIGF0dGVtcHRpbmcgdG8gc2tpcC4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcENvdW50ID0gY2h1bmsuY2h1bmtTaXplO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFX1NLSVBfVFJBSUxJTkdfQ0hVTktfQllURVM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaHVuay5jaHVua1R5cGUgPT0gQ0hVTktfVEFHX0hFQUQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZWFkZXJDaHVuayA9IGNodW5rO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRyeSB0byBkZWNvZGUgdGhlIGhlYWRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEVfREVDT0RFX0lNQUdFX0hFQURFUjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRmlsZSBkaWRuJ3Qgc3RhcnQgd2l0aCBpbWFnZSBoZWFkZXIgY2h1bmtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFX0ZBVEFMO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTVEFURV9ERUNPREVfSU1BR0VfSEVBREVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gY29uY2F0QnVmZmVycyhidWZmZXIsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCBmb3Igd2hvbGUgY2h1bmsgdG8gYmUgYXZhaWxhYmxlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlciB8fCBidWZmZXIubGVuZ3RoIDwgaGVhZGVyQ2h1bmsuY2h1bmtTaXplKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbSA9IG5ldyBBcnJheURhdGFTdHJlYW0oYnVmZmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlciA9IG5ldyBDUENoaWJpSGVhZGVyKHN0cmVhbSwgaGVhZGVyQ2h1bmspO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKGhlYWRlci52ZXJzaW9uID4+PiAxNikgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9GQVRBTDsgLy8gdGhlIGZpbGUgdmVyc2lvbiBpcyBoaWdoZXIgdGhhbiB3aGF0IHdlIGNhbiBkZWFsIHdpdGgsIGJhaWwgb3V0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGFydHdvcmsgPSBuZXcgQ1BBcnR3b3JrKGhlYWRlci53aWR0aCwgaGVhZGVyLmhlaWdodCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgc2tpcENvdW50ID0gaGVhZGVyQ2h1bmsuY2h1bmtTaXplOyAvLyBTa2lwIHRoZSBoZWFkZXIgY2h1bmsgYWxvbmcgd2l0aCBhbnkgdHJhaWxpbmcgYnl0ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEVfU0tJUF9UUkFJTElOR19DSFVOS19CWVRFUztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTVEFURV9ERUNPREVfTEFZRVJfSEVBREVSX0ZJWEVEOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gY29uY2F0QnVmZmVycyhidWZmZXIsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgZmlyc3QgcGFydCBvZiBoZWFkZXIgdG8gYXJyaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlciB8fCBidWZmZXIubGVuZ3RoIDwgQ1BDaGliaUxheWVyQ2h1bmtIZWFkZXIuRklYRURfSEVBREVSX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllckhlYWRlciA9IG5ldyBDUENoaWJpTGF5ZXJDaHVua0hlYWRlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0gPSBuZXcgQXJyYXlEYXRhU3RyZWFtKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllckhlYWRlci5yZWFkRml4ZWRIZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KHN0cmVhbS5wb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IFNUQVRFX0RFQ09ERV9MQVlFUl9IRUFERVJfVkFSSUFCTEVcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTVEFURV9ERUNPREVfTEFZRVJfSEVBREVSX1ZBUklBQkxFOlxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gY29uY2F0QnVmZmVycyhidWZmZXIsIGJsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gV2FpdCBmb3IgdmFyaWFibGUgcGFydCBvZiBoZWFkZXIgdG8gYXJyaXZlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlciB8fCBidWZmZXIubGVuZ3RoIDwgbGF5ZXJIZWFkZXIuZ2V0VmFyaWFibGVIZWFkZXJMZW4oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0gPSBuZXcgQXJyYXlEYXRhU3RyZWFtKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllckhlYWRlci5yZWFkVmFyaWFibGVIZWFkZXIoc3RyZWFtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLnN1YmFycmF5KHN0cmVhbS5wb3MpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllciA9IG5ldyBDUExheWVyKGhlYWRlci53aWR0aCwgaGVhZGVyLmhlaWdodCwgbGF5ZXJIZWFkZXIubmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5ibGVuZE1vZGUgPSBsYXllckhlYWRlci5ibGVuZE1vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllci5hbHBoYSA9IGxheWVySGVhZGVyLmFscGhhO1xuICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIudmlzaWJsZSA9IGxheWVySGVhZGVyLnZpc2libGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQnl0ZXNSZWFkID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyQnl0ZXNUb3RhbCA9IGhlYWRlci53aWR0aCAqIGhlYWRlci5oZWlnaHQgKiBCWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIFxuICAgICAgICAgICAgICAgICAgICAgICAgICogV2hpbGUgZGVjb2RpbmcgbGF5ZXJzLCB3ZSB3b24ndCBrZWVwIGEgcGVyc2lzdGVudCBidWZmZXIgYXJvdW5kLCBzbyBpZiB3ZSBoYXZlIGFueVxuICAgICAgICAgICAgICAgICAgICAgICAgICogYnl0ZXMgbGVmdCBvdmVyLCBwcm92aWRlIHRoZW0gdG8gdGhlIG5leHQgc3RhdGUgYXMgaWYgdGhleSB3ZXJlIGEgbmV3bHkgaW5mbGF0ZWQgYmxvY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gYnVmZmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9ERUNPREVfTEFZRVI7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgU1RBVEVfREVDT0RFX0xBWUVSOlxuICAgICAgICAgICAgICAgICAgICAgICAgLyogXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBXaGVuIGRlY29kaW5nIGxheWVyIGRhdGEsIHdlIG5ldmVyIGNvbmNhdCBibG9ja3MgdG9nZXRoZXIsIHdlIGFyZSBjYXBhYmxlIG9mIGRlY29kaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBwYXJ0aWFsIHBpeGVscyB0aGF0IGdldCBzcGxpdCBvdmVyIGJsb2NrIGJvdW5kYXJpZXMuIFNvIHdlIGRvbid0IHVzZSAnYnVmZmVyJyB0byBhY2N1bXVsYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBkYXRhLCBhbmQgb25seSByZWFkIGZyb20gaW5jb21pbmcgJ2Jsb2NrJ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi8gXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrID0gZGVjb2RlUGl4ZWxzKGJsb2NrLCBsYXllci5kYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGF5ZXJCeXRlc1JlYWQgPj0gbGF5ZXJCeXRlc1RvdGFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFydHdvcmsuYWRkTGF5ZXJPYmplY3QobGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2tpcCBhbnkgdHJhaWxpbmcgYnl0ZXMgaW4gdGhlIGxheWVyIGNodW5rXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBDb3VudCA9IGNodW5rLmNodW5rU2l6ZSAtIGxheWVySGVhZGVyLmdldFRvdGFsSGVhZGVyTGVuKCkgLSBsYXllckJ5dGVzVG90YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gU1RBVEVfU0tJUF9UUkFJTElOR19DSFVOS19CWVRFUztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBTVEFURV9TS0lQX1RSQUlMSU5HX0NIVU5LX0JZVEVTOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBDb3VudCA8IGJsb2NrLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9jayA9IGJsb2NrLnN1YmFycmF5KHNraXBDb3VudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNraXBDb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2tpcENvdW50IC09IGJsb2NrLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNraXBDb3VudCA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBTVEFURV9XQUlUX0ZPUl9DSFVOSztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBhcnJheUJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcblxuICAgICAgICBpZiAoIWhhc0NoaWJpTWFnaWNNYXJrZXIoYXJyYXlCdWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDsgLy8gbm90IGEgQ2hpYmlQYWludCBmaWxlXG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbWFnaWMgaGVhZGVyXG4gICAgICAgIGFycmF5QnVmZmVyID0gYXJyYXlCdWZmZXIuc3ViYXJyYXkoQ0hJX01BR0lDLmxlbmd0aCk7XG4gICAgICAgIFxuICAgICAgICBwYWtvLm9uRGF0YSA9IHByb2Nlc3NCbG9jaztcbiAgICAgICAgXG4gICAgICAgIHBha28ub25FbmQgPSBmdW5jdGlvbihzdGF0dXMpIHtcbiAgICAgICAgICAgIGlmIChzdGF0dXMgPT09IDAgJiYgc3RhdGUgPT0gU1RBVEVfU1VDQ0VTUykge1xuICAgICAgICAgICAgICAgIGFydHdvcmsuc2V0QWN0aXZlTGF5ZXJJbmRleChhcnR3b3JrLmdldFRvcG1vc3RWaXNpYmxlTGF5ZXIoKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSBhcnR3b3JrO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkZhdGFsIGVycm9yIGRlY29kaW5nIENoaWJpRmlsZVwiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB0aGlzLnJlc3VsdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gQmVnaW4gZGVjb21wcmVzc2lvbi9kZWNvZGluZ1xuICAgICAgICBwYWtvLnB1c2goYXJyYXlCdWZmZXIpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHBha28ucmVzdWx0O1xuICAgIH07XG59XG4iLCIvKlxuICAgIENoaWNrZW5QYWludFxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cblxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQ2xpcChibXAsIHgsIHkpIHtcbiAgICB0aGlzLmJtcCA9IGJtcDtcbiAgICBcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG59OyIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ1BCaXRtYXAgZnJvbSBcIi4vQ1BCaXRtYXBcIjtcbmltcG9ydCBDUFJlY3QgZnJvbSBcIi4uL3V0aWwvQ1BSZWN0XCI7XG5cbmZ1bmN0aW9uIGNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgLy8gcmV0dXJuIG5ldyBJbWFnZURhdGEodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpOyAvLyBEb2Vzbid0IHdvcmsgb24gb2xkIElFXG4gICAgdmFyXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgIGNvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIFxuICAgIHJldHVybiBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbn1cblxuLy9cbi8vIEEgMzJicHAgYml0bWFwIGNsYXNzIChvbmUgYnl0ZSBwZXIgY2hhbm5lbCBpbiBSR0JBIG9yZGVyKVxuLy9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BDb2xvckJtcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgQ1BCaXRtYXAuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIC8vIFRoZSBJbWFnZURhdGEgb2JqZWN0IHRoYXQgaG9sZHMgdGhlIGltYWdlIGRhdGFcbiAgICB0aGlzLmltYWdlRGF0YSA9IGNyZWF0ZUltYWdlRGF0YSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgXG4gICAgLy8gVGhlIGJpdG1hcCBkYXRhIGFycmF5IChvbmUgYnl0ZSBwZXIgY2hhbm5lbCBpbiBSR0JBIG9yZGVyKVxuICAgIHRoaXMuZGF0YSA9IHRoaXMuaW1hZ2VEYXRhLmRhdGE7XG59XG5cbkNQQ29sb3JCbXAucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUEJpdG1hcC5wcm90b3R5cGUpO1xuQ1BDb2xvckJtcC5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUENvbG9yQm1wO1xuXG5DUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCA9IDQ7XG5DUENvbG9yQm1wLlJFRF9CWVRFX09GRlNFVCA9IDA7XG5DUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUID0gMTtcbkNQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVCA9IDI7XG5DUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUID0gMztcblxuLy8gQ3JlYXRlcyBhIENQQml0bWFwIGZyb20gYSBwb3J0aW9uIG9mIHRoaXMgYml0bWFwXG5DUENvbG9yQm1wLnByb3RvdHlwZS5jbG9uZVJlY3QgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgdmFyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBDUENvbG9yQm1wKHJlY3QuZ2V0V2lkdGgoKSwgcmVjdC5nZXRIZWlnaHQoKSk7XG4gICAgXG4gICAgcmVzdWx0LmNvcHlCaXRtYXBSZWN0KHRoaXMsIDAsIDAsIHJlY3QpO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vL1xuLy8gUGl4ZWwgYWNjZXNzIHdpdGggZnJpZW5kbHkgY2xpcHBpbmcuIFBpeGVsIHdpbGwgYmUgMzItYml0IGludGVnZXIgaW4gQVJHQiBmb3JtYXRcbi8vXG5DUENvbG9yQm1wLnByb3RvdHlwZS5nZXRQaXhlbCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB4ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy53aWR0aCAtIDEsIHgpKTtcbiAgICB5ID0gTWF0aC5tYXgoMCwgTWF0aC5taW4odGhpcy5oZWlnaHQgLSAxLCB5KSk7XG5cbiAgICB2YXJcbiAgICAgICAgcGl4SW5kZXggPSB0aGlzLm9mZnNldE9mUGl4ZWwoeCwgeSk7XG4gICAgXG4gICAgcmV0dXJuICh0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSA8PCAyNCkgXG4gICAgICAgIHwgKHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSAgICA8PCAxNikgXG4gICAgICAgIHwgKHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuR1JFRU5fQllURV9PRkZTRVRdICA8PCA4KSBcbiAgICAgICAgfCB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdO1xufTtcblxuLyoqXG4gKiBHZXQgYW4gcixnLGIsYSBhcnJheSBvZiB0aGUgeG9yIG9mIHRoaXMgYml0bWFwIGFuZCB0aGUgZ2l2ZW4gb25lLCB3aXRoaW4gdGhlIGdpdmVuIHJlY3RhbmdsZVxuICpcbiAqIEByZXR1cm5zIHtVaW50OEFycmF5fVxuICovXG5DUENvbG9yQm1wLnByb3RvdHlwZS5jb3B5UmVjdFhPUiA9IGZ1bmN0aW9uKGJtcCwgcmVjdCkge1xuICAgIHJlY3QgPSB0aGlzLmdldEJvdW5kcygpLmNsaXAocmVjdCk7XG4gICAgXG4gICAgdmFyIFxuICAgICAgICB3ID0gcmVjdC5nZXRXaWR0aCgpLFxuICAgICAgICBoID0gcmVjdC5nZXRIZWlnaHQoKSxcbiAgICAgICAgXG4gICAgICAgIGJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KHcgKiBoICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpLFxuICAgICAgICBcbiAgICAgICAgb3V0cHV0SW5kZXggPSAwLFxuICAgICAgICBibXAxSW5kZXggPSB0aGlzLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCksIFxuICAgICAgICBibXAySW5kZXggPSBibXAub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSxcbiAgICAgICAgXG4gICAgICAgIGJtcDFZU2tpcCA9ICh0aGlzLndpZHRoIC0gdykgKiBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCxcbiAgICAgICAgYm1wMllTa2lwID0gKGJtcC53aWR0aCAtIHcpICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwsXG4gICAgICAgIFxuICAgICAgICB3aWR0aEJ5dGVzID0gdyAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgIFxuICAgIGZvciAodmFyIHkgPSByZWN0LnRvcDsgeSA8IHJlY3QuYm90dG9tOyB5KyssIGJtcDFJbmRleCArPSBibXAxWVNraXAsIGJtcDJJbmRleCArPSBibXAyWVNraXApIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aEJ5dGVzOyB4KyssIG91dHB1dEluZGV4KyssIGJtcDFJbmRleCsrLCBibXAySW5kZXgrKykge1xuICAgICAgICAgICAgYnVmZmVyW291dHB1dEluZGV4XSA9IHRoaXMuZGF0YVtibXAxSW5kZXhdIF4gYm1wLmRhdGFbYm1wMkluZGV4XTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBidWZmZXI7XG59O1xuXG5DUENvbG9yQm1wLnByb3RvdHlwZS5zZXRSZWN0WE9SID0gZnVuY3Rpb24oYnVmZmVyLCByZWN0KSB7XG4gICAgcmVjdCA9IHRoaXMuZ2V0Qm91bmRzKCkuY2xpcChyZWN0KTtcbiAgICBcbiAgICB2YXIgXG4gICAgICAgIHcgPSByZWN0LmdldFdpZHRoKCksXG4gICAgICAgIGggPSByZWN0LmdldEhlaWdodCgpLFxuICAgICAgICBcbiAgICAgICAgYm1wMUluZGV4ID0gdGhpcy5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApLFxuICAgICAgICBidWZmZXJJbmRleCA9IDAsXG4gICAgICAgIFxuICAgICAgICBibXAxWVNraXAgPSAodGhpcy53aWR0aCAtIHcpICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwsXG4gICAgICAgIFxuICAgICAgICB3aWR0aEJ5dGVzID0gdyAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgIFxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgd2lkdGhCeXRlczsgeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbYm1wMUluZGV4KytdIF49IGJ1ZmZlcltidWZmZXJJbmRleCsrXTtcbiAgICAgICAgfVxuICAgICAgICBibXAxSW5kZXggKz0gYm1wMVlTa2lwO1xuICAgIH1cbn07XG5cbi8vXG4vLyBDb3B5IGFub3RoZXIgYml0bWFwIGludG8gdGhpcyBvbmUgdXNpbmcgYWxwaGEgYmxlbmRpbmdcbi8vXG5DUENvbG9yQm1wLnByb3RvdHlwZS5wYXN0ZUFscGhhUmVjdCA9IGZ1bmN0aW9uKGJtcCwgc3JjUmVjdCwgeCwgeSkge1xuICAgIHZhclxuICAgICAgICBzcmNSZWN0Q3B5ID0gc3JjUmVjdC5jbG9uZSgpLFxuICAgICAgICBkc3RSZWN0ID0gbmV3IENQUmVjdCh4LCB5LCAwLCAwKTtcbiAgICBcbiAgICB0aGlzLmdldEJvdW5kcygpLmNsaXBTb3VyY2VEZXN0KHNyY1JlY3RDcHksIGRzdFJlY3QpO1xuXG4gICAgdmFyXG4gICAgICAgIHNyY1lTdHJpZGUgPSAoYm1wLndpZHRoIC0gZHN0UmVjdC5nZXRXaWR0aCgpKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICBkc3RZU3RyaWRlID0gKHRoaXMud2lkdGggLSBkc3RSZWN0LmdldFdpZHRoKCkpICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwsXG4gICAgICAgIFxuICAgICAgICBzcmNPZmZzZXQgPSBibXAub2Zmc2V0T2ZQaXhlbChzcmNSZWN0Q3B5LmxlZnQsIHNyY1JlY3RDcHkudG9wKSxcbiAgICAgICAgZHN0T2Zmc2V0ID0gdGhpcy5vZmZzZXRPZlBpeGVsKGRzdFJlY3QubGVmdCwgZHN0UmVjdC50b3ApO1xuXG4gICAgZm9yICh2YXIgeSA9IGRzdFJlY3QudG9wOyB5IDwgZHN0UmVjdC5ib3R0b207IHkrKywgc3JjT2Zmc2V0ICs9IHNyY1lTdHJpZGUsIGRzdE9mZnNldCArPSBkc3RZU3RyaWRlKSB7XG4gICAgICAgIGZvciAodmFyIHggPSBkc3RSZWN0LmxlZnQ7IHggPCBkc3RSZWN0LnJpZ2h0OyB4KyspIHtcbiAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICBhbHBoYTEgPSBibXAuZGF0YVtzcmNPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXTtcblxuICAgICAgICAgICAgaWYgKGFscGhhMSA8PSAwKSB7XG4gICAgICAgICAgICAgICAgZHN0T2Zmc2V0ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgICAgIHNyY09mZnNldCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGFscGhhMSA9PSAyNTUpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhW2RzdE9mZnNldCsrXSA9IGJtcC5kYXRhW3NyY09mZnNldCsrXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGFscGhhMiA9IHRoaXMuZGF0YVtkc3RPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSxcbiAgICAgICAgICAgICAgICBuZXdBbHBoYSA9IChhbHBoYTEgKyBhbHBoYTIgLSBhbHBoYTEgKiBhbHBoYTIgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKG5ld0FscGhhID4gMCkge1xuICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgcmVhbEFscGhhID0gKGFscGhhMSAqIDI1NSAvIG5ld0FscGhhKSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhID0gMjU1IC0gcmVhbEFscGhhO1xuXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyssIGRzdE9mZnNldCsrLCBzcmNPZmZzZXQrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFbZHN0T2Zmc2V0XSA9IChibXAuZGF0YVtzcmNPZmZzZXRdICsgKHRoaXMuZGF0YVtkc3RPZmZzZXRdICogaW52QWxwaGEgLSBibXAuZGF0YVtzcmNPZmZzZXRdICogaW52QWxwaGEpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtkc3RPZmZzZXQrK10gPSBuZXdBbHBoYTtcbiAgICAgICAgICAgICAgICBzcmNPZmZzZXQrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZHN0T2Zmc2V0ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgICAgIHNyY09mZnNldCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKiBcbiAqIENvcHkgdGhlIHJlY3RhbmdsZSBhdCBzcmNSZWN0IGZyb20gYm1wIG9udG8gdGhpcyBpbWFnZSBhdCAoZHN0WCwgZHN0WSkuXG4gKi8gXG5DUENvbG9yQm1wLnByb3RvdHlwZS5jb3B5Qml0bWFwUmVjdCA9IGZ1bmN0aW9uKGJtcCwgZHN0WCwgZHN0WSwgc3JjUmVjdCkge1xuICAgIHZhclxuICAgICAgICBzcmNSZWN0ID0gc3JjUmVjdC5jbG9uZSgpLFxuICAgICAgICBkc3RSZWN0ID0gbmV3IENQUmVjdChkc3RYLCBkc3RZLCAwLCAwKTtcblxuICAgIHRoaXMuZ2V0Qm91bmRzKCkuY2xpcFNvdXJjZURlc3Qoc3JjUmVjdCwgZHN0UmVjdCk7XG5cbiAgICB2YXIgXG4gICAgICAgIHcgPSBkc3RSZWN0LmdldFdpZHRoKCkgfCAwLFxuICAgICAgICBoID0gZHN0UmVjdC5nZXRIZWlnaHQoKSB8IDA7XG5cbiAgICAvLyBBcmUgd2UganVzdCB0cnlpbmcgdG8gZHVwbGljYXRlIHRoZSBiaXRtYXA/XG4gICAgaWYgKGRzdFJlY3QubGVmdCA9PSAwICYmIGRzdFJlY3QudG9wID09IDAgJiYgdyA9PSB0aGlzLndpZHRoICYmIGggPT0gdGhpcy5oZWlnaHQgJiYgdyA9PSBibXAud2lkdGggJiYgaCA9PSBibXAuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY29weURhdGFGcm9tKGJtcCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBkc3RJbmRleCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChkc3RSZWN0LmxlZnQsIGRzdFJlY3QudG9wKSxcbiAgICAgICAgICAgIHNyY0luZGV4ID0gYm1wLm9mZnNldE9mUGl4ZWwoc3JjUmVjdC5sZWZ0LCBzcmNSZWN0LnRvcCksXG5cbiAgICAgICAgICAgIGRzdFlTa2lwID0gKHRoaXMud2lkdGggLSB3KSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICAgICAgc3JjWVNraXAgPSAoYm1wLndpZHRoIC0gdykgKiBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcblxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGg7IHkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbZHN0SW5kZXhdID0gYm1wLmRhdGFbc3JjSW5kZXhdO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtkc3RJbmRleCArIDFdID0gYm1wLmRhdGFbc3JjSW5kZXggKyAxXTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbZHN0SW5kZXggKyAyXSA9IGJtcC5kYXRhW3NyY0luZGV4ICsgMl07XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2RzdEluZGV4ICsgM10gPSBibXAuZGF0YVtzcmNJbmRleCArIDNdO1xuICAgICAgICAgICAgICAgIGRzdEluZGV4ICs9IDQ7XG4gICAgICAgICAgICAgICAgc3JjSW5kZXggKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNyY0luZGV4ICs9IHNyY1lTa2lwO1xuICAgICAgICAgICAgZHN0SW5kZXggKz0gZHN0WVNraXA7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vL1xuLy8gQ29waWVzIHRoZSBBbHBoYSBjaGFubmVsIGZyb20gYW5vdGhlciBiaXRtYXAuIEFzc3VtZXMgYm90aCBiaXRtYXBzIGFyZSB0aGUgc2FtZSB3aWR0aC5cbi8vXG5DUENvbG9yQm1wLnByb3RvdHlwZS5jb3B5QWxwaGFGcm9tID0gZnVuY3Rpb24oYm1wLCByZWN0KSB7XG4gICAgcmVjdCA9IHRoaXMuZ2V0Qm91bmRzKCkuY2xpcChyZWN0KTtcblxuICAgIHZhciBcbiAgICAgICAgdyA9IHJlY3QuZ2V0V2lkdGgoKSxcbiAgICAgICAgaCA9IHJlY3QuZ2V0SGVpZ2h0KCksXG4gICAgICAgIFxuICAgICAgICBwaXhJbmRleCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVQgLyogQXBwbHkgb2Zmc2V0IGhlcmUgc28gd2UgZG9uJ3QgaGF2ZSB0byBkbyBpdCBwZXItcGl4ZWwqLyxcbiAgICAgICAgeVNraXAgPSAodGhpcy53aWR0aCAtIHcpICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgXG4gICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyspIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleF0gPSBibXAuZGF0YVtwaXhJbmRleF07XG4gICAgICAgICAgICBwaXhJbmRleCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgfVxuICAgICAgICBwaXhJbmRleCArPSB5U2tpcDtcbiAgICB9XG59O1xuXG5DUENvbG9yQm1wLnByb3RvdHlwZS5jb3B5RGF0YUZyb20gPSBmdW5jdGlvbihibXApIHtcbiAgICBpZiAoYm1wLndpZHRoICE9IHRoaXMud2lkdGggfHwgYm1wLmhlaWdodCAhPSB0aGlzLmhlaWdodCkge1xuICAgICAgICB0aGlzLndpZHRoID0gYm1wLndpZHRoO1xuICAgICAgICB0aGlzLmhlaWdodCA9IGJtcC5oZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICB0aGlzLmltYWdlRGF0YSA9IGNyZWF0ZUltYWdlRGF0YSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuZGF0YSA9IHRoaXMuaW1hZ2VEYXRhLmRhdGE7XG4gICAgfVxuXG4gICAgaWYgKFwic2V0XCIgaW4gdGhpcy5kYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YS5zZXQoYm1wLmRhdGEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIElFIGRvZXNuJ3QgdXNlIFVpbnQ4Q2xhbXBlZEFycmF5IGZvciBJbWFnZURhdGEsIHNvIHNldCgpIGlzbid0IGF2YWlsYWJsZVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2ldID0gYm1wLmRhdGFbaV07XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIEZsb29kIGZpbGwgdGhlIGdpdmVuIGNvbG9yIHN0YXJ0aW5nIGZyb20gdGhlIGdpdmVuIHBvaW50XG4gKiBAcGFyYW0geCBpbnRcbiAqIEBwYXJhbSB5IGludFxuICogQHBhcmFtIGNvbG9yIGludFxuICovXG5DUENvbG9yQm1wLnByb3RvdHlwZS5mbG9vZEZpbGwgPSBmdW5jdGlvbih4LCB5LCBjb2xvcikge1xuICAgIGlmICghdGhpcy5pc0luc2lkZSh4LCB5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyXG4gICAgICAgIG9sZENvbG9yID0gdGhpcy5nZXRQaXhlbCh4LCB5KSxcbiAgICAgICAgXG4gICAgICAgIG9sZEFscGhhID0gKG9sZENvbG9yID4+IDI0KSAmIDB4RkYsXG4gICAgICAgIG9sZFJlZCA9IChvbGRDb2xvciA+PiAxNikgJiAweEZGLFxuICAgICAgICBvbGRHcmVlbiA9IChvbGRDb2xvciA+PiA4KSAmIDB4RkYsXG4gICAgICAgIG9sZEJsdWUgPSBvbGRDb2xvciAmIDB4RkYsXG4gICAgICAgIFxuICAgICAgICBjb2xvckFscGhhID0gKGNvbG9yID4+IDI0KSAmIDB4RkYsXG4gICAgICAgIGNvbG9yUmVkID0gKGNvbG9yID4+IDE2KSAmIDB4RkYsXG4gICAgICAgIGNvbG9yR3JlZW4gPSAoY29sb3IgPj4gOCkgJiAweEZGLFxuICAgICAgICBjb2xvckJsdWUgPSBjb2xvciAmIDB4RkYsXG4gICAgICAgIFxuICAgICAgICBzdGFjayA9IFtdLFxuICAgICAgICBjbGlwID0gdGhpcy5nZXRCb3VuZHMoKSxcbiAgICAgICAgXG4gICAgICAgIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgXG4gICAgLy8gQ2hhbmdlIHRoZSBsZWZ0IGFuZCByaWdodCBib3VuZHMgZnJvbSBwaXhlbCBpbmRleGVzIGludG8gYnl0ZSBpbmRleGVzIGZvciBlYXN5IGNsaXBwaW5nXG4gICAgY2xpcC5sZWZ0ICo9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgIGNsaXAucmlnaHQgKj0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgXG4gICAgc3RhY2sucHVzaCh7eDE6IHggKiBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCwgeDI6IHggKiBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCwgeTogeSwgZHk6IC0xfSk7XG4gICAgc3RhY2sucHVzaCh7eDE6IHggKiBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCwgeDI6IHggKiBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCwgeTogeSArIDEsIGR5OiAxfSk7XG4gICAgXG4gICAgLyogXG4gICAgICogSWYgd2UgYXJlIGZpbGxpbmcgMTAwJSB0cmFuc3BhcmVudCBhcmVhcyB0aGVuIHdlIG5lZWQgdG8gaWdub3JlIHRoZSByZXNpZHVhbCBjb2xvciBpbmZvcm1hdGlvblxuICAgICAqIChpdCB3b3VsZCBhbHNvIGJlIHBvc3NpYmxlIHRvIGNsZWFyIGl0IHdoZW4gZXJhc2luZywgYnV0IHRoZW4gdGhlIHBlcmZvcm1hbmNlIGltcGFjdCB3b3VsZCBiZSBvbiB0aGUgZXJhc2VyIFxuICAgICAqIHJhdGhlciB0aGFuIG9uIHRoaXMgbG93IGltcG9ydGFuY2UgZmxvb2QgZmlsbClcbiAgICAgKi9cbiAgICBpZiAob2xkQWxwaGEgPT0gMCkge1xuICAgICAgICBpZiAoY29sb3JBbHBoYSA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBsaW5lID0gc3RhY2sucG9wKCk7XG4gICAgXG4gICAgICAgICAgICBpZiAobGluZS55IDwgY2xpcC50b3AgfHwgbGluZS55ID49IGNsaXAuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBsaW5lT2Zmc2V0ID0gdGhpcy5vZmZzZXRPZlBpeGVsKDAsIGxpbmUueSksXG4gICAgXG4gICAgICAgICAgICAgICAgbGVmdCA9IGxpbmUueDEsIG5leHQ7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgICAgICBsZWZ0ID49IGNsaXAubGVmdCBcbiAgICAgICAgICAgICAgICAmJiBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0gPT0gMFxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9IGNvbG9yUmVkO1xuICAgICAgICAgICAgICAgIGRhdGFbbGVmdCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9IGNvbG9yR3JlZW47XG4gICAgICAgICAgICAgICAgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVF0gPSBjb2xvckJsdWU7XG4gICAgICAgICAgICAgICAgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID0gY29sb3JBbHBoYTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsZWZ0IC09IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAobGVmdCA+PSBsaW5lLngxKSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICBsZWZ0IDw9IGxpbmUueDIgXG4gICAgICAgICAgICAgICAgICAgICYmIGRhdGFbbGVmdCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSAhPSBvbGRBbHBoYVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBsZWZ0ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gbGVmdCArIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0ID4gbGluZS54Mikge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGxlZnQgKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgPCBsaW5lLngxKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goe3gxOiBsZWZ0LCB4MjogbGluZS54MSAtIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLCB5OiBsaW5lLnkgLSBsaW5lLmR5LCBkeTogLWxpbmUuZHl9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCA9IGxpbmUueDEgKyBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgICAgIH1cbiAgICBcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdID0gY29sb3JSZWQ7XG4gICAgICAgICAgICAgICAgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuR1JFRU5fQllURV9PRkZTRVRdID0gY29sb3JHcmVlbjtcbiAgICAgICAgICAgICAgICBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSA9IGNvbG9yQmx1ZTtcbiAgICAgICAgICAgICAgICBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0gPSBjb2xvckFscGhhO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHdoaWxlIChcbiAgICAgICAgICAgICAgICAgICAgbmV4dCA8IGNsaXAucmlnaHQgXG4gICAgICAgICAgICAgICAgICAgICYmIGRhdGFbbmV4dCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSA9PSBvbGRBbHBoYVxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICBkYXRhW25leHQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdID0gY29sb3JSZWQ7XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbbmV4dCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9IGNvbG9yR3JlZW47XG4gICAgICAgICAgICAgICAgICAgIGRhdGFbbmV4dCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdID0gY29sb3JCbHVlO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW25leHQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0gPSBjb2xvckFscGhhO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgbmV4dCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7eDE6IGxlZnQsIHgyOiBuZXh0IC0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwsIHk6IGxpbmUueSArIGxpbmUuZHksIGR5OiBsaW5lLmR5fSk7XG4gICAgXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgLSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCA+IGxpbmUueDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7eDE6IGxpbmUueDIgKyBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCwgeDI6IG5leHQgLSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCwgeTogbGluZS55IC0gbGluZS5keSwgZHk6IC1saW5lLmR5fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIGxlZnQgPSBuZXh0ICsgQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICAgICAgd2hpbGUgKFxuICAgICAgICAgICAgICAgICAgICBsZWZ0IDw9IGxpbmUueDIgJiYgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdICE9IG9sZEFscGhhXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIG5leHQgPSBsZWZ0ICsgQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICB9IHdoaWxlIChsZWZ0IDw9IGxpbmUueDIpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGNvbG9yID09IG9sZENvbG9yKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoc3RhY2subGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgbGluZSA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgICAgICBpZiAobGluZS55IDwgY2xpcC50b3AgfHwgbGluZS55ID49IGNsaXAuYm90dG9tKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGxpbmVPZmZzZXQgPSB0aGlzLm9mZnNldE9mUGl4ZWwoMCwgbGluZS55KSxcblxuICAgICAgICAgICAgICAgIGxlZnQgPSBsaW5lLngxLCBuZXh0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgbGVmdCA+PSBjbGlwLmxlZnQgXG4gICAgICAgICAgICAgICAgJiYgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9PSBvbGRSZWRcbiAgICAgICAgICAgICAgICAmJiBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5HUkVFTl9CWVRFX09GRlNFVF0gPT0gb2xkR3JlZW5cbiAgICAgICAgICAgICAgICAmJiBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSA9PSBvbGRCbHVlXG4gICAgICAgICAgICAgICAgJiYgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID09IG9sZEFscGhhXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdID0gY29sb3JSZWQ7XG4gICAgICAgICAgICAgICAgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuR1JFRU5fQllURV9PRkZTRVRdID0gY29sb3JHcmVlbjtcbiAgICAgICAgICAgICAgICBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSA9IGNvbG9yQmx1ZTtcbiAgICAgICAgICAgICAgICBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0gPSBjb2xvckFscGhhO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGxlZnQgLT0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChsZWZ0ID49IGxpbmUueDEpIHtcbiAgICAgICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPD0gbGluZS54MiBcbiAgICAgICAgICAgICAgICAgICAgJiYgIShcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGFbbGVmdCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLlJFRF9CWVRFX09GRlNFVF0gPT0gb2xkUmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAmJiBkYXRhW2xlZnQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5HUkVFTl9CWVRFX09GRlNFVF0gPT0gb2xkR3JlZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGRhdGFbbGVmdCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdID09IG9sZEJsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGRhdGFbbGVmdCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSA9PSBvbGRBbHBoYVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGxlZnQgKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQgPSBsZWZ0ICsgQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICAgICAgaWYgKGxlZnQgPiBsaW5lLngyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbGVmdCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgICAgICAgICBpZiAobGVmdCA8IGxpbmUueDEpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7eDE6IGxlZnQsIHgyOiBsaW5lLngxIC0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwsIHk6IGxpbmUueSAtIGxpbmUuZHksIGR5OiAtbGluZS5keX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0ID0gbGluZS54MSArIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgICAgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9IGNvbG9yUmVkO1xuICAgICAgICAgICAgICAgIGRhdGFbbGVmdCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9IGNvbG9yR3JlZW47XG4gICAgICAgICAgICAgICAgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVF0gPSBjb2xvckJsdWU7XG4gICAgICAgICAgICAgICAgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID0gY29sb3JBbHBoYTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgICAgIG5leHQgPCBjbGlwLnJpZ2h0IFxuICAgICAgICAgICAgICAgICAgICAmJiBkYXRhW25leHQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdID09IG9sZFJlZFxuICAgICAgICAgICAgICAgICAgICAmJiBkYXRhW25leHQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5HUkVFTl9CWVRFX09GRlNFVF0gPT0gb2xkR3JlZW5cbiAgICAgICAgICAgICAgICAgICAgJiYgZGF0YVtuZXh0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVF0gPT0gb2xkQmx1ZVxuICAgICAgICAgICAgICAgICAgICAmJiBkYXRhW25leHQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0gPT0gb2xkQWxwaGFcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtuZXh0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9IGNvbG9yUmVkO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW25leHQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5HUkVFTl9CWVRFX09GRlNFVF0gPSBjb2xvckdyZWVuO1xuICAgICAgICAgICAgICAgICAgICBkYXRhW25leHQgKyBsaW5lT2Zmc2V0ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSA9IGNvbG9yQmx1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGF0YVtuZXh0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID0gY29sb3JBbHBoYTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIG5leHQgKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YWNrLnB1c2goe3gxOiBsZWZ0LCB4MjogbmV4dCAtIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLCB5OiBsaW5lLnkgKyBsaW5lLmR5LCBkeTogbGluZS5keX0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKG5leHQgLSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCA+IGxpbmUueDIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhY2sucHVzaCh7eDE6IGxpbmUueDIgKyBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCwgeDI6IG5leHQgLSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCwgeTogbGluZS55IC0gbGluZS5keSwgZHk6IC1saW5lLmR5fSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgbGVmdCA9IG5leHQgKyBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoXG4gICAgICAgICAgICAgICAgICAgIGxlZnQgPD0gbGluZS54MiAmJiAhKFxuICAgICAgICAgICAgICAgICAgICAgICAgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9PSBvbGRSZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICYmIGRhdGFbbGVmdCArIGxpbmVPZmZzZXQgKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9PSBvbGRHcmVlblxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVF0gPT0gb2xkQmx1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgJiYgZGF0YVtsZWZ0ICsgbGluZU9mZnNldCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID09IG9sZEFscGhhXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgbGVmdCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXh0ID0gbGVmdCArIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgfSB3aGlsZSAobGVmdCA8PSBsaW5lLngyKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUHJlbXVsdGlwbHkgdGhlIFJHQiBjaGFubmVscyBpbiB0aGUgZ2l2ZW4gUixHLEIsQSBjaGFubmVsIGJ1ZmZlciB3aXRoIHRoZSBhbHBoYSBjaGFubmVsLlxuICogXG4gKiBAcGFyYW0gYnVmZmVyIFIsRyxCLEEgY2hhbm5lbCBhcnJheVxuICogQHBhcmFtIGxlbiBOdW1iZXIgb2YgcGl4ZWxzIGluIGJ1ZmZlciB0byBtb2RpZnlcbiAqL1xuZnVuY3Rpb24gbXVsdGlwbHlBbHBoYShidWZmZXIsIGxlbikge1xuICAgIHZhclxuICAgICAgICBwaXhJbmRleCA9IDA7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGFscGhhID0gYnVmZmVyW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF07XG4gICAgICAgIFxuICAgICAgICAvLyBNdWx0aXBseSB0aGUgUkdCIGNoYW5uZWxzIGJ5IGFscGhhXG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrLCBwaXhJbmRleCsrKSB7XG4gICAgICAgICAgICBidWZmZXJbcGl4SW5kZXhdID0gTWF0aC5yb3VuZChidWZmZXJbcGl4SW5kZXhdICogYWxwaGEgLyAyNTUpO1xuICAgICAgICB9XG4gICAgICAgIHBpeEluZGV4Kys7IC8vIERvbid0IG1vZGlmeSBhbHBoYSBjaGFubmVsXG4gICAgfVxufVxuXG4vKipcbiAqIEludmVyc2Ugb2YgbXVsdGlwbHlBbHBoYSgpXG4gKi9cbmZ1bmN0aW9uIHNlcGFyYXRlQWxwaGEoYnVmZmVyLCBsZW4pIHtcbiAgICB2YXJcbiAgICAgICAgcGl4SW5kZXggPSAwO1xuICAgIFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBhbHBoYSA9IGJ1ZmZlcltwaXhJbmRleCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdO1xuICAgICAgICBcbiAgICAgICAgaWYgKGFscGhhICE9IDApIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGludkFscGhhID0gMjU1IC8gYWxwaGE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgMzsgaisrLCBwaXhJbmRleCsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZmVyW3BpeEluZGV4XSA9IE1hdGgubWluKE1hdGgucm91bmQoYnVmZmVyW3BpeEluZGV4XSAqIGludkFscGhhKSwgMjU1KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvbid0IG1vZGlmeSBhbHBoYSBjaGFubmVsXG4gICAgICAgICAgICBwaXhJbmRleCsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGl4SW5kZXggKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJveEJsdXJMaW5lKHNyYywgZHN0LCBsZW4sIHJhZGl1cykge1xuICAgIHZhclxuICAgICAgICB0b3RhbFBpeGVscyA9IDAsIHRvdGFsQ2hhbm5lbHMgPSBbMCwgMCwgMCwgMF0sXG4gICAgICAgIHBpeEluZGV4LCBkc3RJbmRleDtcbiAgICBcbiAgICBwaXhJbmRleCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCByYWRpdXMgJiYgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUw7IGorKykge1xuICAgICAgICAgICAgdG90YWxDaGFubmVsc1tqXSArPSBzcmNbcGl4SW5kZXgrK107XG4gICAgICAgIH1cbiAgICAgICAgdG90YWxQaXhlbHMrKztcbiAgICB9XG4gICAgXG4gICAgZHN0SW5kZXggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgLy8gTmV3IHBpeGVsIGpvaW5zIHRoZSB3aW5kb3cgYXQgdGhlIHJpZ2h0XG4gICAgICAgIGlmIChpICsgcmFkaXVzIDwgbGVuKSB7XG4gICAgICAgICAgICBwaXhJbmRleCA9IChpICsgcmFkaXVzKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0b3RhbENoYW5uZWxzW2pdICs9IHNyY1twaXhJbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdGFsUGl4ZWxzKys7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMOyBqKyspIHtcbiAgICAgICAgICAgIGRzdFtkc3RJbmRleCsrXSA9IE1hdGgucm91bmQodG90YWxDaGFubmVsc1tqXSAvIHRvdGFsUGl4ZWxzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9sZCBwaXhlbCBsZWF2ZXMgdGhlIHdpbmRvdyBhdCB0aGUgbGVmdFxuICAgICAgICBpZiAoaSAtIHJhZGl1cyA+PSAwKSB7XG4gICAgICAgICAgICBwaXhJbmRleCA9IChpIC0gcmFkaXVzKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMOyBqKyspIHtcbiAgICAgICAgICAgICAgICB0b3RhbENoYW5uZWxzW2pdIC09IHNyY1twaXhJbmRleCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvdGFsUGl4ZWxzLS07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ29weSBhIGNvbHVtbiBvZiBwaXhlbHMgaW4gdGhlIGJpdG1hcCB0byB0aGUgZ2l2ZW4gUixHLEIsQSBidWZmZXIuXG4gKiBcbiAqIEBwYXJhbSB4IFgtY29vcmRpbmF0ZSBvZiBjb2x1bW5cbiAqIEBwYXJhbSB5IFktY29vcmRpbmF0ZSBvZiB0b3Agb2YgY29sdW1uIHRvIGNvcHlcbiAqIEBwYXJhbSBsZW4gTnVtYmVyIG9mIHBpeGVscyB0byBjb3B5XG4gKiBAcGFyYW0gYnVmZmVyIFIsRyxCLEEgYXJyYXlcbiAqL1xuQ1BDb2xvckJtcC5wcm90b3R5cGUuY29weVBpeGVsQ29sdW1uVG9BcnJheSA9IGZ1bmN0aW9uKHgsIHksIGxlbiwgYnVmZmVyKSB7XG4gICAgdmFyXG4gICAgICAgIHlKdW1wID0gKHRoaXMud2lkdGggLSAxKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICBkc3RPZmZzZXQgPSAwLFxuICAgICAgICBzcmNPZmZzZXQgPSB0aGlzLm9mZnNldE9mUGl4ZWwoeCwgeSk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMOyBqKyspIHtcbiAgICAgICAgICAgIGJ1ZmZlcltkc3RPZmZzZXQrK10gPSB0aGlzLmRhdGFbc3JjT2Zmc2V0KytdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBzcmNPZmZzZXQgKz0geUp1bXA7XG4gICAgfVxufVxuXG4vKipcbiAqIENvcHkgdGhlIHBpeGVscyBmcm9tIHRoZSBnaXZlbiBSLEcsQixBIGJ1ZmZlciB0byBhIGNvbHVtbiBvZiBwaXhlbHMgaW4gdGhlIGJpdG1hcC5cbiAqIFxuICogQHBhcmFtIHggWC1jb29yZGluYXRlIG9mIGNvbHVtblxuICogQHBhcmFtIHkgWS1jb29yZGluYXRlIG9mIHRvcCBvZiBjb2x1bW4gdG8gY29weVxuICogQHBhcmFtIGxlbiBOdW1iZXIgb2YgcGl4ZWxzIHRvIGNvcHlcbiAqIEBwYXJhbSBidWZmZXIgUixHLEIsQSBhcnJheSB0byBjb3B5IGZyb21cbiAqL1xuQ1BDb2xvckJtcC5wcm90b3R5cGUuY29weUFycmF5VG9QaXhlbENvbHVtbiA9IGZ1bmN0aW9uKHgsIHksIGxlbiwgYnVmZmVyKSB7XG4gICAgdmFyXG4gICAgICAgIHlKdW1wID0gKHRoaXMud2lkdGggLSAxKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICBzcmNPZmZzZXQgPSAwLFxuICAgICAgICBkc3RPZmZzZXQgPSB0aGlzLm9mZnNldE9mUGl4ZWwoeCwgeSk7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMOyBqKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtkc3RPZmZzZXQrK10gPSBidWZmZXJbc3JjT2Zmc2V0KytdO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBkc3RPZmZzZXQgKz0geUp1bXA7XG4gICAgfVxufVxuXG5DUENvbG9yQm1wLnByb3RvdHlwZS5ib3hCbHVyID0gZnVuY3Rpb24ocmVjdCwgcmFkaXVzWCwgcmFkaXVzWSkge1xuICAgIHJlY3QgPSB0aGlzLmdldEJvdW5kcygpLmNsaXAocmVjdCk7XG5cbiAgICB2YXJcbiAgICAgICAgcmVjdFdpZHRoID0gcmVjdC5nZXRXaWR0aCgpLFxuICAgICAgICByZWN0V2lkdGhCeXRlcyA9IHJlY3RXaWR0aCAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICByZWN0SGVpZ2h0ID0gcmVjdC5nZXRIZWlnaHQoKSxcbiAgICAgICAgcmVjdExlbmd0aCA9IE1hdGgubWF4KHJlY3RXaWR0aCwgcmVjdEhlaWdodCksXG5cbiAgICAgICAgc3JjID0gbmV3IFVpbnQ4QXJyYXkocmVjdExlbmd0aCAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMKSxcbiAgICAgICAgZHN0ID0gbmV3IFVpbnQ4QXJyYXkocmVjdExlbmd0aCAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMKTtcblxuICAgIGZvciAodmFyIHkgPSByZWN0LnRvcDsgeSA8IHJlY3QuYm90dG9tOyB5KyspIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBwaXhPZmZzZXQgPSB0aGlzLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCB5KTtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgcmVjdFdpZHRoQnl0ZXM7IHgrKykge1xuICAgICAgICAgICAgc3JjW3hdID0gdGhpcy5kYXRhW3BpeE9mZnNldCsrXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbXVsdGlwbHlBbHBoYShzcmMsIHJlY3RXaWR0aCk7XG4gICAgICAgIGJveEJsdXJMaW5lKHNyYywgZHN0LCByZWN0V2lkdGgsIHJhZGl1c1gpO1xuICAgICAgICBcbiAgICAgICAgcGl4T2Zmc2V0ID0gdGhpcy5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgeSk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHJlY3RXaWR0aEJ5dGVzOyB4KyspIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhPZmZzZXQrK10gPSBkc3RbeF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZm9yICh2YXIgeCA9IHJlY3QubGVmdDsgeCA8IHJlY3QucmlnaHQ7IHgrKykge1xuICAgICAgICB0aGlzLmNvcHlQaXhlbENvbHVtblRvQXJyYXkoeCwgcmVjdC50b3AsIHJlY3RIZWlnaHQsIHNyYyk7XG4gICAgICAgIFxuICAgICAgICBib3hCbHVyTGluZShzcmMsIGRzdCwgcmVjdEhlaWdodCwgcmFkaXVzWSk7XG4gICAgICAgIHNlcGFyYXRlQWxwaGEoZHN0LCByZWN0SGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuY29weUFycmF5VG9QaXhlbENvbHVtbih4LCByZWN0LnRvcCwgcmVjdEhlaWdodCwgZHN0KTtcbiAgICB9XG59O1xuXG5DUENvbG9yQm1wLnByb3RvdHlwZS5vZmZzZXRPZlBpeGVsID0gZnVuY3Rpb24oeCwgeSkge1xuICAgIHJldHVybiAoKHkgKiB0aGlzLndpZHRoICsgeCkgKiBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCkgfCAwO1xufTtcblxuQ1BDb2xvckJtcC5wcm90b3R5cGUuZ2V0TWVtb3J5U2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmRhdGEubGVuZ3RoO1xufTtcblxuLy8gTG9hZCBmcm9tIGEgbG9hZGVkIEhUTUwgSW1hZ2Ugb2JqZWN0XG5DUENvbG9yQm1wLnByb3RvdHlwZS5sb2FkRnJvbUltYWdlID0gZnVuY3Rpb24oaW1hZ2UpIHtcbiAgICB2YXJcbiAgICAgICAgaW1hZ2VDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICBpbWFnZUNvbnRleHQgPSBpbWFnZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG5cbiAgICBpbWFnZUNhbnZhcy53aWR0aCA9IGltYWdlLndpZHRoO1xuICAgIGltYWdlQ2FudmFzLmhlaWdodCA9IGltYWdlLmhlaWdodDtcbiAgICBcbiAgICBpbWFnZUNvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJjb3B5XCI7XG4gICAgaW1hZ2VDb250ZXh0LmRyYXdJbWFnZShpbWFnZSwgMCwgMCk7XG4gICAgXG4gICAgdGhpcy5pbWFnZURhdGEgPSBpbWFnZUNvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcbiAgICB0aGlzLmRhdGEgPSB0aGlzLmltYWdlRGF0YS5kYXRhO1xufTtcblxuQ1BDb2xvckJtcC5wcm90b3R5cGUuZ2V0SW1hZ2VEYXRhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuaW1hZ2VEYXRhO1xufTtcblxuLyoqXG4gKiBSZXBsYWNlIHRoZSBpbWFnZSBkYXRhIHdpdGggdGhlIHByb3ZpZGVkIEltYWdlRGF0YSBvYmplY3QgKGkuZS4gdXNlIGl0IGJ5IHJlZmVyZW5jZSkuXG4gKlxuICogQHBhcmFtIGltYWdlRGF0YSB7SW1hZ2VEYXRhfVxuICovXG5DUENvbG9yQm1wLnByb3RvdHlwZS5zZXRJbWFnZURhdGEgPSBmdW5jdGlvbihpbWFnZURhdGEpIHtcbiAgICB0aGlzLndpZHRoID0gaW1hZ2VEYXRhLndpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gaW1hZ2VEYXRhLmhlaWdodDtcbiAgICB0aGlzLmltYWdlRGF0YSA9IGltYWdlRGF0YTtcbiAgICB0aGlzLmRhdGEgPSBpbWFnZURhdGEuZGF0YTtcbn07XG4iLCIvKlxuICAgIENoaWNrZW5QYWludFxuICAgIFxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG4gICAgXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IENQQml0bWFwIGZyb20gXCIuL0NQQml0bWFwXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQR3JleUJtcCh3aWR0aCwgaGVpZ2h0LCBiaXREZXB0aCkge1xuXG4gICAgQ1BCaXRtYXAuY2FsbCh0aGlzLCB3aWR0aCwgaGVpZ2h0KTtcblxuICAgIHRoaXMuYml0RGVwdGggPSBiaXREZXB0aDtcbiAgICBcbiAgICBzd2l0Y2ggKGJpdERlcHRoKSB7XG4gICAgICAgIGNhc2UgMzI6XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDMyQXJyYXkod2lkdGggKiBoZWlnaHQpO1xuICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxNjpcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5ldyBVaW50MTZBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aGlzLmRhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDUEdyZXlCbXAodGhpcy53aWR0aCwgdGhpcy5oZWlnaHQsIHRoaXMuYml0RGVwdGgpO1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0LmRhdGEuc2V0KHRoaXMuZGF0YSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5jbGVhckFsbCA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbaV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5jbGVhclJlY3QgPSBmdW5jdGlvbihyZWN0LCB2YWx1ZSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLmdldEJvdW5kcygpLmNsaXAocmVjdCksXG4gICAgICAgICAgICB5U3RyaWRlID0gdGhpcy53aWR0aCAtIHJlY3QuZ2V0V2lkdGgoKSxcbiAgICAgICAgICAgIHBpeEluZGV4ID0gdGhpcy5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgeSA9IHJlY3QudG9wOyB5IDwgcmVjdC5ib3R0b207IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IHJlY3QubGVmdDsgeCA8IHJlY3QucmlnaHQ7IHgrKywgcGl4SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLm1pcnJvckhvcml6b250YWxseSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIG5ld0RhdGEgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCk7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3aWR0aDsgeCsrKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YVt5ICogd2lkdGggKyB4XSA9IHRoaXMuZGF0YVt5ICogd2lkdGggKyB3aWR0aCAtIHggLSAxXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGF0YSA9IG5ld0RhdGE7XG4gICAgfTtcblxuICAgIHRoaXMuYXBwbHlMVVQgPSBmdW5jdGlvbihsdXQpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtpXSA9IGx1dC50YWJsZVt0aGlzLmRhdGFbaV1dO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnRvQ2FudmFzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgaW1hZ2VEYXRhID0gdGhpcy50b0ltYWdlRGF0YSgpLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICAgIFxuICAgICAgICBjYW52YXMud2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgICAgIFxuICAgICAgICBjb250ZXh0LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIDAsIDApO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuICAgIFxuICAgIHRoaXMudG9JbWFnZURhdGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICAgICAgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksXG4gICAgICAgICAgICBpbWFnZURhdGEgPSBjb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNyY0luZGV4ID0gMCxcbiAgICAgICAgICAgIGRzdEluZGV4ID0gMDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDwgdGhpcy5oZWlnaHQ7IHkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB0aGlzLndpZHRoOyB4KyspIHtcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtkc3RJbmRleCsrXSA9IHRoaXMuZGF0YVtzcmNJbmRleF07XG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhLmRhdGFbZHN0SW5kZXgrK10gPSB0aGlzLmRhdGFbc3JjSW5kZXhdO1xuICAgICAgICAgICAgICAgIGltYWdlRGF0YS5kYXRhW2RzdEluZGV4KytdID0gdGhpcy5kYXRhW3NyY0luZGV4XTtcbiAgICAgICAgICAgICAgICBpbWFnZURhdGEuZGF0YVtkc3RJbmRleCsrXSA9IDB4RkY7XG4gICAgICAgICAgICAgICAgc3JjSW5kZXgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGltYWdlRGF0YTtcbiAgICB9O1xufVxuXG5DUEdyZXlCbXAucHJvdG90eXBlLm9mZnNldE9mUGl4ZWwgPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIHkgKiB0aGlzLndpZHRoICsgeDtcbn0iLCIvKlxuICAgIENoaWNrZW5QYWludFxuICAgIFxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG4gICAgXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IENQQ29sb3JCbXAgZnJvbSAnLi9DUENvbG9yQm1wJztcbmltcG9ydCBDUEJsZW5kIGZyb20gJy4vQ1BCbGVuZCc7XG5cbi8qKlxuICogTm90ZSBsYXllciBpcyBub3QgY2xlYXJlZCB0byBhbnkgc3BlY2lmaWMgdmFsdWVzIHVwb24gaW5pdGlhbCBjcmVhdGlvbiwgdXNlIGNsZWFyQWxsKCkuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQTGF5ZXIod2lkdGgsIGhlaWdodCwgbmFtZSkge1xuICAgIC8vIFN1cGVyLWNvbnN0cnVjdG9yXG4gICAgQ1BDb2xvckJtcC5jYWxsKHRoaXMsIHdpZHRoLCBoZWlnaHQpO1xuICAgIFxuICAgIHRoaXMubmFtZSA9IG5hbWUgfHwgXCJcIjtcbiAgICBcbiAgICB0aGlzLmFscGhhID0gMTAwO1xuICAgIHRoaXMudmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5ibGVuZE1vZGUgPSBDUEJsZW5kLkxNX05PUk1BTDtcbn1cblxuQ1BMYXllci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQQ29sb3JCbXAucHJvdG90eXBlKTtcbkNQTGF5ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BMYXllcjtcblxuY29uc3RcbiAgICBCWVRFU19QRVJfUElYRUwgPSA0LFxuICAgIFxuICAgIEFMUEhBX0JZVEVfT0ZGU0VUID0gMztcblxuQ1BMYXllci5wcm90b3R5cGUuY2xlYXJBbGwgPSBmdW5jdGlvbihjb2xvcikge1xuICAgIHZhclxuICAgICAgICBhID0gKGNvbG9yID4+IDI0KSAmIDB4RkYsXG4gICAgICAgIHIgPSAoY29sb3IgPj4gMTYpICYgMHhGRixcbiAgICAgICAgZyA9IChjb2xvciA+PiA4KSAmIDB4RkYsXG4gICAgICAgIGIgPSBjb2xvciAmIDB4RkY7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLndpZHRoICogdGhpcy5oZWlnaHQgKiBCWVRFU19QRVJfUElYRUw7ICkge1xuICAgICAgICB0aGlzLmRhdGFbaSsrXSA9IHI7XG4gICAgICAgIHRoaXMuZGF0YVtpKytdID0gZztcbiAgICAgICAgdGhpcy5kYXRhW2krK10gPSBiO1xuICAgICAgICB0aGlzLmRhdGFbaSsrXSA9IGE7XG4gICAgfVxufTtcblxuQ1BMYXllci5wcm90b3R5cGUuY2xlYXJSZWN0ID0gZnVuY3Rpb24ocmVjdCwgY29sb3IpIHtcbiAgICB2YXJcbiAgICAgICAgYSA9IChjb2xvciA+PiAyNCkgJiAweEZGLFxuICAgICAgICByID0gKGNvbG9yID4+IDE2KSAmIDB4RkYsXG4gICAgICAgIGcgPSAoY29sb3IgPj4gOCkgJiAweEZGLFxuICAgICAgICBiID0gY29sb3IgJiAweEZGO1xuICAgIFxuICAgIHZhclxuICAgICAgICByZWN0ID0gdGhpcy5nZXRCb3VuZHMoKS5jbGlwKHJlY3QpLFxuICAgICAgICB5U3RyaWRlID0gKHRoaXMud2lkdGggLSByZWN0LmdldFdpZHRoKCkpICogQllURVNfUEVSX1BJWEVMLFxuICAgICAgICBcbiAgICAgICAgcGl4SW5kZXggPSB0aGlzLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCk7XG4gICAgXG4gICAgZm9yICh2YXIgeSA9IHJlY3QudG9wOyB5IDwgcmVjdC5ib3R0b207IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICBmb3IgKHZhciB4ID0gcmVjdC5sZWZ0OyB4IDwgcmVjdC5yaWdodDsgeCsrKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXgrK10gPSByO1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4KytdID0gZztcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCsrXSA9IGI7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXgrK10gPSBhO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuLyoqXG4gKiBAcGFyYW0gcmVjdCBDUFJlY3RcbiAqIEBwYXJhbSBzb3VyY2UgQ1BMYXllclxuICovXG5DUExheWVyLnByb3RvdHlwZS5jb3B5UmVnaW9uSEZsaXAgPSBmdW5jdGlvbihyZWN0LCBzb3VyY2UpIHtcbiAgICByZWN0ID0gdGhpcy5nZXRCb3VuZHMoKS5jbGlwKHJlY3QpO1xuXG4gICAgZm9yICh2YXIgeSA9IHJlY3QudG9wOyB5IDwgcmVjdC5ib3R0b207IHkrKykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGRzdE9mZnNldCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHkpLFxuICAgICAgICAgICAgc3JjT2Zmc2V0ID0gc291cmNlLm9mZnNldE9mUGl4ZWwocmVjdC5yaWdodCAtIDEsIHkpO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgeCA9IHJlY3QubGVmdDsgeCA8IHJlY3QucmlnaHQ7IHgrKywgc3JjT2Zmc2V0IC09IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMICogMikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW2RzdE9mZnNldCsrXSA9IHNvdXJjZS5kYXRhW3NyY09mZnNldCsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHJlY3QgQ1BSZWN0XG4gKiBAcGFyYW0gc291cmNlIENQTGF5ZXJcbiAqL1xuQ1BMYXllci5wcm90b3R5cGUuY29weVJlZ2lvblZGbGlwID0gZnVuY3Rpb24ocmVjdCwgc291cmNlKSB7XG4gICAgcmVjdCA9IHRoaXMuZ2V0Qm91bmRzKCkuY2xpcChyZWN0KTtcbiAgICBcbiAgICB2YXJcbiAgICAgICAgd2lkdGhCeXRlcyA9IHJlY3QuZ2V0V2lkdGgoKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuXG4gICAgZm9yICh2YXIgeSA9IHJlY3QudG9wOyB5IDwgcmVjdC5ib3R0b207IHkrKykge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGRzdE9mZnNldCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHkpLFxuICAgICAgICAgICAgc3JjT2Zmc2V0ID0gc291cmNlLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LmJvdHRvbSAtIDEgLSAoeSAtIHJlY3QudG9wKSk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHdpZHRoQnl0ZXM7IHgrKykge1xuICAgICAgICAgICAgdGhpcy5kYXRhW2RzdE9mZnNldCsrXSA9IHNvdXJjZS5kYXRhW3NyY09mZnNldCsrXTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0gciBDUFJlY3RcbiAqL1xuQ1BMYXllci5wcm90b3R5cGUuZmlsbFdpdGhOb2lzZSA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICByZWN0ID0gdGhpcy5nZXRCb3VuZHMoKS5jbGlwKHJlY3QpO1xuXG4gICAgdmFyXG4gICAgICAgIHZhbHVlLFxuICAgICAgICB5U3RyaWRlID0gKHRoaXMud2lkdGggLSByZWN0LmdldFdpZHRoKCkpICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwsXG4gICAgICAgIFxuICAgICAgICBwaXhJbmRleCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKTtcblxuICAgIGZvciAodmFyIHkgPSByZWN0LnRvcDsgeSA8IHJlY3QuYm90dG9tOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IHJlY3QubGVmdDsgeCA8IHJlY3QucmlnaHQ7IHgrKywgcGl4SW5kZXggKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgIHZhbHVlID0gKE1hdGgucmFuZG9tKCkgKiAweDEwMCkgfCAwO1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLlJFRF9CWVRFX09GRlNFVF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuR1JFRU5fQllURV9PRkZTRVRdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSA9IDB4RkY7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIHBpeGVscyBpbiB0aGUgZ2l2ZW4gcmVjdCB3aXRoIHRoZSBnaXZlbiBob3Jpem9udGFsIGdyYWRpZW50LlxuICpcbiAqIEBwYXJhbSByZWN0IENQUmVjdFxuICogQHBhcmFtIGZyb21YIGludFxuICogQHBhcmFtIHRvWCBpbnRcbiAqIEBwYXJhbSBncmFkaWVudFBvaW50cyBpbnRbXVxuICovXG5DUExheWVyLnByb3RvdHlwZS5ncmFkaWVudEhvcnpSZXBsYWNlID0gZnVuY3Rpb24ocmVjdCwgZnJvbVgsIHRvWCwgZ3JhZGllbnRQb2ludHMpIHtcbiAgICB2YXJcbiAgICAgICAgZnJvbUNvbG9yID0ge1xuICAgICAgICAgICAgcjogKGdyYWRpZW50UG9pbnRzWzBdID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICBnOiAoZ3JhZGllbnRQb2ludHNbMF0gPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgYjogZ3JhZGllbnRQb2ludHNbMF0gJiAweEZGLFxuICAgICAgICAgICAgYTogKGdyYWRpZW50UG9pbnRzWzBdID4+IDI0KSAmIDB4RkZcbiAgICAgICAgfSxcbiAgICAgICAgdG9Db2xvciA9IHtcbiAgICAgICAgICAgIHI6IChncmFkaWVudFBvaW50c1sxXSA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgZzogKGdyYWRpZW50UG9pbnRzWzFdID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGI6IGdyYWRpZW50UG9pbnRzWzFdICYgMHhGRixcbiAgICAgICAgICAgIGE6IChncmFkaWVudFBvaW50c1sxXSA+PiAyNCkgJiAweEZGXG4gICAgICAgIH0sXG5cbiAgICAgICAgeVN0cmlkZSA9ICh0aGlzLndpZHRoIC0gcmVjdC5nZXRXaWR0aCgpKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICBwaXhJbmRleCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDAsXG4gICAgICAgIGggPSAocmVjdC5ib3R0b20gLSByZWN0LnRvcCkgfCAwO1xuXG4gICAgaWYgKHRvWCA8IGZyb21YKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgdGVtcCA9IHRvWDtcbiAgICAgICAgdG9YID0gZnJvbVg7XG4gICAgICAgIGZyb21YID0gdGVtcDtcblxuICAgICAgICB0ZW1wID0gZnJvbUNvbG9yO1xuICAgICAgICBmcm9tQ29sb3IgPSB0b0NvbG9yO1xuICAgICAgICB0b0NvbG9yID0gdGVtcDtcbiAgICB9XG4gICAgXG4gICAgdmFyXG4gICAgICAgIGdyYWRpZW50UmFuZ2UgPSAodG9YIC0gZnJvbVgpIHwgMCxcbiAgICAgICAgclN0ZXAgPSAodG9Db2xvci5yIC0gZnJvbUNvbG9yLnIpIC8gZ3JhZGllbnRSYW5nZSxcbiAgICAgICAgZ1N0ZXAgPSAodG9Db2xvci5nIC0gZnJvbUNvbG9yLmcpIC8gZ3JhZGllbnRSYW5nZSxcbiAgICAgICAgYlN0ZXAgPSAodG9Db2xvci5iIC0gZnJvbUNvbG9yLmIpIC8gZ3JhZGllbnRSYW5nZSxcbiAgICAgICAgYVN0ZXAgPSAodG9Db2xvci5hIC0gZnJvbUNvbG9yLmEpIC8gZ3JhZGllbnRSYW5nZSxcbiAgICBcbiAgICAgICAganVtcCA9IE1hdGgubWF4KHJlY3QubGVmdCAtIGZyb21YLCAwKTtcblxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaDsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgIC8vIFRoZSBzb2xpZCBjb2xvciBzZWN0aW9uIGJlZm9yZSB0aGUgZ3JhZGllbnRcbiAgICAgICAgdmFyXG4gICAgICAgICAgICB4ID0gcmVjdC5sZWZ0O1xuXG4gICAgICAgIGZvciAodmFyIHhFbmQgPSBNYXRoLm1pbihmcm9tWCwgcmVjdC5yaWdodCkgfCAwOyB4IDwgeEVuZDsgeCsrLCBwaXhJbmRleCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdID0gZnJvbUNvbG9yLnI7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9IGZyb21Db2xvci5nO1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSA9IGZyb21Db2xvci5iO1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0gPSBmcm9tQ29sb3IuYTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEluIHRoZSBncmFkaWVudFxuICAgICAgICB2YXJcbiAgICAgICAgICAgIHIgPSBmcm9tQ29sb3IuciArIHJTdGVwICoganVtcCxcbiAgICAgICAgICAgIGcgPSBmcm9tQ29sb3IuZyArIGdTdGVwICoganVtcCxcbiAgICAgICAgICAgIGIgPSBmcm9tQ29sb3IuYiArIGJTdGVwICoganVtcCxcbiAgICAgICAgICAgIGEgPSBmcm9tQ29sb3IuYSArIGFTdGVwICoganVtcDtcblxuICAgICAgICBmb3IgKHhFbmQgPSBNYXRoLm1pbih0b1gsIHJlY3QucmlnaHQpIHwgMDsgeCA8IHhFbmQ7IHgrKywgcGl4SW5kZXggKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9IHI7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9IGc7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdID0gYjtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID0gYTtcblxuICAgICAgICAgICAgciArPSByU3RlcDtcbiAgICAgICAgICAgIGcgKz0gZ1N0ZXA7XG4gICAgICAgICAgICBiICs9IGJTdGVwO1xuICAgICAgICAgICAgYSArPSBhU3RlcDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRoZSBzZWN0aW9uIGFmdGVyIHRoZSBlbmQgb2YgdGhlIGdyYWRpZW50XG4gICAgICAgIGZvciAoOyB4IDwgcmVjdC5yaWdodDsgeCsrLCBwaXhJbmRleCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdID0gdG9Db2xvci5yO1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5HUkVFTl9CWVRFX09GRlNFVF0gPSB0b0NvbG9yLmc7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdID0gdG9Db2xvci5iO1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0gPSB0b0NvbG9yLmE7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG4vKipcbiAqIFJlcGxhY2UgdGhlIHBpeGVscyBpbiB0aGUgZ2l2ZW4gcmVjdCB3aXRoIHRoZSBnaXZlbiB2ZXJ0aWNhbCBncmFkaWVudC5cbiAqXG4gKiBAcGFyYW0ge0NQUmVjdH0gcmVjdFxuICogQHBhcmFtIGZyb21ZIGludFxuICogQHBhcmFtIHRvWSBpbnRcbiAqIEBwYXJhbSBncmFkaWVudFBvaW50cyBpbnRbXVxuICovXG5DUExheWVyLnByb3RvdHlwZS5ncmFkaWVudFZlcnRSZXBsYWNlID0gZnVuY3Rpb24ocmVjdCwgZnJvbVksIHRvWSwgZ3JhZGllbnRQb2ludHMpIHtcbiAgICB2YXJcbiAgICAgICAgZnJvbUNvbG9yID0ge1xuICAgICAgICAgICAgcjogKGdyYWRpZW50UG9pbnRzWzBdID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICBnOiAoZ3JhZGllbnRQb2ludHNbMF0gPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgYjogZ3JhZGllbnRQb2ludHNbMF0gJiAweEZGLFxuICAgICAgICAgICAgYTogKGdyYWRpZW50UG9pbnRzWzBdID4+IDI0KSAmIDB4RkZcbiAgICAgICAgfSxcbiAgICAgICAgdG9Db2xvciA9IHtcbiAgICAgICAgICAgIHI6IChncmFkaWVudFBvaW50c1sxXSA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgZzogKGdyYWRpZW50UG9pbnRzWzFdID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGI6IGdyYWRpZW50UG9pbnRzWzFdICYgMHhGRixcbiAgICAgICAgICAgIGE6IChncmFkaWVudFBvaW50c1sxXSA+PiAyNCkgJiAweEZGXG4gICAgICAgIH0sXG5cbiAgICAgICAgeVN0cmlkZSA9ICh0aGlzLndpZHRoIC0gcmVjdC5nZXRXaWR0aCgpKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICBwaXhJbmRleCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDAsXG4gICAgICAgIHcgPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgfCAwO1xuXG4gICAgaWYgKHRvWSA8IGZyb21ZKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgdGVtcCA9IHRvWTtcbiAgICAgICAgdG9ZID0gZnJvbVk7XG4gICAgICAgIGZyb21ZID0gdGVtcDtcblxuICAgICAgICB0ZW1wID0gZnJvbUNvbG9yO1xuICAgICAgICBmcm9tQ29sb3IgPSB0b0NvbG9yO1xuICAgICAgICB0b0NvbG9yID0gdGVtcDtcbiAgICB9XG5cbiAgICB2YXJcbiAgICAgICAgeSA9IHJlY3QudG9wO1xuXG4gICAgLy8gVGhlIHNvbGlkIGNvbG9yIHNlY3Rpb24gYmVmb3JlIHRoZSBzdGFydCBvZiB0aGUgZ3JhZGllbnRcbiAgICBmb3IgKHZhciB5RW5kID0gTWF0aC5taW4ocmVjdC5ib3R0b20sIGZyb21ZKSB8IDA7IHkgPCB5RW5kOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLlJFRF9CWVRFX09GRlNFVF0gPSBmcm9tQ29sb3IucjtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuR1JFRU5fQllURV9PRkZTRVRdID0gZnJvbUNvbG9yLmc7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdID0gZnJvbUNvbG9yLmI7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSA9IGZyb21Db2xvci5hO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gSW5zaWRlIHRoZSBncmFkaWVudFxuICAgIHZhclxuICAgICAgICBncmFkaWVudFJhbmdlID0gKHRvWSAtIGZyb21ZKSB8IDAsXG4gICAgICAgIHJTdGVwID0gKHRvQ29sb3IuciAtIGZyb21Db2xvci5yKSAvIGdyYWRpZW50UmFuZ2UsXG4gICAgICAgIGdTdGVwID0gKHRvQ29sb3IuZyAtIGZyb21Db2xvci5nKSAvIGdyYWRpZW50UmFuZ2UsXG4gICAgICAgIGJTdGVwID0gKHRvQ29sb3IuYiAtIGZyb21Db2xvci5iKSAvIGdyYWRpZW50UmFuZ2UsXG4gICAgICAgIGFTdGVwID0gKHRvQ29sb3IuYSAtIGZyb21Db2xvci5hKSAvIGdyYWRpZW50UmFuZ2UsXG4gICAgICAgIFxuICAgICAgICBqdW1wID0gTWF0aC5tYXgoeSAtIGZyb21ZLCAwKSxcbiAgICAgICAgciA9IGZyb21Db2xvci5yICsgclN0ZXAgKiBqdW1wLFxuICAgICAgICBnID0gZnJvbUNvbG9yLmcgKyBnU3RlcCAqIGp1bXAsXG4gICAgICAgIGIgPSBmcm9tQ29sb3IuYiArIGJTdGVwICoganVtcCxcbiAgICAgICAgYSA9IGZyb21Db2xvci5hICsgYVN0ZXAgKiBqdW1wO1xuXG4gICAgZm9yICh2YXIgeUVuZCA9IE1hdGgubWluKHJlY3QuYm90dG9tLCB0b1kpIHwgMDsgeSA8IHlFbmQ7IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKywgcGl4SW5kZXggKz0gQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9IHI7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9IGc7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdID0gYjtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID0gYTtcbiAgICAgICAgfVxuXG4gICAgICAgIHIgKz0gclN0ZXA7XG4gICAgICAgIGcgKz0gZ1N0ZXA7XG4gICAgICAgIGIgKz0gYlN0ZXA7XG4gICAgICAgIGEgKz0gYVN0ZXA7XG4gICAgfVxuXG4gICAgLy8gVGhlIHNlY3Rpb24gYWZ0ZXIgdGhlIGVuZCBvZiB0aGUgZ3JhZGllbnRcbiAgICBmb3IgKDsgeSA8IHJlY3QuYm90dG9tOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLlJFRF9CWVRFX09GRlNFVF0gPSB0b0NvbG9yLnI7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9IHRvQ29sb3IuZztcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVF0gPSB0b0NvbG9yLmI7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSA9IHRvQ29sb3IuYTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogUmVwbGFjZSB0aGUgcGl4ZWxzIGluIHRoZSBnaXZlbiByZWN0IHdpdGggdGhlIGdpdmVuIGdyYWRpZW50LlxuICpcbiAqIEBwYXJhbSByZWN0IENQUmVjdFxuICogQHBhcmFtIGZyb21YIGludFxuICogQHBhcmFtIGZyb21ZIGludFxuICogQHBhcmFtIHRvWCBpbnRcbiAqIEBwYXJhbSB0b1kgaW50XG4gKiBAcGFyYW0gZ3JhZGllbnRQb2ludHMgaW50W11cbiAqL1xuQ1BMYXllci5wcm90b3R5cGUuZ3JhZGllbnRSZXBsYWNlID0gZnVuY3Rpb24ocmVjdCwgZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSwgZ3JhZGllbnRQb2ludHMpIHtcbiAgICB2YXJcbiAgICAgICAgeVN0cmlkZSA9ICh0aGlzLndpZHRoIC0gcmVjdC5nZXRXaWR0aCgpKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICBwaXhJbmRleCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChyZWN0LmxlZnQsIHJlY3QudG9wKSB8IDAsXG4gICAgICAgIHcgPSAocmVjdC5yaWdodCAtIHJlY3QubGVmdCkgfCAwLFxuXG4gICAgICAgIGZyb21Db2xvciA9IHtcbiAgICAgICAgICAgIHI6IChncmFkaWVudFBvaW50c1swXSA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgZzogKGdyYWRpZW50UG9pbnRzWzBdID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGI6IGdyYWRpZW50UG9pbnRzWzBdICYgMHhGRixcbiAgICAgICAgICAgIGE6IChncmFkaWVudFBvaW50c1swXSA+PiAyNCkgJiAweEZGXG4gICAgICAgIH0sXG4gICAgICAgIHRvQ29sb3IgPSB7XG4gICAgICAgICAgICByOiAoZ3JhZGllbnRQb2ludHNbMV0gPj4gMTYpICYgMHhGRixcbiAgICAgICAgICAgIGc6IChncmFkaWVudFBvaW50c1sxXSA+PiA4KSAmIDB4RkYsXG4gICAgICAgICAgICBiOiBncmFkaWVudFBvaW50c1sxXSAmIDB4RkYsXG4gICAgICAgICAgICBhOiAoZ3JhZGllbnRQb2ludHNbMV0gPj4gMjQpICYgMHhGRlxuICAgICAgICB9LFxuXG4gICAgLy8gSG93IG1hbnkgcGl4ZWxzIHZlcnRpY2FsbHkgZG9lcyB0aGUgZ3JhZGllbnQgc2VxdWVuY2UgY29tcGxldGUgb3ZlciAoK2luZmluaXR5IGZvciBob3Jpem9udGFsIGdyYWRpZW50cyEpXG4gICAgICAgIHZlcnRSYW5nZSA9ICh0b1kgLSBmcm9tWSkgKyAoKHRvWCAtIGZyb21YKSAqICh0b1ggLSBmcm9tWCkpIC8gKHRvWSAtIGZyb21ZKSxcbiAgICAvLyBTYW1lIGZvciBob3Jpem9udGFsXG4gICAgICAgIGhvcnpSYW5nZSA9ICh0b1ggLSBmcm9tWCkgKyAoKHRvWSAtIGZyb21ZKSAqICh0b1kgLSBmcm9tWSkpIC8gKHRvWCAtIGZyb21YKSxcbiAgICAgICAgaG9yelN0ZXAgPSAxIC8gaG9yelJhbmdlO1xuXG4gICAgZm9yICh2YXIgeSA9IHJlY3QudG9wOyB5IDwgcmVjdC5ib3R0b207IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICB2YXJcbiAgICAgICAgLy8gVGhlIHBvc2l0aW9uIHRoZSByb3cgc3RhcnRzIGF0IGluIHRoZSBncmFkaWVudCBbMC4wIC4uLiAxLjApXG4gICAgICAgICAgICBwcm9wID0gKHJlY3QubGVmdCAtIGZyb21YKSAvIGhvcnpSYW5nZSArICh5IC0gZnJvbVkpIC8gdmVydFJhbmdlO1xuXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdzsgeCsrLCBwaXhJbmRleCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgcHJvcENsYW1wZWQgPSBNYXRoLm1pbihNYXRoLm1heChwcm9wLCAwLjApLCAxLjApLFxuICAgICAgICAgICAgICAgIGludlByb3BDbGFtcGVkID0gMSAtIHByb3BDbGFtcGVkO1xuXG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLlJFRF9CWVRFX09GRlNFVF0gPSBmcm9tQ29sb3IuciAqIGludlByb3BDbGFtcGVkICsgdG9Db2xvci5yICogcHJvcENsYW1wZWQ7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9IGZyb21Db2xvci5nICogaW52UHJvcENsYW1wZWQgKyB0b0NvbG9yLmcgKiBwcm9wQ2xhbXBlZDtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVF0gPSBmcm9tQ29sb3IuYiAqIGludlByb3BDbGFtcGVkICsgdG9Db2xvci5iICogcHJvcENsYW1wZWQ7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSA9IGZyb21Db2xvci5hICogaW52UHJvcENsYW1wZWQgKyB0b0NvbG9yLmEgKiBwcm9wQ2xhbXBlZDtcblxuICAgICAgICAgICAgcHJvcCArPSBob3J6U3RlcDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQWxwaGEgYmxlbmQgdGhlIGdpdmVuIGdyYWRpZW50IG9udG8gdGhlIHBpeGVscyBpbiB0aGUgZ2l2ZW4gcmVjdC5cbiAqXG4gKiBAcGFyYW0gcmVjdCBDUFJlY3RcbiAqIEBwYXJhbSBmcm9tWCBpbnRcbiAqIEBwYXJhbSBmcm9tWSBpbnRcbiAqIEBwYXJhbSB0b1ggaW50XG4gKiBAcGFyYW0gdG9ZIGludFxuICogQHBhcmFtIGdyYWRpZW50UG9pbnRzIGludFtdXG4gKi9cbkNQTGF5ZXIucHJvdG90eXBlLmdyYWRpZW50QWxwaGEgPSBmdW5jdGlvbihyZWN0LCBmcm9tWCwgZnJvbVksIHRvWCwgdG9ZLCBncmFkaWVudFBvaW50cykge1xuICAgIHZhclxuICAgICAgICB5U3RyaWRlID0gKHRoaXMud2lkdGggLSByZWN0LmdldFdpZHRoKCkpICogQ1BDb2xvckJtcC5CWVRFU19QRVJfUElYRUwsXG4gICAgICAgIHBpeEluZGV4ID0gdGhpcy5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApIHwgMCxcbiAgICAgICAgdyA9IChyZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0KSB8IDAsXG5cbiAgICAgICAgZnJvbUNvbG9yID0ge1xuICAgICAgICAgICAgcjogKGdyYWRpZW50UG9pbnRzWzBdID4+IDE2KSAmIDB4RkYsXG4gICAgICAgICAgICBnOiAoZ3JhZGllbnRQb2ludHNbMF0gPj4gOCkgJiAweEZGLFxuICAgICAgICAgICAgYjogZ3JhZGllbnRQb2ludHNbMF0gJiAweEZGLFxuICAgICAgICAgICAgYTogKGdyYWRpZW50UG9pbnRzWzBdID4+IDI0KSAmIDB4RkZcbiAgICAgICAgfSxcbiAgICAgICAgdG9Db2xvciA9IHtcbiAgICAgICAgICAgIHI6IChncmFkaWVudFBvaW50c1sxXSA+PiAxNikgJiAweEZGLFxuICAgICAgICAgICAgZzogKGdyYWRpZW50UG9pbnRzWzFdID4+IDgpICYgMHhGRixcbiAgICAgICAgICAgIGI6IGdyYWRpZW50UG9pbnRzWzFdICYgMHhGRixcbiAgICAgICAgICAgIGE6IChncmFkaWVudFBvaW50c1sxXSA+PiAyNCkgJiAweEZGXG4gICAgICAgIH0sXG5cbiAgICAvLyBIb3cgbWFueSBwaXhlbHMgdmVydGljYWxseSBkb2VzIHRoZSBncmFkaWVudCBzZXF1ZW5jZSBjb21wbGV0ZSBvdmVyICgraW5maW5pdHkgZm9yIGhvcml6b250YWwgZ3JhZGllbnRzISlcbiAgICAgICAgdmVydFJhbmdlID0gKHRvWSAtIGZyb21ZKSArICgodG9YIC0gZnJvbVgpICogKHRvWCAtIGZyb21YKSkgLyAodG9ZIC0gZnJvbVkpLFxuICAgIC8vIFNhbWUgZm9yIGhvcml6b250YWxcbiAgICAgICAgaG9yelJhbmdlID0gKHRvWCAtIGZyb21YKSArICgodG9ZIC0gZnJvbVkpICogKHRvWSAtIGZyb21ZKSkgLyAodG9YIC0gZnJvbVgpLFxuICAgICAgICBob3J6U3RlcCA9IDEgLyBob3J6UmFuZ2U7XG5cbiAgICBmb3IgKHZhciB5ID0gcmVjdC50b3A7IHkgPCByZWN0LmJvdHRvbTsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgIHZhclxuICAgICAgICAvLyBUaGUgcG9zaXRpb24gdGhlIHJvdyBzdGFydHMgYXQgaW4gdGhlIGdyYWRpZW50IFswLjAgLi4uIDEuMClcbiAgICAgICAgICAgIHByb3AgPSAocmVjdC5sZWZ0IC0gZnJvbVgpIC8gaG9yelJhbmdlICsgKHkgLSBmcm9tWSkgLyB2ZXJ0UmFuZ2U7XG5cbiAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyssIHBpeEluZGV4ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBwcm9wQ2xhbXBlZCA9IE1hdGgubWluKE1hdGgubWF4KHByb3AsIDAuMCksIDEuMCksXG4gICAgICAgICAgICAgICAgaW52UHJvcENsYW1wZWQgPSAxIC0gcHJvcENsYW1wZWQsXG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgZ3JhZGllbnQgY29sb3IgdG8gZHJhd1xuICAgICAgICAgICAgICAgIHIgPSBmcm9tQ29sb3IuciAqIGludlByb3BDbGFtcGVkICsgdG9Db2xvci5yICogcHJvcENsYW1wZWQsXG4gICAgICAgICAgICAgICAgZyA9IGZyb21Db2xvci5nICogaW52UHJvcENsYW1wZWQgKyB0b0NvbG9yLmcgKiBwcm9wQ2xhbXBlZCxcbiAgICAgICAgICAgICAgICBiID0gZnJvbUNvbG9yLmIgKiBpbnZQcm9wQ2xhbXBlZCArIHRvQ29sb3IuYiAqIHByb3BDbGFtcGVkLFxuICAgICAgICAgICAgICAgIGEgPSBmcm9tQ29sb3IuYSAqIGludlByb3BDbGFtcGVkICsgdG9Db2xvci5hICogcHJvcENsYW1wZWQsXG5cbiAgICAgICAgICAgICAgICBhbHBoYTIgPSB0aGlzLmRhdGFbcGl4SW5kZXggKyBBTFBIQV9CWVRFX09GRlNFVF0sXG4gICAgICAgICAgICAgICAgbmV3QWxwaGEgPSAoYSArIGFscGhhMiAtIGEgKiBhbHBoYTIgLyAyNTUpIHwgMDtcblxuICAgICAgICAgICAgaWYgKG5ld0FscGhhID4gMCkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICByZWFsQWxwaGEgPSAoYSAqIDI1NSAvIG5ld0FscGhhKSB8IDAsXG4gICAgICAgICAgICAgICAgICAgIGludkFscGhhID0gMjU1IC0gcmVhbEFscGhhO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdID0gICAoKHIgKiByZWFsQWxwaGEgKyB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLlJFRF9CWVRFX09GRlNFVF0gKiBpbnZBbHBoYSkgLyAyNTUpIHwgMDtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9ICgoZyAqIHJlYWxBbHBoYSArIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuR1JFRU5fQllURV9PRkZTRVRdICogaW52QWxwaGEpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSA9ICAoKGIgKiByZWFsQWxwaGEgKyB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkJMVUVfQllURV9PRkZTRVRdICogaW52QWxwaGEpIC8gMjU1KSB8IDA7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5BTFBIQV9CWVRFX09GRlNFVF0gPSBuZXdBbHBoYTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcHJvcCArPSBob3J6U3RlcDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogRHJhdyBhIGdyYWRpZW50IHdoaWNoIGJlZ2lucyBhdCBmcm9tWCwgZnJvbVkgYW5kIGVuZHMgYXQgdG9YLCB0b1ksIGNsaXBwZWQgdG8gdGhlIGdpdmVuIHJlY3QsIG9uIHRvcCBvZiB0aGVcbiAqIHBpeGVscyBpbiB0aGUgbGF5ZXIuXG4gKlxuICogQHBhcmFtIGdyYWRpZW50UG9pbnRzIEFycmF5IHdpdGggZ3JhZGllbnQgY29sb3JzIChBUkdCIGludGVnZXJzKVxuICogQHBhcmFtIHJlY3QgQ1BSZWN0XG4gKiBAcGFyYW0gcmVwbGFjZSBTZXQgdG8gdHJ1ZSB0byByZXBsYWNlIHRoZSBwaXhlbHMgaW4gdGhlIGxheWVyIHJhdGhlciB0aGFuIGJsZW5kaW5nIHRoZSBncmFkaWVudCBvbiB0b3Agb2YgdGhlbS5cbiAqL1xuQ1BMYXllci5wcm90b3R5cGUuZ3JhZGllbnQgPSBmdW5jdGlvbihyZWN0LCBmcm9tWCwgZnJvbVksIHRvWCwgdG9ZLCBncmFkaWVudFBvaW50cywgcmVwbGFjZSkge1xuICAgIHJlY3QgPSB0aGlzLmdldEJvdW5kcygpLmNsaXAocmVjdCk7XG5cbiAgICAvLyBEZWdlbmVyYXRlIGNhc2VcbiAgICBpZiAoZnJvbVggPT0gdG9YICYmIGZyb21ZID09IHRvWSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gT3BhcXVlIGJsZW5kIGlmIHBvc3NpYmxlXG4gICAgaWYgKHJlcGxhY2UgfHwgZ3JhZGllbnRQb2ludHNbMF0gPj4+IDI0ID09IDI1NSAmJiBncmFkaWVudFBvaW50c1sxXSA+Pj4gMjQgPT0gMjU1KSB7XG4gICAgICAgIGlmIChmcm9tWCA9PSB0b1gpIHtcbiAgICAgICAgICAgIHRoaXMuZ3JhZGllbnRWZXJ0UmVwbGFjZShyZWN0LCBmcm9tWSwgdG9ZLCBncmFkaWVudFBvaW50cyk7XG4gICAgICAgIH0gZWxzZSBpZiAoZnJvbVkgPT0gdG9ZKSB7XG4gICAgICAgICAgICB0aGlzLmdyYWRpZW50SG9yelJlcGxhY2UocmVjdCwgZnJvbVgsIHRvWCwgZ3JhZGllbnRQb2ludHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5ncmFkaWVudFJlcGxhY2UocmVjdCwgZnJvbVgsIGZyb21ZLCB0b1gsIHRvWSwgZ3JhZGllbnRQb2ludHMpO1xuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5ncmFkaWVudEFscGhhKHJlY3QsIGZyb21YLCBmcm9tWSwgdG9YLCB0b1ksIGdyYWRpZW50UG9pbnRzKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIEBwYXJhbSByIENQUmVjdFxuICovXG5DUExheWVyLnByb3RvdHlwZS5maWxsV2l0aENvbG9yTm9pc2UgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgcmVjdCA9IHRoaXMuZ2V0Qm91bmRzKCkuY2xpcChyZWN0KTtcblxuICAgIHZhclxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgeVN0cmlkZSA9ICh0aGlzLndpZHRoIC0gcmVjdC5nZXRXaWR0aCgpKSAqIENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMLFxuICAgICAgICBcbiAgICAgICAgcGl4SW5kZXggPSB0aGlzLm9mZnNldE9mUGl4ZWwocmVjdC5sZWZ0LCByZWN0LnRvcCk7XG5cbiAgICBmb3IgKHZhciB5ID0gcmVjdC50b3A7IHkgPCByZWN0LmJvdHRvbTsgeSsrLCBwaXhJbmRleCArPSB5U3RyaWRlKSB7XG4gICAgICAgIGZvciAodmFyIHggPSByZWN0LmxlZnQ7IHggPCByZWN0LnJpZ2h0OyB4KyssIHBpeEluZGV4ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IChNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwKSB8IDA7XG5cbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9ICh2YWx1ZSA+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5HUkVFTl9CWVRFX09GRlNFVF0gPSAodmFsdWUgPj4gOCkgJiAweEZGO1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSA9IHZhbHVlICYgMHhGRjtcbiAgICAgICAgICAgIHRoaXMuZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID0gMHhGRjtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cbi8qKlxuICogQHBhcmFtIHIgQ1BSZWN0XG4gKi9cbkNQTGF5ZXIucHJvdG90eXBlLmludmVydCA9IGZ1bmN0aW9uKHJlY3QpIHtcbiAgICByZWN0ID0gdGhpcy5nZXRCb3VuZHMoKS5jbGlwKHJlY3QpO1xuXG4gICAgdmFyXG4gICAgICAgIHlTdHJpZGUgPSAodGhpcy53aWR0aCAtIHJlY3QuZ2V0V2lkdGgoKSkgKiBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCxcbiAgICAgICAgXG4gICAgICAgIHBpeEluZGV4ID0gdGhpcy5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApO1xuXG4gICAgZm9yICh2YXIgeSA9IHJlY3QudG9wOyB5IDwgcmVjdC5ib3R0b207IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICBmb3IgKHZhciB4ID0gcmVjdC5sZWZ0OyB4IDwgcmVjdC5yaWdodDsgeCsrLCBwaXhJbmRleCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdIF49IDB4RkY7XG4gICAgICAgICAgICB0aGlzLmRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSBePSAweEZGO1xuICAgICAgICAgICAgdGhpcy5kYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5CTFVFX0JZVEVfT0ZGU0VUXSBePSAweEZGO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQ1BMYXllci5wcm90b3R5cGUuZ2V0QWxwaGEgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5hbHBoYTtcbn07XG5cbkNQTGF5ZXIucHJvdG90eXBlLmdldEJsZW5kTW9kZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmJsZW5kTW9kZTtcbn07XG5cbkNQTGF5ZXIucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyXG4gICAgICAgIHJlc3VsdCA9IG5ldyBDUExheWVyKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCBcIlwiKTtcblxuICAgIHJlc3VsdC5jb3B5RnJvbSh0aGlzKTtcblxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG5DUExheWVyLnByb3RvdHlwZS5jb3B5RnJvbSA9IGZ1bmN0aW9uKGxheWVyKSB7XG4gICAgdGhpcy5uYW1lID0gbGF5ZXIubmFtZTtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IGxheWVyLmJsZW5kTW9kZTtcbiAgICB0aGlzLmFscGhhID0gbGF5ZXIuYWxwaGE7XG4gICAgdGhpcy52aXNpYmxlID0gbGF5ZXIudmlzaWJsZTtcblxuICAgIHRoaXMuY29weURhdGFGcm9tKGxheWVyKTtcbn07XG5cbi8vIERvIHdlIGhhdmUgYW55IG5vbi1vcGFxdWUgcGl4ZWxzIGluIHRoZSBlbnRpcmUgbGF5ZXI/XG5DUExheWVyLnByb3RvdHlwZS5oYXNBbHBoYSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLmFscGhhICE9IDEwMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgdmFyIFxuICAgICAgICBwaXhJbmRleCA9IEFMUEhBX0JZVEVfT0ZGU0VUO1xuICAgIFxuICAgIGZvciAodmFyIHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBhbHBoYUFuZGVkID0gMHhGRjtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIHggPSAwOyB4IDwgdGhpcy53aWR0aDsgeCsrLCBwaXhJbmRleCArPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgIGFscGhhQW5kZWQgJj0gdGhpcy5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gT25seSBjaGVjayBvbmNlIHBlciByb3cgaW4gb3JkZXIgdG8gcmVkdWNlIGJyYW5jaGluZyBpbiB0aGUgaW5uZXIgbG9vcFxuICAgICAgICBpZiAoYWxwaGFBbmRlZCAhPSAweEZGKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBEbyB3ZSBoYXZlIGFueSBzZW1pLXRyYW5zcGFyZW50IHBpeGVscyBpbiB0aGUgZ2l2ZW4gcmVjdGFuZ2xlP1xuQ1BMYXllci5wcm90b3R5cGUuaGFzQWxwaGFJblJlY3QgPSBmdW5jdGlvbihyZWN0KSB7XG4gICAgaWYgKHRoaXMuYWxwaGEgIT0gMTAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIHJlY3QgPSB0aGlzLmdldEJvdW5kcygpLmNsaXAocmVjdCk7XG5cbiAgICB2YXIgXG4gICAgICAgIHlTdHJpZGUgPSAodGhpcy53aWR0aCAtIHJlY3QuZ2V0V2lkdGgoKSkgKiBCWVRFU19QRVJfUElYRUwsXG4gICAgICAgIHBpeEluZGV4ID0gdGhpcy5vZmZzZXRPZlBpeGVsKHJlY3QubGVmdCwgcmVjdC50b3ApICsgQUxQSEFfQllURV9PRkZTRVQ7XG4gICAgXG4gICAgZm9yICh2YXIgeSA9IHJlY3QudG9wOyB5IDwgcmVjdC5ib3R0b207IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGFscGhhQW5kZWQgPSAweEZGO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgeCA9IHJlY3QubGVmdDsgeCA8IHJlY3QucmlnaHQ7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICBhbHBoYUFuZGVkICY9IHRoaXMuZGF0YVtwaXhJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIE9ubHkgY2hlY2sgb25jZSBwZXIgcm93IGluIG9yZGVyIHRvIHJlZHVjZSBicmFuY2hpbmcgaW4gdGhlIGlubmVyIGxvb3BcbiAgICAgICAgaWYgKGFscGhhQW5kZWQgIT0gMHhGRikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuLyoqXG4gKiBHZXQgYSByZWN0YW5nbGUgdGhhdCBlbmNsb3NlcyBhbnkgbm9uLXRyYW5zcGFyZW50IHBpeGVscyBpbiB0aGUgbGF5ZXIgd2l0aGluIHRoZSBnaXZlbiBpbml0aWFsQm91bmRzIChvciBhbiBlbXB0eVxuICogcmVjdCBpZiB0aGUgcGl4ZWxzIGluc2lkZSB0aGUgZ2l2ZW4gYm91bmRzIGFyZSAxMDAlIHRyYW5zcGFyZW50KS5cbiAqXG4gKiBAcGFyYW0ge0NQUmVjdH0gaW5pdGlhbEJvdW5kcyAtIFRoZSByZWN0IHRvIHNlYXJjaCB3aXRoaW4gKHBhc3MgZ2V0Qm91bmRzKCkgdG8gc2VhcmNoIHRoZSB3aG9sZSBsYXllcilcbiAqXG4gKiBAcmV0dXJucyB7Q1BSZWN0fVxuICovXG5DUExheWVyLnByb3RvdHlwZS5nZXROb25UcmFuc3BhcmVudEJvdW5kcyA9IGZ1bmN0aW9uKGluaXRpYWxCb3VuZHMpIHtcbiAgICB2YXJcbiAgICAgICAgcGl4SW5kZXgsXG4gICAgICAgIHJlc3VsdCA9IGluaXRpYWxCb3VuZHMuY2xvbmUoKSxcbiAgICAgICAgeCwgeSxcbiAgICAgICAgYWxwaGFPcmVkLFxuICAgICAgICB5U3RyaWRlO1xuXG4gICAgLy8gRmluZCB0aGUgZmlyc3Qgbm9uLXRyYW5zcGFyZW50IHJvd1xuICAgIHlTdHJpZGUgPSAodGhpcy53aWR0aCAtIHJlc3VsdC5nZXRXaWR0aCgpKSAqIEJZVEVTX1BFUl9QSVhFTDtcbiAgICBwaXhJbmRleCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChyZXN1bHQubGVmdCwgcmVzdWx0LnRvcCkgKyBBTFBIQV9CWVRFX09GRlNFVDtcblxuICAgIGZvciAoeSA9IHJlc3VsdC50b3A7IHkgPCByZXN1bHQuYm90dG9tOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgYWxwaGFPcmVkID0gMHgwMDtcblxuICAgICAgICBmb3IgKHZhciB4ID0gcmVzdWx0LmxlZnQ7IHggPCByZXN1bHQucmlnaHQ7IHgrKywgcGl4SW5kZXggKz0gQllURVNfUEVSX1BJWEVMKSB7XG4gICAgICAgICAgICBhbHBoYU9yZWQgfD0gdGhpcy5kYXRhW3BpeEluZGV4XTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE9ubHkgY2hlY2sgb25jZSBwZXIgcm93IGluIG9yZGVyIHRvIHJlZHVjZSBicmFuY2hpbmcgaW4gdGhlIGlubmVyIGxvb3BcbiAgICAgICAgaWYgKGFscGhhT3JlZCAhPSAweDAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC50b3AgPSB5O1xuXG4gICAgaWYgKHJlc3VsdC50b3AgPT0gcmVzdWx0LmJvdHRvbSkge1xuICAgICAgICAvLyBSZWN0IGlzIGVtcHR5LCBubyBvcGFxdWUgcGl4ZWxzIGluIHRoZSBpbml0aWFsQm91bmRzXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gTm93IHRoZSBsYXN0IG5vbi10cmFuc3BhcmVudCByb3dcbiAgICBwaXhJbmRleCA9IHRoaXMub2Zmc2V0T2ZQaXhlbChyZXN1bHQucmlnaHQgLSAxLCByZXN1bHQuYm90dG9tIC0gMSkgKyBBTFBIQV9CWVRFX09GRlNFVDtcbiAgICBmb3IgKHkgPSByZXN1bHQuYm90dG9tIC0gMTsgeSA+PSByZXN1bHQudG9wOyB5LS0sIHBpeEluZGV4IC09IHlTdHJpZGUpIHtcbiAgICAgICAgYWxwaGFPcmVkID0gMHgwMDtcblxuICAgICAgICBmb3IgKHZhciB4ID0gcmVzdWx0LnJpZ2h0IC0gMTsgeCA+PSByZXN1bHQubGVmdDsgeC0tLCBwaXhJbmRleCAtPSBCWVRFU19QRVJfUElYRUwpIHtcbiAgICAgICAgICAgIGFscGhhT3JlZCB8PSB0aGlzLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gT25seSBjaGVjayBvbmNlIHBlciByb3cgaW4gb3JkZXIgdG8gcmVkdWNlIGJyYW5jaGluZyBpbiB0aGUgaW5uZXIgbG9vcFxuICAgICAgICBpZiAoYWxwaGFPcmVkICE9IDB4MDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LmJvdHRvbSA9IHkgKyAxOyAvKiArMSBzaW5jZSB0aGUgYm90dG9tL3JpZ2h0IGVkZ2VzIG9mIHRoZSByZWN0IGFyZSBleGNsdXNpdmUgKi9cblxuICAgIC8vIE5vdyBjb2x1bW5zIGZyb20gdGhlIGxlZnRcbiAgICB5U3RyaWRlID0gQllURVNfUEVSX1BJWEVMICogdGhpcy53aWR0aDtcbiAgICBmb3IgKHggPSByZXN1bHQubGVmdDsgeCA8IHJlc3VsdC5yaWdodDsgeCsrKSB7XG4gICAgICAgIHBpeEluZGV4ID0gdGhpcy5vZmZzZXRPZlBpeGVsKHgsIHJlc3VsdC50b3ApICsgQUxQSEFfQllURV9PRkZTRVQ7XG4gICAgICAgIGFscGhhT3JlZCA9IDB4MDA7XG5cbiAgICAgICAgZm9yICh5ID0gcmVzdWx0LnRvcDsgeSA8IHJlc3VsdC5ib3R0b207IHkrKywgcGl4SW5kZXggKz0geVN0cmlkZSkge1xuICAgICAgICAgICAgYWxwaGFPcmVkIHw9IHRoaXMuZGF0YVtwaXhJbmRleF07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWxwaGFPcmVkICE9IDB4MDApIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmVzdWx0LmxlZnQgPSB4O1xuXG4gICAgLy8gQW5kIGNvbHVtbnMgZnJvbSB0aGUgcmlnaHRcbiAgICBmb3IgKHggPSByZXN1bHQucmlnaHQgLSAxOyB4ID49IHJlc3VsdC5sZWZ0OyB4LS0pIHtcbiAgICAgICAgcGl4SW5kZXggPSB0aGlzLm9mZnNldE9mUGl4ZWwoeCwgcmVzdWx0LnRvcCkgKyBBTFBIQV9CWVRFX09GRlNFVDtcbiAgICAgICAgYWxwaGFPcmVkID0gMHgwMFxuXG4gICAgICAgIGZvciAoeSA9IHJlc3VsdC50b3A7IHkgPCByZXN1bHQuYm90dG9tOyB5KyssIHBpeEluZGV4ICs9IHlTdHJpZGUpIHtcbiAgICAgICAgICAgIGFscGhhT3JlZCB8PSB0aGlzLmRhdGFbcGl4SW5kZXhdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFscGhhT3JlZCAhPSAweDAwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlc3VsdC5yaWdodCA9IHggKyAxO1xuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbkNQTGF5ZXIucHJvdG90eXBlLnNldEFscGhhID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICB0aGlzLmFscGhhID0gYWxwaGE7XG59O1xuXG5DUExheWVyLnByb3RvdHlwZS5zZXRCbGVuZE1vZGUgPSBmdW5jdGlvbihibGVuZE1vZGUpIHtcbiAgICB0aGlzLmJsZW5kTW9kZSA9IGJsZW5kTW9kZTtcbn07XG5cbkNQTGF5ZXIucHJvdG90eXBlLmdldEFscGhhID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWxwaGE7XG59O1xuXG5DUExheWVyLnByb3RvdHlwZS5nZXRCbGVuZE1vZGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ibGVuZE1vZGU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYSBuZXcgY2FudmFzIHdpdGggYSByb3RhdGVkIHZlcnNpb24gb2YgdGhlIGdpdmVuIGNhbnZhcy5cbiAqIFxuICogUm90YXRpb24gaXMgWzAuLjNdIGFuZCBzZWxlY3RzIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcyBvZiBjbG9ja3dpc2Ugcm90YXRpb24gdG8gYmUgYXBwbGllZC5cbiAqL1xuZnVuY3Rpb24gZ2V0Um90YXRlZENhbnZhcyhjYW52YXMsIHJvdGF0aW9uKSB7XG4gICAgcm90YXRpb24gPSByb3RhdGlvbiAlIDQ7XG4gICAgXG4gICAgaWYgKHJvdGF0aW9uID09IDApIHtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG4gICAgXG4gICAgdmFyXG4gICAgICAgIHJvdGF0ZWRDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICByb3RhdGVkQ2FudmFzQ29udGV4dCA9IHJvdGF0ZWRDYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG4gICAgaWYgKHJvdGF0aW9uICUgMiA9PSAwKSB7XG4gICAgICAgIHJvdGF0ZWRDYW52YXMud2lkdGggPSBjYW52YXMud2lkdGg7XG4gICAgICAgIHJvdGF0ZWRDYW52YXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgICByb3RhdGVkQ2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodDtcbiAgICAgICAgcm90YXRlZENhbnZhcy5oZWlnaHQgPSBjYW52YXMud2lkdGg7XG4gICAgfVxuICAgIFxuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgLy8gOTAgZGVncmVlIGNsb2Nrd2lzZTpcbiAgICAgICAgICAgIHJvdGF0ZWRDYW52YXNDb250ZXh0LnJvdGF0ZShNYXRoLlBJIC8gMik7XG4gICAgICAgICAgICByb3RhdGVkQ2FudmFzQ29udGV4dC5kcmF3SW1hZ2UoY2FudmFzLCAwLCAtY2FudmFzLmhlaWdodCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcm90YXRlZENhbnZhc0NvbnRleHQucm90YXRlKE1hdGguUEkpO1xuICAgICAgICAgICAgcm90YXRlZENhbnZhc0NvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgLWNhbnZhcy53aWR0aCwgLWNhbnZhcy5oZWlnaHQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIC8vIDkwIGRlZ3JlZSBjb3VudGVyLWNsb2Nrd2lzZTpcbiAgICAgICAgICAgIHJvdGF0ZWRDYW52YXNDb250ZXh0LnJvdGF0ZSgtTWF0aC5QSSAvIDIpO1xuICAgICAgICAgICAgcm90YXRlZENhbnZhc0NvbnRleHQuZHJhd0ltYWdlKGNhbnZhcywgLWNhbnZhcy53aWR0aCwgMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJvdGF0ZWRDYW52YXM7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2U2NFBOR0RhdGFVUkwodXJsKSB7XG4gICAgaWYgKHR5cGVvZiB1cmwgIT09IFwic3RyaW5nXCIgfHwgIXVybC5tYXRjaCgvXmRhdGE6aW1hZ2VcXC9wbmc7YmFzZTY0LC9pKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB3aW5kb3cuYXRvYih1cmwuc3Vic3RyaW5nKFwiZGF0YTppbWFnZVxcL3BuZztiYXNlNjQsXCIubGVuZ3RoKSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBsYXllciBhcyBhIFBORyBpbWFnZS5cbiAqIFxuICogUm90YXRpb24gaXMgWzAuLjNdIGFuZCBzZWxlY3RzIGEgbXVsdGlwbGUgb2YgOTAgZGVncmVlcyBvZiBjbG9ja3dpc2Ugcm90YXRpb24gdG8gYmUgYXBwbGllZCwgb3IgMCB0byBsZWF2ZVxuICogdW5yb3RhdGVkLlxuICovXG5DUExheWVyLnByb3RvdHlwZS5nZXRBc1BORyA9IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG4gICAgdmFyXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgIGNhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIFxuICAgIC8vIEZpcnN0IGRyYXcgb3VyIGltYWdlIGRhdGEgb250byBhIGNhbnZhcy4uLlxuICAgIGNhbnZhcy53aWR0aCA9IHRoaXMuaW1hZ2VEYXRhLndpZHRoO1xuICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmltYWdlRGF0YS5oZWlnaHQ7XG4gICAgXG4gICAgY2FudmFzQ29udGV4dC5wdXRJbWFnZURhdGEodGhpcy5pbWFnZURhdGEsIDAsIDApO1xuICAgIFxuICAgIC8vIFJvdGF0ZSBpdCBpZiBuZWVkZWRcbiAgICBjYW52YXMgPSBnZXRSb3RhdGVkQ2FudmFzKGNhbnZhcywgcm90YXRpb24gfHwgMCk7XG4gICAgXG4gICAgcmV0dXJuIGRlY29kZUJhc2U2NFBOR0RhdGFVUkwoY2FudmFzLnRvRGF0YVVSTCgnaW1hZ2UvcG5nJykpO1xufTtcbiIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUExvb2tVcFRhYmxlKCkge1xuICAgIHRoaXMudGFibGUgPSBuZXcgVWludDhBcnJheSgyNTYpO1xuXG4gICAgdGhpcy5sb2FkSWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgdGhpcy50YWJsZVtpXSA9IGk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5sb2FkQnJpZ2h0bmVzc0NvbnRyYXN0ID0gZnVuY3Rpb24oYnJpZ2h0bmVzcywgY29udHJhc3QpIHtcbiAgICAgICAgdmFyIFxuICAgICAgICAgICAgc2xvcGUgPSBjb250cmFzdCA+IDAuMCA/ICgxLjAgLyAoMS4wMDAxIC0gY29udHJhc3QpKTogMS4wICsgY29udHJhc3QsXG4gICAgICAgICAgICBvZmZzZXQgPSAwLjUgLSBzbG9wZSAqIDAuNSArIGJyaWdodG5lc3M7XG4gICAgICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgIHggPSBpIC8gMjU1LjAsXG4gICAgICAgICAgICAgICAgeSA9IHggKiBzbG9wZSArIG9mZnNldDtcblxuICAgICAgICAgICAgdGhpcy50YWJsZVtpXSA9IE1hdGgubWluKDI1NSwgTWF0aC5tYXgofn4oeSAqIDI1NS4wKSwgMCkpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaW52ZXJ0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMudGFibGVbaV0gPSAyNTUgLSB0aGlzLnRhYmxlW2ldO1xuICAgICAgICB9XG4gICAgfTtcbn1cbiIsImltcG9ydCBDUENoaWJpRmlsZSBmcm9tIFwiLi9DUENoaWJpRmlsZVwiO1xuaW1wb3J0IENQQXJ0d29yayBmcm9tIFwiLi9DUEFydHdvcmtcIjtcbmltcG9ydCBDUExheWVyIGZyb20gXCIuL0NQTGF5ZXJcIjtcbmltcG9ydCBBZG9iZUNvbG9yVGFibGUgZnJvbSBcIi4uL3V0aWwvQWRvYmVDb2xvclRhYmxlXCI7XG5cbi8qKlxuICogTG9hZHMgQ2hpY2tlblBhaW50IHJlc291cmNlcyBmcm9tIGEgcmVtb3RlIHNlcnZlciBhbmQgZW1pdHMgcHJvZ3Jlc3MgZXZlbnRzLlxuICpcbiAqIGxvYWRJbWFnZVVSTCAtIFVSTCBvZiBQTkcvSlBFRyBpbWFnZSB0byBsb2FkIGZvciBlZGl0aW5nIChvcHRpb25hbClcbiAqIGxvYWRDaGliaUZpbGVVUkwgLSBVUkwgb2YgLmNoaSBmaWxlIHRvIGxvYWQgZm9yIGVkaXRpbmcgKG9wdGlvbmFsKS4gVXNlZCBpbiBwcmVmZXJlbmNlIHRvIGxvYWRJbWFnZS5cbiAqIGxvYWRTd2F0Y2hlc1VSTCAtIFVSTCBvZiBhbiAuYWNvIHBhbGV0dGUgdG8gbG9hZCAob3B0aW9uYWwpXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQUmVzb3VyY2VMb2FkZXIob3B0aW9ucykge1xuICAgIHZhclxuICAgICAgICByZXNvdXJjZXMgPSBbXSxcbiAgICAgICAgY29tcGxldGVkID0ge30sXG4gICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgaWYgKG9wdGlvbnMubG9hZENoaWJpRmlsZVVybCAmJiAoXCJcIiArIG9wdGlvbnMubG9hZENoaWJpRmlsZVVybCkubGVuZ3RoID4gMCkge1xuICAgICAgICByZXNvdXJjZXMucHVzaCh7XG4gICAgICAgICAgICB1cmw6IG9wdGlvbnMubG9hZENoaWJpRmlsZVVybCxcbiAgICAgICAgICAgIGZyaWVuZGx5OiBcImRyYXdpbmcgbGF5ZXJzXCIsXG4gICAgICAgICAgICBuYW1lOiBcImxheWVyc1wiLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKG9wdGlvbnMubG9hZEltYWdlVXJsICYmIChcIlwiICsgb3B0aW9ucy5sb2FkSW1hZ2VVcmwpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJlc291cmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB1cmw6IG9wdGlvbnMubG9hZEltYWdlVXJsLFxuICAgICAgICAgICAgICAgIGZyaWVuZGx5OiBcImRyYXdpbmdcIixcbiAgICAgICAgICAgICAgICBuYW1lOiBcImZsYXRcIixcbiAgICAgICAgICAgICAgICByZXF1aXJlZDogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgaWYgKG9wdGlvbnMubG9hZFN3YXRjaGVzVXJsKSB7XG4gICAgICAgIHJlc291cmNlcy5wdXNoKHtcbiAgICAgICAgICAgIHVybDogb3B0aW9ucy5sb2FkU3dhdGNoZXNVcmwsXG4gICAgICAgICAgICBmcmllbmRseTogXCJjb2xvciBzd2F0Y2hlc1wiLFxuICAgICAgICAgICAgbmFtZTogXCJzd2F0Y2hlc1wiLFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICAgICAgbm9Qcm9ncmVzczogdHJ1ZSAvLyBTbyBzaG9ydCB0aGF0IHdlIG1heSBhcyB3ZWxsIGtlZXAgdGhlIHNtb290aGllIGRyYWluZWRcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZGVjb2RlUmVzb3VyY2UocmVzb3VyY2UsIHJlc291cmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHJlc291cmNlLm5hbWUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmxhdFwiOlxuICAgICAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgICAgICBibG9iID0gbmV3IEJsb2IoW3Jlc291cmNlRGF0YV0sIHt0eXBlOiBcImltYWdlL3BuZ1wifSksXG4gICAgICAgICAgICAgICAgICAgICAgICBpbWFnZVVybCA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgaWYgKGltYWdlVXJsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2Uub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFydHdvcmsgPSBuZXcgQ1BBcnR3b3JrKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGF5ZXIgPSBuZXcgQ1BMYXllcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgXCJMYXllciAxXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxheWVyLmxvYWRGcm9tSW1hZ2UoaW1hZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFydHdvcmsuYWRkTGF5ZXJPYmplY3QobGF5ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuVVJMLnJldm9rZU9iamVjdFVSTChpbWFnZVVybCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhcnR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLnNyYyA9IGltYWdlVXJsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzd2F0Y2hlc1wiOlxuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyBBZG9iZUNvbG9yVGFibGUoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9ycyA9IHJlYWRlci5yZWFkKHJlc291cmNlRGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKGNvbG9ycyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcImxheWVyc1wiOlxuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWRlciA9IG5ldyBDUENoaWJpRmlsZSgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJ0d29yayA9IHJlYWRlci5yZWFkKHJlc291cmNlRGF0YSk7XG4gICAgXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoYXJ0d29yayk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVwb3J0UHJvZ3Jlc3MocmVzb3VyY2UsIHByb2dyZXNzKSB7XG4gICAgICAgIGlmIChwcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhhdC5lbWl0RXZlbnQoXCJsb2FkaW5nUHJvZ3Jlc3NcIiwgWzEuMCwgXCJMb2FkaW5nIHlvdXIgXCIgKyByZXNvdXJjZS5mcmllbmRseSArIFwiLi4uXCJdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuZW1pdEV2ZW50KFwibG9hZGluZ1Byb2dyZXNzXCIsIFtwcm9ncmVzcywgXCJMb2FkaW5nIHlvdXIgXCIgKyByZXNvdXJjZS5mcmllbmRseSArIFwiIChcIiArIE1hdGgucm91bmQocHJvZ3Jlc3MgKiAxMDApICsgXCIlKS4uLlwiXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChyZXNvdXJjZXMubGVuZ3RoID09IDApIHtcbiAgICAgICAgICAgIHRoYXQuZW1pdEV2ZW50KFwibG9hZGluZ0NvbXBsZXRlXCIsIFtjb21wbGV0ZWRdKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhclxuICAgICAgICAgICAgcmVzb3VyY2UgPSByZXNvdXJjZXMuc2hpZnQoKSxcbiAgICAgICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBwcm9ncmVzcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGV2dC5sZW5ndGhDb21wdXRhYmxlICYmICFyZXNvdXJjZS5ub1Byb2dyZXNzKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSBldnQubG9hZGVkIC8gZXZ0LnRvdGFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlcG9ydFByb2dyZXNzKHJlc291cmNlLCBwcm9ncmVzcyk7XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICBmdW5jdGlvbiBoYW5kbGVGYXRhbCgpIHtcbiAgICAgICAgICAgIGlmIChyZXNvdXJjZS5yZXF1aXJlZCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdEV2ZW50KFwibG9hZGluZ0ZhaWx1cmVcIiwgW1wiRmFpbGVkIHRvIGxvYWQgeW91ciBcIiArIHJlc291cmNlLmZyaWVuZGx5ICsgXCIsIHBsZWFzZSB0cnkgYWdhaW4gbGF0ZXIuXCJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gU2tpcCB1bmltcG9ydGFudCByZXNvdXJjZXNcbiAgICAgICAgICAgICAgICB0aGF0LmxvYWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgeGhyLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uKGV2dCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHRoaXMucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhhdC5lbWl0RXZlbnQoXCJsb2FkaW5nUHJvZ3Jlc3NcIiwgWzEuMCwgXCJTdGFydGluZyBDaGlja2VuUGFpbnQuLi5cIl0pO1xuICAgIFxuICAgICAgICAgICAgICAgIC8vIFlpZWxkIHRvIHRoZSBET00gdG8gZ2l2ZSBpdCBhIGNoYW5jZSB0byBwYWludCB0aGUgbG9hZGVkIG1lc3NhZ2UgYmVmb3JlIHdlIGJlZ2luIGRlY29kaW5nXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNvZGVSZXNvdXJjZShyZXNvdXJjZSwgcmVzcG9uc2UpLnRoZW4oZnVuY3Rpb24oZGVjb2RlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkZWNvZGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZFtyZXNvdXJjZS5uYW1lXSA9IGRlY29kZWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIG9uIHRvIHRoZSBuZXh0IGZpbGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5sb2FkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5lbWl0RXZlbnQoXCJsb2FkaW5nRmFpbHVyZVwiLCBbXCJGYWlsZWQgdG8gcmVhZCB5b3VyIFwiICsgcmVzb3VyY2UuZnJpZW5kbHldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgMFxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZUZhdGFsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIGZhbHNlKTtcblxuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGhhbmRsZUZhdGFsKTtcblxuICAgICAgICByZXBvcnRQcm9ncmVzcyhyZXNvdXJjZSwgcmVzb3VyY2Uubm9Qcm9ncmVzcyA/IG51bGwgOiAwLjApO1xuXG4gICAgICAgIHhoci5vcGVuKFwiR0VUXCIsIHJlc291cmNlLnVybCwgdHJ1ZSk7XG4gICAgICAgIFxuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblxuICAgICAgICB4aHIuc2VuZCgpO1xuICAgIH1cbn1cblxuQ1BSZXNvdXJjZUxvYWRlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuQ1BSZXNvdXJjZUxvYWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFJlc291cmNlTG9hZGVyO1xuIiwiaW1wb3J0IENQQ2hpYmlGaWxlIGZyb20gXCIuL0NQQ2hpYmlGaWxlXCI7XG5pbXBvcnQgQ1BBcnR3b3JrIGZyb20gXCIuL0NQQXJ0d29ya1wiO1xuaW1wb3J0IEFkb2JlQ29sb3JUYWJsZSBmcm9tIFwiLi4vdXRpbC9BZG9iZUNvbG9yVGFibGVcIjtcblxuLyoqXG4gKiBXZSBnZW5lcmFsbHkgY2FuJ3QgZG8gbXVjaCB3aXRoIGJpbmFyeSBzdHJpbmdzIGJlY2F1c2UgdmFyaW91cyBtZXRob2RzIHdpbGwgdHJ5IHRvIFVURi04IG1hbmdsZSB0aGVtLlxuICogVGhpcyBmdW5jdGlvbiBjb252ZXJ0cyBzdWNoIGEgc3RyaW5nIHRvIGEgVWludDhBcnJheSBpbnN0ZWFkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmluYXJ5U3RyaW5nVG9CeXRlQXJyYXkocykge1xuICAgIHZhclxuICAgICAgICByZXN1bHQgPSBuZXcgVWludDhBcnJheShzLmxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgcmVzdWx0W2ldID0gcy5jaGFyQ29kZUF0KGkpO1xuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogU2F2ZXMgQ2hpY2tlblBhaW50IHJlc291cmNlcyB0byBhIHJlbW90ZSBzZXJ2ZXIgb3IgdG8gdGhlIGRpc2sgYW5kIGVtaXRzIHByb2dyZXNzIGV2ZW50cy5cbiAqXG4gKiBPcHRpb25zOlxuICogICAgIHVybCAtIFVSTCB0byBzZW5kIHRvLiBJZiBvbWl0dGVkLCB3aWxsIHNhdmUgdG8gdGhlIGRpc2sgaW5zdGVhZC5cbiAqICAgICBhcnR3b3JrIC0gQXJ0d29yayB0byBzZW5kXG4gKiAgICAgcm90YXRpb24gLSBJbnRlZ2VyIFswLi4zXSBvZiB0aGUgbnVtYmVyIG9mIDkwIGRlZ3JlZSByb3RhdGlvbiBzdGVwcyB0aGF0IHNob3VsZCBiZSBhcHBsaWVkIHRvIGNhbnZhcyB1cG9uIG9wZW5pbmcuXG4gKiAgICAgc3dhdGNoZXMgLSBBcnJheSBvZiBBUkdCIGludGVnZXIgY29sb3JzIHRvIHNhdmUgYXMgdGhlIGltYWdlIHN3YXRjaGVzIChvcHRpb25hbClcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BSZXNvdXJjZVNhdmVyKG9wdGlvbnMpIHtcbiAgICB2YXJcbiAgICAgICAgdGhhdCA9IHRoaXMsXG4gICAgICAgIFxuICAgICAgICBjYW5jZWxsZWQgPSBmYWxzZTtcbiAgICBcbiAgICBvcHRpb25zLnJvdGF0aW9uID0gb3B0aW9ucy5yb3RhdGlvbiB8fCAwO1xuICAgIFxuICAgIGZ1bmN0aW9uIHJlcG9ydFByb2dyZXNzKHByb2dyZXNzKSB7XG4gICAgICAgIGlmIChwcm9ncmVzcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhhdC5lbWl0RXZlbnQoXCJzYXZpbmdQcm9ncmVzc1wiLCBbMS4wLCBcIlNhdmluZyB5b3VyIGRyYXdpbmcgdG8gdGhlIHNlcnZlci4uLlwiXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LmVtaXRFdmVudChcInNhdmluZ1Byb2dyZXNzXCIsIFtwcm9ncmVzcywgXCJTYXZpbmcgeW91ciBkcmF3aW5nIHRvIHRoZSBzZXJ2ZXIuLi4gIChcIiArIE1hdGgucm91bmQocHJvZ3Jlc3MgKiAxMDApICsgXCIlKVwiXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gcmVwb3J0RmF0YWwoc2VydmVyTWVzc2FnZSkge1xuICAgICAgICB0aGF0LmVtaXRFdmVudChcInNhdmluZ0ZhaWx1cmVcIiwgW3NlcnZlck1lc3NhZ2VdKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gcG9zdERyYXdpbmcoZm9ybURhdGEpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICBcbiAgICAgICAgeGhyLnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKFwicHJvZ3Jlc3NcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBwcm9ncmVzcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGV2dC5sZW5ndGhDb21wdXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgcHJvZ3Jlc3MgPSBldnQubG9hZGVkIC8gZXZ0LnRvdGFsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwcm9ncmVzcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlcG9ydFByb2dyZXNzKHByb2dyZXNzKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIFxuICAgICAgICB4aHIuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24oZXZ0KSB7XG4gICAgICAgICAgICByZXBvcnRQcm9ncmVzcygxLjApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT0gMjAwICYmIC9eQ0hJQklPSy8udGVzdCh0aGlzLnJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdEV2ZW50KFwic2F2aW5nQ29tcGxldGVcIik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlcG9ydEZhdGFsKHRoaXMucmVzcG9uc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCBmYWxzZSk7XG4gICAgXG4gICAgICAgIHhoci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXBvcnRGYXRhbCh0aGlzLnJlc3BvbnNlKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIFxuICAgICAgICByZXBvcnRQcm9ncmVzcygwKTtcbiAgICBcbiAgICAgICAgeGhyLm9wZW4oXCJQT1NUXCIsIG9wdGlvbnMudXJsLCB0cnVlKTtcbiAgICAgICAgXG4gICAgICAgIHhoci5yZXNwb25zZVR5cGUgPSBcInRleHRcIjtcbiAgICAgICAgXG4gICAgICAgIHhoci5zZW5kKGZvcm1EYXRhKTtcbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogQmVnaW4gc2F2aW5nIHRoZSBkYXRhIHByb3ZpZGVkIGluIHRoZSBjb25zdHJ1Y3Rvci4gUmV0dXJucyBpbW1lZGlhdGVseSwgYW5kIGZpcmVzIHRoZXNlIGV2ZW50cyB0byByZXBvcnQgdGhlXG4gICAgICogc2F2aW5nIHByb2dyZXNzOlxuICAgICAqIFxuICAgICAqIHNhdmluZ1Byb2dyZXNzKHByb2dyZXNzKSAtIFByb2dyZXNzIGlzIFswLjAgLi4uIDEuMF0gYW5kIHJlcG9ydHMgaG93IG11Y2ggaGFzIHVwbG9hZGVkIHNvIGZhciwgb3IgbnVsbCBpZiB0aGUgXG4gICAgICogICAgICAgICAgICAgICAgICAgICAgICAgICAgdG90YWwgcHJvZ3Jlc3MgY291bGQgbm90IGJlIGRldGVybWluZWQuXG4gICAgICogc2F2aW5nRmFpbHVyZShlcnJvcikgICAgIC0gV2hlbiBzYXZpbmcgZmFpbHMsIGFsb25nIHdpdGggYSBzdHJpbmcgZXJyb3IgbWVzc2FnZSB0byBkaXNwbGF5IHRvIHRoZSB1c2VyLiBcbiAgICAgKiBzYXZpbmdDb21wbGV0ZSgpICAgICAgICAgLSBXaGVuIHNhdmluZyBjb21wbGV0ZXMgc3VjY2VzZnVsbHlcbiAgICAgKi9cbiAgICB0aGlzLnNhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBmbGF0LFxuICAgICAgICAgICAgZmxhdEJsb2IsXG4gICAgICAgICAgICBzd2F0Y2hlc0Jsb2I7XG5cbiAgICAgICAgZmxhdCA9IGJpbmFyeVN0cmluZ1RvQnl0ZUFycmF5KG9wdGlvbnMuYXJ0d29yay5nZXRGbGF0UE5HKG9wdGlvbnMucm90YXRpb24pKTtcbiAgICAgICAgZmxhdEJsb2IgPSBuZXcgQmxvYihbZmxhdF0sIHt0eXBlOiBcImltYWdlL3BuZ1wifSk7XG4gICAgICAgIGZsYXQgPSBudWxsOyAvLyBEb24ndCBuZWVkIHRoaXMgYW55IG1vcmVcbiAgICAgICAgXG4gICAgICAgIHZhclxuICAgICAgICAgICAgc2VyaWFsaXplTGF5ZXJzO1xuXG4gICAgICAgIGlmIChvcHRpb25zLmFydHdvcmsuaXNTaW1wbGVEcmF3aW5nKCkpIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZUxheWVycyA9IFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlcmlhbGl6ZUxheWVycyA9IChuZXcgQ1BDaGliaUZpbGUoKSkuc2VyaWFsaXplKG9wdGlvbnMuYXJ0d29yayk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHNlcmlhbGl6ZUxheWVycy50aGVuKGZ1bmN0aW9uKGNoaWJpQmxvYikge1xuICAgICAgICAgICAgaWYgKGNhbmNlbGxlZCkge1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdEV2ZW50KFwic2F2aW5nRmFpbHVyZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnN3YXRjaGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGFjbyA9IG5ldyBBZG9iZUNvbG9yVGFibGUoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzd2F0Y2hlc0Jsb2IgPSBuZXcgQmxvYihbYWNvLndyaXRlKG9wdGlvbnMuc3dhdGNoZXMpXSwge3R5cGU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3dhdGNoZXNCbG9iID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnVybCkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBtYXJrZXIgPSBcIlRoaXMgbWFya2VyIGVuc3VyZXMgdGhlIHVwbG9hZCB3YXNuJ3QgdHJ1bmNhdGVkXCIsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJiZWdpbk1hcmtlclwiLCBtYXJrZXIpO1xuXG5cdFx0XHRcdGZvcm1EYXRhLmFwcGVuZChcInBhaW50ZXJcIiwgXCJDaGlja2VuUGFpbnQgdjEuMFwiKTtcblxuXHRcdFx0XHRmb3JtRGF0YS5hcHBlbmQoXCJwaWN0dXJlXCIsIGZsYXRCbG9iKTtcbiAgICAgICAgICAgICAgICBmbGF0QmxvYiA9IG51bGw7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGNoaWJpQmxvYikge1xuXHRcdFx0XHRcdGZvcm1EYXRhLmFwcGVuZChcImNoaWJpZmlsZUZvcm1hdFwiLCBcIkNoaWNrZW5QYWludCB2MC4wXCIpO1xuXHRcdFx0XHRcdGZvcm1EYXRhLmFwcGVuZChcImNoaWJpZmlsZVwiLCBjaGliaUJsb2IpO1xuICAgICAgICAgICAgICAgICAgICBjaGliaUJsb2IgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIExheWVycyB3aWxsIG5lZWQgdG8gYmUgcm90YXRlZCB1cG9uIG9wZW5pbmdcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEuYXBwZW5kKFwicm90YXRpb25cIiwgXCJcIiArIG9wdGlvbnMucm90YXRpb24pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAqIEJlY2F1c2UgdGhlIGltYWdlIGlzIGEgZmxhdCBQTkcsIHdlIHJvdGF0ZSBpdCBiZWZvcmUgd2Ugc2F2ZWQgaXQgYW5kIGl0IGRvZXNuJ3QgbmVlZCBmdXJ0aGVyXG4gICAgICAgICAgICAgICAgICAgICAqIHJvdGF0aW9uIHVwb24gb3BlbmluZy5cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcInJvdGF0aW9uXCIsIFwiMFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHN3YXRjaGVzQmxvYikge1xuICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoXCJzd2F0Y2hlc1wiLCBzd2F0Y2hlc0Jsb2IpO1xuICAgICAgICAgICAgICAgICAgICBzd2F0Y2hlc0Jsb2IgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChcImVuZE1hcmtlclwiLCBtYXJrZXIpO1xuXG4gICAgICAgICAgICAgICAgcG9zdERyYXdpbmcoZm9ybURhdGEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuc2F2ZUFzKGZsYXRCbG9iLCBcIm9la2FraS5wbmdcIik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGNoaWJpQmxvYikge1xuICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2F2ZUFzKGNoaWJpQmxvYiwgXCJvZWtha2kuY2hpXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3dhdGNoZXNCbG9iKSB7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zYXZlQXMoc3dhdGNoZXNCbG9iLCBcIm9la2FraS5hY29cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuY2FuY2VsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbmNlbGxlZCA9IHRydWU7XG4gICAgfTtcbn1cblxuQ1BSZXNvdXJjZVNhdmVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5DUFJlc291cmNlU2F2ZXIucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BSZXNvdXJjZVNhdmVyO1xuIiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQVW5kbygpIHtcbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIG1lcmdlIHRoZSBnaXZlbiB1bmRvIGludG8gdGhpcyBvbmUsIGFuZCByZXR1cm4gdHJ1ZSBpZiBzdWNjZXNzZnVsLlxuICpcbiAqIEBwYXJhbSB1bmRvXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQ1BVbmRvLnByb3RvdHlwZS5tZXJnZSA9IGZ1bmN0aW9uKHVuZG8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoaXMgdW5kbyBkaWRuJ3QgbW9kaWZ5IHRoZSBkb2N1bWVudC5cbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuQ1BVbmRvLnByb3RvdHlwZS5ub0NoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBudW1iZXIgb2YgYnl0ZXMgb2YgbWVtb3J5IHVzZWQgYnkgdGhpcyB1bmRvLCBvciAwIGlmIGl0IGNhbm5vdCBiZSBlc3RpbWF0ZWQuXG4gKlxuICogQHBhcmFtIHVuZG9uZVxuICogQHBhcmFtIHBhcmFtXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5DUFVuZG8ucHJvdG90eXBlLmdldE1lbW9yeVVzZWQgPSBmdW5jdGlvbih1bmRvbmUsIHBhcmFtKSB7XG4gICAgcmV0dXJuIDA7XG59O1xuXG4vKipcbiAqIENhbGwgd2hlbiB0aGlzIHVuZG8gaXMgbm8gbG9uZ2VyIG9uIHRoZSB0b3Agb2YgdGhlIHN0YWNrLCBzbyBpdCBjYW4gb3B0aW1pemUgaXRzIG1lbW9yeSB1c2FnZS5cbiAqL1xuQ1BVbmRvLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG59O1xuIiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQWJvdXREaWFsb2cocGFyZW50KSB7XG4gICAgdmFyXG4gICAgICAgIGRpYWxvZyA9IFxuICAgICAgICAgICAgJChgPGRpdiBjbGFzcz1cIm1vZGFsIGZhZGUgY2hpY2tlbnBhaW50LWFib3V0LWRpYWxvZ1wiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiZGlhbG9nXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZ1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+QWJvdXQgQ2hpY2tlblBhaW50PC9oND5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YSBjbGFzcz1cImNoaWNrZW5wYWludC1vbi1naXRodWJcIiB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL3RoZW5pY2tkdWRlL2NoaWNrZW5wYWludFwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtZ2l0aHViXCI+PC9zcGFuPiBDaGlja2VuUGFpbnQgb24gR2l0SHViPC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiA8YSBocmVmPVwiaHR0cDovL3d3dy5jaGliaXBhaW50LmNvbS9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5DaGliaVBhaW50PC9hPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdCBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyLiBBbGwgUmlnaHRzIFJlc2VydmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHA+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvXCI+R05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2U8L2E+IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cHJlIGNsYXNzPVwicHJlLXNjcm9sbGFibGUgY2hpY2tlbnBhaW50LXRoaXJkLXBhcnR5LWxpY2Vuc2VzXCI+SW5jbHVkZXMgaWNvbnMgZnJvbSB0aGUgPGEgaHJlZj1cImh0dHA6Ly90YW5nby5mcmVlZGVza3RvcC5vcmcvXCIgdGFyZ2V0PVwiX2JsYW5rXCI+VGFuZ28gRGVza3RvcCBQcm9qZWN0PC9hPlxuXG5JbmNsdWRlcyB0aGVzZSBNSVQtbGljZW5zZWQgbGlicmFyaWVzOlxuXG4gICAgSW5jbHVkZXMgdGhlIDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vZWxpZ3JleS9GaWxlU2F2ZXIuanNcIj5GaWxlU2F2ZXIuanMgbGlicmFyeTwvYT5cbiAgICBGaWxlU2F2ZXIuanMgQ29weXJpZ2h0IMKpIDIwMTUgPGEgdGFyZ2V0PVwiX2JsYW5rXCIgaHJlZj1cImh0dHA6Ly9lbGlncmV5LmNvbS9cIj5FbGkgR3JleTwvYT5cblxuICAgIEluY2x1ZGVzIHRoZSA8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL25vZGVjYS9wYWtvXCI+UGFrbyB6bGliIGNvbXByZXNzaW9uIGxpYnJhcnk8L2E+XG4gICAgQ29weXJpZ2h0IChDKSAyMDE0LTIwMTUgYnkgVml0YWx5IFB1enJpblxuICAgIFxuICAgIEluY2x1ZGVzIHRoZSA8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiaHR0cHM6Ly9naXRodWIuY29tL21hZHJvYmJ5L2tleW1hc3RlclwiPmtleW1hc3Rlci5qczwvYT4ga2V5Ym9hcmQgbGlicmFyeVxuICAgIENvcHlyaWdodCAoYykgMjAxMS0yMDEzIFRob21hcyBGdWNoc1xuXG4gICAgSW5jbHVkZXMgdGhlIDxhIHRhcmdldD1cIl9ibGFua1wiIGhyZWY9XCJodHRwczovL2dpdGh1Yi5jb20vc3RlZmFucGVubmVyL2VzNi1wcm9taXNlXCI+ZXM2LXByb21pc2U8L2E+IGxpYnJhcnlcbiAgICBDb3B5cmlnaHQgKGMpIDIwMTQgWWVodWRhIEthdHosIFRvbSBEYWxlLCBTdGVmYW4gUGVubmVyIGFuZCBjb250cmlidXRvcnNcblxuICAgIEluY2x1ZGVzIHRoZSA8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiaHR0cDovL2JlbmFsbWFuLmNvbS9wcm9qZWN0cy9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UtcGx1Z2luL1wiPmpRdWVyeSB0aHJvdHRsZS1kZWJvdW5jZTwvYT4gbGlicmFyeVxuICAgIENvcHlyaWdodCAoYykgMjAxMCBcIkNvd2JveVwiIEJlbiBBbG1hblxuXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cbiAgICBvYnRhaW5pbmcgYSBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvblxuICAgIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dFxuICAgIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxuICAgIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vclxuICAgIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlXG4gICAgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcbiAgICBjb25kaXRpb25zOlxuXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuICAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICAgRVhQUkVTUyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTXG4gICAgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkRcbiAgICBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBcbiAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5JbmNsdWRlcyB0aGUgPGEgaHJlZj1cImh0dHA6Ly93d3cuanF1ZXJ5LmNvbS9cIiB0YXJnZXQ9XCJfYmxhbmtcIj5KUXVlcnkgbGlicmFyeTwvYT5cbkNvcHlyaWdodCA8YSBocmVmPVwiaHR0cHM6Ly9qcXVlcnkub3JnL1wiIHRhcmdldD1cIl9ibGFua1wiPmpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnM8L2E+XG4gICAgXG4gICAgVGhpcyBzb2Z0d2FyZSBjb25zaXN0cyBvZiB2b2x1bnRhcnkgY29udHJpYnV0aW9ucyBtYWRlIGJ5IG1hbnlcbiAgICBpbmRpdmlkdWFscy4gRm9yIGV4YWN0IGNvbnRyaWJ1dGlvbiBoaXN0b3J5LCBzZWUgdGhlIHJldmlzaW9uIFxuICAgIGhpc3RvcnkgYXZhaWxhYmxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5XG4gICAgXG4gICAgVGhlIGZvbGxvd2luZyBsaWNlbnNlIGFwcGxpZXMgdG8gYWxsIHBhcnRzIG9mIHRoaXMgc29mdHdhcmUgXG4gICAgZXhjZXB0IGFzIGRvY3VtZW50ZWQgYmVsb3c6XG4gICAgXG4gICAgUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gXG4gICAgb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiAgICBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiAgICByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgXG4gICAgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yXG4gICAgc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGVcbiAgICBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZ1xuICAgIGNvbmRpdGlvbnM6XG4gICAgXG4gICAgVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcbiAgICBpbmNsdWRlZCBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICBcbiAgICBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuICAgIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuICAgIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gICAgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiAgICBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiAgICBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiAgICBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gICAgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICAgICAgICAgICAgICAgICAgICA8L3ByZT5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICBgKTtcbiAgICBcbiAgICAvLyBEZXN0cm95IHRoZSBtb2RhbCB1cG9uIGNsb3NlXG4gICAgZGlhbG9nLm9uKFwiaGlkZGVuLmJzLm1vZGFsXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlhbG9nLnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIGRpYWxvZy5tb2RhbCh7XG4gICAgICAgIHNob3c6IGZhbHNlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gRml4IHRoZSBiYWNrZHJvcCBsb2NhdGlvbiBpbiB0aGUgRE9NIGJ5IHJlcGFyZW50aW5nIGl0IHRvIHRoZSBjaGlja2VucGFpbnQgY29udGFpbmVyXG4gICAgZGlhbG9nLmRhdGEoXCJicy5tb2RhbFwiKS4kYm9keSA9ICQocGFyZW50KTtcbiAgICBcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZGlhbG9nWzBdKTtcblxuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkaWFsb2cubW9kYWwoXCJzaG93XCIpO1xuICAgIH07XG59IiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQm94Qmx1ckRpYWxvZyhwYXJlbnQsIGNvbnRyb2xsZXIpIHtcbiAgICB2YXJcbiAgICAgICAgZGlhbG9nID0gXG4gICAgICAgICAgICAkKGA8ZGl2IGNsYXNzPVwibW9kYWwgZmFkZVwiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiZGlhbG9nXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZ1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+Qm94IGJsdXI8L2g0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmb3JtPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZm9ybS1ncm91cFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxhYmVsPkJsdXIgYW1vdW50IChwaXhlbHMpPC9sYWJlbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpbnB1dCB0eXBlPVwidGV4dFwiIGNsYXNzPVwiZm9ybS1jb250cm9sIGNoaWNrZW5wYWludC1ibHVyLWFtb3VudFwiIHZhbHVlPVwiM1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbD5JdGVyYXRpb25zICgxLTgsIGxhcmdlciBnaXZlcyBzbW9vdGhlciBibHVyKTwvbGFiZWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiBjbGFzcz1cImZvcm0tY29udHJvbCBjaGlja2VucGFpbnQtYmx1ci1pdGVyYXRpb25zXCIgdmFsdWU9XCIxXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZm9ybT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0XCIgZGF0YS1kaXNtaXNzPVwibW9kYWxcIj5DYW5jZWw8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBjaGlja2VucGFpbnQtYXBwbHktYm94LWJsdXJcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiPk9rPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYCksXG4gICAgICAgIFxuICAgICAgICBibHVyQW1vdW50RWxlbSA9ICQoXCIuY2hpY2tlbnBhaW50LWJsdXItYW1vdW50XCIsIGRpYWxvZyksXG4gICAgICAgIGJsdXJJdGVyYXRpb25zRWxlbSA9ICQoXCIuY2hpY2tlbnBhaW50LWJsdXItaXRlcmF0aW9uc1wiLCBkaWFsb2cpLFxuICAgICAgICBhcHBseUJ1dHRvbiA9ICQoXCIuY2hpY2tlbnBhaW50LWFwcGx5LWJveC1ibHVyXCIsIGRpYWxvZyk7XG5cbiAgICB0aGlzLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGlhbG9nLm1vZGFsKFwic2hvd1wiKTtcbiAgICB9O1xuICAgIFxuICAgIGFwcGx5QnV0dG9uLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBibHVyID0gTWF0aC5tYXgocGFyc2VJbnQoYmx1ckFtb3VudEVsZW0udmFsKCksIDEwKSwgMSksXG4gICAgICAgICAgICBpdGVyYXRpb25zID0gTWF0aC5taW4oTWF0aC5tYXgocGFyc2VJbnQoYmx1ckl0ZXJhdGlvbnNFbGVtLnZhbCgpLCAxMCksIDEpLCA4KTtcbiAgICAgICAgXG4gICAgICAgIGNvbnRyb2xsZXIuZ2V0QXJ0d29yaygpLmJveEJsdXIoYmx1ciwgYmx1ciwgaXRlcmF0aW9ucyk7XG4gICAgfSk7XG4gICAgXG4gICAgZGlhbG9nXG4gICAgICAgIC5tb2RhbCh7XG4gICAgICAgICAgICBzaG93OiBmYWxzZVxuICAgICAgICB9KVxuICAgICAgICAub24oJ3Nob3duLmJzLm1vZGFsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBibHVyQW1vdW50RWxlbS5mb2N1cygpO1xuICAgICAgICB9KVxuICAgICAgICAub24oJ2tleXByZXNzJywgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAxMykge1xuICAgICAgICAgICAgICAgIGFwcGx5QnV0dG9uLmNsaWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIFxuICAgIC8vIEZpeCB0aGUgYmFja2Ryb3AgbG9jYXRpb24gaW4gdGhlIERPTSBieSByZXBhcmVudGluZyBpdCB0byB0aGUgY2hpY2tlbnBhaW50IGNvbnRhaW5lclxuICAgIGRpYWxvZy5kYXRhKFwiYnMubW9kYWxcIikuJGJvZHkgPSAkKHBhcmVudCk7XG4gICAgXG4gICAgcGFyZW50LmFwcGVuZENoaWxkKGRpYWxvZ1swXSk7XG4gICAgXG4gICAgLyogVE9ET1xuICAgIHBhbmVsLmFkZChuZXcgSkxhYmVsKFwiQmx1ciBhbW91bnQ6XCIpKTtcbiAgICBTcGlubmVyTW9kZWwgYmx1clhTTSA9IG5ldyBTcGlubmVyTnVtYmVyTW9kZWwoMywgMSwgMTAwLCAxKTtcbiAgICBcbiAgICBwYW5lbC5hZGQobmV3IEpMYWJlbChcIkl0ZXJhdGlvbnM6XCIpKTtcbiAgICBTcGlubmVyTW9kZWwgaXRlclNNID0gbmV3IFNwaW5uZXJOdW1iZXJNb2RlbCgxLCAxLCA4LCAxKTtcbiAgICAqL1xufSIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ2hpY2tlblBhaW50IGZyb20gXCIuLi9DaGlja2VuUGFpbnRcIjtcblxuaW1wb3J0IENQUGFsZXR0ZSBmcm9tIFwiLi9DUFBhbGV0dGVcIjtcbmltcG9ydCBDUENoZWNrYm94IGZyb20gXCIuL0NQQ2hlY2tib3hcIjtcbmltcG9ydCBDUENvbG9yU3dhdGNoIGZyb20gXCIuL0NQQ29sb3JTd2F0Y2hcIjtcbmltcG9ydCBDUFNsaWRlciBmcm9tIFwiLi9DUFNsaWRlclwiO1xuaW1wb3J0IHtjcmVhdGVDaGVja2VyYm9hcmRQYXR0ZXJufSBmcm9tIFwiLi9DUEdVSVV0aWxzXCI7XG5cbmltcG9ydCBDUExheWVyIGZyb20gXCIuLi9lbmdpbmUvQ1BMYXllclwiO1xuXG5pbXBvcnQgQ1BDb2xvciBmcm9tIFwiLi4vdXRpbC9DUENvbG9yXCI7XG5pbXBvcnQge2lzQ2FudmFzSW50ZXJwb2xhdGlvblN1cHBvcnRlZH0gZnJvbSBcIi4uL3V0aWwvQ1BQb2x5ZmlsbFwiO1xuXG5mdW5jdGlvbiBzbGlkZXJDaGVja2JveEdyb3VwKGNoZWNrYm94LCBzbGlkZXIpIHtcbiAgICB2YXJcbiAgICAgICAgZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgZ3JvdXAuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtY2hlY2tib3gtc2xpZGVyLWdyb3VwXCI7XG5cbiAgICBncm91cC5hcHBlbmRDaGlsZChjaGVja2JveC5nZXRFbGVtZW50KCkpO1xuICAgIGdyb3VwLmFwcGVuZENoaWxkKHNsaWRlci5nZXRFbGVtZW50KCkpO1xuXG4gICAgcmV0dXJuIGdyb3VwO1xufVxuXG5mdW5jdGlvbiBmaWxsQ29tYm9ib3goY29tYm8sIG9wdGlvbk5hbWVzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIG9wdGlvbk5hbWVzKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcblxuICAgICAgICBvcHRpb24uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUob3B0aW9uTmFtZXNba2V5XSkpO1xuICAgICAgICBvcHRpb24udmFsdWUgPSBrZXk7XG5cbiAgICAgICAgY29tYm8uYXBwZW5kQ2hpbGQob3B0aW9uKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIENQR3JhZGllbnRQcmV2aWV3KGNvbnRyb2xsZXIpIHtcbiAgICB2YXJcbiAgICAgICAgdGhhdCA9IHRoaXMsXG5cbiAgICAgICAgdyA9IDE1MCwgaCA9IDMyLFxuXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgIGNhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLFxuXG4gICAgICAgIGNoZWNrZXJib2FyZCA9IGNyZWF0ZUNoZWNrZXJib2FyZFBhdHRlcm4oY2FudmFzQ29udGV4dCksXG5cbiAgICAgICAgaW1hZ2UgPSBuZXcgQ1BMYXllcih3LCBoLCBcIlwiKSxcbiAgICAgICAgaW1hZ2VDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICBpbWFnZUNhbnZhc0NvbnRleHQgPSBpbWFnZUNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksXG5cbiAgICAgICAgZ3JhZGllbnQgPSBjb250cm9sbGVyLmdldEN1ckdyYWRpZW50KCk7XG5cbiAgICBmdW5jdGlvbiBwYWludCgpIHtcbiAgICAgICAgaW1hZ2UuZ3JhZGllbnQoaW1hZ2UuZ2V0Qm91bmRzKCksIDAsIDAsIGltYWdlLndpZHRoLCAwLCBncmFkaWVudCwgdHJ1ZSk7XG4gICAgICAgIGltYWdlQ2FudmFzQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2UuaW1hZ2VEYXRhLCAwLCAwLCAwLCAwLCB3LCBoKTtcblxuICAgICAgICBjYW52YXNDb250ZXh0LmZpbGxSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKGltYWdlQ2FudmFzLCAwLCAwKTtcbiAgICB9XG5cbiAgICB0aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuXG4gICAgY29udHJvbGxlci5vbihcImdyYWRpZW50Q2hhbmdlXCIsIGZ1bmN0aW9uKF9ncmFkaWVudCkge1xuICAgICAgICBncmFkaWVudCA9IF9ncmFkaWVudDtcblxuICAgICAgICBwYWludCgpO1xuICAgIH0pO1xuXG4gICAgY2FudmFzLndpZHRoID0gaW1hZ2VDYW52YXMud2lkdGggPSB3O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBpbWFnZUNhbnZhcy5oZWlnaHQgPSBoO1xuXG4gICAgY2FudmFzLmNsYXNzTmFtZSA9ICdjaGlja2VucGFpbnQtZ3JhZGllbnQtcHJldmlldyc7XG5cbiAgICBjYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9IGNoZWNrZXJib2FyZDtcblxuICAgIHBhaW50KCk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQnJ1c2hQYWxldHRlKGNvbnRyb2xsZXIpIHtcbiAgICBDUFBhbGV0dGUuY2FsbCh0aGlzLCBjb250cm9sbGVyLCBcImJydXNoXCIsIFwiVG9vbCBvcHRpb25zXCIpO1xuXG4gICAgdmFyXG4gICAgICAgIGJydXNoUGFuZWwgPSBuZXcgQ1BCcnVzaFBhbmVsKGNvbnRyb2xsZXIpLFxuICAgICAgICBncmFkaWVudFBhbmVsID0gbmV3IENQR3JhZGllbnRQYW5lbChjb250cm9sbGVyKSxcbiAgICAgICAgdHJhbnNmb3JtUGFuZWwgPSBuZXcgQ1BUcmFuc2Zvcm1QYW5lbChjb250cm9sbGVyKSxcblxuICAgICAgICBib2R5ID0gdGhpcy5nZXRCb2R5RWxlbWVudCgpO1xuXG4gICAgYm9keS5hcHBlbmRDaGlsZChicnVzaFBhbmVsLmdldEVsZW1lbnQoKSk7XG4gICAgYm9keS5hcHBlbmRDaGlsZChncmFkaWVudFBhbmVsLmdldEVsZW1lbnQoKSk7XG4gICAgYm9keS5hcHBlbmRDaGlsZCh0cmFuc2Zvcm1QYW5lbC5nZXRFbGVtZW50KCkpO1xuXG4gICAgY29udHJvbGxlci5vbignbW9kZUNoYW5nZScsIGZ1bmN0aW9uKG1vZGUpIHtcbiAgICAgICAgYnJ1c2hQYW5lbC5nZXRFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICBncmFkaWVudFBhbmVsLmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgIHRyYW5zZm9ybVBhbmVsLmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG5cbiAgICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgICAgICBjYXNlIENoaWNrZW5QYWludC5NX0dSQURJRU5URklMTDpcbiAgICAgICAgICAgICAgICBncmFkaWVudFBhbmVsLmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIENoaWNrZW5QYWludC5NX1RSQU5TRk9STTpcbiAgICAgICAgICAgICAgICB0cmFuc2Zvcm1QYW5lbC5nZXRFbGVtZW50KCkuc3R5bGUuZGlzcGxheSA9IFwiYmxvY2tcIjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicnVzaFBhbmVsLmdldEVsZW1lbnQoKS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgfVxuICAgIH0pO1xufVxuXG5DUEJydXNoUGFsZXR0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQUGFsZXR0ZS5wcm90b3R5cGUpO1xuQ1BCcnVzaFBhbGV0dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BCcnVzaFBhbGV0dGU7XG5cbmZ1bmN0aW9uIENQQnJ1c2hQYW5lbChjb250cm9sbGVyKSB7XG4gICAgY29uc3RcbiAgICAgICAgVElQX05BTUVTID0gW1wiUm91bmQgUGl4ZWxhdGVkXCIsIFwiUm91bmQgSGFyZCBFZGdlXCIsIFwiUm91bmQgU29mdFwiLCBcIlNxdWFyZSBQaXhlbGF0ZWRcIiwgXCJTcXVhcmUgSGFyZCBFZGdlXCJdLFxuICAgICAgICBCUlVTSF9TSVpFUyA9IFsxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTUsIDIwLCAyNSwgMzAsIDM1LCA0MCwgNDUsIDUwLCA2MCwgNzAsIDgwLCA5MCwgMTAwLCAxMjUsIDE1MCwgMTc1LCAyMDBdO1xuXG4gICAgdmFyXG4gICAgICAgIHBhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcblxuICAgICAgICB0aXBDb21ibyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXG5cbiAgICAgICAgYWxwaGFDQiA9IG5ldyBDUENoZWNrYm94KGZhbHNlLCBcIkNvbnRyb2wgYnJ1c2ggb3BhY2l0eSB3aXRoIHBlbiBwcmVzc3VyZVwiKSxcbiAgICAgICAgYWxwaGFTbGlkZXIgPSBuZXcgQ1BTbGlkZXIoMSwgMjU1KSxcblxuICAgICAgICBzaXplQ0IgPSBuZXcgQ1BDaGVja2JveCh0cnVlLCBcIkNvbnRyb2wgYnJ1c2ggc2l6ZSB3aXRoIHBlbiBwcmVzc3VyZVwiKSxcbiAgICAgICAgc2l6ZVNsaWRlciA9IG5ldyBDUFNsaWRlcigxLCAyMDAsIGZhbHNlLCB0cnVlKSxcblxuICAgICAgICBzY2F0dGVyaW5nQ0IgID0gbmV3IENQQ2hlY2tib3goZmFsc2UsIFwiQ29udHJvbCBicnVzaCBzY2F0dGVyaW5nIHdpdGggcGVuIHByZXNzdXJlXCIpLFxuICAgICAgICBzY2F0dGVyaW5nU2xpZGVyID0gbmV3IENQU2xpZGVyKDAsIDEwMDAsIGZhbHNlLCB0cnVlKSxcblxuICAgICAgICByZXNhdFNsaWRlciA9IG5ldyBDUFNsaWRlcigwLCAxMDAsIGZhbHNlLCB0cnVlKSxcbiAgICAgICAgYmxlZWRTbGlkZXIgPSBuZXcgQ1BTbGlkZXIoMCwgMTAwLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgIHNwYWNpbmdTbGlkZXIgPSBuZXcgQ1BTbGlkZXIoMCwgMTAwLCBmYWxzZSwgdHJ1ZSksXG4gICAgICAgIHNtb290aGluZ1NsaWRlciA9IG5ldyBDUFNsaWRlcigwLCAxMDAsIGZhbHNlLCB0cnVlKSxcblxuICAgICAgICBicnVzaFByZXZpZXcgPSBuZXcgQ1BCcnVzaFBhbGV0dGUuQ1BCcnVzaFByZXZpZXcoY29udHJvbGxlcik7XG5cbiAgICBmdW5jdGlvbiBmaWxsV2l0aEluaXRpYWxWYWx1ZXMoKSB7XG4gICAgICAgIGFscGhhQ0Iuc2V0VmFsdWUoY29udHJvbGxlci5nZXRCcnVzaEluZm8oKS5wcmVzc3VyZUFscGhhKTtcbiAgICAgICAgYWxwaGFTbGlkZXIuc2V0VmFsdWUoY29udHJvbGxlci5nZXRBbHBoYSgpKTtcblxuICAgICAgICBzaXplQ0Iuc2V0VmFsdWUoY29udHJvbGxlci5nZXRCcnVzaEluZm8oKS5wcmVzc3VyZVNpemUpO1xuICAgICAgICBzaXplU2xpZGVyLnNldFZhbHVlKGNvbnRyb2xsZXIuZ2V0QnJ1c2hTaXplKCkpO1xuXG4gICAgICAgIHNjYXR0ZXJpbmdDQi5zZXRWYWx1ZShjb250cm9sbGVyLmdldEJydXNoSW5mbygpLnByZXNzdXJlU2NhdHRlcmluZyk7XG4gICAgICAgIHNjYXR0ZXJpbmdTbGlkZXIuc2V0VmFsdWUofn4oY29udHJvbGxlci5nZXRCcnVzaEluZm8oKS5zY2F0dGVyaW5nICogMTAwKSk7XG5cbiAgICAgICAgdGlwQ29tYm8udmFsdWUgPSBjb250cm9sbGVyLmdldEJydXNoSW5mbygpLnR5cGU7XG5cbiAgICAgICAgcmVzYXRTbGlkZXIuc2V0VmFsdWUofn4oY29udHJvbGxlci5nZXRCcnVzaEluZm8oKS5yZXNhdCAqIDEwMCkpO1xuICAgICAgICBibGVlZFNsaWRlci5zZXRWYWx1ZSh+fihjb250cm9sbGVyLmdldEJydXNoSW5mbygpLmJsZWVkICogMTAwKSk7XG4gICAgICAgIHNwYWNpbmdTbGlkZXIuc2V0VmFsdWUofn4oY29udHJvbGxlci5nZXRCcnVzaEluZm8oKS5zcGFjaW5nICogMTAwKSk7XG4gICAgICAgIHNtb290aGluZ1NsaWRlci5zZXRWYWx1ZSh+fihjb250cm9sbGVyLmdldEJydXNoSW5mbygpLnNtb290aGluZyAqIDEwMCkpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFuZWw7XG4gICAgfTtcblxuICAgIGFscGhhU2xpZGVyLnRpdGxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBcIk9wYWNpdHk6IFwiICsgdmFsdWU7XG4gICAgfTtcblxuICAgIGFscGhhU2xpZGVyLm9uKCd2YWx1ZUNoYW5nZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb250cm9sbGVyLnNldEFscGhhKHZhbHVlKTtcbiAgICB9KTtcblxuICAgIHNpemVTbGlkZXIudGl0bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwiQnJ1c2ggc2l6ZTogXCIgKyB2YWx1ZTtcbiAgICB9XG5cbiAgICBzaXplU2xpZGVyLm9uKCd2YWx1ZUNoYW5nZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb250cm9sbGVyLnNldEJydXNoU2l6ZSh2YWx1ZSk7XG4gICAgfSk7XG5cbiAgICByZXNhdFNsaWRlci50aXRsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gXCJDb2xvcjogXCIgKyB2YWx1ZSArIFwiJVwiO1xuICAgIH07XG5cbiAgICByZXNhdFNsaWRlci5vbigndmFsdWVDaGFuZ2UnLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29udHJvbGxlci5nZXRCcnVzaEluZm8oKS5yZXNhdCA9IHZhbHVlIC8gMTAwLjA7XG4gICAgICAgIGNvbnRyb2xsZXIuY2FsbFRvb2xMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIGJsZWVkU2xpZGVyLnRpdGxlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBcIkJsZW5kOiBcIiArIHZhbHVlICsgXCIlXCI7XG4gICAgfTtcblxuICAgIGJsZWVkU2xpZGVyLm9uKCd2YWx1ZUNoYW5nZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb250cm9sbGVyLmdldEJydXNoSW5mbygpLmJsZWVkID0gdmFsdWUgLyAxMDAuMDtcbiAgICAgICAgY29udHJvbGxlci5jYWxsVG9vbExpc3RlbmVycygpO1xuICAgIH0pO1xuXG4gICAgc3BhY2luZ1NsaWRlci50aXRsZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gXCJTcGFjaW5nOiBcIiArIHZhbHVlICsgXCIlXCI7XG4gICAgfTtcblxuICAgIHNwYWNpbmdTbGlkZXIub24oJ3ZhbHVlQ2hhbmdlJywgZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZ2V0QnJ1c2hJbmZvKCkuc3BhY2luZyA9IHZhbHVlIC8gMTAwLjA7XG4gICAgICAgIGNvbnRyb2xsZXIuY2FsbFRvb2xMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIHNjYXR0ZXJpbmdTbGlkZXIudGl0bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwiU2NhdHRlcmluZzogXCIgKyB2YWx1ZSArIFwiJVwiO1xuICAgIH07XG5cbiAgICBzY2F0dGVyaW5nU2xpZGVyLm9uKCd2YWx1ZUNoYW5nZScsIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBjb250cm9sbGVyLmdldEJydXNoSW5mbygpLnNjYXR0ZXJpbmcgPSB2YWx1ZSAvIDEwMC4wO1xuICAgICAgICBjb250cm9sbGVyLmNhbGxUb29sTGlzdGVuZXJzKCk7XG4gICAgfSk7XG5cbiAgICBzbW9vdGhpbmdTbGlkZXIudGl0bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIFwiU21vb3RoaW5nOiBcIiArIHZhbHVlICsgXCIlXCI7XG4gICAgfTtcblxuICAgIHNtb290aGluZ1NsaWRlci5vbigndmFsdWVDaGFuZ2UnLCBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgY29udHJvbGxlci5nZXRCcnVzaEluZm8oKS5zbW9vdGhpbmcgPSB2YWx1ZSAvIDEwMC4wO1xuICAgICAgICBjb250cm9sbGVyLmNhbGxUb29sTGlzdGVuZXJzKCk7XG4gICAgfSk7XG5cbiAgICBzY2F0dGVyaW5nQ0Iub24oJ3ZhbHVlQ2hhbmdlJywgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZ2V0QnJ1c2hJbmZvKCkucHJlc3N1cmVTY2F0dGVyaW5nID0gc3RhdGU7XG4gICAgICAgIGNvbnRyb2xsZXIuY2FsbFRvb2xMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIGFscGhhQ0Iub24oJ3ZhbHVlQ2hhbmdlJywgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZ2V0QnJ1c2hJbmZvKCkucHJlc3N1cmVBbHBoYSA9IHN0YXRlO1xuICAgICAgICBjb250cm9sbGVyLmNhbGxUb29sTGlzdGVuZXJzKCk7XG4gICAgfSk7XG5cbiAgICBzaXplQ0Iub24oJ3ZhbHVlQ2hhbmdlJywgZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZ2V0QnJ1c2hJbmZvKCkucHJlc3N1cmVTaXplID0gc3RhdGU7XG4gICAgICAgIGNvbnRyb2xsZXIuY2FsbFRvb2xMaXN0ZW5lcnMoKTtcbiAgICB9KTtcblxuICAgIHRpcENvbWJvLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBjb250cm9sbGVyLmdldEJydXNoSW5mbygpLnR5cGUgPSBwYXJzZUludCh0aXBDb21iby52YWx1ZSwgMTApO1xuICAgIH0pO1xuXG4gICAgdGlwQ29tYm8uY2xhc3NOYW1lID0gJ2Zvcm0tY29udHJvbCc7XG4gICAgZmlsbENvbWJvYm94KHRpcENvbWJvLCBUSVBfTkFNRVMpO1xuXG4gICAgcGFuZWwuYXBwZW5kQ2hpbGQodGlwQ29tYm8pO1xuXG4gICAgcGFuZWwuYXBwZW5kQ2hpbGQoYnJ1c2hQcmV2aWV3LmdldEVsZW1lbnQoKSk7XG5cbiAgICBwYW5lbC5hcHBlbmRDaGlsZChzbGlkZXJDaGVja2JveEdyb3VwKHNpemVDQiwgc2l6ZVNsaWRlcikpO1xuICAgIHBhbmVsLmFwcGVuZENoaWxkKHNsaWRlckNoZWNrYm94R3JvdXAoYWxwaGFDQiwgYWxwaGFTbGlkZXIpKTtcbiAgICBwYW5lbC5hcHBlbmRDaGlsZChyZXNhdFNsaWRlci5nZXRFbGVtZW50KCkpO1xuICAgIHBhbmVsLmFwcGVuZENoaWxkKGJsZWVkU2xpZGVyLmdldEVsZW1lbnQoKSk7XG4gICAgcGFuZWwuYXBwZW5kQ2hpbGQoc3BhY2luZ1NsaWRlci5nZXRFbGVtZW50KCkpO1xuICAgIHBhbmVsLmFwcGVuZENoaWxkKHNsaWRlckNoZWNrYm94R3JvdXAoc2NhdHRlcmluZ0NCLCBzY2F0dGVyaW5nU2xpZGVyKSk7XG4gICAgcGFuZWwuYXBwZW5kQ2hpbGQoc21vb3RoaW5nU2xpZGVyLmdldEVsZW1lbnQoKSk7XG5cbiAgICBmaWxsV2l0aEluaXRpYWxWYWx1ZXMoKTtcblxuICAgIGNvbnRyb2xsZXIub24oJ3Rvb2xDaGFuZ2UnLCBmdW5jdGlvbih0b29sLCB0b29sSW5mbykge1xuICAgICAgICBhbHBoYVNsaWRlci5zZXRWYWx1ZSh0b29sSW5mby5hbHBoYSk7XG4gICAgICAgIHNpemVTbGlkZXIuc2V0VmFsdWUodG9vbEluZm8uc2l6ZSk7XG4gICAgICAgIHNpemVDQi5zZXRWYWx1ZSh0b29sSW5mby5wcmVzc3VyZVNpemUpO1xuICAgICAgICBhbHBoYUNCLnNldFZhbHVlKHRvb2xJbmZvLnByZXNzdXJlQWxwaGEpO1xuICAgICAgICB0aXBDb21iby52YWx1ZSA9IHRvb2xJbmZvLnR5cGU7XG4gICAgICAgIHNjYXR0ZXJpbmdDQi5zZXRWYWx1ZSh0b29sSW5mby5wcmVzc3VyZVNjYXR0ZXJpbmcpO1xuXG4gICAgICAgIGlmICh+fih0b29sSW5mby5yZXNhdCAqIDEwMC4wKSAhPSByZXNhdFNsaWRlci52YWx1ZSkge1xuICAgICAgICAgICAgcmVzYXRTbGlkZXIuc2V0VmFsdWUofn4odG9vbEluZm8ucmVzYXQgKiAxMDAuMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKH5+KHRvb2xJbmZvLmJsZWVkICogMTAwLjApICE9IGJsZWVkU2xpZGVyLnZhbHVlKSB7XG4gICAgICAgICAgICBibGVlZFNsaWRlci5zZXRWYWx1ZSh+fih0b29sSW5mby5ibGVlZCAqIDEwMC4wKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAofn4odG9vbEluZm8uc3BhY2luZyAqIDEwMC4wKSAhPSBzcGFjaW5nU2xpZGVyLnZhbHVlKSB7XG4gICAgICAgICAgICBzcGFjaW5nU2xpZGVyLnNldFZhbHVlKH5+KHRvb2xJbmZvLnNwYWNpbmcgKiAxMDAuMCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKH5+KHRvb2xJbmZvLnNjYXR0ZXJpbmcgKiAxMDAuMCkgIT0gc2NhdHRlcmluZ1NsaWRlci52YWx1ZSkge1xuICAgICAgICAgICAgc2NhdHRlcmluZ1NsaWRlci5zZXRWYWx1ZSh+fih0b29sSW5mby5zY2F0dGVyaW5nICogMTAwLjApKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh+fih0b29sSW5mby5zbW9vdGhpbmcgKiAxMDAuMCkgIT0gc21vb3RoaW5nU2xpZGVyLnZhbHVlKSB7XG4gICAgICAgICAgICBzbW9vdGhpbmdTbGlkZXIuc2V0VmFsdWUofn4odG9vbEluZm8uc21vb3RoaW5nICogMTAwLjApKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAga2V5KFwiMSwyLDMsNCw1LDYsNyw4LDksMFwiLCBmdW5jdGlvbihldmVudCwgaGFuZGxlcikge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHNob3J0Y3V0ID0gcGFyc2VJbnQoaGFuZGxlci5zaG9ydGN1dCwgMTApO1xuXG4gICAgICAgIGlmIChzaG9ydGN1dCA9PSAwKSB7XG4gICAgICAgICAgICBzaG9ydGN1dCA9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udHJvbGxlci5zZXRBbHBoYShNYXRoLnJvdW5kKHNob3J0Y3V0IC8gMTAgKiAyNTUpKTtcbiAgICB9KTtcblxuICAgIGtleShcInssW1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBzaXplID0gY29udHJvbGxlci5nZXRCcnVzaFNpemUoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gQlJVU0hfU0laRVMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChzaXplID4gQlJVU0hfU0laRVNbaV0pIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLnNldEJydXNoU2l6ZShCUlVTSF9TSVpFU1tpXSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGtleShcIn0sXVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBzaXplID0gY29udHJvbGxlci5nZXRCcnVzaFNpemUoKTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IEJSVVNIX1NJWkVTLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoc2l6ZSA8IEJSVVNIX1NJWkVTW2ldKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5zZXRCcnVzaFNpemUoQlJVU0hfU0laRVNbaV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbkNQQnJ1c2hQYWxldHRlLkNQQnJ1c2hQcmV2aWV3ID0gZnVuY3Rpb24oY29udHJvbGxlcikge1xuICAgIHZhclxuICAgICAgICBzaXplID0gMTYsXG4gICAgICAgIFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICBjYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcbiAgICAgICAgXG4gICAgICAgIG1vdXNlQ2FwdHVyZWQgPSBmYWxzZTtcbiAgICBcbiAgICBmdW5jdGlvbiBwYWludCgpIHtcbiAgICAgICAgY2FudmFzQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuYXJjKGNhbnZhcy53aWR0aCAvIDIsIGNhbnZhcy5oZWlnaHQgLyAyLCBzaXplIC8gMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGhhbmRsZU1vdXNlRHJhZyhlKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIG9mZnNldCA9ICQoY2FudmFzKS5vZmZzZXQoKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcHQgPSB7eDogZS5wYWdlWCAtIG9mZnNldC5sZWZ0LCB5OiBlLnBhZ2VZIC0gb2Zmc2V0LnRvcH0sXG4gICAgICAgIFxuICAgICAgICAgICAgeCA9IHB0LnggLSAkKGNhbnZhcykud2lkdGgoKSAvIDIsXG4gICAgICAgICAgICB5ID0gcHQueSAtICQoY2FudmFzKS5oZWlnaHQoKSAvIDIsXG5cbiAgICAgICAgICAgIG5ld1NpemUgPSBNYXRoLnJvdW5kKE1hdGguc3FydCh4ICogeCArIHkgKiB5KSAqIDIpO1xuICAgICAgICBcbiAgICAgICAgc2l6ZSA9IE1hdGgubWF4KDEsIE1hdGgubWluKDIwMCwgbmV3U2l6ZSkpO1xuXG4gICAgICAgIHBhaW50KCk7XG4gICAgICAgIGNvbnRyb2xsZXIuc2V0QnJ1c2hTaXplKHNpemUpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVVwKGUpIHtcbiAgICAgICAgaWYgKG1vdXNlQ2FwdHVyZWQpIHtcbiAgICAgICAgICAgIG1vdXNlQ2FwdHVyZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCk7XG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VEcmFnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICB0aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuICAgIFxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghbW91c2VDYXB0dXJlZCkge1xuICAgICAgICAgICAgbW91c2VDYXB0dXJlZCA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgaGFuZGxlTW91c2VVcCk7XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgaGFuZGxlTW91c2VEcmFnKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaGFuZGxlTW91c2VEcmFnKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgY29udHJvbGxlci5vbihcInRvb2xDaGFuZ2VcIiwgZnVuY3Rpb24odG9vbCwgdG9vbEluZm8pIHtcbiAgICAgICAgaWYgKHRvb2xJbmZvLnNpemUgIT0gc2l6ZSkge1xuICAgICAgICAgICAgc2l6ZSA9IHRvb2xJbmZvLnNpemU7XG4gICAgICAgICAgICBwYWludCgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgXG4gICAgY2FudmFzLndpZHRoID0gNjQ7IFxuICAgIGNhbnZhcy5oZWlnaHQgPSA2NDtcbiAgICBcbiAgICBpZiAod2luZG93LmRldmljZVBpeGVsUmF0aW8gPiAxKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS53aWR0aCA9IGNhbnZhcy53aWR0aCArICdweCc7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ICsgJ3B4JztcbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy53aWR0aCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gY2FudmFzLmhlaWdodCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgIH1cbiAgICBcbiAgICBjYW52YXMuY2xhc3NOYW1lID0gJ2NoaWNrZW5wYWludC1icnVzaC1wcmV2aWV3JztcblxuICAgIGNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgIGNhbnZhc0NvbnRleHQubGluZVdpZHRoID0gMS4wICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgXG4gICAgcGFpbnQoKTtcbn1cblxuZnVuY3Rpb24gQ1BHcmFkaWVudFBhbmVsKGNvbnRyb2xsZXIpIHtcbiAgICB2YXJcbiAgICAgICAgZ3JhZGllbnRQYW5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cbiAgICAgICAgZ3JhZGllbnRQcmV2aWV3ID0gbmV3IENQR3JhZGllbnRQcmV2aWV3KGNvbnRyb2xsZXIpLFxuXG4gICAgICAgIGdyYWRpZW50U3RhcnRTd2F0Y2ggPSBuZXcgQ1BDb2xvclN3YXRjaChuZXcgQ1BDb2xvcihjb250cm9sbGVyLmdldEN1ckdyYWRpZW50KClbMF0gJiAweEZGRkZGRikpLFxuICAgICAgICBncmFkaWVudEVuZFN3YXRjaCA9IG5ldyBDUENvbG9yU3dhdGNoKG5ldyBDUENvbG9yKGNvbnRyb2xsZXIuZ2V0Q3VyR3JhZGllbnQoKVsxXSAmIDB4RkZGRkZGKSk7XG5cbiAgICBmdW5jdGlvbiB1cGRhdGVHcmFkaWVudCgpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBncmFkaWVudCA9IG5ldyBBcnJheSgyKTtcblxuICAgICAgICBncmFkaWVudFswXSA9IChncmFkaWVudFN0YXJ0U3dhdGNoLmdldEFscGhhKCkgPDwgMjQpIHwgZ3JhZGllbnRTdGFydFN3YXRjaC5nZXRDb2xvclJnYigpO1xuICAgICAgICBncmFkaWVudFsxXSA9IChncmFkaWVudEVuZFN3YXRjaC5nZXRBbHBoYSgpIDw8IDI0KSB8ICBncmFkaWVudEVuZFN3YXRjaC5nZXRDb2xvclJnYigpO1xuXG4gICAgICAgIGNvbnRyb2xsZXIuc2V0Q3VyR3JhZGllbnQoZ3JhZGllbnQpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ3JhZGllbnRQYW5lbDtcbiAgICB9O1xuXG4gICAgZ3JhZGllbnRQYW5lbC5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC1ncmFkaWVudC1wYW5lbFwiO1xuICAgIGdyYWRpZW50UGFuZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgZ3JhZGllbnRTdGFydFN3YXRjaC5vbihcImNvbG9yQ2hhbmdlXCIsIHVwZGF0ZUdyYWRpZW50KTtcbiAgICBncmFkaWVudFN0YXJ0U3dhdGNoLm9uKFwiYWxwaGFDaGFuZ2VcIiwgdXBkYXRlR3JhZGllbnQpO1xuICAgIGdyYWRpZW50RW5kU3dhdGNoLm9uKFwiY29sb3JDaGFuZ2VcIiwgdXBkYXRlR3JhZGllbnQpO1xuICAgIGdyYWRpZW50RW5kU3dhdGNoLm9uKFwiYWxwaGFDaGFuZ2VcIiwgdXBkYXRlR3JhZGllbnQpO1xuXG4gICAgdmFyXG4gICAgICAgIHRpdGxlLCBjb2xvcnNHcm91cCwgY29sb3JHcm91cDtcblxuICAgIHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgdGl0bGUuaW5uZXJIVE1MID0gXCJHcmFkaWVudFwiO1xuXG4gICAgZ3JhZGllbnRQYW5lbC5hcHBlbmRDaGlsZCh0aXRsZSk7XG4gICAgZ3JhZGllbnRQYW5lbC5hcHBlbmRDaGlsZChncmFkaWVudFByZXZpZXcuZ2V0RWxlbWVudCgpKTtcblxuICAgIGNvbG9yc0dyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb2xvcnNHcm91cC5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC1ncmFkaWVudC1jb2xvcnNcIjtcblxuICAgIGNvbG9yR3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbG9yR3JvdXAuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtZ3JhZGllbnQtc3RhcnQtY29sb3JcIjtcblxuICAgIGNvbG9yR3JvdXAuYXBwZW5kQ2hpbGQoZ3JhZGllbnRTdGFydFN3YXRjaC5nZXRFbGVtZW50KCkpO1xuXG4gICAgY29sb3JzR3JvdXAuYXBwZW5kQ2hpbGQoY29sb3JHcm91cCk7XG5cbiAgICBjb2xvckdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBjb2xvckdyb3VwLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LWdyYWRpZW50LWVuZC1jb2xvclwiO1xuXG4gICAgY29sb3JHcm91cC5hcHBlbmRDaGlsZChncmFkaWVudEVuZFN3YXRjaC5nZXRFbGVtZW50KCkpO1xuXG4gICAgY29sb3JzR3JvdXAuYXBwZW5kQ2hpbGQoY29sb3JHcm91cCk7XG5cbiAgICBncmFkaWVudFBhbmVsLmFwcGVuZENoaWxkKGNvbG9yc0dyb3VwKTtcbn1cblxuZnVuY3Rpb24gQ1BUcmFuc2Zvcm1QYW5lbChjb250cm9sbGVyKSB7XG4gICAgY29uc3RcbiAgICAgICAgVFJBTlNGT1JNX0lOVEVSUE9MQVRJT04gPSB7c21vb3RoOiBcIlNtb290aFwiLCBzaGFycDogXCJTaGFycFwifTtcblxuICAgIHZhclxuICAgICAgICBwYW5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG5cbiAgICAgICAgYWNjZXB0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSxcbiAgICAgICAgcmVqZWN0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSxcbiAgICAgICAgaW50ZXJwQ29tYm8gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYW5lbDtcbiAgICB9O1xuXG4gICAgcGFuZWwuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtdHJhbnNmb3JtLXBhbmVsXCI7XG4gICAgcGFuZWwuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuXG4gICAgYWNjZXB0QnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiO1xuICAgIHJlamVjdEJ1dHRvbi50eXBlID0gXCJidXR0b25cIjtcblxuICAgIGFjY2VwdEJ1dHRvbi5jbGFzc05hbWUgPSBcImJ0biBidG4tcHJpbWFyeSBidG4tYmxvY2tcIjtcbiAgICByZWplY3RCdXR0b24uY2xhc3NOYW1lID0gXCJidG4gYnRuLWRlZmF1bHQgYnRuLWJsb2NrXCI7XG5cbiAgICBhY2NlcHRCdXR0b24uaW5uZXJIVE1MID0gXCJBcHBseSB0cmFuc2Zvcm1cIjtcbiAgICByZWplY3RCdXR0b24uaW5uZXJIVE1MID0gXCJDYW5jZWxcIjtcblxuICAgIGludGVycENvbWJvLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBjb250cm9sbGVyLnNldFRyYW5zZm9ybUludGVycG9sYXRpb24odGhpcy52YWx1ZSk7XG4gICAgfSk7XG5cbiAgICBpbnRlcnBDb21iby5jbGFzc05hbWUgPSAnZm9ybS1jb250cm9sIGNoaWNrZW5wYWludC10cmFuc2Zvcm0taW50ZXJwb2xhdGlvbic7XG4gICAgZmlsbENvbWJvYm94KGludGVycENvbWJvLCBUUkFOU0ZPUk1fSU5URVJQT0xBVElPTik7XG5cbiAgICBpZiAoaXNDYW52YXNJbnRlcnBvbGF0aW9uU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBpbnRlcnBHcm91cCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgICAgICBpbnRlcnBMYWJlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsYWJlbFwiKTtcblxuICAgICAgICBpbnRlcnBMYWJlbC5pbm5lckhUTUwgPSBcIlRyYW5zZm9ybSBzdHlsZVwiO1xuXG4gICAgICAgIGludGVycEdyb3VwLmNsYXNzTmFtZSA9IFwiZm9ybS1ncm91cFwiO1xuICAgICAgICBpbnRlcnBHcm91cC5hcHBlbmRDaGlsZChpbnRlcnBMYWJlbCk7XG4gICAgICAgIGludGVycEdyb3VwLmFwcGVuZENoaWxkKGludGVycENvbWJvKTtcblxuICAgICAgICBwYW5lbC5hcHBlbmRDaGlsZChpbnRlcnBHcm91cCk7XG4gICAgfVxuXG4gICAgdmFyXG4gICAgICAgIGJ1dHRvbkdyb3VwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgIGJ1dHRvbkdyb3VwLmFwcGVuZENoaWxkKGFjY2VwdEJ1dHRvbik7XG4gICAgYnV0dG9uR3JvdXAuYXBwZW5kQ2hpbGQocmVqZWN0QnV0dG9uKTtcblxuICAgIGJ1dHRvbkdyb3VwLmNsYXNzTmFtZSA9IFwiZm9ybS1ncm91cFwiO1xuXG4gICAgcGFuZWwuYXBwZW5kQ2hpbGQoYnV0dG9uR3JvdXApO1xuXG4gICAgYWNjZXB0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWN0aW9uUGVyZm9ybWVkKHthY3Rpb246IFwiQ1BUcmFuc2Zvcm1BY2NlcHRcIn0pO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG5cbiAgICByZWplY3RCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogXCJDUFRyYW5zZm9ybVJlamVjdFwifSk7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9KTtcbn1cbiIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ1BSZWN0IGZyb20gXCIuLi91dGlsL0NQUmVjdFwiO1xuaW1wb3J0IENQVHJhbnNmb3JtIGZyb20gXCIuLi91dGlsL0NQVHJhbnNmb3JtXCI7XG5pbXBvcnQgQ1BXYWNvbVRhYmxldCBmcm9tIFwiLi4vdXRpbC9DUFdhY29tVGFibGV0XCI7XG5pbXBvcnQgQ1BCZXppZXIgZnJvbSBcIi4uL3V0aWwvQ1BCZXppZXJcIjtcbmltcG9ydCB7dGhyb3R0bGV9IGZyb20gXCIuLi91dGlsL3Rocm90dGxlLWRlYm91bmNlXCI7XG5pbXBvcnQgQ1BQb2x5Z29uIGZyb20gXCIuLi91dGlsL0NQUG9seWdvblwiO1xuaW1wb3J0IHtzZXRDYW52YXNJbnRlcnBvbGF0aW9ufSBmcm9tIFwiLi4vdXRpbC9DUFBvbHlmaWxsXCI7XG5cbmltcG9ydCBDaGlja2VuUGFpbnQgZnJvbSBcIi4uL0NoaWNrZW5QYWludFwiO1xuXG5pbXBvcnQgQ1BCcnVzaEluZm8gZnJvbSBcIi4uL2VuZ2luZS9DUEJydXNoSW5mb1wiO1xuXG5pbXBvcnQge2NyZWF0ZUNoZWNrZXJib2FyZFBhdHRlcm59IGZyb20gXCIuL0NQR1VJVXRpbHNcIjtcbmltcG9ydCBDUFNjcm9sbGJhciBmcm9tIFwiLi9DUFNjcm9sbGJhclwiO1xuaW1wb3J0IENQVmVjdG9yIGZyb20gXCIuLi91dGlsL0NQVmVjdG9yXCI7XG5cbmZ1bmN0aW9uIENQTW9kZVN0YWNrKCkge1xuICAgIHRoaXMubW9kZXMgPSBbXTtcbn1cblxuLyogV2UgaGF2ZSB0d28gZGlzdGluZ3Vpc2hlZCBtb2RlIGluZGV4ZXMgd2hpY2ggY29ycmVzcG9uZCB0byB0aGUgQ1BEZWZhdWx0TW9kZSBhbmQgdGhlIG1vZGUgdGhhdCB0aGUgdXNlciBoYXMgc2VsZWN0ZWRcbiAqIGluIHRoZSB0b29sIHBhbGV0dGUgKHRoZSBnbG9iYWwgZHJhd2luZyBtb2RlKS4gT24gdG9wIG9mIHRoYXQgYXJlIG90aGVyIHRyYW5zaWVudCBtb2Rlcy5cbiAqL1xuQ1BNb2RlU3RhY2suTU9ERV9JTkRFWF9ERUZBVUxUID0gMDtcbkNQTW9kZVN0YWNrLk1PREVfSU5ERVhfVVNFUiA9IDE7XG5cbkNQTW9kZVN0YWNrLnByb3RvdHlwZS5zZXRNb2RlID0gZnVuY3Rpb24oaW5kZXgsIG5ld01vZGUpIHtcbiAgICB2YXJcbiAgICAgICAgb2xkTW9kZSA9IHRoaXMubW9kZXNbaW5kZXhdO1xuXG4gICAgaWYgKG9sZE1vZGUgPT0gbmV3TW9kZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG9sZE1vZGUpIHtcbiAgICAgICAgb2xkTW9kZS5sZWF2ZSgpO1xuICAgIH1cblxuICAgIHRoaXMubW9kZXNbaW5kZXhdID0gbmV3TW9kZTtcbiAgICBuZXdNb2RlLmVudGVyKCk7XG59O1xuXG5DUE1vZGVTdGFjay5wcm90b3R5cGUuc2V0RGVmYXVsdE1vZGUgPSBmdW5jdGlvbihuZXdNb2RlKSB7XG4gICAgbmV3TW9kZS50cmFuc2llbnQgPSBmYWxzZTtcbiAgICBuZXdNb2RlLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0TW9kZShDUE1vZGVTdGFjay5NT0RFX0lOREVYX0RFRkFVTFQsIG5ld01vZGUpO1xufTtcblxuQ1BNb2RlU3RhY2sucHJvdG90eXBlLnNldFVzZXJNb2RlID0gZnVuY3Rpb24obmV3TW9kZSkge1xuICAgIC8vIExlYXZlIGFueSB0cmFuc2llbnQgbW9kZXMgdGhhdCB3ZXJlIG9uIHRvcCBvZiB0aGUgdXNlciBtb2RlXG4gICAgZm9yICh2YXIgaSA9IHRoaXMubW9kZXMubGVuZ3RoIC0gMTsgaSA+IENQTW9kZVN0YWNrLk1PREVfSU5ERVhfVVNFUjsgaS0tKSB7XG4gICAgICAgIHRoaXMubW9kZXNbaV0ubGVhdmUoKTtcbiAgICAgICAgdGhpcy5tb2Rlcy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuXG4gICAgbmV3TW9kZS50cmFuc2llbnQgPSBmYWxzZTtcbiAgICBuZXdNb2RlLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgIHRoaXMuc2V0TW9kZShDUE1vZGVTdGFjay5NT0RFX0lOREVYX1VTRVIsIG5ld01vZGUpO1xufTtcblxuLyoqXG4gKiBEZWxpdmVyIHRoZSBldmVudCB3aXRoIHRoZSBnaXZlbiBuYW1lIGFuZCBhcnJheSBvZiBwYXJhbWV0ZXJzIHRvIHRoZSBtb2RlIHN0YWNrLlxuICpcbiAqIEBwYXJhbSBldmVudFxuICogQHBhcmFtIHBhcmFtc1xuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgYW55IG1vZGUgY2FwdHVyZWQgdGhlIGV2ZW50XG4gKi9cbkNQTW9kZVN0YWNrLnByb3RvdHlwZS5kZWxpdmVyRXZlbnQgPSBmdW5jdGlvbihldmVudCwgcGFyYW1zKSB7XG4gICAgZm9yICh2YXIgaSA9IHRoaXMubW9kZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBtb2RlID0gdGhpcy5tb2Rlc1tpXTtcblxuICAgICAgICBpZiAobW9kZVtldmVudF0uYXBwbHkobW9kZSwgcGFyYW1zKSB8fCBtb2RlLmNhcHR1cmUgJiYgZXZlbnQgIT0gXCJwYWludFwiKSB7XG4gICAgICAgICAgICAvKiBJZiB0aGUgZXZlbnQgd2FzIGhhbmRsZWQsIGRvbid0IHRyeSB0byBkZWxpdmVyIGl0IHRvIGFueXRoaW5nIGZ1cnRoZXIgdXAgdGhlIHN0YWNrICovXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbn07XG5cbi8vIFdlIGNhbiBjYWxsIHRoZXNlIHJvdXRpbmVzIHRvIGRlbGl2ZXIgZXZlbnRzIHRoYXQgYnViYmxlIHVwIHRoZSBtb2RlIHN0YWNrXG5mb3IgKGxldCBldmVudE5hbWUgb2YgW1wibW91c2VEb3duXCIsIFwibW91c2VVcFwiXSkge1xuICAgIENQTW9kZVN0YWNrLnByb3RvdHlwZVtldmVudE5hbWVdID0gZnVuY3Rpb24gKGUsIGJ1dHRvbiwgcHJlc3N1cmUpIHtcbiAgICAgICAgdGhpcy5kZWxpdmVyRXZlbnQoZXZlbnROYW1lLCBbZSwgYnV0dG9uLCBwcmVzc3VyZV0pO1xuICAgIH07XG59XG5cbmZvciAobGV0IGV2ZW50TmFtZSBvZiBbXCJtb3VzZURyYWdcIiwgXCJtb3VzZU1vdmVcIl0pIHtcbiAgICBDUE1vZGVTdGFjay5wcm90b3R5cGVbZXZlbnROYW1lXSA9IGZ1bmN0aW9uIChlLCBwcmVzc3VyZSkge1xuICAgICAgICB0aGlzLmRlbGl2ZXJFdmVudChldmVudE5hbWUsIFtlLCBwcmVzc3VyZV0pO1xuICAgIH07XG59XG5cbmZvciAobGV0IGV2ZW50TmFtZSBvZiBbXCJrZXlEb3duXCIsIFwia2V5VXBcIl0pIHtcbiAgICBDUE1vZGVTdGFjay5wcm90b3R5cGVbZXZlbnROYW1lXSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmICh0aGlzLmRlbGl2ZXJFdmVudChldmVudE5hbWUsIFtlXSkpIHtcbiAgICAgICAgICAgIC8vIFN3YWxsb3cgaGFuZGxlZCBrZXlwcmVzc2VzXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuXG5DUE1vZGVTdGFjay5wcm90b3R5cGUucGFpbnQgPSBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgdGhpcy5kZWxpdmVyRXZlbnQoXCJwYWludFwiLCBbY29udGV4dF0pO1xufTtcblxuLyoqXG4gKiBBZGQgYSBtb2RlIHRvIHRoZSB0b3Agb2YgdGhlIG1vZGUgc3RhY2suXG4gKlxuICogQHBhcmFtIG1vZGUge0NQTW9kZX1cbiAqIEBwYXJhbSB0cmFuc2llbnQge2Jvb2xlYW59IFNldCB0byB0cnVlIGlmIHRoZSBtb2RlIGlzIGV4cGVjdGVkIHRvIHJlbW92ZSBpdHNlbGYgZnJvbSBzdGFjayB1cG9uIGNvbXBsZXRpb24uXG4gKi9cbkNQTW9kZVN0YWNrLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obW9kZSwgdHJhbnNpZW50KSB7XG4gICAgdmFyXG4gICAgICAgIHByZXZpb3VzVG9wID0gdGhpcy5wZWVrKCk7XG5cbiAgICBpZiAocHJldmlvdXNUb3ApIHtcbiAgICAgICAgcHJldmlvdXNUb3Auc3VzcGVuZCgpO1xuICAgIH1cblxuICAgIG1vZGUudHJhbnNpZW50ID0gdHJhbnNpZW50O1xuICAgIG1vZGUuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgbW9kZS5lbnRlcigpO1xuXG4gICAgdGhpcy5tb2Rlcy5wdXNoKG1vZGUpO1xufTtcblxuQ1BNb2RlU3RhY2sucHJvdG90eXBlLnBlZWsgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5tb2Rlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1vZGVzW3RoaXMubW9kZXMubGVuZ3RoIC0gMV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIG5vZGUgYXQgdGhlIHRvcCBvZiB0aGUgc3RhY2sgYW5kIHJldHVybiB0aGUgbmV3IHRvcCBvZiB0aGUgc3RhY2suXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbkNQTW9kZVN0YWNrLnByb3RvdHlwZS5wb3AgPSBmdW5jdGlvbigpIHtcbiAgICB2YXJcbiAgICAgICAgb3V0Z29pbmdNb2RlID0gdGhpcy5tb2Rlcy5wb3AoKSxcbiAgICAgICAgbmV3VG9wID0gdGhpcy5wZWVrKCk7XG5cbiAgICBpZiAob3V0Z29pbmdNb2RlKSB7XG4gICAgICAgIG91dGdvaW5nTW9kZS5sZWF2ZSgpO1xuICAgIH1cblxuICAgIGlmIChuZXdUb3ApIHtcbiAgICAgICAgbmV3VG9wLnJlc3VtZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXdUb3A7XG59O1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUENhbnZhcyhjb250cm9sbGVyKSB7XG4gICAgY29uc3RcbiAgICAgICAgQlVUVE9OX1BSSU1BUlkgPSAwLFxuICAgICAgICBCVVRUT05fV0hFRUwgPSAxLFxuICAgICAgICBCVVRUT05fU0VDT05EQVJZID0gMixcblxuICAgICAgICBNSU5fWk9PTSA9IDAuMTAsXG4gICAgICAgIE1BWF9aT09NID0gMTYuMCxcblxuICAgICAgICBDVVJTT1JfREVGQVVMVCA9IFwiZGVmYXVsdFwiLCBDVVJTT1JfUEFOTkFCTEUgPSBcImdyYWJcIiwgQ1VSU09SX1BBTk5JTkcgPSBcImdyYWJiaW5nXCIsIENVUlNPUl9DUk9TU0hBSVIgPSBcImNyb3NzaGFpclwiLFxuICAgICAgICBDVVJTT1JfTU9WRSA9IFwibW92ZVwiLCBDVVJTT1JfTkVTV19SRVNJWkUgPSBcIm5lc3ctcmVzaXplXCIsIENVUlNPUl9OV1NFX1JFU0laRSA9IFwibndzZS1yZXNpemVcIixcbiAgICAgICAgQ1VSU09SX05TX1JFU0laRSA9IFwibnMtcmVzaXplXCIsIENVUlNPUl9FV19SRVNJWkUgPSBcImV3LXJlc2l6ZVwiO1xuXG4gICAgdmFyXG4gICAgICAgIHRoYXQgPSB0aGlzLFxuICAgIFxuICAgICAgICBjYW52YXNDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBjYW52YXNDb250YWluZXJUb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBjYW52YXNDb250YWluZXJCb3R0b20gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBcbiAgICAgICAgLy8gT3VyIGNhbnZhcyB0aGF0IGZpbGxzIHRoZSBlbnRpcmUgc2NyZWVuXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgIGNhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLFxuICAgICAgICBcbiAgICAgICAgLy8gT3VyIGNhY2hlIG9mIHRoZSBhcnR3b3JrJ3MgZnVzaW9uIHRvIGJlIGRyYXduIG9udG8gb3VyIG1haW4gY2FudmFzIHVzaW5nIG91ciBjdXJyZW50IHRyYW5zZm9ybVxuICAgICAgICBhcnR3b3JrQ2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgYXJ0d29ya0NhbnZhc0NvbnRleHQgPSBhcnR3b3JrQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcbiAgICAgICAgXG4gICAgICAgIGNoZWNrZXJib2FyZFBhdHRlcm4gPSBjcmVhdGVDaGVja2VyYm9hcmRQYXR0ZXJuKGNhbnZhc0NvbnRleHQpLFxuICAgICAgICBcbiAgICAgICAgYXJ0d29yayA9IGNvbnRyb2xsZXIuZ2V0QXJ0d29yaygpLFxuXG4gICAgICAgIC8vIENhbnZhcyB0cmFuc2Zvcm1hdGlvbnNcbiAgICAgICAgem9vbSA9IDEsXG4gICAgICAgIG9mZnNldFggPSAwLCBvZmZzZXRZID0gMCxcbiAgICAgICAgY2FudmFzUm90YXRpb24gPSAwLjAsXG4gICAgICAgIHRyYW5zZm9ybSA9IG5ldyBDUFRyYW5zZm9ybSgpLFxuICAgICAgICBpbnRlcnBvbGF0aW9uID0gZmFsc2UsXG5cbiAgICAgICAgLy8gR3JpZCBvcHRpb25zXG4gICAgICAgIHNob3dHcmlkID0gZmFsc2UsXG4gICAgICAgIGdyaWRTaXplID0gMzIsXG4gICAgICAgIFxuICAgICAgICBtb3VzZVggPSAwLCBtb3VzZVkgPSAwLFxuXG4gICAgICAgIG1vdXNlSW4gPSBmYWxzZSwgbW91c2VEb3duID0gW2ZhbHNlLCBmYWxzZSwgZmFsc2VdIC8qIFRyYWNrIGVhY2ggYnV0dG9uIGluZGVwZW5kZW50bHkgKi8sIHdhY29tUGVuRG93biA9IGZhbHNlLFxuICAgICAgICBcbiAgICAgICAgLyogVGhlIGFyZWEgb2YgdGhlIGRvY3VtZW50IHRoYXQgc2hvdWxkIGhhdmUgaXRzIGxheWVycyBmdXNlZCBhbmQgcmVwYWludGVkIHRvIHRoZSBzY3JlZW5cbiAgICAgICAgICogKGkuZS4gYW4gYXJlYSBtb2RpZmllZCBieSBkcmF3aW5nIHRvb2xzKS4gXG4gICAgICAgICAqIFxuICAgICAgICAgKiBJbml0aWFsbHkgc2V0IHRvIHRoZSBzaXplIG9mIHRoZSBhcnR3b3JrIHNvIHdlIGNhbiByZXBhaW50IHRoZSB3aG9sZSB0aGluZy5cbiAgICAgICAgICovXG4gICAgICAgIGFydHdvcmtVcGRhdGVSZWdpb24gPSBuZXcgQ1BSZWN0KDAsIDAsIGFydHdvcmsud2lkdGgsIGFydHdvcmsuaGVpZ2h0KSxcbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGUgYXJlYSBvZiB0aGUgY2FudmFzIHRoYXQgc2hvdWxkIGJlIHJlcGFpbnRlZCB0byB0aGUgc2NyZWVuIGR1cmluZyB0aGUgbmV4dCByZXBhaW50IGludGVybmFsIChpbiBjYW52YXNcbiAgICAgICAgICogY29vcmRpbmF0ZXMpLlxuICAgICAgICAgKi9cbiAgICAgICAgcmVwYWludFJlZ2lvbiA9IG5ldyBDUFJlY3QoMCwgMCwgMCwgMCksXG4gICAgICAgIHNjaGVkdWxlZFJlcGFpbnQgPSBmYWxzZSxcbiAgICAgICAgXG4gICAgICAgIC8vXG4gICAgICAgIC8vIE1vZGVzIHN5c3RlbTogbW9kZXMgY29udHJvbCB0aGUgd2F5IHRoZSBHVUkgaXMgcmVhY3RpbmcgdG8gdGhlIHVzZXIgaW5wdXRcbiAgICAgICAgLy8gQWxsIHRoZSB0b29scyBhcmUgaW1wbGVtZW50ZWQgdGhyb3VnaCBtb2Rlc1xuICAgICAgICAvL1xuICAgICAgICBcbiAgICAgICAgZGVmYXVsdE1vZGUsXG4gICAgICAgIGNvbG9yUGlja2VyTW9kZSxcbiAgICAgICAgcGFuTW9kZSxcbiAgICAgICAgcm90YXRlQ2FudmFzTW9kZSxcbiAgICAgICAgZmxvb2RGaWxsTW9kZSxcbiAgICAgICAgZ3JhZGllbnRGaWxsTW9kZSxcbiAgICAgICAgcmVjdFNlbGVjdGlvbk1vZGUsXG4gICAgICAgIG1vdmVUb29sTW9kZSxcbiAgICAgICAgdHJhbnNmb3JtTW9kZSxcblxuICAgICAgICAvLyB0aGlzIG11c3QgY29ycmVzcG9uZCB0byB0aGUgc3Ryb2tlIG1vZGVzIGRlZmluZWQgaW4gQ1BUb29sSW5mb1xuICAgICAgICBkcmF3aW5nTW9kZXMgPSBbXSxcblxuICAgICAgICBtb2RlU3RhY2sgPSBuZXcgQ1BNb2RlU3RhY2soKSxcblxuICAgICAgICBjdXJEcmF3TW9kZSwgY3VyU2VsZWN0ZWRNb2RlLFxuICAgICAgICBcbiAgICAgICAgaG9yelNjcm9sbCA9IG5ldyBDUFNjcm9sbGJhcihmYWxzZSksIFxuICAgICAgICB2ZXJ0U2Nyb2xsID0gbmV3IENQU2Nyb2xsYmFyKHRydWUpLFxuICAgICAgICBcbiAgICAgICAgdGFibGV0ID0gQ1BXYWNvbVRhYmxldC5nZXRSZWYoKTtcblxuICAgIE1hdGguc2lnbiA9IE1hdGguc2lnbiB8fCBmdW5jdGlvbih4KSB7XG4gICAgICAgIHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuICAgICAgICBpZiAoeCA9PT0gMCB8fCBpc05hTih4KSkge1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHggPiAwID8gMSA6IC0xO1xuICAgIH07XG5cbiAgICAvLyBQYXJlbnQgY2xhc3Mgd2l0aCBlbXB0eSBldmVudCBoYW5kbGVycyBmb3IgdGhvc2UgZHJhd2luZyBtb2RlcyB0aGF0IGRvbid0IG5lZWQgZXZlcnkgZXZlbnRcbiAgICBmdW5jdGlvbiBDUE1vZGUoKSB7XG4gICAgfVxuXG5cdC8qKlxuICAgICAqIFRydWUgaWYgdGhpcyBtb2RlIHdpbGwgYmUgZXhpdGluZyB0aGUgbW9kZSBzdGFjayBhcyBzb29uIGFzIHRoZSBjdXJyZW50IGludGVyYXRpb24gaXMgY29tcGxldGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBDUE1vZGUucHJvdG90eXBlLnRyYW5zaWVudCA9IGZhbHNlO1xuXG5cdC8qKlxuICAgICAqIElmIHRydWUsIG5vIGlucHV0IGV2ZW50cyB3aWxsIGJlIHNlbnQgdG8gYW55IG1vZGVzIHVuZGVybmVhdGggdGhpcyBvbmUgKGV2ZW50IHN0cmVhbSBpcyBjYXB0dXJlZCkuXG4gICAgICpcbiAgICAgKiBQYWludGluZyBldmVudHMgd2lsbCBjb250aW51ZSB0byBidWJibGUuXG4gICAgICpcbiAgICAgKiBAdHlwZSB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBDUE1vZGUucHJvdG90eXBlLmNhcHR1cmUgPSBmYWxzZTtcbiAgICBcbiAgICBDUE1vZGUucHJvdG90eXBlLmVudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHNldEN1cnNvcihDVVJTT1JfREVGQVVMVCk7XG4gICAgfTtcblxuICAgIENQTW9kZS5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jYXB0dXJlID0gZmFsc2U7XG4gICAgfTtcblxuICAgIENQTW9kZS5wcm90b3R5cGUubW91c2VNb3ZlID0gQ1BNb2RlLnByb3RvdHlwZS5wYWludCA9IENQTW9kZS5wcm90b3R5cGUubW91c2VEb3duXG4gICAgICAgID0gQ1BNb2RlLnByb3RvdHlwZS5tb3VzZURyYWcgPSBDUE1vZGUucHJvdG90eXBlLm1vdXNlVXAgPSBDUE1vZGUucHJvdG90eXBlLmtleURvd25cbiAgICAgICAgPSBDUE1vZGUucHJvdG90eXBlLnN1c3BlbmQgPSBDUE1vZGUucHJvdG90eXBlLnJlc3VtZSA9IENQTW9kZS5wcm90b3R5cGUua2V5VXAgPSBmdW5jdGlvbigpIHt9O1xuXG4gICAgLy9cbiAgICAvLyBEZWZhdWx0IFVJIE1vZGUgd2hlbiBub3QgZG9pbmcgYW55dGhpbmc6IHVzZWQgdG8gc3RhcnQgdGhlIG90aGVyIG1vZGVzXG4gICAgLy9cblxuICAgIGZ1bmN0aW9uIENQRGVmYXVsdE1vZGUoKSB7XG4gICAgfVxuICAgIFxuICAgIENQRGVmYXVsdE1vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUE1vZGUucHJvdG90eXBlKTtcbiAgICBDUERlZmF1bHRNb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQRGVmYXVsdE1vZGU7XG4gICAgXG4gICAgQ1BEZWZhdWx0TW9kZS5wcm90b3R5cGUubW91c2VEb3duID0gZnVuY3Rpb24oZSwgYnV0dG9uLCBwcmVzc3VyZSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHNwYWNlUHJlc3NlZCA9IGtleS5pc1ByZXNzZWQoXCJzcGFjZVwiKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghc3BhY2VQcmVzc2VkXG4gICAgICAgICAgICAgICAgJiYgKGJ1dHRvbiA9PSBCVVRUT05fU0VDT05EQVJZIHx8IGJ1dHRvbiA9PSBCVVRUT05fUFJJTUFSWSAmJiBlLmFsdEtleSkpIHtcbiAgICAgICAgICAgIG1vZGVTdGFjay5wdXNoKGNvbG9yUGlja2VyTW9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAvLyBBdm9pZCBpbmZpbml0ZSByZWN1cnNpb24gYnkgb25seSBkZWxpdmVyaW5nIHRoZSBldmVudCB0byB0aGUgbmV3IG1vZGUgKGRvbid0IGxldCBpdCBidWJibGUgYmFjayB0byB1cyEpXG4gICAgICAgICAgICBtb2RlU3RhY2sucGVlaygpLm1vdXNlRG93bihlLCBidXR0b24sIHByZXNzdXJlKTtcbiAgICAgICAgfSBlbHNlIGlmIChidXR0b24gPT0gQlVUVE9OX1dIRUVMIHx8IHNwYWNlUHJlc3NlZCAmJiBidXR0b24gPT0gQlVUVE9OX1BSSU1BUlkpIHtcbiAgICAgICAgICAgIGlmIChlLmFsdEtleSkge1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5wdXNoKHJvdGF0ZUNhbnZhc01vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5wZWVrKCkubW91c2VEb3duKGUsIGJ1dHRvbiwgcHJlc3N1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlU3RhY2sucHVzaChwYW5Nb2RlLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBtb2RlU3RhY2sucGVlaygpLm1vdXNlRG93bihlLCBidXR0b24sIHByZXNzdXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgQ1BEZWZhdWx0TW9kZS5wcm90b3R5cGUua2V5RG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGUua2V5Q29kZSA9PSAzMiAvKiBTcGFjZSAqLykge1xuICAgICAgICAgICAgaWYgKGUuYWx0S2V5KSB7XG4gICAgICAgICAgICAgICAgbW9kZVN0YWNrLnB1c2gocm90YXRlQ2FudmFzTW9kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgbW9kZVN0YWNrLnBlZWsoKS5rZXlEb3duKGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBjYW4gc3RhcnQgdGhlIHBhbiBtb2RlIGJlZm9yZSB0aGUgbW91c2UgYnV0dG9uIGlzIGV2ZW4gcHJlc3NlZCwgc28gdGhhdCB0aGUgXCJncmFiYmFibGVcIiBjdXJzb3IgYXBwZWFyc1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5wdXNoKHBhbk1vZGUsIHRydWUpO1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5wZWVrKCkua2V5RG93bihlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuXHQvKipcbiAgICAgKiBBIGJhc2UgZm9yIHRoZSB0aHJlZSBkcmF3aW5nIG1vZGVzLCBzbyB0aGV5IGNhbiBhbGwgc2hhcmUgdGhlIHNhbWUgYnJ1c2gtcHJldmlldy1jaXJjbGUgZHJhd2luZyBiZWhhdmlvdXIuXG4gICAgICpcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBDUERyYXdpbmdNb2RlKCkge1xuICAgICAgICB0aGlzLnNob3VsZFBhaW50QnJ1c2hQcmV2aWV3ID0gZmFsc2U7XG5cbiAgICAgICAgLyogVGhlIGxhc3QgcmVjdGFuZ2xlIHdlIGRpcnRpZWQgd2l0aCBhIGJydXNoIHByZXZpZXcgY2lyY2xlLCBvciBudWxsIGlmIG9uZSBoYXNuJ3QgYmVlbiBkcmF3biB5ZXQgKi9cbiAgICAgICAgdGhpcy5vbGRQcmV2aWV3UmVjdCA9IG51bGw7XG4gICAgfVxuXG4gICAgQ1BEcmF3aW5nTW9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQTW9kZS5wcm90b3R5cGUpO1xuICAgIENQRHJhd2luZ01vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BEcmF3aW5nTW9kZTtcblxuICAgIC8qKlxuICAgICAqIEdldCBhIHJlY3RhbmdsZSB0aGF0IGVuY2xvc2VzIHRoZSBwcmV2aWV3IGJydXNoLCBpbiBzY3JlZW4gY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgQ1BEcmF3aW5nTW9kZS5wcm90b3R5cGUuZ2V0QnJ1c2hQcmV2aWV3T3ZhbCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGJydXNoU2l6ZSA9IGNvbnRyb2xsZXIuZ2V0QnJ1c2hTaXplKCkgKiB6b29tO1xuXG4gICAgICAgIHJldHVybiBuZXcgQ1BSZWN0KFxuICAgICAgICAgICAgbW91c2VYIC0gYnJ1c2hTaXplIC8gMixcbiAgICAgICAgICAgIG1vdXNlWSAtIGJydXNoU2l6ZSAvIDIsXG4gICAgICAgICAgICBtb3VzZVggKyBicnVzaFNpemUgLyAyLFxuICAgICAgICAgICAgbW91c2VZICsgYnJ1c2hTaXplIC8gMlxuICAgICAgICApO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBRdWV1ZXMgdXAgdGhlIGJydXNoIHByZXZpZXcgb3ZhbCB0byBiZSBkcmF3bi5cbiAgICAgKi9cbiAgICBDUERyYXdpbmdNb2RlLnByb3RvdHlwZS5xdWV1ZUJydXNoUHJldmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvKiBJZiB3ZSdyZSBub3QgdGhlIHRvcC1tb3N0IG1vZGUsIGl0J3MgdW5saWtlbHkgdGhhdCBsZWZ0IGNsaWNraW5nIHdpbGwgZHJhd2luZyBmb3IgdXMsIHNvIGRvbid0IGNvbnNpZGVyXG4gICAgICAgICAqIHBhaW50aW5nIHRoZSBicnVzaCBwcmV2aWV3XG4gICAgICAgICAqL1xuICAgICAgICBpZiAobW9kZVN0YWNrLnBlZWsoKSAhPSB0aGlzKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNob3VsZFBhaW50QnJ1c2hQcmV2aWV3ID0gdHJ1ZTtcblxuICAgICAgICB2YXJcbiAgICAgICAgICAgIHJlY3QgPSB0aGlzLmdldEJydXNoUHJldmlld092YWwoKTtcblxuICAgICAgICByZWN0Lmdyb3coMiwgMik7XG5cbiAgICAgICAgLy8gSWYgYSBicnVzaCBwcmV2aWV3IHdhcyBkcmF3biBwcmV2aW91c2x5LCBzdHJldGNoIHRoZSByZXBhaW50IHJlZ2lvbiB0byByZW1vdmUgdGhhdCBvbGQgY29weVxuICAgICAgICBpZiAodGhpcy5vbGRQcmV2aWV3UmVjdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZWN0LnVuaW9uKHRoaXMub2xkUHJldmlld1JlY3QpO1xuICAgICAgICAgICAgdGhpcy5vbGRQcmV2aWV3UmVjdCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICByZXBhaW50UmVjdChyZWN0KTtcbiAgICB9O1xuXG5cdC8qKlxuICAgICAqIEVyYXNlIHRoZSBicnVzaCBwcmV2aWV3IGlmIG9uZSBoYWQgYmVlbiBkcmF3blxuICAgICAqL1xuICAgIENQRHJhd2luZ01vZGUucHJvdG90eXBlLmVyYXNlQnJ1c2hQcmV2aWV3ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuc2hvdWxkUGFpbnRCcnVzaFByZXZpZXcgPSBmYWxzZTtcblxuICAgICAgICBpZiAodGhpcy5vbGRQcmV2aWV3UmVjdCAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXBhaW50UmVjdCh0aGlzLm9sZFByZXZpZXdSZWN0KTtcbiAgICAgICAgICAgIHRoaXMub2xkUHJldmlld1JlY3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENQRHJhd2luZ01vZGUucHJvdG90eXBlLm1vdXNlTW92ZSA9IGZ1bmN0aW9uKGUsIHByZXNzdXJlKSB7XG4gICAgICAgIHRoaXMucXVldWVCcnVzaFByZXZpZXcoKTtcbiAgICB9O1xuXG4gICAgQ1BEcmF3aW5nTW9kZS5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgQ1BNb2RlLnByb3RvdHlwZS5lbnRlci5jYWxsKHRoaXMpO1xuXG4gICAgICAgIGlmIChtb3VzZUluKSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlQnJ1c2hQcmV2aWV3KCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ1BEcmF3aW5nTW9kZS5wcm90b3R5cGUubGVhdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgQ1BNb2RlLnByb3RvdHlwZS5sZWF2ZS5jYWxsKHRoaXMpO1xuICAgICAgICB0aGlzLmVyYXNlQnJ1c2hQcmV2aWV3KCk7XG4gICAgfTtcblxuICAgIENQRHJhd2luZ01vZGUucHJvdG90eXBlLnN1c3BlbmQgPSBDUERyYXdpbmdNb2RlLnByb3RvdHlwZS5sZWF2ZTtcbiAgICBDUERyYXdpbmdNb2RlLnByb3RvdHlwZS5yZXN1bWUgPSBDUERyYXdpbmdNb2RlLnByb3RvdHlwZS5lbnRlcjtcblxuICAgIENQRHJhd2luZ01vZGUucHJvdG90eXBlLnBhaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLnNob3VsZFBhaW50QnJ1c2hQcmV2aWV3KSB7XG4gICAgICAgICAgICB0aGlzLnNob3VsZFBhaW50QnJ1c2hQcmV2aWV3ID0gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHIgPSB0aGlzLmdldEJydXNoUHJldmlld092YWwoKTtcblxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5hcmMoXG4gICAgICAgICAgICAgICAgKHIubGVmdCArIHIucmlnaHQpIC8gMixcbiAgICAgICAgICAgICAgICAoci50b3AgKyByLmJvdHRvbSkgLyAyLFxuICAgICAgICAgICAgICAgIHIuZ2V0V2lkdGgoKSAvIDIsXG4gICAgICAgICAgICAgICAgMCxcbiAgICAgICAgICAgICAgICBNYXRoLlBJICogMlxuICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5zdHJva2UoKTtcblxuICAgICAgICAgICAgci5ncm93KDIsIDIpO1xuXG4gICAgICAgICAgICBpZiAodGhpcy5vbGRQcmV2aWV3UmVjdCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbGRQcmV2aWV3UmVjdCA9IHI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub2xkUHJldmlld1JlY3QudW5pb24ocik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQ1BGcmVlaGFuZE1vZGUoKSB7XG4gICAgICAgIENQRHJhd2luZ01vZGUuY2FsbCh0aGlzKTtcblxuICAgICAgICB0aGlzLnNtb290aE1vdXNlID0ge3g6MC4wLCB5OjAuMH07XG4gICAgfVxuICAgIFxuICAgIENQRnJlZWhhbmRNb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BEcmF3aW5nTW9kZS5wcm90b3R5cGUpO1xuICAgIENQRnJlZWhhbmRNb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQRnJlZWhhbmRNb2RlO1xuICAgIFxuICAgIENQRnJlZWhhbmRNb2RlLnByb3RvdHlwZS5tb3VzZURvd24gPSBmdW5jdGlvbihlLCBidXR0b24sIHByZXNzdXJlKSB7XG4gICAgICAgIGlmICghdGhpcy5jYXB0dXJlICYmIGJ1dHRvbiA9PSBCVVRUT05fUFJJTUFSWSAmJiAhZS5hbHRLZXkgJiYgIWtleS5pc1ByZXNzZWQoXCJzcGFjZVwiKSAmJiBzaG91bGREcmF3VG9UaGlzTGF5ZXIoKSkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgcGYgPSBjb29yZFRvRG9jdW1lbnQoe3g6IG1vdXNlWCwgeTptb3VzZVl9KTtcblxuICAgICAgICAgICAgdGhpcy5lcmFzZUJydXNoUHJldmlldygpO1xuXG4gICAgICAgICAgICB0aGlzLmNhcHR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgYXJ0d29yay5iZWdpblN0cm9rZShwZi54LCBwZi55LCBwcmVzc3VyZSk7XG5cbiAgICAgICAgICAgIHRoaXMuc21vb3RoTW91c2UgPSBwZjtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgQ1BGcmVlaGFuZE1vZGUucHJvdG90eXBlLm1vdXNlRHJhZyA9IGZ1bmN0aW9uKGUsIHByZXNzdXJlKSB7XG4gICAgICAgIGlmICh0aGlzLmNhcHR1cmUpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHBmID0gY29vcmRUb0RvY3VtZW50KHt4OiBtb3VzZVgsIHk6IG1vdXNlWX0pLFxuICAgICAgICAgICAgICAgIHNtb290aGluZyA9IE1hdGgubWluKDAuOTk5LCBNYXRoLnBvdyhjb250cm9sbGVyLmdldEJydXNoSW5mbygpLnNtb290aGluZywgMC4zKSk7XG5cbiAgICAgICAgICAgIHRoaXMuc21vb3RoTW91c2UueCA9ICgxLjAgLSBzbW9vdGhpbmcpICogcGYueCArIHNtb290aGluZyAqIHRoaXMuc21vb3RoTW91c2UueDtcbiAgICAgICAgICAgIHRoaXMuc21vb3RoTW91c2UueSA9ICgxLjAgLSBzbW9vdGhpbmcpICogcGYueSArIHNtb290aGluZyAqIHRoaXMuc21vb3RoTW91c2UueTtcblxuICAgICAgICAgICAgYXJ0d29yay5jb250aW51ZVN0cm9rZSh0aGlzLnNtb290aE1vdXNlLngsIHRoaXMuc21vb3RoTW91c2UueSwgcHJlc3N1cmUpO1xuXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VNb3ZlKGUpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENQRnJlZWhhbmRNb2RlLnByb3RvdHlwZS5tb3VzZVVwID0gZnVuY3Rpb24oZSwgYnV0dG9uLCBwcmVzc3VyZSkge1xuICAgICAgICBpZiAodGhpcy5jYXB0dXJlKSB7XG4gICAgICAgICAgICBpZiAoYnV0dG9uID09IEJVVFRPTl9QUklNQVJZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgYXJ0d29yay5lbmRTdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAgICAgXG4gICAgZnVuY3Rpb24gQ1BMaW5lTW9kZSgpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBkcmFnTGluZUZyb20sIGRyYWdMaW5lVG8sXG4gICAgICAgICAgICBMSU5FX1BSRVZJRVdfV0lEVEggPSAxO1xuXG4gICAgICAgIHRoaXMubW91c2VEb3duID0gZnVuY3Rpb24oZSwgYnV0dG9uLCBwcmVzc3VyZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmUgJiYgYnV0dG9uID09IEJVVFRPTl9QUklNQVJZICYmICFlLmFsdEtleSAmJiAha2V5LmlzUHJlc3NlZChcInNwYWNlXCIpICYmIHNob3VsZERyYXdUb1RoaXNMYXllcigpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBkcmFnTGluZUZyb20gPSBkcmFnTGluZVRvID0ge3g6IG1vdXNlWCArIDAuNSwgeTogbW91c2VZICsgMC41fTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZXJhc2VCcnVzaFByZXZpZXcoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMubW91c2VEcmFnID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FwdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIC8vIFRoZSBvbGQgbGluZSBwb3NpdGlvbiB0aGF0IHdlJ2xsIGludmFsaWRhdGUgZm9yIHJlZHJhd1xuICAgICAgICAgICAgICAgICAgICBpbnZhbGlkYXRlUmVjdCA9IG5ldyBDUFJlY3QoXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihkcmFnTGluZUZyb20ueCwgZHJhZ0xpbmVUby54KSAtIExJTkVfUFJFVklFV19XSURUSCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihkcmFnTGluZUZyb20ueSwgZHJhZ0xpbmVUby55KSAtIExJTkVfUFJFVklFV19XSURUSCAtIDEsXG4gICAgICAgICAgICAgICAgICAgICAgICBNYXRoLm1heChkcmFnTGluZUZyb20ueCwgZHJhZ0xpbmVUby54KSArIExJTkVfUFJFVklFV19XSURUSCArIDEgKyAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZHJhZ0xpbmVGcm9tLnksIGRyYWdMaW5lVG8ueSkgKyBMSU5FX1BSRVZJRVdfV0lEVEggKyAxICsgMVxuICAgICAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgZHJhZ0xpbmVUbyA9IHt4OiBtb3VzZVggKyAwLjUsIHk6IG1vdXNlWSArIDAuNX07IC8vIFRhcmdldCBjZW50cmUgb2YgcGl4ZWxcblxuICAgICAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFNuYXAgdG8gbmVhcmVzdCA0NSBkZWdyZWVzXG4gICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgc25hcCA9IE1hdGguUEkgLyA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5nbGUgPSBNYXRoLnJvdW5kKE1hdGguYXRhbjIoZHJhZ0xpbmVUby55IC0gZHJhZ0xpbmVGcm9tLnksIGRyYWdMaW5lVG8ueCAtIGRyYWdMaW5lRnJvbS54KSAvIHNuYXApO1xuXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoYW5nbGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcmFnTGluZVRvLnkgPSBkcmFnTGluZUZyb20ueTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdMaW5lVG8ueCA9IGRyYWdMaW5lRnJvbS54O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuZ2xlICo9IHNuYXA7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gTWF0aC5zcXJ0KChkcmFnTGluZVRvLnkgLSBkcmFnTGluZUZyb20ueSkgKiAoZHJhZ0xpbmVUby55IC0gZHJhZ0xpbmVGcm9tLnkpICsgKGRyYWdMaW5lVG8ueCAtIGRyYWdMaW5lRnJvbS54KSAqIChkcmFnTGluZVRvLnggLSBkcmFnTGluZUZyb20ueCkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0xpbmVUby54ID0gZHJhZ0xpbmVGcm9tLnggKyBsZW5ndGggKiBNYXRoLmNvcyhhbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ0xpbmVUby55ID0gZHJhZ0xpbmVGcm9tLnkgKyBsZW5ndGggKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaGUgbmV3IGxpbmUgcG9zaXRpb25cbiAgICAgICAgICAgICAgICBpbnZhbGlkYXRlUmVjdC51bmlvbihuZXcgQ1BSZWN0KFxuICAgICAgICAgICAgICAgICAgICBNYXRoLm1pbihkcmFnTGluZUZyb20ueCwgZHJhZ0xpbmVUby54KSAtIExJTkVfUFJFVklFV19XSURUSCAtIDEsXG4gICAgICAgICAgICAgICAgICAgIE1hdGgubWluKGRyYWdMaW5lRnJvbS55LCBkcmFnTGluZVRvLnkpIC0gTElORV9QUkVWSUVXX1dJRFRIIC0gMSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZHJhZ0xpbmVGcm9tLngsIGRyYWdMaW5lVG8ueCkgKyBMSU5FX1BSRVZJRVdfV0lEVEggKyAxICsgMSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZHJhZ0xpbmVGcm9tLnksIGRyYWdMaW5lVG8ueSkgKyBMSU5FX1BSRVZJRVdfV0lEVEggKyAxICsgMVxuICAgICAgICAgICAgICAgICkpO1xuXG4gICAgICAgICAgICAgICAgcmVwYWludFJlY3QoaW52YWxpZGF0ZVJlY3QpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMubW91c2VNb3ZlLmNhbGwodGhpcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZVVwID0gZnVuY3Rpb24oZSwgYnV0dG9uLCBwcmVzc3VyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FwdHVyZSAmJiBidXR0b24gPT0gQlVUVE9OX1BSSU1BUlkpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgZnJvbSA9IGNvb3JkVG9Eb2N1bWVudChkcmFnTGluZUZyb20pLFxuICAgICAgICAgICAgICAgICAgICB0byA9IGNvb3JkVG9Eb2N1bWVudChkcmFnTGluZVRvKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5kcmF3TGluZShmcm9tLCB0byk7XG5cbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgaW52YWxpZGF0ZVJlY3QgPSBuZXcgQ1BSZWN0KFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oZHJhZ0xpbmVGcm9tLngsIGRyYWdMaW5lVG8ueCkgLSBMSU5FX1BSRVZJRVdfV0lEVEggLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5taW4oZHJhZ0xpbmVGcm9tLnksIGRyYWdMaW5lVG8ueSkgLSBMSU5FX1BSRVZJRVdfV0lEVEggLSAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5tYXgoZHJhZ0xpbmVGcm9tLngsIGRyYWdMaW5lVG8ueCkgKyBMSU5FX1BSRVZJRVdfV0lEVEggKyAxICsgMSxcbiAgICAgICAgICAgICAgICAgICAgICAgIE1hdGgubWF4KGRyYWdMaW5lRnJvbS55LCBkcmFnTGluZVRvLnkpICsgTElORV9QUkVWSUVXX1dJRFRIICsgMSArIDFcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByZXBhaW50UmVjdChpbnZhbGlkYXRlUmVjdCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnBhaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5saW5lV2lkdGggPSBMSU5FX1BSRVZJRVdfV0lEVEg7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0Lm1vdmVUbyhkcmFnTGluZUZyb20ueCwgZHJhZ0xpbmVGcm9tLnkpO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQubGluZVRvKGRyYWdMaW5lVG8ueCwgZHJhZ0xpbmVUby55KTtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEcmF3IHRoZSByZWd1bGFyIGJydXNoIHByZXZpZXcgY2lyY2xlXG4gICAgICAgICAgICAgICAgQ1BEcmF3aW5nTW9kZS5wcm90b3R5cGUucGFpbnQuY2FsbCh0aGlzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBDUERyYXdpbmdNb2RlLmNhbGwodGhpcyk7XG4gICAgfVxuICAgIFxuICAgIENQTGluZU1vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUERyYXdpbmdNb2RlLnByb3RvdHlwZSk7XG4gICAgQ1BMaW5lTW9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUExpbmVNb2RlO1xuXG4gICAgQ1BMaW5lTW9kZS5wcm90b3R5cGUuZHJhd0xpbmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICBhcnR3b3JrLmJlZ2luU3Ryb2tlKGZyb20ueCwgZnJvbS55LCAxKTtcbiAgICAgICAgYXJ0d29yay5jb250aW51ZVN0cm9rZSh0by54LCB0by55LCAxKTtcbiAgICAgICAgYXJ0d29yay5lbmRTdHJva2UoKTtcbiAgICB9O1xuXG4gICAgZnVuY3Rpb24gQ1BCZXppZXJNb2RlKCkge1xuICAgICAgICBjb25zdFxuICAgICAgICAgICAgQkVaSUVSX1BPSU5UUyA9IDUwMCxcbiAgICAgICAgICAgIEJFWklFUl9QT0lOVFNfUFJFVklFVyA9IDEwMDtcblxuICAgICAgICB2YXJcbiAgICAgICAgICAgIGRyYWdCZXppZXJNb2RlID0gMCwgLy8gMCBJbml0aWFsIGRyYWcsIDEgZmlyc3QgY29udHJvbCBwb2ludCwgMiBzZWNvbmQgcG9pbnRcbiAgICAgICAgICAgIGRyYWdCZXppZXJQMCwgZHJhZ0JlemllclAxLCBkcmFnQmV6aWVyUDIsIGRyYWdCZXppZXJQMztcblxuICAgICAgICB0aGlzLm1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIGJ1dHRvbiwgcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jYXB0dXJlICYmIGJ1dHRvbiA9PSBCVVRUT05fUFJJTUFSWSAmJiAhZS5hbHRLZXkgJiYgIWtleS5pc1ByZXNzZWQoXCJzcGFjZVwiKSAmJiBzaG91bGREcmF3VG9UaGlzTGF5ZXIoKSkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBwID0gY29vcmRUb0RvY3VtZW50KHt4OiBtb3VzZVgsIHk6IG1vdXNlWX0pO1xuXG4gICAgICAgICAgICAgICAgZHJhZ0Jlemllck1vZGUgPSAwO1xuICAgICAgICAgICAgICAgIGRyYWdCZXppZXJQMCA9IGRyYWdCZXppZXJQMSA9IGRyYWdCZXppZXJQMiA9IGRyYWdCZXppZXJQMyA9IHA7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHRoaXMuZXJhc2VCcnVzaFByZXZpZXcoKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEhhbmRsZXMgdGhlIGZpcnN0IHBhcnQgb2YgdGhlIEJlemllciB3aGVyZSB0aGUgdXNlciBkcmFncyBvdXQgYSBzdHJhaWdodCBsaW5lXG4gICAgICAgIHRoaXMubW91c2VEcmFnID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FwdHVyZSAmJiBkcmFnQmV6aWVyTW9kZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBjb29yZFRvRG9jdW1lbnQoe3g6IG1vdXNlWCwgeTogbW91c2VZfSk7XG5cbiAgICAgICAgICAgICAgICBkcmFnQmV6aWVyUDIgPSBkcmFnQmV6aWVyUDMgPSBwO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5yZXBhaW50QWxsKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tb3VzZU1vdmUuY2FsbCh0aGlzLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1vdXNlVXAgPSBmdW5jdGlvbihlLCBidXR0b24sIHByZXNzdXJlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYXB0dXJlICYmIGJ1dHRvbiA9PSBCVVRUT05fUFJJTUFSWSkge1xuICAgICAgICAgICAgICAgIGlmIChkcmFnQmV6aWVyTW9kZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdCZXppZXJNb2RlID0gMTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGRyYWdCZXppZXJNb2RlID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgZHJhZ0Jlemllck1vZGUgPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZHJhZ0Jlemllck1vZGUgPT0gMikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgICAgICBwMCA9IGRyYWdCZXppZXJQMCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gZHJhZ0JlemllclAxLFxuICAgICAgICAgICAgICAgICAgICAgICAgcDIgPSBkcmFnQmV6aWVyUDIsXG4gICAgICAgICAgICAgICAgICAgICAgICBwMyA9IGRyYWdCZXppZXJQMyxcblxuICAgICAgICAgICAgICAgICAgICAgICAgYmV6aWVyID0gbmV3IENQQmV6aWVyKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBiZXppZXIueDAgPSBwMC54O1xuICAgICAgICAgICAgICAgICAgICBiZXppZXIueTAgPSBwMC55O1xuICAgICAgICAgICAgICAgICAgICBiZXppZXIueDEgPSBwMS54O1xuICAgICAgICAgICAgICAgICAgICBiZXppZXIueTEgPSBwMS55O1xuICAgICAgICAgICAgICAgICAgICBiZXppZXIueDIgPSBwMi54O1xuICAgICAgICAgICAgICAgICAgICBiZXppZXIueTIgPSBwMi55O1xuICAgICAgICAgICAgICAgICAgICBiZXppZXIueDMgPSBwMy54O1xuICAgICAgICAgICAgICAgICAgICBiZXppZXIueTMgPSBwMy55O1xuXG4gICAgICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgICAgIHggPSBuZXcgQXJyYXkoQkVaSUVSX1BPSU5UUyksXG4gICAgICAgICAgICAgICAgICAgICAgICB5ID0gbmV3IEFycmF5KEJFWklFUl9QT0lOVFMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGJlemllci5jb21wdXRlKHgsIHksIEJFWklFUl9QT0lOVFMpO1xuXG4gICAgICAgICAgICAgICAgICAgIGFydHdvcmsuYmVnaW5TdHJva2UoeFswXSwgeVswXSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgQkVaSUVSX1BPSU5UUzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcnR3b3JrLmNvbnRpbnVlU3Ryb2tlKHhbaV0sIHlbaV0sIDEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGFydHdvcmsuZW5kU3Ryb2tlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucmVwYWludEFsbCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMubW91c2VNb3ZlID0gZnVuY3Rpb24oZSwgcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgcCA9IGNvb3JkVG9Eb2N1bWVudCh7eDogbW91c2VYLCB5OiBtb3VzZVl9KTtcblxuICAgICAgICAgICAgICAgIGlmIChkcmFnQmV6aWVyTW9kZSA9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdCZXppZXJQMSA9IHA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChkcmFnQmV6aWVyTW9kZSA9PSAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdCZXppZXJQMiA9IHA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoYXQucmVwYWludEFsbCgpOyAvLyBGSVhNRTogcmVwYWludCBvbmx5IHRoZSBiZXppZXIgcmVnaW9uXG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRHJhdyB0aGUgbm9ybWFsIGJydXNoIHByZXZpZXcgd2hpbGUgbm90IGluIHRoZSBtaWRkbGUgb2YgYSBiZXppZXIgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgQ1BEcmF3aW5nTW9kZS5wcm90b3R5cGUubW91c2VNb3ZlLmNhbGwodGhpcywgZSwgcHJlc3N1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMucGFpbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgYmV6aWVyID0gbmV3IENQQmV6aWVyKCksXG5cbiAgICAgICAgICAgICAgICAgICAgcDAgPSBjb29yZFRvRGlzcGxheShkcmFnQmV6aWVyUDApLFxuICAgICAgICAgICAgICAgICAgICBwMSA9IGNvb3JkVG9EaXNwbGF5KGRyYWdCZXppZXJQMSksXG4gICAgICAgICAgICAgICAgICAgIHAyID0gY29vcmRUb0Rpc3BsYXkoZHJhZ0JlemllclAyKSxcbiAgICAgICAgICAgICAgICAgICAgcDMgPSBjb29yZFRvRGlzcGxheShkcmFnQmV6aWVyUDMpO1xuXG4gICAgICAgICAgICAgICAgYmV6aWVyLngwID0gcDAueDtcbiAgICAgICAgICAgICAgICBiZXppZXIueTAgPSBwMC55O1xuICAgICAgICAgICAgICAgIGJlemllci54MSA9IHAxLng7XG4gICAgICAgICAgICAgICAgYmV6aWVyLnkxID0gcDEueTtcbiAgICAgICAgICAgICAgICBiZXppZXIueDIgPSBwMi54O1xuICAgICAgICAgICAgICAgIGJlemllci55MiA9IHAyLnk7XG4gICAgICAgICAgICAgICAgYmV6aWVyLngzID0gcDMueDtcbiAgICAgICAgICAgICAgICBiZXppZXIueTMgPSBwMy55O1xuXG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIHggPSBuZXcgQXJyYXkoQkVaSUVSX1BPSU5UU19QUkVWSUVXKSxcbiAgICAgICAgICAgICAgICAgICAgeSA9IG5ldyBBcnJheShCRVpJRVJfUE9JTlRTX1BSRVZJRVcpO1xuICAgICAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBiZXppZXIuY29tcHV0ZSh4LCB5LCBCRVpJRVJfUE9JTlRTX1BSRVZJRVcpO1xuXG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0Lm1vdmVUbyh4WzBdLCB5WzBdKTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IEJFWklFUl9QT0lOVFNfUFJFVklFVzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQubGluZVRvKHhbaV0sIHlbaV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0Lm1vdmVUbyh+fnAwLngsIH5+cDAueSk7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5saW5lVG8ofn5wMS54LCB+fnAxLnkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQubW92ZVRvKH5+cDIueCwgfn5wMi55KTtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0LmxpbmVUbyh+fnAzLngsIH5+cDMueSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUGFpbnQgdGhlIHJlZ3VsYXIgYnJ1c2ggcHJldmlld1xuICAgICAgICAgICAgICAgIENQRHJhd2luZ01vZGUucHJvdG90eXBlLnBhaW50LmNhbGwodGhpcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgQ1BEcmF3aW5nTW9kZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBcbiAgICBDUEJlemllck1vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUERyYXdpbmdNb2RlLnByb3RvdHlwZSk7XG4gICAgQ1BCZXppZXJNb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQQmV6aWVyTW9kZTtcblxuICAgIGZ1bmN0aW9uIENQQ29sb3JQaWNrZXJNb2RlKCkge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBtb3VzZUJ1dHRvbjtcblxuICAgICAgICB0aGlzLm1vdXNlRG93biA9IGZ1bmN0aW9uKGUsIGJ1dHRvbiwgcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWtleS5pc1ByZXNzZWQoXCJzcGFjZVwiKSAmJiAoYnV0dG9uID09IEJVVFRPTl9QUklNQVJZICYmICghdGhpcy50cmFuc2llbnQgfHwgZS5hbHRLZXkpIHx8IGJ1dHRvbiA9PSBCVVRUT05fU0VDT05EQVJZKSkge1xuICAgICAgICAgICAgICAgIG1vdXNlQnV0dG9uID0gYnV0dG9uO1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBzZXRDdXJzb3IoQ1VSU09SX0NST1NTSEFJUik7XG5cbiAgICAgICAgICAgICAgICB0aGlzLm1vdXNlRHJhZyhlKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIG5vdCBzYW1wbGluZyBhbmQgd2UgZ2V0IGEgYnV0dG9uIG5vdCBpbnRlbmRlZCBmb3IgdXMsIHdlIHByb2JhYmx5IHNob3VsZG4ndCBiZSBvbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICBtb2RlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZURyYWcgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIHBmID0gY29vcmRUb0RvY3VtZW50KHt4OiBtb3VzZVgsIHk6IG1vdXNlWX0pO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFydHdvcmsuaXNQb2ludFdpdGhpbihwZi54LCBwZi55KSkge1xuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyLnNldEN1ckNvbG9yUmdiKGFydHdvcmsuY29sb3JQaWNrZXIocGYueCwgcGYueSkpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMubW91c2VVcCA9IGZ1bmN0aW9uKGUsIGJ1dHRvbiwgcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmUgJiYgYnV0dG9uID09IG1vdXNlQnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgbW91c2VCdXR0b24gPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBzZXRDdXJzb3IoQ1VSU09SX0RFRkFVTFQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmVudGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBDUE1vZGUucHJvdG90eXBlLmVudGVyLmNhbGwodGhpcyk7XG4gICAgICAgICAgICBtb3VzZUJ1dHRvbiA9IC0xO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBDUENvbG9yUGlja2VyTW9kZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQTW9kZS5wcm90b3R5cGUpO1xuICAgIENQQ29sb3JQaWNrZXJNb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQQ29sb3JQaWNrZXJNb2RlO1xuXG4gICAgZnVuY3Rpb24gQ1BQYW5Nb2RlKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHBhbm5pbmdYLCBwYW5uaW5nWSxcbiAgICAgICAgICAgIHBhbm5pbmdPZmZzZXQsXG4gICAgICAgICAgICBwYW5uaW5nQnV0dG9uO1xuXG4gICAgICAgIHRoaXMua2V5RG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMzIgLyogU3BhY2UgKi8pIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgYWxyZWFkeSBwYW5uaW5nLCB0aGVuIGFkdmVydGlzZSB0aGF0IGEgbGVmdC1jbGljayB3b3VsZCBwYW5cbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2FwdHVyZSkge1xuICAgICAgICAgICAgICAgICAgICBzZXRDdXJzb3IoQ1VSU09SX1BBTk5BQkxFKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmtleVVwID0gZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpZW50ICYmIHBhbm5pbmdCdXR0b24gIT0gQlVUVE9OX1dIRUVMICYmIGUua2V5Q29kZSA9PSAzMiAvKiBTcGFjZSAqLykge1xuICAgICAgICAgICAgICAgIHNldEN1cnNvcihDVVJTT1JfREVGQVVMVCk7XG5cbiAgICAgICAgICAgICAgICBtb2RlU3RhY2sucG9wKCk7IC8vIHlpZWxkIGNvbnRyb2wgdG8gdGhlIGRlZmF1bHQgbW9kZVxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmdW5jdGlvbihlLCBidXR0b24sIHByZXNzdXJlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGJ1dHRvbiA9PSBCVVRUT05fV0hFRUwgfHwga2V5LmlzUHJlc3NlZChcInNwYWNlXCIpICYmIGJ1dHRvbiA9PSBCVVRUT05fUFJJTUFSWSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGFubmluZ0J1dHRvbiA9IGJ1dHRvbjtcbiAgICAgICAgICAgICAgICBwYW5uaW5nWCA9IGUucGFnZVg7XG4gICAgICAgICAgICAgICAgcGFubmluZ1kgPSBlLnBhZ2VZO1xuICAgICAgICAgICAgICAgIHBhbm5pbmdPZmZzZXQgPSB0aGF0LmdldE9mZnNldCgpO1xuICAgICAgICAgICAgICAgIHNldEN1cnNvcihDVVJTT1JfUEFOTklORyk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy50cmFuc2llbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSdyZSBub3QgcGFubmluZyBhbmQgd2UgZ2V0IGEgYnV0dG9uIG5vdCBpbnRlbmRlZCBmb3IgdXMsIHdlIHByb2JhYmx5IHNob3VsZG4ndCBiZSBvbiB0aGUgc3RhY2tcbiAgICAgICAgICAgICAgICBtb2RlU3RhY2sucG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZURyYWcgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zZXRPZmZzZXQocGFubmluZ09mZnNldC54ICsgZS5wYWdlWCAtIHBhbm5pbmdYLCBwYW5uaW5nT2Zmc2V0LnkgKyBlLnBhZ2VZIC0gcGFubmluZ1kpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZVVwID0gZnVuY3Rpb24oZSwgYnV0dG9uLCBwcmVzc3VyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FwdHVyZSAmJiBidXR0b24gPT0gcGFubmluZ0J1dHRvbikge1xuICAgICAgICAgICAgICAgIHBhbm5pbmdCdXR0b24gPSAtMTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUgPSBmYWxzZTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zaWVudCAmJiAha2V5LmlzUHJlc3NlZChcInNwYWNlXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnNvcihDVVJTT1JfREVGQVVMVCk7XG5cbiAgICAgICAgICAgICAgICAgICAgbW9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMuZW50ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNldEN1cnNvcihDVVJTT1JfUEFOTkFCTEUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBcbiAgICBDUFBhbk1vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUE1vZGUucHJvdG90eXBlKTtcbiAgICBDUFBhbk1vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BGbG9vZEZpbGxNb2RlO1xuXG4gICAgZnVuY3Rpb24gQ1BGbG9vZEZpbGxNb2RlKCkge1xuICAgIH1cbiAgICBcbiAgICBDUEZsb29kRmlsbE1vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUE1vZGUucHJvdG90eXBlKTtcbiAgICBDUEZsb29kRmlsbE1vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BGbG9vZEZpbGxNb2RlO1xuXG4gICAgQ1BGbG9vZEZpbGxNb2RlLnByb3RvdHlwZS5tb3VzZURvd24gPSBmdW5jdGlvbihlLCBidXR0b24sIHByZXNzdXJlKSB7XG4gICAgICAgIGlmIChidXR0b24gPT0gQlVUVE9OX1BSSU1BUlkgJiYgIWUuYWx0S2V5ICYmICFrZXkuaXNQcmVzc2VkKFwic3BhY2VcIikgJiYgc2hvdWxkRHJhd1RvVGhpc0xheWVyKCkpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHBmID0gY29vcmRUb0RvY3VtZW50KHt4OiBtb3VzZVgsIHk6IG1vdXNlWX0pO1xuXG4gICAgICAgICAgICBpZiAoYXJ0d29yay5pc1BvaW50V2l0aGluKHBmLngsIHBmLnkpKSB7XG4gICAgICAgICAgICAgICAgYXJ0d29yay5mbG9vZEZpbGwocGYueCwgcGYueSk7XG4gICAgICAgICAgICAgICAgdGhhdC5yZXBhaW50QWxsKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIENQUmVjdFNlbGVjdGlvbk1vZGUoKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgZmlyc3RDbGljayxcbiAgICAgICAgICAgIGN1clJlY3QgPSBuZXcgQ1BSZWN0KDAsIDAsIDAsIDApLFxuICAgICAgICAgICAgc2VsZWN0aW5nQnV0dG9uID0gLTE7XG5cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmdW5jdGlvbiAoZSwgYnV0dG9uLCBwcmVzc3VyZSkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmUgJiYgYnV0dG9uID09IEJVVFRPTl9QUklNQVJZICYmICFlLmFsdEtleSAmJiAha2V5LmlzUHJlc3NlZChcInNwYWNlXCIpKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIHAgPSBjb29yZFRvRG9jdW1lbnRJbnQoe3g6IG1vdXNlWCwgeTogbW91c2VZfSk7XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RpbmdCdXR0b24gPSBidXR0b247XG5cbiAgICAgICAgICAgICAgICBjdXJSZWN0Lm1ha2VFbXB0eSgpO1xuICAgICAgICAgICAgICAgIGZpcnN0Q2xpY2sgPSBwO1xuXG4gICAgICAgICAgICAgICAgdGhhdC5yZXBhaW50QWxsKCk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZURyYWcgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FwdHVyZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHAgPSBjb29yZFRvRG9jdW1lbnRJbnQoe3g6IG1vdXNlWCwgeTogbW91c2VZfSksXG4gICAgICAgICAgICAgICAgc3F1YXJlID0gZS5zaGlmdEtleSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzcXVhcmVEaXN0ID0gfn5NYXRoLm1heChNYXRoLmFicyhwLnggLSBmaXJzdENsaWNrLngpLCBNYXRoLmFicyhwLnkgLSBmaXJzdENsaWNrLnkpKTtcblxuICAgICAgICAgICAgaWYgKHAueCA+PSBmaXJzdENsaWNrLngpIHtcbiAgICAgICAgICAgICAgICBjdXJSZWN0LmxlZnQgPSBmaXJzdENsaWNrLng7XG4gICAgICAgICAgICAgICAgY3VyUmVjdC5yaWdodCA9IChzcXVhcmUgPyBmaXJzdENsaWNrLnggKyBzcXVhcmVEaXN0IDogcC54KSArIDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGN1clJlY3QubGVmdCA9IHNxdWFyZSA/IGZpcnN0Q2xpY2sueCAtIHNxdWFyZURpc3QgOiBwLng7XG4gICAgICAgICAgICAgICAgY3VyUmVjdC5yaWdodCA9IGZpcnN0Q2xpY2sueCArIDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwLnkgPj0gZmlyc3RDbGljay55KSB7XG4gICAgICAgICAgICAgICAgY3VyUmVjdC50b3AgPSBmaXJzdENsaWNrLnk7XG4gICAgICAgICAgICAgICAgY3VyUmVjdC5ib3R0b20gPSAoc3F1YXJlID8gZmlyc3RDbGljay55ICsgc3F1YXJlRGlzdCA6IHAueSkgKyAxO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjdXJSZWN0LnRvcCA9IHNxdWFyZSA/IGZpcnN0Q2xpY2sueSAtIHNxdWFyZURpc3QgOiBwLnk7XG4gICAgICAgICAgICAgICAgY3VyUmVjdC5ib3R0b20gPSBmaXJzdENsaWNrLnkgKyAxO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0LnJlcGFpbnRBbGwoKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZVVwID0gZnVuY3Rpb24gKGUsIGJ1dHRvbiwgcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmUgJiYgYnV0dG9uID09IHNlbGVjdGluZ0J1dHRvbikge1xuICAgICAgICAgICAgICAgIGFydHdvcmsucmVjdGFuZ2xlU2VsZWN0aW9uKGN1clJlY3QpO1xuICAgICAgICAgICAgICAgIGN1clJlY3QubWFrZUVtcHR5KCk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnJlcGFpbnRBbGwoKTtcblxuICAgICAgICAgICAgICAgIHRoaXMuY2FwdHVyZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHNlbGVjdGluZ0J1dHRvbiA9IC0xO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wYWludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCFjdXJSZWN0LmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQubGluZVdpZHRoID0gMTtcbiAgICAgICAgICAgICAgICBwbG90U2VsZWN0aW9uUmVjdChjYW52YXNDb250ZXh0LCBjdXJSZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBDUFJlY3RTZWxlY3Rpb25Nb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BNb2RlLnByb3RvdHlwZSk7XG4gICAgQ1BSZWN0U2VsZWN0aW9uTW9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFJlY3RTZWxlY3Rpb25Nb2RlO1xuXG4gICAgZnVuY3Rpb24gQ1BNb3ZlVG9vbE1vZGUoKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIGxhc3RQb2ludCxcbiAgICAgICAgICAgIGNvcHlNb2RlLFxuICAgICAgICAgICAgZmlyc3RNb3ZlID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmdW5jdGlvbihlLCBidXR0b24sIHByZXNzdXJlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FwdHVyZSAmJiBidXR0b24gPT0gQlVUVE9OX1BSSU1BUlkgJiYgIWtleS5pc1ByZXNzZWQoXCJzcGFjZVwiKSAmJiBzaG91bGREcmF3VG9UaGlzTGF5ZXIoKSkge1xuICAgICAgICAgICAgICAgIGxhc3RQb2ludCA9IGNvb3JkVG9Eb2N1bWVudCh7eDogbW91c2VYLCB5OiBtb3VzZVl9KTtcblxuICAgICAgICAgICAgICAgIGNvcHlNb2RlID0gZS5hbHRLZXk7XG4gICAgICAgICAgICAgICAgZmlyc3RNb3ZlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZURyYWcgPSB0aHJvdHRsZSgyNSwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FwdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBwID0gY29vcmRUb0RvY3VtZW50KHt4OiBtb3VzZVgsIHk6IG1vdXNlWX0pLFxuXG4gICAgICAgICAgICAgICAgICAgIG1vdmVGbG9hdCA9IHt4OiBwLnggLSBsYXN0UG9pbnQueCwgeTogcC55IC0gbGFzdFBvaW50Lnl9LFxuICAgICAgICAgICAgICAgICAgICBtb3ZlSW50ID0ge3g6IH5+bW92ZUZsb2F0LngsIHk6IH5+bW92ZUZsb2F0Lnl9OyAvLyBSb3VuZCB0b3dhcmRzIHplcm9cblxuICAgICAgICAgICAgICAgIGFydHdvcmsubW92ZShtb3ZlSW50LngsIG1vdmVJbnQueSwgY29weU1vZGUgJiYgZmlyc3RNb3ZlKTtcblxuICAgICAgICAgICAgICAgIGZpcnN0TW92ZSA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBOdWRnZSB0aGUgbGFzdCBwb2ludCBieSB0aGUgcmVtYWluZGVyIHdlIHdlcmVuJ3QgYWJsZSB0byBtb3ZlIHRoaXMgaXRlcmF0aW9uIChkdWUgdG8gbW92ZSgpIG9ubHlcbiAgICAgICAgICAgICAgICAgKiBhY2NlcHRpbmcgaW50ZWdlciBvZmZzZXRzKS4gVGhpcydsbCBjYXJyeSB0aGF0IGZyYWN0aW9uYWwgcGFydCBvZiB0aGUgbW92ZSBvdmVyIGZvciBuZXh0IGl0ZXJhdGlvbi5cbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBsYXN0UG9pbnQueCA9IHAueCAtIChtb3ZlRmxvYXQueCAtIG1vdmVJbnQueCk7XG4gICAgICAgICAgICAgICAgbGFzdFBvaW50LnkgPSBwLnkgLSAobW92ZUZsb2F0LnkgLSBtb3ZlSW50LnkpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMubW91c2VVcCA9IGZ1bmN0aW9uKGUsIGJ1dHRvbiwgcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmUgJiYgYnV0dG9uID09IEJVVFRPTl9QUklNQVJZKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNpZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgQ1BNb3ZlVG9vbE1vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUE1vZGUucHJvdG90eXBlKTtcbiAgICBDUE1vdmVUb29sTW9kZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUE1vdmVUb29sTW9kZTtcblxuICAgIENQTW92ZVRvb2xNb2RlLnByb3RvdHlwZS5tb3VzZU1vdmUgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICgha2V5LmlzUHJlc3NlZChcInNwYWNlXCIpICYmICFlLmFsdEtleSkge1xuICAgICAgICAgICAgc2V0Q3Vyc29yKENVUlNPUl9NT1ZFKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIENQTW92ZVRvb2xNb2RlLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBzZXRDdXJzb3IoQ1VSU09SX01PVkUpO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBDUFRyYW5zZm9ybU1vZGUoKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBIQU5ETEVfUkFESVVTID0gMyxcblxuICAgICAgICAgICAgRFJBR19OT05FID0gLTEsXG4gICAgICAgICAgICBEUkFHX1JPVEFURSA9IC0yLFxuICAgICAgICAgICAgRFJBR19NT1ZFID0gLTMsXG4gICAgICAgICAgICBEUkFHX05XX0NPUk5FUiA9IDAsXG4gICAgICAgICAgICBEUkFHX05fRURHRSA9IDEsXG4gICAgICAgICAgICBEUkFHX05FX0NPUk5FUiA9IDIsXG4gICAgICAgICAgICBEUkFHX0VfRURHRSA9IDMsXG4gICAgICAgICAgICBEUkFHX1NFX0NPUk5FUiA9IDQsXG4gICAgICAgICAgICBEUkFHX1NfRURHRSA9IDUsXG4gICAgICAgICAgICBEUkFHX1NXX0NPUk5FUiA9IDYsXG4gICAgICAgICAgICBEUkFHX1dfRURHRSA9IDc7XG5cbiAgICAgICAgdmFyXG4gICAgICAgICAgICAvKiogQHR5cGUge0NQVHJhbnNmb3JtfSBUaGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiAqL1xuICAgICAgICAgICAgYWZmaW5lLFxuICAgICAgICAgICAgLyoqIEB0eXBlIHtDUFJlY3R9IFRoZSBpbml0aWFsIGRvY3VtZW50IHJlY3RhbmdsZSB0byB0cmFuc2Zvcm0gKi9cbiAgICAgICAgICAgIHNyY1JlY3QsXG4gICAgICAgICAgICAvKiogQHR5cGUge0NQUG9seWdvbn0gVGhlIGluaXRpYWwgdHJhbnNmb3JtIHJlY3QgKi9cbiAgICAgICAgICAgIG9yaWdDb3JuZXJQb2ludHMsXG4gICAgICAgICAgICAvKiogQHR5cGUge0NQUG9seWdvbn0gVGhlIGN1cnJlbnQgY29ybmVycyBvZiB0aGUgdHJhbnNmb3JtIHJlY3QgaW4gZG9jdW1lbnQgc3BhY2UgKi9cbiAgICAgICAgICAgIGNvcm5lclBvaW50cyxcblxuICAgICAgICAgICAgZHJhZ2dpbmdNb2RlID0gRFJBR19OT05FLFxuXG4gICAgICAgICAgICBsYXN0RHJhZ1BvaW50RGlzcGxheSxcbiAgICAgICAgICAgIGxhc3REcmFnUG9pbnREb2MsXG5cbiAgICAgICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgaG93IG1hbnkgZGVncmVlcyB3ZSd2ZSByb3RhdGVkIHNvIGZhciBkdXJpbmcgdGhpcyB0cmFuc2Zvcm1hdGlvblxuICAgICAgICAgICAgcm90YXRpb25BY2N1bXVsYXRvcjtcblxuXHRcdC8qKlxuICAgICAgICAgKiBHZXQgdGhlIHBvbHlnb24gdGhhdCByZXByZXNlbnRzIHRoZSBjdXJyZW50IHRyYW5zZm9ybSByZXN1bHQgYXJlYSBpbiBkaXNwbGF5IGNvb3JkaW5hdGVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcmV0dXJucyB7Q1BQb2x5Z29ufVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gY29ybmVyc1RvRGlzcGxheVBvbHlnb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY29ybmVyUG9pbnRzLmdldFRyYW5zZm9ybWVkKHRyYW5zZm9ybSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBhdmVyYWdlUG9pbnRzKHAxLCBwMikge1xuICAgICAgICAgICAgcmV0dXJuIHt4OiAocDEueCArIHAyLngpIC8gMiwgeTogKHAxLnkgKyBwMi55KSAvIDJ9O1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcm91bmRQb2ludChwKSB7XG4gICAgICAgICAgICByZXR1cm4ge3ggOiBNYXRoLnJvdW5kKHAueCksIHk6IE1hdGgucm91bmQocC55KX07XG4gICAgICAgIH1cblxuXHRcdC8qKlxuICAgICAgICAgKiBEZWNpZGUgd2hpY2ggZHJhZyBhY3Rpb24gc2hvdWxkIGJlIHRha2VuIGlmIG91ciBtb3VzZSB3YXMgcHJlc3NlZCBpbiB0aGUgZ2l2ZW4gcG9zaXRpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7Q1BQb2x5Z29ufSBjb3JuZXJzIC0gVGhlIGNvcm5lcnMgb2YgdGhlIGN1cnJlbnQgdHJhbnNmb3JtIGFyZWFcbiAgICAgICAgICogQHBhcmFtIG1vdXNlIC0gVGhlIG1vdXNlIHBvaW50XG4gICAgICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IEEgRFJBR18qIGNvbnN0YW50XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBjbGFzc2lmeURyYWdBY3Rpb24oY29ybmVycywgbW91c2UpIHtcbiAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgSEFORExFX0NBUFRVUkVfUkFESVVTID0gNyxcbiAgICAgICAgICAgICAgICBIQU5ETEVfQ0FQVFVSRV9SQURJVVNfU1FSID0gSEFORExFX0NBUFRVUkVfUkFESVVTICogSEFORExFX0NBUFRVUkVfUkFESVVTLFxuICAgICAgICAgICAgICAgIEVER0VfQ0FQVFVSRV9SQURJVVMgPSBIQU5ETEVfQ0FQVFVSRV9SQURJVVMsXG4gICAgICAgICAgICAgICAgRURHRV9DQVBUVVJFX1JBRElVU19TUVIgPSBFREdFX0NBUFRVUkVfUkFESVVTICogRURHRV9DQVBUVVJFX1JBRElVUztcblxuICAgICAgICAgICAgLy8gQXJlIHdlIGRyYWdnaW5nIGEgY29ybmVyP1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3JuZXJzLnBvaW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICgobW91c2UueCAtIGNvcm5lcnMucG9pbnRzW2ldLngpICogKG1vdXNlLnggLSBjb3JuZXJzLnBvaW50c1tpXS54KSArIChtb3VzZS55IC0gY29ybmVycy5wb2ludHNbaV0ueSkgKiAobW91c2UueSAtIGNvcm5lcnMucG9pbnRzW2ldLnkpIDw9IEhBTkRMRV9DQVBUVVJFX1JBRElVU19TUVIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKiAyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gQXJlIHdlIGRyYWdnaW5nIGFuIGVkZ2U/XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvcm5lcnMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGVkZ2VQMSA9IGNvcm5lcnMucG9pbnRzW2ldLFxuICAgICAgICAgICAgICAgICAgICBlZGdlUDIgPSBjb3JuZXJzLnBvaW50c1soaSArIDEpICUgY29ybmVycy5wb2ludHMubGVuZ3RoXSxcblxuICAgICAgICAgICAgICAgICAgICB2RWRnZSA9IG5ldyBDUFZlY3RvcihlZGdlUDIueCAtIGVkZ2VQMS54LCBlZGdlUDIueSAtIGVkZ2VQMS55KSxcbiAgICAgICAgICAgICAgICAgICAgdk1vdXNlID0gbmV3IENQVmVjdG9yKG1vdXNlLnggLSBlZGdlUDEueCwgbW91c2UueSAtIGVkZ2VQMS55KSxcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHZFZGdlTGVuID0gdkVkZ2UuZ2V0TGVuZ3RoKCksXG5cbiAgICAgICAgICAgICAgICAgICAgdkVkZ2VTY2FsZWQgPSB2RWRnZS5nZXRTY2FsZWQoMSAvIHZFZGdlTGVuKSxcbiAgICAgICAgICAgICAgICAgICAgdk1vdXNlU2NhbGVkID0gdk1vdXNlLmdldFNjYWxlZCgxIC8gdkVkZ2VMZW4pLFxuXG4gICAgICAgICAgICAgICAgICAgIG1vdXNlUHJvcE9uTGluZSA9IHZFZGdlU2NhbGVkLmdldERvdFByb2R1Y3Qodk1vdXNlU2NhbGVkKTtcblxuICAgICAgICAgICAgICAgIC8vIElmIHdlJ3JlIHdpdGhpbiB0aGUgZW5kcyBvZiB0aGUgbGluZSAocGVycGVuZGljdWxhcmx5IHNwZWFraW5nKVxuICAgICAgICAgICAgICAgIGlmIChtb3VzZVByb3BPbkxpbmUgPj0gMC4wICYmIG1vdXNlUHJvcE9uTGluZSA8PSAxLjApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBnaXZlcyB1cyB0aGUgcG9pbnQgb24gdGhlIGxpbmUgY2xvc2VzdCB0byB0aGUgbW91c2VcbiAgICAgICAgICAgICAgICAgICAgdkVkZ2Uuc2NhbGUobW91c2VQcm9wT25MaW5lKTtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGlmICgodkVkZ2UueCAtIHZNb3VzZS54KSAqICh2RWRnZS54IC0gdk1vdXNlLngpICsgKHZFZGdlLnkgLSB2TW91c2UueSkgKiAodkVkZ2UueSAtIHZNb3VzZS55KSA8PSBFREdFX0NBUFRVUkVfUkFESVVTX1NRUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGkgKiAyICsgMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNvcm5lcnMuY29udGFpbnNQb2ludChtb3VzZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gRFJBR19NT1ZFO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gRFJBR19ST1RBVEU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBzZXRDdXJzb3JGb3JIYW5kbGVzKCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgY29ybmVycyA9IGNvcm5lcnNUb0Rpc3BsYXlQb2x5Z29uKCksXG4gICAgICAgICAgICAgICAgbW91c2UgPSB7eDogbW91c2VYLCB5OiBtb3VzZVl9LFxuICAgICAgICAgICAgICAgIGRyYWdBY3Rpb24gPSBjbGFzc2lmeURyYWdBY3Rpb24oY29ybmVycywgbW91c2UpO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKGRyYWdBY3Rpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIERSQUdfTldfQ09STkVSOlxuICAgICAgICAgICAgICAgIGNhc2UgRFJBR19ORV9DT1JORVI6XG4gICAgICAgICAgICAgICAgY2FzZSBEUkFHX1NFX0NPUk5FUjpcbiAgICAgICAgICAgICAgICBjYXNlIERSQUdfU1dfQ09STkVSOlxuICAgICAgICAgICAgICAgICAgICAvLyBDaG9vc2UgYSBjdXJzb3IgZm9yIGEgNDUtZGVncmVlIHJlc2l6ZSBmcm9tIHRoaXMgY29ybmVyXG4gICAgICAgICAgICAgICAgICAgIGxldFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVySW5kZXggPSB+fihkcmFnQWN0aW9uIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb3JuZXJCZWZvcmUgPSBjb3JuZXJzLnBvaW50c1soY29ybmVySW5kZXggKyAzKSAlIDRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyID0gY29ybmVycy5wb2ludHNbY29ybmVySW5kZXhdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyQWZ0ZXIgPSBjb3JuZXJzLnBvaW50c1soY29ybmVySW5kZXggKyAxKSAlIDRdLFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIEdldCBhIHZlY3RvciB3aGljaCBwb2ludHMgNDUgZGVncmVlcyB0b3dhcmQgdGhlIGNlbnRlciBvZiB0aGUgYm94LCB0aGlzJ2xsIGRvIGZvciBjdXJzb3IgZGlyZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICB2NDUgPSBDUFZlY3Rvci5zdWJ0cmFjdFBvaW50cyhjb3JuZXJCZWZvcmUsIGNvcm5lcikubm9ybWFsaXplKCkuYWRkKENQVmVjdG9yLnN1YnRyYWN0UG9pbnRzKGNvcm5lckFmdGVyLCBjb3JuZXIpLm5vcm1hbGl6ZSgpKTtcblxuICAgICAgICAgICAgICAgICAgICBzZXRSZXNpemVDdXJzb3JGb3JWZWN0b3IodjQ1KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEUkFHX05fRURHRTpcbiAgICAgICAgICAgICAgICBjYXNlIERSQUdfRV9FREdFOlxuICAgICAgICAgICAgICAgIGNhc2UgRFJBR19TX0VER0U6XG4gICAgICAgICAgICAgICAgY2FzZSBEUkFHX1dfRURHRTpcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzaXppbmcgZnJvbSBoZXJlIHdpbGwgbW92ZSBlZGdlIHBlcnBlbmRpY3VsYXJseVxuICAgICAgICAgICAgICAgICAgICBsZXRcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvcm5lcjEgPSBjb3JuZXJzLnBvaW50c1t+fihkcmFnQWN0aW9uIC8gMildLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29ybmVyMiA9IGNvcm5lcnMucG9pbnRzWyh+fihkcmFnQWN0aW9uIC8gMikgKyAxKSAlIDRdLFxuICAgICAgICAgICAgICAgICAgICAgICAgdlBlcnAgPSBDUFZlY3Rvci5zdWJ0cmFjdFBvaW50cyhjb3JuZXIyLCBjb3JuZXIxKS5nZXRQZXJwZW5kaWN1bGFyKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgc2V0UmVzaXplQ3Vyc29yRm9yVmVjdG9yKHZQZXJwKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBEUkFHX01PVkU6XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnNvcihDVVJTT1JfTU9WRSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgRFJBR19ST1RBVEU6XG4gICAgICAgICAgICAgICAgICAgIHNldEN1cnNvcihDVVJTT1JfREVGQVVMVCk7IC8vIFRPRE8gYWRkIGEgY3VzdG9tIHJvdGF0aW9uIGN1cnNvclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBzZXRDdXJzb3IoQ1VSU09SX0RFRkFVTFQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmdW5jdGlvbihlLCBidXR0b24sIHByZXNzdXJlKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2FwdHVyZSAmJiBidXR0b24gPT0gQlVUVE9OX1BSSU1BUlkgJiYgIWUuYWx0S2V5ICYmICFrZXkuaXNQcmVzc2VkKFwic3BhY2VcIikpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgY29ybmVycyA9IGNvcm5lcnNUb0Rpc3BsYXlQb2x5Z29uKCk7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2luZ01vZGUgPSBjbGFzc2lmeURyYWdBY3Rpb24oY29ybmVycywge3g6IG1vdXNlWCwgeTogbW91c2VZfSk7XG5cbiAgICAgICAgICAgICAgICBsYXN0RHJhZ1BvaW50RGlzcGxheSA9IHt4OiBtb3VzZVgsIHk6IG1vdXNlWX07XG4gICAgICAgICAgICAgICAgbGFzdERyYWdQb2ludERvYyA9IGNvb3JkVG9Eb2N1bWVudChsYXN0RHJhZ1BvaW50RGlzcGxheSk7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUgPSB0cnVlO1xuXG4gICAgICAgICAgICAgICAgc2V0Q3Vyc29yRm9ySGFuZGxlcygpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5tb3VzZURyYWcgPSB0aHJvdHRsZSg0MCwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBNSU5fU0NBTEUgPSAwLjAwMTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuY2FwdHVyZSkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBkcmFnUG9pbnREaXNwbGF5ID0ge3g6IG1vdXNlWCwgeTogbW91c2VZfTtcblxuICAgICAgICAgICAgICAgIHN3aXRjaCAoZHJhZ2dpbmdNb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRFJBR19NT1ZFOlxuICAgICAgICAgICAgICAgICAgICAgICAgbGV0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhZ1BvaW50RG9jID0gcm91bmRQb2ludChjb29yZFRvRG9jdW1lbnQoZHJhZ1BvaW50RGlzcGxheSkpLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb24gPSBDUFZlY3Rvci5zdWJ0cmFjdFBvaW50cyhkcmFnUG9pbnREb2MsIGxhc3REcmFnUG9pbnREb2MpLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSB0cmFuc2xhdGUgaW4gd2hvbGUtcGl4ZWwgaW5jcmVtZW50cyAoaW4gZG9jdW1lbnQgc3BhY2Ugbm90IGNhbnZhcyBzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvblJvdW5kZWQgPSB0cmFuc2xhdGlvbi5nZXRUcnVuY2F0ZWQoKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uUmVtYWluZGVyID0gdHJhbnNsYXRpb24uc3VidHJhY3QodHJhbnNsYXRpb25Sb3VuZGVkKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUluc3RhbmNlID0gbmV3IENQVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBBcHBseSB0aGUgdHJhbnNsYXRlICphZnRlciogdGhlIGN1cnJlbnQgYWZmaW5lIGlzIGFwcGxpZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0ZUluc3RhbmNlLnRyYW5zbGF0ZSh0cmFuc2xhdGlvblJvdW5kZWQueCwgdHJhbnNsYXRpb25Sb3VuZGVkLnkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBhZmZpbmUucHJlTXVsdGlwbHkodHJhbnNsYXRlSW5zdGFuY2UpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBBY2N1bXVsYXRlIHRoZSBmcmFjdGlvbmFsIG1vdmUgdGhhdCB3ZSBkaWRuJ3QgYXBwbHkgZm9yIG5leHQgdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdERyYWdQb2ludERvYyA9IENQVmVjdG9yLnN1YnRyYWN0UG9pbnRzKGRyYWdQb2ludERvYywgdHJhbnNsYXRpb25SZW1haW5kZXIpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBEUkFHX1JPVEFURTpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgRFJBR19ST1RBVEVfU05BUF9BTkdMRSA9IE1hdGguUEkgLyA0O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJEb2MgPSBjb3JuZXJQb2ludHMuZ2V0Q2VudGVyKCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyRGlzcGxheSA9IGNvb3JkVG9EaXNwbGF5KGNlbnRlckRvYyksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRNb3VzZUFuZ2xlID0gTWF0aC5hdGFuMihsYXN0RHJhZ1BvaW50RGlzcGxheS55IC0gY2VudGVyRGlzcGxheS55LCBsYXN0RHJhZ1BvaW50RGlzcGxheS54IC0gY2VudGVyRGlzcGxheS54KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdNb3VzZUFuZ2xlID0gTWF0aC5hdGFuMihkcmFnUG9pbnREaXNwbGF5LnkgLSBjZW50ZXJEaXNwbGF5LnksIGRyYWdQb2ludERpc3BsYXkueCAtIGNlbnRlckRpc3BsYXkueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFNb3VzZUFuZ2xlID0gbmV3TW91c2VBbmdsZSAtIG9sZE1vdXNlQW5nbGUsXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVJbnN0YW5jZSA9IG5ldyBDUFRyYW5zZm9ybSgpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbkFjY3VtdWxhdG9yICs9IGRlbHRhTW91c2VBbmdsZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hpZnRLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIFRoZSByb3RhdGlvbiBpbiB0aGUgZGVjb21wb3NpdGlvbiB3YXMgbWFkZSBhYm91dCB0aGUgb3JpZ2luLiBXZSB3YW50IHRvIHJvdGF0ZSBhYm91dCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKiBjZW50ZXIgb2YgdGhlIHNlbGVjdGlvbiwgc28gZmlyc3Qgcm90YXRlIHRoZSBzZWxlY3Rpb24gdG8gc3F1YXJlIGl0IHVwIHdpdGggdGhlIGF4ZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlbiB3ZSdsbCBwaXZvdCB0aGUgc2VsZWN0aW9uIGFib3V0IGl0cyBjZW50ZXIgdG8gdGhlIG5ldyBhbmdsZS5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVBbmdsZSA9IC1hZmZpbmUuZGVjb21wb3NlKCkucm90YXRlICsgTWF0aC5yb3VuZChyb3RhdGlvbkFjY3VtdWxhdG9yIC8gRFJBR19ST1RBVEVfU05BUF9BTkdMRSkgKiBEUkFHX1JPVEFURV9TTkFQX0FOR0xFO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByb3RhdGVBbmdsZSA9IGRlbHRhTW91c2VBbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgLyogQXBwbHkgdGhlIHJvdGF0aW9uICphZnRlciogdGhlIGN1cnJlbnQgYWZmaW5lIGluc3RlYWQgb2YgYmVmb3JlIGl0LCBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgICAgICAgICAgICAgICAgICAgKiBlbmQgdXAgc2NhbGluZyBvbiB0b3Agb2YgdGhlIHJvdGF0ZWQgc2VsZWN0aW9uIGxhdGVyICh3aGljaCB3b3VsZCBjYXVzZSBhbiB1bndhbnRlZCBzaGVhcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgcm90YXRlSW5zdGFuY2Uucm90YXRlQXJvdW5kUG9pbnQocm90YXRlQW5nbGUsIGNlbnRlckRvYy54LCBjZW50ZXJEb2MueSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmluZS5wcmVNdWx0aXBseShyb3RhdGVJbnN0YW5jZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3REcmFnUG9pbnREaXNwbGF5ID0gZHJhZ1BvaW50RGlzcGxheTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRFJBR19OV19DT1JORVI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRFJBR19ORV9DT1JORVI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRFJBR19TRV9DT1JORVI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRFJBR19TV19DT1JORVI6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYWdnaW5nQ29ybmVyID0gfn4oZHJhZ2dpbmdNb2RlIC8gMiksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRDb3JuZXIgPSBvcmlnQ29ybmVyUG9pbnRzLnBvaW50c1tkcmFnZ2luZ0Nvcm5lcl0sXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29ybmVyIHdlIGRyYWdnZWQgd2lsbCBtb3ZlIGludG8gaXRzIG5ldyBwb3NpdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0Nvcm5lciA9IGFmZmluZS5nZXRJbnZlcnRlZCgpLmdldFRyYW5zZm9ybWVkUG9pbnQocm91bmRQb2ludChjb29yZFRvRG9jdW1lbnQoZHJhZ1BvaW50RGlzcGxheSkpKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG9wcG9zaXRlIGNvcm5lciB0byB0aGUgb25lIHdlIGRyYWdnZWQgbXVzdCBub3QgbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpeENvcm5lciA9IG9yaWdDb3JuZXJQb2ludHMucG9pbnRzWyhkcmFnZ2luZ0Nvcm5lciArIDIpICUgNF0sXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIE5vdyB3ZSBjYW4gc2VlIGhvdyBtdWNoIHdlJ2QgbmVlZCB0byBzY2FsZSB0aGUgb3JpZ2luYWwgcmVjdGFuZ2xlIGFib3V0IHRoZSBmaXhlZCBjb3JuZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGZvciB0aGUgb3RoZXIgY29ybmVyIHRvIHJlYWNoIHRoZSBuZXcgcG9zaXRpb24uXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVggPSAobmV3Q29ybmVyLnggLSBmaXhDb3JuZXIueCkgLyAob2xkQ29ybmVyLnggLSBmaXhDb3JuZXIueCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVZID0gKG5ld0Nvcm5lci55IC0gZml4Q29ybmVyLnkpIC8gKG9sZENvcm5lci55IC0gZml4Q29ybmVyLnkpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIHVzZXIgcmVzaXplZCBpdCB1bnRpbCBpdCB3YXMgemVyby1zaXplZCwganVzdCBpZ25vcmUgdGhhdCBwb3NpdGlvbiBhbmQgYXNzdW1lIHRoZXknbGwgbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogcGFzdCBpdCBpbiBhIG1zZWMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhzY2FsZVgpIDwgTUlOX1NDQUxFIHx8IE1hdGguYWJzKHNjYWxlWSkgPCBNSU5fU0NBTEUgfHwgaXNOYU4oc2NhbGVYKSB8fCBpc05hTihzY2FsZVkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERvZXMgdXNlciB3YW50IHByb3BvcnRpb25hbCByZXNpemU/XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5zaGlmdEtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXJnZXN0U2NhbGUgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVggPSBsYXJnZXN0U2NhbGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVZID0gbGFyZ2VzdFNjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgdHJhbnNmb3JtIHdlIGRvIGhlcmUgd2lsbCBiZSBwZXJmb3JtZWQgZmlyc3QgYmVmb3JlIGFueSBvZiB0aGUgb3RoZXIgdHJhbnNmb3JtcyAoc2NhbGUsIHJvdGF0ZSwgZXRjKVxuICAgICAgICAgICAgICAgICAgICAgICAgYWZmaW5lLnNjYWxlQXJvdW5kUG9pbnQoc2NhbGVYLCBzY2FsZVksIGZpeENvcm5lci54LCBmaXhDb3JuZXIueSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRFJBR19OX0VER0U6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRFJBR19TX0VER0U6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRFJBR19FX0VER0U6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgRFJBR19XX0VER0U6XG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvcm5lckluZGV4ID0gfn4oZHJhZ2dpbmdNb2RlIC8gMiksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRIYW5kbGUgPSBhdmVyYWdlUG9pbnRzKG9yaWdDb3JuZXJQb2ludHMucG9pbnRzW2Nvcm5lckluZGV4XSwgb3JpZ0Nvcm5lclBvaW50cy5wb2ludHNbKGNvcm5lckluZGV4ICsgMSkgJSA0XSksXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRoZSBoYW5kbGUgd2UgZHJhZ2dlZCB3aWxsIG1vdmUgaW50byBpdHMgbmV3IHBvc2l0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3SGFuZGxlID0gYWZmaW5lLmdldEludmVydGVkKCkuZ2V0VHJhbnNmb3JtZWRQb2ludChyb3VuZFBvaW50KGNvb3JkVG9Eb2N1bWVudChkcmFnUG9pbnREaXNwbGF5KSkpLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgb3Bwb3NpdGUgaGFuZGxlIHRvIHRoZSBvbmUgd2UgZHJhZ2dlZCBtdXN0IG5vdCBtb3ZlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZml4SGFuZGxlID0gYXZlcmFnZVBvaW50cyhvcmlnQ29ybmVyUG9pbnRzLnBvaW50c1soY29ybmVySW5kZXggKyAyKSAlIDRdLCBvcmlnQ29ybmVyUG9pbnRzLnBvaW50c1soY29ybmVySW5kZXggKyAzKSAlIDRdKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWCwgc2NhbGVZLFxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkVmVjdG9yID0gQ1BWZWN0b3Iuc3VidHJhY3RQb2ludHMob2xkSGFuZGxlLCBmaXhIYW5kbGUpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1ZlY3RvciA9IENQVmVjdG9yLnN1YnRyYWN0UG9pbnRzKG5ld0hhbmRsZSwgZml4SGFuZGxlKSxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZExlbmd0aCA9IG9sZFZlY3Rvci5nZXRMZW5ndGgoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG9ubHkgdGFrZSB0aGUgbGVuZ3RoIGluIHRoZSBwZXJwZW5kaWN1bGFyIGRpcmVjdGlvbiB0byB0aGUgdHJhbnNmb3JtIGVkZ2U6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3TGVuZ3RoID0gb2xkVmVjdG9yLmdldERvdFByb2R1Y3QobmV3VmVjdG9yKSAvIG9sZExlbmd0aCxcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld1NjYWxlID0gbmV3TGVuZ3RoIC8gb2xkTGVuZ3RoO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogSWYgdGhlIHVzZXIgcmVzaXplZCBpdCB1bnRpbCBpdCB3YXMgemVyby1zaXplZCwganVzdCBpZ25vcmUgdGhhdCBwb3NpdGlvbiBhbmQgYXNzdW1lIHRoZXknbGwgbW92ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogcGFzdCBpdCBpbiBhIG1zZWMuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChNYXRoLmFicyhuZXdTY2FsZSkgPCBNSU5fU0NBTEUgfHwgaXNOYU4obmV3U2NhbGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkcmFnZ2luZ01vZGUgPT0gRFJBR19OX0VER0UgfHwgZHJhZ2dpbmdNb2RlID09IERSQUdfU19FREdFKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2NhbGVYID0gMS4wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjYWxlWSA9IG5ld1NjYWxlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVggPSBuZXdTY2FsZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FsZVkgPSAxLjA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGFmZmluZS5zY2FsZUFyb3VuZFBvaW50KHNjYWxlWCwgc2NhbGVZLCBmaXhIYW5kbGUueCwgZml4SGFuZGxlLnkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvcm5lclBvaW50cyA9IG9yaWdDb3JuZXJQb2ludHMuZ2V0VHJhbnNmb3JtZWQoYWZmaW5lKTtcblxuICAgICAgICAgICAgICAgIGFydHdvcmsudHJhbnNmb3JtQWZmaW5lQW1lbmQoYWZmaW5lKTtcblxuICAgICAgICAgICAgICAgIC8vIFRPRE8gbWFrZSBtZSBtb3JlIHNwZWNpZmljXG4gICAgICAgICAgICAgICAgdGhhdC5yZXBhaW50QWxsKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5tb3VzZVVwID0gZnVuY3Rpb24oZSwgYnV0dG9uLCBwcmVzc3VyZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2FwdHVyZSAmJiBidXR0b24gPT0gQlVUVE9OX1BSSU1BUlkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkcmFnZ2luZ01vZGUgPSBEUkFHX05PTkU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgLypcbiAgICAgICAgICogU2V0IGFuIGFwcHJvcHJpYXRlIHJlc2l6ZSBjdXJzb3IgZm9yIHRoZSBzcGVjaWZpZWQgdmVjdG9yIGZyb20gdGhlIGNlbnRlciB0byB0aGUgaGFuZGxlLlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gc2V0UmVzaXplQ3Vyc29yRm9yVmVjdG9yKHYpIHtcbiAgICAgICAgICAgIGxldFxuICAgICAgICAgICAgICAgIGFuZ2xlID0gTWF0aC5hdGFuMigtdi55LCB2LngpLFxuICAgICAgICAgICAgLypcbiAgICAgICAgICAgICAgICAgKiBTbGljZSB1cCBpbnRvIDQ1IGRlZ3JlZXMgc2xpY2VzIHNvIHRoYXQgdGhlcmUgYXJlICstMjIuNSBkZWdyZWVzIGNlbnRlcmVkIGFyb3VuZCBlYWNoIGNvcm5lcixcbiAgICAgICAgICAgICAgICAgKiBhbmQgYSA0NSBkZWdyZWUgc2VnbWVudCBmb3IgZWFjaCBlZGdlXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgc2xpY2UgPSBNYXRoLmZsb29yKGFuZ2xlIC8gKE1hdGguUEkgLyA0KSArIDAuNSksXG4gICAgICAgICAgICAgICAgY3Vyc29yO1xuXG4gICAgICAgICAgICAvLyBXcmFwIGFuZ2xlcyBiZWxvdyB0aGUgeC1heGlzIHdyYXAgdG8gcG9zaXRpdmUgb25lcy4uLlxuICAgICAgICAgICAgaWYgKHNsaWNlIDwgMCkge1xuICAgICAgICAgICAgICAgIHNsaWNlICs9IDQ7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHN3aXRjaCAoc2xpY2UpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgY3Vyc29yID0gQ1VSU09SX0VXX1JFU0laRTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IENVUlNPUl9ORVNXX1JFU0laRTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIGN1cnNvciA9IENVUlNPUl9OU19SRVNJWkU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgICAgICBjdXJzb3IgPSBDVVJTT1JfTldTRV9SRVNJWkU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNldEN1cnNvcihjdXJzb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5tb3VzZU1vdmUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8vIFdlIHdhbnQgdG8gc3RpY2sgd2l0aCBvdXIgY2hvaWNlIG9mIGN1cnNvciB0aHJvdWdob3V0IHRoZSBkcmFnIG9wZXJhdGlvblxuICAgICAgICAgICAgaWYgKCF0aGlzLmNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXJzb3JGb3JIYW5kbGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5wYWludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgY29ybmVycyA9IGNvcm5lcnNUb0Rpc3BsYXlQb2x5Z29uKCkucG9pbnRzLFxuICAgICAgICAgICAgICAgIGhhbmRsZXMgPSBuZXcgQXJyYXkoY29ybmVycy5sZW5ndGggKiAyKTtcblxuICAgICAgICAgICAgLy8gQ29sbGVjdCB0aGUgcG9zaXRpb25zIG9mIHRoZSBlZGdlIGFuZCBjb3JuZXIgaGFuZGxlcy4uLlxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3JuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaGFuZGxlc1tpXSA9IGNvcm5lcnNbaV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29ybmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBlZGdlUDEgPSBjb3JuZXJzW2ldLFxuICAgICAgICAgICAgICAgICAgICBlZGdlUDIgPSBjb3JuZXJzWyhpICsgMSkgJSBjb3JuZXJzLmxlbmd0aF0sXG5cbiAgICAgICAgICAgICAgICAgICAgbWlkV2F5ID0ge3g6IChlZGdlUDEueCArIGVkZ2VQMi54KSAvIDIsIHk6IChlZGdlUDEueSArIGVkZ2VQMi55KSAvIDJ9O1xuXG4gICAgICAgICAgICAgICAgaGFuZGxlc1tpICsgY29ybmVycy5sZW5ndGhdID0gbWlkV2F5O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZXRDb250cmFzdGluZ0RyYXdTdHlsZShjYW52YXNDb250ZXh0LCBcImZpbGxcIik7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0LmZpbGxSZWN0KGhhbmRsZXNbaV0ueCAtIEhBTkRMRV9SQURJVVMsIGhhbmRsZXNbaV0ueSAtIEhBTkRMRV9SQURJVVMsIEhBTkRMRV9SQURJVVMgKiAyICsgMSwgSEFORExFX1JBRElVUyAqIDIgKyAxKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgc3Ryb2tlUG9seWdvbihjYW52YXNDb250ZXh0LCBjb3JuZXJzKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmtleURvd24gPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzIC8qIEVudGVyICovKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogXCJDUFRyYW5zZm9ybUFjY2VwdFwifSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZS5rZXlDb2RlID09IDI3IC8qIEVzY2FwZSAqLykge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWN0aW9uUGVyZm9ybWVkKHthY3Rpb246IFwiQ1BUcmFuc2Zvcm1SZWplY3RcIn0pO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgdGhpcy5lbnRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgQ1BNb2RlLnByb3RvdHlwZS5lbnRlci5jYWxsKHRoaXMpO1xuXG4gICAgICAgICAgICAvLyBTdGFydCBvZmYgd2l0aCB0aGUgaWRlbnRpdHkgdHJhbnNmb3JtXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBpbml0aWFsID0gYXJ0d29yay50cmFuc2Zvcm1BZmZpbmVCZWdpbigpLFxuICAgICAgICAgICAgICAgIGluaXRpYWxTZWxlY3Rpb247XG5cbiAgICAgICAgICAgIGFmZmluZSA9IGluaXRpYWwudHJhbnNmb3JtO1xuICAgICAgICAgICAgc3JjUmVjdCA9IGluaXRpYWwucmVjdDtcblxuICAgICAgICAgICAgLy8gRGVjaWRlIG9uIHRoZSByZWN0YW5nbGUgd2UnbGwgc2hvdyBhcyB0aGUgYm91bmRhcnkgb2YgdGhlIHRyYW5zZm9ybSBhcmVhXG4gICAgICAgICAgICBpbml0aWFsU2VsZWN0aW9uID0gaW5pdGlhbC5zZWxlY3Rpb247XG5cbiAgICAgICAgICAgIC8qIElmIHRoZSB1c2VyIGRpZG4ndCBoYXZlIGFueXRoaW5nIHNlbGVjdGVkLCB3ZSdsbCB1c2UgdGhlIGFjdHVhbCBzaHJpbmstd3JhcHBlZCB0cmFuc2Zvcm0gYXJlYSBpbnN0ZWFkLiAqL1xuICAgICAgICAgICAgaWYgKGluaXRpYWxTZWxlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbFNlbGVjdGlvbiA9IGluaXRpYWwucmVjdC5jbG9uZSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBvcmlnQ29ybmVyUG9pbnRzID0gbmV3IENQUG9seWdvbihpbml0aWFsU2VsZWN0aW9uLnRvUG9pbnRzKCkpO1xuICAgICAgICAgICAgY29ybmVyUG9pbnRzID0gb3JpZ0Nvcm5lclBvaW50cy5nZXRUcmFuc2Zvcm1lZChhZmZpbmUpO1xuXG4gICAgICAgICAgICBkcmFnZ2luZ01vZGUgPSAtMTtcbiAgICAgICAgICAgIHJvdGF0aW9uQWNjdW11bGF0b3IgPSAwO1xuXG4gICAgICAgICAgICB0aGF0LnJlcGFpbnRBbGwoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmxlYXZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBDUE1vZGUucHJvdG90eXBlLmxlYXZlLmNhbGwodGhpcyk7XG4gICAgICAgICAgICB0aGF0LnJlcGFpbnRBbGwoKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBDUFRyYW5zZm9ybU1vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUE1vZGUucHJvdG90eXBlKTtcbiAgICBDUFRyYW5zZm9ybU1vZGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BUcmFuc2Zvcm1Nb2RlO1xuXG4gICAgZnVuY3Rpb24gQ1BSb3RhdGVDYW52YXNNb2RlKCkge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBmaXJzdENsaWNrLFxuICAgICAgICAgICAgaW5pdEFuZ2xlID0gMC4wLFxuICAgICAgICAgICAgaW5pdFRyYW5zZm9ybSxcbiAgICAgICAgICAgIGRyYWdnZWQgPSBmYWxzZSxcblxuICAgICAgICAgICAgcm90YXRlQnV0dG9uID0gLTE7XG5cbiAgICAgICAgdGhpcy5tb3VzZURvd24gPSBmdW5jdGlvbihlLCBidXR0b24sIHByZXNzdXJlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jYXB0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLnRyYW5zaWVudCAmJiBidXR0b24gPT0gQlVUVE9OX1BSSU1BUlkgJiYgIWUuYWx0S2V5ICYmICFrZXkuaXNQcmVzc2VkKFwic3BhY2VcIilcbiAgICAgICAgICAgICAgICAgICAgfHwgZS5hbHRLZXkgJiYgKGJ1dHRvbiA9PSBCVVRUT05fV0hFRUwgfHwgYnV0dG9uID09IEJVVFRPTl9QUklNQVJZICYmIGtleS5pc1ByZXNzZWQoXCJzcGFjZVwiKSkpIHtcbiAgICAgICAgICAgICAgICBmaXJzdENsaWNrID0ge3g6IG1vdXNlWCwgeTogbW91c2VZfTtcblxuICAgICAgICAgICAgICAgIGluaXRBbmdsZSA9IHRoYXQuZ2V0Um90YXRpb24oKTtcbiAgICAgICAgICAgICAgICBpbml0VHJhbnNmb3JtID0gdHJhbnNmb3JtLmNsb25lKCk7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2VkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmNhcHR1cmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHJvdGF0ZUJ1dHRvbiA9IGJ1dHRvbjtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnRyYW5zaWVudCkge1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5wb3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLm1vdXNlRHJhZyA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmUpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgcCA9IHt4OiBtb3VzZVgsIHk6IG1vdXNlWX0sXG5cbiAgICAgICAgICAgICAgICAgICAgZGlzcGxheUNlbnRlciA9IHt4OiAkKGNhbnZhcykud2lkdGgoKSAvIDIsIHk6ICQoY2FudmFzKS5oZWlnaHQoKSAvIDJ9LFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNDZW50ZXIgPSB7eDogY2FudmFzLndpZHRoIC8gMiwgeTogY2FudmFzLmhlaWdodCAvIDJ9LFxuXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhQW5nbGUgPSBNYXRoLmF0YW4yKHAueSAtIGRpc3BsYXlDZW50ZXIueSwgcC54IC0gZGlzcGxheUNlbnRlci54KSAtIE1hdGguYXRhbjIoZmlyc3RDbGljay55IC0gZGlzcGxheUNlbnRlci55LCBmaXJzdENsaWNrLnggLSBkaXNwbGF5Q2VudGVyLngpLFxuXG4gICAgICAgICAgICAgICAgICAgIHJvdFRyYW5zID0gbmV3IENQVHJhbnNmb3JtKCk7XG5cbiAgICAgICAgICAgICAgICByb3RUcmFucy5yb3RhdGVBcm91bmRQb2ludChkZWx0YUFuZ2xlLCBjYW52YXNDZW50ZXIueCwgY2FudmFzQ2VudGVyLnkpO1xuXG4gICAgICAgICAgICAgICAgcm90VHJhbnMubXVsdGlwbHkoaW5pdFRyYW5zZm9ybSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnNldFJvdGF0aW9uKGluaXRBbmdsZSArIGRlbHRhQW5nbGUpO1xuICAgICAgICAgICAgICAgIHRoYXQuc2V0T2Zmc2V0KH5+cm90VHJhbnMuZ2V0VHJhbnNsYXRlWCgpLCB+fnJvdFRyYW5zLmdldFRyYW5zbGF0ZVkoKSk7XG5cbiAgICAgICAgICAgICAgICBkcmFnZ2VkID0gdHJ1ZTtcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBXaGVuIHRoZSBtb3VzZSBpcyByZWxlYXNlZCBhZnRlciByb3RhdGlvbiwgd2UgbWlnaHQgd2FudCB0byBzbmFwIG91ciBhbmdsZSB0byB0aGUgbmVhcmVzdCA5MCBkZWdyZWUgbWFyay5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGZpbmlzaFJvdGF0aW9uKCkge1xuICAgICAgICAgICAgY29uc3RcbiAgICAgICAgICAgICAgICBST1RBVEVfU05BUF9ERUdSRUVTID0gNTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgIG5lYXJlc3Q5MCA9IE1hdGgucm91bmQoY2FudmFzUm90YXRpb24gLyAoTWF0aC5QSSAvIDIpKSAqIE1hdGguUEkgLyAyO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoTWF0aC5hYnMoY2FudmFzUm90YXRpb24gLSBuZWFyZXN0OTApIDwgUk9UQVRFX1NOQVBfREVHUkVFUyAvIDE4MCAqIE1hdGguUEkpIHtcbiAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgIGRlbHRhQW5nbGUgPSBuZWFyZXN0OTAgLSBpbml0QW5nbGUsXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNlbnRlciA9IHt4OiBjYW52YXMud2lkdGggLyAyLCB5OiBjYW52YXMuaGVpZ2h0IC8gMn0sXG5cbiAgICAgICAgICAgICAgICAgICAgcm90VHJhbnMgPSBuZXcgQ1BUcmFuc2Zvcm0oKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICByb3RUcmFucy5yb3RhdGVBcm91bmRQb2ludChkZWx0YUFuZ2xlLCBjZW50ZXIueCwgY2VudGVyLnkpO1xuXG4gICAgICAgICAgICAgICAgcm90VHJhbnMubXVsdGlwbHkoaW5pdFRyYW5zZm9ybSk7XG5cbiAgICAgICAgICAgICAgICB0aGF0LnNldFJvdGF0aW9uKGluaXRBbmdsZSArIGRlbHRhQW5nbGUpO1xuICAgICAgICAgICAgICAgIHRoYXQuc2V0T2Zmc2V0KH5+cm90VHJhbnMuZ2V0VHJhbnNsYXRlWCgpLCB+fnJvdFRyYW5zLmdldFRyYW5zbGF0ZVkoKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdGhhdC5yZXBhaW50QWxsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMubW91c2VVcCA9IGZ1bmN0aW9uKGUsIGJ1dHRvbiwgcHJlc3N1cmUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNhcHR1cmUgJiYgYnV0dG9uID09IHJvdGF0ZUJ1dHRvbikge1xuICAgICAgICAgICAgICAgIGlmIChkcmFnZ2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbmlzaFJvdGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5yZXNldFJvdGF0aW9uKCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jYXB0dXJlID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc2llbnQgJiYgIShrZXkuaXNQcmVzc2VkKFwic3BhY2VcIikgJiYga2V5LmFsdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgbW9kZVN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMua2V5VXAgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50cmFuc2llbnQgJiYgcm90YXRlQnV0dG9uICE9IEJVVFRPTl9XSEVFTCAmJiBlLmtleUNvZGUgPT0gMzIgLyogU3BhY2UgKi8pIHtcbiAgICAgICAgICAgICAgICBzZXRDdXJzb3IoQ1VSU09SX0RFRkFVTFQpO1xuXG4gICAgICAgICAgICAgICAgbW9kZVN0YWNrLnBvcCgpOyAvLyB5aWVsZCBjb250cm9sIHRvIHRoZSBkZWZhdWx0IG1vZGVcblxuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIHRoaXMua2V5RG93biA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMzIgLyogU3BhY2UgKi8gJiYgZS5hbHRLZXkpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGF0J3Mgb3VyIGhvdGtleSwgc28gc3RheSBpbiB0aGlzIG1vZGUgKGRvbid0IGZvcndhcmQgdG8gQ1BEZWZhdWx0TW9kZSlcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgXG4gICAgQ1BSb3RhdGVDYW52YXNNb2RlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BNb2RlLnByb3RvdHlwZSk7XG4gICAgQ1BSb3RhdGVDYW52YXNNb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQUm90YXRlQ2FudmFzTW9kZTtcblxuICAgIGZ1bmN0aW9uIENQR3JhZGllbnRGaWxsTW9kZSgpIHtcbiAgICAgICAgLy8gU3VwZXIgY29uc3RydWN0b3JcbiAgICAgICAgQ1BMaW5lTW9kZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgICBcbiAgICBDUEdyYWRpZW50RmlsbE1vZGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUExpbmVNb2RlLnByb3RvdHlwZSk7XG4gICAgQ1BHcmFkaWVudEZpbGxNb2RlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQR3JhZGllbnRGaWxsTW9kZTtcblxuICAgIENQR3JhZGllbnRGaWxsTW9kZS5wcm90b3R5cGUuZHJhd0xpbmUgPSBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgICBhcnR3b3JrLmdyYWRpZW50RmlsbChNYXRoLnJvdW5kKGZyb20ueCksIE1hdGgucm91bmQoZnJvbS55KSwgTWF0aC5yb3VuZCh0by54KSwgTWF0aC5yb3VuZCh0by55KSwgY29udHJvbGxlci5nZXRDdXJHcmFkaWVudCgpKTtcbiAgICB9O1xuXG4gICAgQ1BHcmFkaWVudEZpbGxNb2RlLnByb3RvdHlwZS5xdWV1ZUJydXNoUHJldmlldyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvL1N1cHByZXNzIHRoZSBkcmF3aW5nIG9mIHRoZSBicnVzaCBwcmV2aWV3IChpbmhlcml0ZWQgZnJvbSBDUERyYXdpbmdNb2RlKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiBzZXRDdXJzb3IoY3Vyc29yKSB7XG4gICAgICAgIGlmIChjYW52YXMuZ2V0QXR0cmlidXRlKFwiZGF0YS1jdXJzb3JcIikgIT0gY3Vyc29yKSB7XG4gICAgICAgICAgICBjYW52YXMuc2V0QXR0cmlidXRlKFwiZGF0YS1jdXJzb3JcIiwgY3Vyc29yKTtcbiAgICAgICAgfVxuICAgIH1cblxuXHQvKipcbiAgICAgKiBDaGVjayB0aGF0IHdlIHNob3VsZCBiZSBkcmF3aW5nIHRvIHRoZSBjdXJyZW50IGxheWVyLCBhbmQgbGV0IHRoZSB1c2VyIGtub3cgaWYgdGhleSBhcmUgYmVpbmcgYmxvY2tlZCBieSB0aGVcbiAgICAgKiBsYXllciBzZXR0aW5ncy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHdlIHNob3VsZCBkcmF3IHRvIHRoZSBjdXJyZW50IGxheWVyXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2hvdWxkRHJhd1RvVGhpc0xheWVyKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGFjdGl2ZUxheWVyID0gYXJ0d29yay5nZXRBY3RpdmVMYXllcigpO1xuXG4gICAgICAgIGlmICghYWN0aXZlTGF5ZXIudmlzaWJsZSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5zaG93TGF5ZXJOb3RpZmljYXRpb24oYXJ0d29yay5nZXRBY3RpdmVMYXllckluZGV4KCksIFwiV2hvb3BzISBUaGlzIGxheWVyIGlzIGN1cnJlbnRseSBoaWRkZW5cIiwgXCJsYXllclwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IGVsc2UgaWYgKGFjdGl2ZUxheWVyLmFscGhhID09IDApIHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuc2hvd0xheWVyTm90aWZpY2F0aW9uKGFydHdvcmsuZ2V0QWN0aXZlTGF5ZXJJbmRleCgpLCBcIldob29wcyEgVGhpcyBsYXllcidzIG9wYWNpdHkgaXMgY3VycmVudGx5IDAlXCIsIFwib3BhY2l0eVwiKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXBkYXRlIHRoZSBzY3JvbGxiYXIncyByYW5nZS9wb3NpdGlvbiB0byBtYXRjaCB0aGUgY3VycmVudCB2aWV3IHNldHRpbmdzIGZvciB0aGUgZG9jdW1lbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2Nyb2xsYmFyIHtDUFNjcm9sbGJhcn1cbiAgICAgKiBAcGFyYW0gdmlzTWluIFRoZSBzbWFsbGVzdCBjb29yZGluYXRlIGluIHRoaXMgYXhpcyBpbiB3aGljaCB0aGUgZHJhd2luZyBhcHBlYXJzXG4gICAgICogQHBhcmFtIHZpc1dpZHRoIFRoZSBleHRlbnQgb2YgdGhlIGRyYXdpbmcgaW4gdGhpcyBheGlzXG4gICAgICogQHBhcmFtIHZpZXdTaXplIFRoZSBleHRlbnQgb2YgdGhlIHNjcmVlbiBjYW52YXMgaW4gdGhpcyBheGlzXG4gICAgICogQHBhcmFtIG9mZnNldCBUaGUgcHJlc2VudCBwaXhlbCBvZmZzZXQgb2YgdGhlIGRyYXdpbmcgaW4gdGhpcyBheGlzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsQmFyKHNjcm9sbGJhciwgdmlzTWluLCB2aXNXaWR0aCwgdmlld1NpemUsIG9mZnNldCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHhNaW4gPSB2aXNNaW4gLSB2aWV3U2l6ZSAtIG9mZnNldCArIHZpc1dpZHRoIC8gNCxcbiAgICAgICAgICAgIHhNYXggPSB2aXNNaW4gKyB2aXNXaWR0aCAtIG9mZnNldCAtIHZpc1dpZHRoIC8gNDtcbiAgICAgICAgXG4gICAgICAgIHNjcm9sbGJhci5zZXRWYWx1ZXMoLW9mZnNldCwgdmlld1NpemUsIHhNaW4sIHhNYXgpO1xuICAgICAgICBcbiAgICAgICAgc2Nyb2xsYmFyLnNldEJsb2NrSW5jcmVtZW50KE1hdGgubWF4KDEsIH5+KHZpZXdTaXplICogLjY2KSkpO1xuICAgICAgICBzY3JvbGxiYXIuc2V0VW5pdEluY3JlbWVudChNYXRoLm1heCgxLCB+fih2aWV3U2l6ZSAqIC4wNSkpKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gdXBkYXRlU2Nyb2xsQmFycygpIHtcbiAgICAgICAgaWYgKGhvcnpTY3JvbGwgPT0gbnVsbCB8fCB2ZXJ0U2Nyb2xsID09IG51bGxcbiAgICAgICAgICAgICAgICB8fCBob3J6U2Nyb2xsLmdldFZhbHVlSXNBZGp1c3RpbmcoKSB8fCB2ZXJ0U2Nyb2xsLmdldFZhbHVlSXNBZGp1c3RpbmcoKSApIHtcbiAgICAgICAgICAgcmV0dXJuO1xuICAgICAgIH1cblxuICAgICAgIHZhclxuICAgICAgICAgICB2aXNpYmxlUmVjdCA9IGdldFJlZnJlc2hBcmVhKG5ldyBDUFJlY3QoMCwgMCwgYXJ0d29ya0NhbnZhcy53aWR0aCwgYXJ0d29ya0NhbnZhcy5oZWlnaHQpKTtcblxuICAgICAgIHVwZGF0ZVNjcm9sbEJhcihob3J6U2Nyb2xsLCB2aXNpYmxlUmVjdC5sZWZ0LCB2aXNpYmxlUmVjdC5nZXRXaWR0aCgpLCAkKGNhbnZhcykud2lkdGgoKSwgdGhhdC5nZXRPZmZzZXQoKS54KTtcbiAgICAgICB1cGRhdGVTY3JvbGxCYXIodmVydFNjcm9sbCwgdmlzaWJsZVJlY3QudG9wLCB2aXNpYmxlUmVjdC5nZXRIZWlnaHQoKSwgJChjYW52YXMpLmhlaWdodCgpLCB0aGF0LmdldE9mZnNldCgpLnkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVRyYW5zZm9ybSgpIHtcbiAgICAgICAgdHJhbnNmb3JtLnNldFRvSWRlbnRpdHkoKTtcbiAgICAgICAgdHJhbnNmb3JtLnRyYW5zbGF0ZShvZmZzZXRYLCBvZmZzZXRZKTtcbiAgICAgICAgdHJhbnNmb3JtLnNjYWxlKHpvb20sIHpvb20pO1xuICAgICAgICB0cmFuc2Zvcm0ucm90YXRlKGNhbnZhc1JvdGF0aW9uKTtcblxuICAgICAgICB1cGRhdGVTY3JvbGxCYXJzKCk7XG4gICAgICAgIHRoYXQucmVwYWludEFsbCgpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgY2FudmFzLXJlbGF0aXZlIGNvb3JkaW5hdGUgaW50byBkb2N1bWVudCBjb29yZGluYXRlcyBhbmQgcmV0dXJuIHRoZSBuZXcgY29vcmRpbmF0ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb29yZFRvRG9jdW1lbnQoY29vcmQpIHtcbiAgICAgICAgLy8gVE9ETyBjYWNoZSBpbnZlcnRlZCB0cmFuc2Zvcm1cbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS5nZXRJbnZlcnRlZCgpLmdldFRyYW5zZm9ybWVkUG9pbnQoY29vcmQpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IGEgY2FudmFzLXJlbGF0aXZlIGNvb3JkaW5hdGUgaW50byBkb2N1bWVudCBjb29yZGluYXRlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb29yZFRvRG9jdW1lbnRJbnQoY29vcmQpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICByZXN1bHQgPSBjb29yZFRvRG9jdW1lbnQoY29vcmQpO1xuICAgICAgICBcbiAgICAgICAgcmVzdWx0LnggPSBNYXRoLmZsb29yKHJlc3VsdC54KTtcbiAgICAgICAgcmVzdWx0LnkgPSBNYXRoLmZsb29yKHJlc3VsdC55KTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIENvbnZlcnQgYSB7eDogcGFnZVgsIHk6IHBhZ2VZfSBjby1vcmRpbmF0ZSBwYWlyIGZyb20gYSBtb3VzZSBldmVudCB0byBjYW52YXMtcmVsYXRpdmUgY29vcmRpbmF0ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbW91c2VDb29yZFRvQ2FudmFzKGNvb3JkKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICByZXR1cm4ge3g6IGNvb3JkLnggLSByZWN0LmxlZnQgLSB3aW5kb3cucGFnZVhPZmZzZXQsIHk6IGNvb3JkLnkgLSByZWN0LnRvcCAtIHdpbmRvdy5wYWdlWU9mZnNldH07XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGNvb3JkVG9EaXNwbGF5KHApIHtcbiAgICAgICAgcmV0dXJuIHRyYW5zZm9ybS5nZXRUcmFuc2Zvcm1lZFBvaW50KHApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNvb3JkVG9EaXNwbGF5SW50KHApIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICByZXN1bHQgPSBjb29yZFRvRGlzcGxheShwKTtcbiAgICAgICAgXG4gICAgICAgIHJlc3VsdC54ID0gTWF0aC5yb3VuZChyZXN1bHQueCk7XG4gICAgICAgIHJlc3VsdC55ID0gTWF0aC5yb3VuZChyZXN1bHQueSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBcblx0LyoqXG4gICAgICogQ29udmVydCBhIHJlY3RhbmdsZSB0aGF0IGVuY2xvc2VzIHRoZSBnaXZlbiBkb2N1bWVudCBwaXhlbHMgaW50byBhIHJlY3RhbmdsZSBpbiBkaXNwbGF5IGNvb3JkaW5hdGVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlY3Qge0NQUmVjdH1cbiAgICAgKiBAcmV0dXJucyB7KltdfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlY3RUb0Rpc3BsYXkocmVjdCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGNlbnRlciA9IGNvb3JkVG9EaXNwbGF5KHt4OiAocmVjdC5sZWZ0ICsgcmVjdC5yaWdodCkgLyAyLCB5OiAocmVjdC50b3AgKyByZWN0LmJvdHRvbSkgLyAyfSksXG4gICAgICAgICAgICBjb29yZHMgPSByZWN0LnRvUG9pbnRzKCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvb3Jkc1tpXSA9IGNvb3JkVG9EaXNwbGF5SW50KGNvb3Jkc1tpXSk7XG5cbiAgICAgICAgICAgIC8vIE5lZWQgdG8gaW5zZXQgdGhlIGNvLW9yZGluYXRlcyBieSAwLjUgZGlzcGxheSBwaXhlbHMgZm9yIHRoZSBsaW5lIHRvIHBhc3MgdGhyb3VnaCB0aGUgbWlkZGxlIG9mIHRoZSBkaXNwbGF5IHBpeGVsXG4gICAgICAgICAgICBjb29yZHNbaV0ueCArPSAgTWF0aC5zaWduKGNlbnRlci54IC0gY29vcmRzW2ldLngpICogMC41O1xuICAgICAgICAgICAgY29vcmRzW2ldLnkgKz0gIE1hdGguc2lnbihjZW50ZXIueSAtIGNvb3Jkc1tpXS55KSAqIDAuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBjb29yZHM7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3Ryb2tlUG9seWdvbihjb250ZXh0LCBjb29yZHMpIHtcbiAgICAgICAgY29udGV4dC5iZWdpblBhdGgoKTtcblxuICAgICAgICBjb250ZXh0Lm1vdmVUbyhjb29yZHNbMF0ueCwgY29vcmRzWzBdLnkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29udGV4dC5saW5lVG8oY29vcmRzW2ldLngsIGNvb3Jkc1tpXS55KTtcbiAgICAgICAgfVxuICAgICAgICBjb250ZXh0LmxpbmVUbyhjb29yZHNbMF0ueCwgY29vcmRzWzBdLnkpO1xuXG4gICAgICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU3Ryb2tlIGEgc2VsZWN0aW9uIHJlY3RhbmdsZSB0aGF0IGVuY2xvc2VzIHRoZSBwaXhlbHMgaW4gdGhlIGdpdmVuIHJlY3RhbmdsZSAoaW4gZG9jdW1lbnQgY28tb3JkaW5hdGVzKS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwbG90U2VsZWN0aW9uUmVjdChjb250ZXh0LCByZWN0KSB7XG4gICAgICAgIHN0cm9rZVBvbHlnb24oY29udGV4dCwgcmVjdFRvRGlzcGxheShyZWN0KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGFrZSBhIENQUmVjdCBvZiBkb2N1bWVudCBjb29yZGluYXRlcyBhbmQgcmV0dXJuIGEgQ1BSZWN0IG9mIGNhbnZhcyBjb29yZGluYXRlcyB0byByZXBhaW50IGZvciB0aGF0IHJlZ2lvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRSZWZyZXNoQXJlYShyKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgcDEgPSBjb29yZFRvRGlzcGxheUludCh7eDogci5sZWZ0IC0gMSwgeTogci50b3AgLSAxfSksXG4gICAgICAgICAgICBwMiA9IGNvb3JkVG9EaXNwbGF5SW50KHt4OiByLmxlZnQgLSAxLCB5OiByLmJvdHRvbX0pLFxuICAgICAgICAgICAgcDMgPSBjb29yZFRvRGlzcGxheUludCh7eDogci5yaWdodCwgeTogci50b3AgLSAxfSksXG4gICAgICAgICAgICBwNCA9IGNvb3JkVG9EaXNwbGF5SW50KHt4OiByLnJpZ2h0LCB5OiByLmJvdHRvbX0pLFxuXG4gICAgICAgICAgICByMiA9IG5ldyBDUFJlY3QoXG4gICAgICAgICAgICAgICAgTWF0aC5taW4oTWF0aC5taW4ocDEueCwgcDIueCksIE1hdGgubWluKHAzLngsIHA0LngpKSxcbiAgICAgICAgICAgICAgICBNYXRoLm1pbihNYXRoLm1pbihwMS55LCBwMi55KSwgTWF0aC5taW4ocDMueSwgcDQueSkpLFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KE1hdGgubWF4KHAxLngsIHAyLngpLCBNYXRoLm1heChwMy54LCBwNC54KSkgKyAxLFxuICAgICAgICAgICAgICAgIE1hdGgubWF4KE1hdGgubWF4KHAxLnksIHAyLnkpLCBNYXRoLm1heChwMy55LCBwNC55KSkgKyAxXG4gICAgICAgICAgICApO1xuXG4gICAgICAgIHIyLmdyb3coMiwgMik7IC8vIHRvIGJlIHN1cmUgdG8gaW5jbHVkZSBldmVyeXRoaW5nXG5cbiAgICAgICAgcmV0dXJuIHIyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFkanVzdCB0aGUgY3VycmVudCBvZmZzZXQgdG8gYnJpbmcgdGhlIGNlbnRlciBvZiB0aGUgYXJ0d29yayB0byB0aGUgY2VudGVyIG9mIHRoZSBjYW52YXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjZW50ZXJDYW52YXMoKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgd2lkdGggPSBjYW52YXMud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQgPSBjYW52YXMuaGVpZ2h0LFxuICAgICAgICBcbiAgICAgICAgICAgIGFydHdvcmtDZW50ZXIgPSBjb29yZFRvRGlzcGxheSh7eDogYXJ0d29yay53aWR0aCAvIDIsIHk6IGFydHdvcmsuaGVpZ2h0IC8gMn0pO1xuICAgICAgICBcbiAgICAgICAgdGhhdC5zZXRPZmZzZXQoXG4gICAgICAgICAgICBNYXRoLnJvdW5kKG9mZnNldFggKyB3aWR0aCAvIDIuMCAtIGFydHdvcmtDZW50ZXIueCksXG4gICAgICAgICAgICBNYXRoLnJvdW5kKG9mZnNldFkgKyBoZWlnaHQgLyAyLjAgLSBhcnR3b3JrQ2VudGVyLnkpXG4gICAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2V0Wm9vbSA9IGZ1bmN0aW9uKF96b29tKSB7XG4gICAgICAgIHpvb20gPSBfem9vbTtcbiAgICAgICAgdXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0Wm9vbSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gem9vbTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0R3JpZFNpemUgPSBmdW5jdGlvbihfZ3JpZFNpemUpIHtcbiAgICAgICAgZ3JpZFNpemUgPSBNYXRoLm1heChNYXRoLnJvdW5kKF9ncmlkU2l6ZSksIDEpO1xuICAgICAgICB0aGlzLnJlcGFpbnRBbGwoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5nZXRHcmlkU2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gZ3JpZFNpemU7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0T2Zmc2V0ID0gZnVuY3Rpb24oeCwgeSkge1xuICAgICAgICBpZiAoaXNOYU4oeCkgfHwgaXNOYU4oeSkpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiQmFkIG9mZnNldFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG9mZnNldFggPSB4O1xuICAgICAgICAgICAgb2Zmc2V0WSA9IHk7XG4gICAgICAgICAgICB1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmdldE9mZnNldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4ge3g6IG9mZnNldFgsIHk6IG9mZnNldFl9O1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXRJbnRlcnBvbGF0aW9uID0gZnVuY3Rpb24oZW5hYmxlZCkge1xuICAgICAgICBpbnRlcnBvbGF0aW9uID0gZW5hYmxlZDtcblxuICAgICAgICBzZXRDYW52YXNJbnRlcnBvbGF0aW9uKGNhbnZhc0NvbnRleHQsIGVuYWJsZWQpO1xuXG4gICAgICAgIHRoaXMucmVwYWludEFsbCgpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFJvdGF0aW9uID0gZnVuY3Rpb24oYW5nbGUpIHtcbiAgICAgICAgY2FudmFzUm90YXRpb24gPSBhbmdsZSAlICgyICogTWF0aC5QSSk7XG4gICAgICAgIHVwZGF0ZVRyYW5zZm9ybSgpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBHZXQgY2FudmFzIHJvdGF0aW9uIGluIHJhZGlhbnMuXG4gICAgICogXG4gICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAqL1xuICAgIHRoaXMuZ2V0Um90YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbnZhc1JvdGF0aW9uO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByb3RhdGlvbiBhcyB0aGUgbmVhcmVzdCBudW1iZXIgb2Ygd2hvbGUgOTAgZGVncmVlIGNsb2Nrd2lzZSByb3RhdGlvbnMgKFswLi4zXSlcbiAgICAgKi9cbiAgICB0aGlzLmdldFJvdGF0aW9uOTAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICByb3RhdGlvbiA9IE1hdGgucm91bmQodGhpcy5nZXRSb3RhdGlvbigpIC8gTWF0aC5QSSAqIDIpO1xuICAgICAgICBcbiAgICAgICAgLy8gSnVzdCBpbiBjYXNlOlxuICAgICAgICByb3RhdGlvbiAlPSA0O1xuICAgICAgICBcbiAgICAgICAgLy8gV2Ugd2FudCBbMC4uM10gYXMgb3V0cHV0XG4gICAgICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgICAgICAgIHJvdGF0aW9uICs9IDQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiByb3RhdGlvbjtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gem9vbSBmbG9hdFxuICAgICAqIEBwYXJhbSBjZW50ZXJYIGZsb2F0IFggY28tb3JkaW5hdGUgaW4gdGhlIGNhbnZhcyBzcGFjZVxuICAgICAqIEBwYXJhbSBjZW50ZXJZIGZsb2F0IFkgY28tb3JkaW5hdGUgaW4gdGhlIGNhbnZhcyBzcGFjZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHpvb21PblBvaW50KHpvb20sIGNlbnRlclgsIGNlbnRlclkpIHtcbiAgICAgICAgem9vbSA9IE1hdGgubWF4KE1JTl9aT09NLCBNYXRoLm1pbihNQVhfWk9PTSwgem9vbSkpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRoYXQuZ2V0Wm9vbSgpICE9IHpvb20pIHtcbiAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICBvZmZzZXQgPSB0aGF0LmdldE9mZnNldCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGF0LnNldE9mZnNldChcbiAgICAgICAgICAgICAgICBvZmZzZXQueCArIH5+KChjZW50ZXJYIC0gb2Zmc2V0LngpICogKDEgLSB6b29tIC8gdGhhdC5nZXRab29tKCkpKSwgXG4gICAgICAgICAgICAgICAgb2Zmc2V0LnkgKyB+figoY2VudGVyWSAtIG9mZnNldC55KSAqICgxIC0gem9vbSAvIHRoYXQuZ2V0Wm9vbSgpKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoYXQuc2V0Wm9vbSh6b29tKTtcblxuICAgICAgICAgICAgLypDUENvbnRyb2xsZXIuQ1BWaWV3SW5mbyB2aWV3SW5mbyA9IG5ldyBDUENvbnRyb2xsZXIuQ1BWaWV3SW5mbygpO1xuICAgICAgICAgICAgdmlld0luZm8uem9vbSA9IHpvb207XG4gICAgICAgICAgICB2aWV3SW5mby5vZmZzZXRYID0gb2Zmc2V0WDtcbiAgICAgICAgICAgIHZpZXdJbmZvLm9mZnNldFkgPSBvZmZzZXRZO1xuICAgICAgICAgICAgY29udHJvbGxlci5jYWxsVmlld0xpc3RlbmVycyh2aWV3SW5mbyk7IFRPRE8gKi9cblxuICAgICAgICAgICAgdGhhdC5yZXBhaW50QWxsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLy8gTW9yZSBhZHZhbmNlZCB6b29tIG1ldGhvZHNcbiAgICBmdW5jdGlvbiB6b29tT25DZW50ZXIoem9vbSkge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICB3aWR0aCA9ICQoY2FudmFzKS53aWR0aCgpLFxuICAgICAgICAgICAgaGVpZ2h0ID0gJChjYW52YXMpLmhlaWdodCgpXG4gICAgICAgICAgICBcbiAgICAgICAgem9vbU9uUG9pbnQoem9vbSwgd2lkdGggLyAyLCBoZWlnaHQgLyAyKTtcbiAgICB9XG5cbiAgICB0aGlzLnpvb21JbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB6b29tT25DZW50ZXIodGhpcy5nZXRab29tKCkgKiAyKTtcbiAgICB9O1xuXG4gICAgdGhpcy56b29tT3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHpvb21PbkNlbnRlcih0aGlzLmdldFpvb20oKSAqIDAuNSk7XG4gICAgfTtcblxuICAgIHRoaXMuem9vbTEwMCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB6b29tT25DZW50ZXIoMSk7XG4gICAgICAgIGNlbnRlckNhbnZhcygpO1xuICAgIH07XG5cbiAgICB0aGlzLnJlc2V0Um90YXRpb24gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBjZW50ZXIgPSB7eDogY2FudmFzLndpZHRoIC8gMiwgeTogY2FudmFzLmhlaWdodCAvIDJ9LFxuXG4gICAgICAgICAgICByb3RUcmFucyA9IG5ldyBDUFRyYW5zZm9ybSgpO1xuICAgICAgICBcbiAgICAgICAgcm90VHJhbnMucm90YXRlQXJvdW5kUG9pbnQoLXRoaXMuZ2V0Um90YXRpb24oKSwgY2VudGVyLngsIGNlbnRlci55KTtcbiAgICAgICAgcm90VHJhbnMubXVsdGlwbHkodHJhbnNmb3JtKTtcblxuICAgICAgICB0aGlzLnNldE9mZnNldCh+fnJvdFRyYW5zLmdldFRyYW5zbGF0ZVgoKSwgfn5yb3RUcmFucy5nZXRUcmFuc2xhdGVZKCkpO1xuICAgICAgICB0aGlzLnNldFJvdGF0aW9uKDApO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogQWRkIHRoZSBwb2ludGVyIHByZXNzdXJlIGZpZWxkIHRvIHRoZSBnaXZlbiBwb2ludGVyIGV2ZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFBvaW50ZXJQcmVzc3VyZShlKSB7XG4gICAgICAgIC8vIFVzZSBXYWNvbSBwcmVzc3VyZSBpbiBwcmVmZXJlbmNlIHRvIHBvaW50ZXIgZXZlbnQgcHJlc3N1cmUgKGlmIHByZXNlbnQpXG4gICAgICAgIGlmICh3YWNvbVBlbkRvd24pIHtcbiAgICAgICAgICAgIHJldHVybiB0YWJsZXQuZ2V0UHJlc3N1cmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIEluIHRoZSBQb2ludGVyIEV2ZW50cyBBUEksIG1pY2UgaGF2ZSBhIGRlZmF1bHQgcHJlc3N1cmUgb2YgMC41LCBidXQgd2Ugd2FudCAxLjAuIFNpbmNlIHdlIGNhbid0IFxuICAgICAgICAgICAgICogZGlzdGluZ3Vpc2ggYmV0d2VlbiBtaWNlIGFuZCBwZW5zIGF0IHRoaXMgcG9pbnQsIHdlIGRvbid0IGhhdmUgYW55IGJldHRlciBvcHRpb25zOlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZXR1cm4gZS5wcmVzc3VyZSAqIDI7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXJcbiAgICAgICAgbW91c2VXaGVlbERlYm91bmNlID0gZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBoYW5kbGVNb3VzZVdoZWVsKGUpIHtcbiAgICAgICAgaWYgKGUuZGVsdGFZICE9IDApIHtcbiAgICAgICAgICAgIGlmICghbW91c2VXaGVlbERlYm91bmNlIHx8IE1hdGguYWJzKGUuZGVsdGFZKSA+IDIwKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcjtcblxuICAgICAgICAgICAgICAgIGlmIChlLmRlbHRhWSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yID0gMSAvIDEuMTU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmFjdG9yID0gMS4xNTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzUG9pbnQgPSBtb3VzZUNvb3JkVG9DYW52YXMoe3g6IGUucGFnZVgsIHk6IGUucGFnZVl9KSxcbiAgICAgICAgICAgICAgICAgICAgZG9jUG9pbnQgPSBjb29yZFRvRG9jdW1lbnQoY2FudmFzUG9pbnQpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGFydHdvcmsuaXNQb2ludFdpdGhpbihkb2NQb2ludC54LCBkb2NQb2ludC55KSkge1xuICAgICAgICAgICAgICAgICAgICB6b29tT25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZ2V0Wm9vbSgpICogZmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2FudmFzUG9pbnQueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbnZhc1BvaW50LnlcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB6b29tT25Qb2ludChcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZ2V0Wm9vbSgpICogZmFjdG9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0WCArIH5+KGFydHdvcmsud2lkdGggKiB6b29tIC8gMiksXG4gICAgICAgICAgICAgICAgICAgICAgICBvZmZzZXRZICsgfn4oYXJ0d29yay5oZWlnaHQgKiB6b29tIC8gMilcbiAgICAgICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBtb3VzZVdoZWVsRGVib3VuY2UgPSBtb3VzZVdoZWVsRGVib3VuY2UgfHwgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VXaGVlbERlYm91bmNlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfSwgNTApO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXJcbiAgICAgICAgY2FudmFzQ2xpZW50UmVjdDtcblxuICAgIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJNb3ZlKGUpIHtcbiAgICAgICAgLy8gVXNlIHRoZSBjYWNoZWQgcG9zaXRpb24gb2YgdGhlIGNhbnZhcyBvbiB0aGUgcGFnZSBpZiBwb3NzaWJsZVxuICAgICAgICBpZiAoIWNhbnZhc0NsaWVudFJlY3QpIHtcbiAgICAgICAgICAgIGNhbnZhc0NsaWVudFJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKiBTdG9yZSB0aGVzZSBnbG9iYWxseSBmb3IgdGhlIGV2ZW50IGhhbmRsZXJzIHRvIHJlZmVyIHRvICh3ZSdkIHdyaXRlIHRvIHRoZSBldmVudCBpdHNlbGYgYnV0IHNvbWUgYnJvd3NlcnNcbiAgICAgICAgICogZG9uJ3QgZW5qb3kgdGhhdClcbiAgICAgICAgICovXG4gICAgICAgIG1vdXNlWCA9IGUuY2xpZW50WCAtIGNhbnZhc0NsaWVudFJlY3QubGVmdDtcbiAgICAgICAgbW91c2VZID0gZS5jbGllbnRZIC0gY2FudmFzQ2xpZW50UmVjdC50b3A7XG5cbiAgICAgICAgLy8gRmxhZ3MgdXNlZCBieSBlLmJ1dHRvbnNcbiAgICAgICAgY29uc3RcbiAgICAgICAgICAgIEZMQUdfUFJJTUFSWSA9IDEsXG4gICAgICAgICAgICBGTEFHX1NFQ09OREFSWSA9IDIsXG4gICAgICAgICAgICBGTEFHX1dIRUVMID0gNDtcblxuICAgICAgICB2YXJcbiAgICAgICAgICAgIGlzRHJhZ2dpbmcgPSBlLmJ1dHRvbnMgIT0gMCxcbiAgICAgICAgICAgIHByZXNzdXJlID0gZ2V0UG9pbnRlclByZXNzdXJlKGUpO1xuXG5cdFx0Ly8gRGlkIGFueSBvZiBvdXIgYnV0dG9ucyBjaGFuZ2Ugc3RhdGU/XG4gICAgICAgIGlmICgoKGUuYnV0dG9ucyAmIEZMQUdfUFJJTUFSWSkgIT0gMCkgIT0gbW91c2VEb3duW0JVVFRPTl9QUklNQVJZXSkge1xuICAgICAgICAgICAgaWYgKGUubW96UHJlc3N1cmUgPT09IDAuNSkge1xuICAgICAgICAgICAgICAgIC8qIFdlIHJlY2VpdmVkIGEgTW96aWxsYSBcImNsaWNrXCIgbGV2ZWwgb2YgcHJlc3N1cmUgKDAuNSkgYXMgYSBwb2ludGVyLW1vdmVcbiAgICAgICAgICAgICAgICAgKiBiZWZvcmUgd2UgcmVjZWl2ZWQgdGhlIGFjdHVhbCBtb3VzZURvd24gZXZlbnQgKHdoaWNoIGNhcnJpZXMgdGhlIGNvcnJlY3QgcHJlc3N1cmUpLlxuICAgICAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgICAgICogT2JzZXJ2ZWQgb24gRmlyZWZveCA1NiBvbiBtYWNPUyBIaWdoIFNpZXJyYVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gSWdub3JlIVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBtb3VzZURvd25bQlVUVE9OX1BSSU1BUlldID0gIW1vdXNlRG93bltCVVRUT05fUFJJTUFSWV07XG5cbiAgICAgICAgICAgIGlmIChtb3VzZURvd25bQlVUVE9OX1BSSU1BUlldKSB7XG4gICAgICAgICAgICAgICAgbW9kZVN0YWNrLm1vdXNlRG93bihlLCBCVVRUT05fUFJJTUFSWSwgcHJlc3N1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlU3RhY2subW91c2VVcChlLCBCVVRUT05fUFJJTUFSWSwgcHJlc3N1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCgoZS5idXR0b25zICYgRkxBR19TRUNPTkRBUlkpICE9IDApICE9IG1vdXNlRG93bltCVVRUT05fU0VDT05EQVJZXSkge1xuICAgICAgICAgICAgbW91c2VEb3duW0JVVFRPTl9TRUNPTkRBUlldID0gIW1vdXNlRG93bltCVVRUT05fU0VDT05EQVJZXTtcblxuICAgICAgICAgICAgaWYgKG1vdXNlRG93bltCVVRUT05fU0VDT05EQVJZXSkge1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5tb3VzZURvd24oZSwgQlVUVE9OX1NFQ09OREFSWSwgcHJlc3N1cmUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBtb2RlU3RhY2subW91c2VVcChlLCBCVVRUT05fU0VDT05EQVJZLCBwcmVzc3VyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoKChlLmJ1dHRvbnMgJiBGTEFHX1dIRUVMKSAhPSAwKSAhPSBtb3VzZURvd25bQlVUVE9OX1dIRUVMXSkge1xuICAgICAgICAgICAgbW91c2VEb3duW0JVVFRPTl9XSEVFTF0gPSAhbW91c2VEb3duW0JVVFRPTl9XSEVFTF07XG5cbiAgICAgICAgICAgIGlmIChtb3VzZURvd25bQlVUVE9OX1dIRUVMXSkge1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5tb3VzZURvd24oZSwgQlVUVE9OX1dIRUVMLCBwcmVzc3VyZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5tb3VzZVVwKGUsIEJVVFRPTl9XSEVFTCwgcHJlc3N1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGlzRHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIG1vZGVTdGFjay5tb3VzZURyYWcoZSwgcHJlc3N1cmUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbW9kZVN0YWNrLm1vdXNlTW92ZShlLCBwcmVzc3VyZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgd2hlbiBhbGwgbW91c2UvcG9pbnRlciBidXR0b25zIGFyZSByZWxlYXNlZFxuICAgIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXJVcChlKSB7XG4gICAgICAgIG1vdXNlRG93bltCVVRUT05fUFJJTUFSWV0gPSBmYWxzZTtcbiAgICAgICAgbW91c2VEb3duW0JVVFRPTl9TRUNPTkRBUlldID0gZmFsc2U7XG4gICAgICAgIG1vdXNlRG93bltCVVRUT05fV0hFRUxdID0gZmFsc2U7XG5cbiAgICAgICAgd2Fjb21QZW5Eb3duID0gZmFsc2U7XG4gICAgICAgIG1vZGVTdGFjay5tb3VzZVVwKGUsIGUuYnV0dG9uLCAwLjApO1xuICAgICAgICBjYW52YXMucmVsZWFzZVBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICB9XG5cbiAgICAvLyBDYWxsZWQgd2hlbiB0aGUgZmlyc3QgYnV0dG9uIG9uIHRoZSBwb2ludGVyIGlzIGRlcHJlc3NlZCAvIHBlbiB0b3VjaGVzIHRoZSBzdXJmYWNlXG4gICAgZnVuY3Rpb24gaGFuZGxlUG9pbnRlckRvd24oZSkge1xuICAgICAgICBjYW52YXMuc2V0UG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xuXG4gICAgICAgIGNhbnZhc0NsaWVudFJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlc2UgZ2xvYmFsbHkgZm9yIHRoZSBldmVudCBoYW5kbGVycyB0byByZWZlciB0b1xuICAgICAgICBtb3VzZVggPSBlLmNsaWVudFggLSBjYW52YXNDbGllbnRSZWN0LmxlZnQ7XG4gICAgICAgIG1vdXNlWSA9IGUuY2xpZW50WSAtIGNhbnZhc0NsaWVudFJlY3QudG9wO1xuXG4gICAgICAgIHdhY29tUGVuRG93biA9IHRhYmxldC5pc1BlbigpO1xuXG4gICAgICAgIG1vdXNlRG93bltCVVRUT05fUFJJTUFSWV0gPSBmYWxzZTtcbiAgICAgICAgbW91c2VEb3duW0JVVFRPTl9TRUNPTkRBUlldID0gZmFsc2U7XG4gICAgICAgIG1vdXNlRG93bltCVVRUT05fV0hFRUxdID0gZmFsc2U7XG5cbiAgICAgICAgbW91c2VEb3duW2UuYnV0dG9uXSA9IHRydWU7XG5cbiAgICAgICAgbW9kZVN0YWNrLm1vdXNlRG93bihlLCBlLmJ1dHRvbiwgZ2V0UG9pbnRlclByZXNzdXJlKGUpKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gaGFuZGxlS2V5RG93bihlKSB7XG4gICAgICAgIG1vZGVTdGFjay5rZXlEb3duKGUpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBoYW5kbGVLZXlVcChlKSB7XG4gICAgICAgIG1vZGVTdGFjay5rZXlVcChlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gR2V0IHRoZSBET00gZWxlbWVudCBmb3IgdGhlIGNhbnZhcyBhcmVhXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjYW52YXNDb250YWluZXI7XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBTY2hlZHVsZSBhIHJlcGFpbnQgZm9yIHRoZSBjdXJyZW50IHJlcGFpbnQgcmVnaW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGFpbnQoKSB7XG4gICAgICAgIGlmICghc2NoZWR1bGVkUmVwYWludCkge1xuICAgICAgICAgICAgc2NoZWR1bGVkUmVwYWludCA9IHRydWU7XG4gICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHRoYXQucGFpbnQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGEgcmVwYWludCBmb3IgdGhlIGVudGlyZSBzY3JlZW4uXG4gICAgICovXG4gICAgdGhpcy5yZXBhaW50QWxsID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJlcGFpbnRSZWdpb24ubGVmdCA9IDA7XG4gICAgICAgIHJlcGFpbnRSZWdpb24udG9wID0gMDtcbiAgICAgICAgcmVwYWludFJlZ2lvbi5yaWdodCA9IGNhbnZhcy53aWR0aDtcbiAgICAgICAgcmVwYWludFJlZ2lvbi5ib3R0b20gPSBjYW52YXMuaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgcmVwYWludCgpO1xuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogU2NoZWR1bGUgYSByZXBhaW50IGZvciBhbiBhcmVhIG9mIHRoZSBzY3JlZW4gZm9yIGxhdGVyLlxuICAgICAqIFxuICAgICAqIEBwYXJhbSByZWN0IENQUmVjdCBSZWdpb24gdGhhdCBzaG91bGQgYmUgcmVwYWludGVkIHVzaW5nIGRpc3BsYXkgY29vcmRpbmF0ZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBhaW50UmVjdChyZWN0KSB7XG4gICAgICAgIHJlcGFpbnRSZWdpb24udW5pb24ocmVjdCk7XG4gICAgICAgIFxuICAgICAgICByZXBhaW50KCk7XG4gICAgfVxuXG5cdC8qKlxuICAgICAqIFNldCB0aGUgZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uIGFuZCBmaWxsL3N0cm9rZSBjb2xvciB1cCB0byBtYXhpbWl6ZSBjb250cmFzdCBmb3IgdGhlIGRyYXduIGl0ZW1zXG4gICAgICogYWdhaW5zdCBhcmJpdHJhcnkgYmFja2dyb3VuZHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2FudmFzQ29udGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBraW5kIC0gXCJzdHJva2VcIiBvciBcImZpbGxcIiBkZXBlbmRpbmcgb24gd2hpY2ggY29sb3VyIHlvdSdkIGxpa2UgdG8gc2V0XG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q29udHJhc3RpbmdEcmF3U3R5bGUoY2FudmFzQ29udGV4dCwga2luZCkge1xuICAgICAgICBraW5kID0ga2luZCArIFwiU3R5bGVcIjtcbiAgICAgICAgY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZXhjbHVzaW9uJztcblxuICAgICAgICBpZiAoY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPT0gXCJleGNsdXNpb25cIikge1xuICAgICAgICAgICAgLy8gV2hpdGUgKyBleGNsdXNpb24gaW52ZXJ0cyB0aGUgY29sb3JzIHVuZGVybmVhdGgsIGdpdmluZyB1cyBnb29kIGNvbnRyYXN0XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0W2tpbmRdID0gJ3doaXRlJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIElFIEVkZ2UgZG9lc24ndCBzdXBwb3J0IEV4Y2x1c2lvbiwgc28gaG93IGFib3V0IERpZmZlcmVuY2Ugd2l0aCBtaWQtZ3JleSBpbnN0ZWFkXG4gICAgICAgICAgICAvLyBUaGlzIGlzIHZpc2libGUgb24gYmxhY2sgYW5kIHdoaXRlLCBidXQgZGlzYXBwZWFycyBvbiBhIGdyZXkgYmFja2dyb3VuZFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZGlmZmVyZW5jZSc7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0W2tpbmRdID0gJyM4ODgnO1xuXG4gICAgICAgICAgICAvLyBGb3Igc3VwZXIgZHVtYiBicm93c2VycyAob25seSBzdXBwb3J0IHNvdXJjZS1vdmVyKSwgYXQgbGVhc3QgZG9uJ3QgbWFrZSB0aGUgY3Vyc29yIGludmlzaWJsZSBvbiBhIHdoaXRlIEJHIVxuICAgICAgICAgICAgaWYgKGNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uICE9IFwiZGlmZmVyZW5jZVwiKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dFtraW5kXSA9ICdibGFjayc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5wYWludCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGRyYXdpbmdXYXNDbGlwcGVkID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICBzY2hlZHVsZWRSZXBhaW50ID0gZmFsc2U7XG4gICAgICAgIFxuICAgICAgICAvKiBDbGlwIGRyYXdpbmcgdG8gdGhlIGFyZWEgb2YgdGhlIHNjcmVlbiB3ZSB3YW50IHRvIHJlcGFpbnQgKi9cbiAgICAgICAgaWYgKCFyZXBhaW50UmVnaW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChjYW52YXNDb250ZXh0LmNsaXApIHtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgICAgICAgICAgcmVwYWludFJlZ2lvbi5sZWZ0ID0gcmVwYWludFJlZ2lvbi5sZWZ0IHwgMDsgXG4gICAgICAgICAgICAgICAgcmVwYWludFJlZ2lvbi50b3AgPSByZXBhaW50UmVnaW9uLnRvcCB8IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5yZWN0KFxuICAgICAgICAgICAgICAgICAgICByZXBhaW50UmVnaW9uLmxlZnQsXG4gICAgICAgICAgICAgICAgICAgIHJlcGFpbnRSZWdpb24udG9wLFxuICAgICAgICAgICAgICAgICAgICBNYXRoLmNlaWwocmVwYWludFJlZ2lvbi5nZXRXaWR0aCgpKSxcbiAgICAgICAgICAgICAgICAgICAgTWF0aC5jZWlsKHJlcGFpbnRSZWdpb24uZ2V0SGVpZ2h0KCkpXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuY2xpcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBkcmF3aW5nV2FzQ2xpcHBlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8qIENvcHkgcGl4ZWxzIHRoYXQgY2hhbmdlZCBpbiB0aGUgZG9jdW1lbnQgaW50byBvdXIgbG9jYWwgZnVzZWQgaW1hZ2UgY2FjaGUgKi9cbiAgICAgICAgaWYgKCFhcnR3b3JrVXBkYXRlUmVnaW9uLmlzRW1wdHkoKSkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgaW1hZ2VEYXRhID0gYXJ0d29yay5mdXNpb25MYXllcnMoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYXJ0d29ya0NhbnZhc0NvbnRleHQucHV0SW1hZ2VEYXRhKFxuICAgICAgICAgICAgICAgIGltYWdlRGF0YSwgMCwgMCwgYXJ0d29ya1VwZGF0ZVJlZ2lvbi5sZWZ0LCBhcnR3b3JrVXBkYXRlUmVnaW9uLnRvcCwgYXJ0d29ya1VwZGF0ZVJlZ2lvbi5nZXRXaWR0aCgpLCBhcnR3b3JrVXBkYXRlUmVnaW9uLmdldEhlaWdodCgpXG4gICAgICAgICAgICApO1xuXG4gICAgICAgICAgICBhcnR3b3JrVXBkYXRlUmVnaW9uLm1ha2VFbXB0eSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSAnIzYwNjA2MCc7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFJlY3QoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIC8vIFRyYW5zZm9ybSB0aGUgY29vcmRpbmF0ZSBzeXN0ZW0gdG8gYnJpbmcgdGhlIGRvY3VtZW50IGludG8gdGhlIHJpZ2h0IHBvc2l0aW9uIG9uIHRoZSBzY3JlZW4gKHRyYW5zbGF0ZS96b29tL2V0YylcbiAgICAgICAgY2FudmFzQ29udGV4dC5zYXZlKCk7XG4gICAgICAgIHtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKHRyYW5zZm9ybS5tWzBdLCB0cmFuc2Zvcm0ubVsxXSwgdHJhbnNmb3JtLm1bMl0sIHRyYW5zZm9ybS5tWzNdLCB0cmFuc2Zvcm0ubVs0XSwgdHJhbnNmb3JtLm1bNV0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9IGNoZWNrZXJib2FyZFBhdHRlcm47XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmZpbGxSZWN0KDAsIDAsIGFydHdvcmsud2lkdGgsIGFydHdvcmsuaGVpZ2h0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICAgICAgYXJ0d29ya0NhbnZhcywgMCwgMCwgYXJ0d29ya0NhbnZhcy53aWR0aCwgYXJ0d29ya0NhbnZhcy5oZWlnaHRcbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBUaGUgcmVzdCBvZiB0aGUgZHJhd2luZyBoYXBwZW5zIHVzaW5nIHRoZSBvcmlnaW5hbCBzY3JlZW4gY29vcmRpbmF0ZSBzeXN0ZW1cbiAgICAgICAgc2V0Q29udHJhc3RpbmdEcmF3U3R5bGUoY2FudmFzQ29udGV4dCwgXCJzdHJva2VcIik7XG5cbiAgICAgICAgY2FudmFzQ29udGV4dC5saW5lV2lkdGggPSAxLjA7XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IHRoZSBhcnR3b3JrIHNlbGVjdGlvbiBzbyBsb25nIGFzIHdlJ3JlIG5vdCBpbiB0aGUgbWlkZGxlIG9mIHNlbGVjdGluZyBhIG5ldyByZWN0YW5nbGVcbiAgICAgICAgaWYgKCFhcnR3b3JrLmdldFNlbGVjdGlvbigpLmlzRW1wdHkoKSAmJiAhKG1vZGVTdGFjay5wZWVrKCkgaW5zdGFuY2VvZiBDUFJlY3RTZWxlY3Rpb25Nb2RlICYmIG1vZGVTdGFjay5wZWVrKCkuY2FwdHVyZSkpIHtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuc2V0TGluZURhc2goWzMsIDJdKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcGxvdFNlbGVjdGlvblJlY3QoY2FudmFzQ29udGV4dCwgYXJ0d29yay5nZXRTZWxlY3Rpb24oKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuc2V0TGluZURhc2goW10pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvLyBEcmF3IGdyaWRcbiAgICAgICAgaWYgKHNob3dHcmlkKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBib3VuZHMgPSBhcnR3b3JrLmdldEJvdW5kcygpLFxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGdyaWRWaXN1YWxQaXRjaCA9IHpvb20gKiBncmlkU2l6ZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogSWYgdGhlIGdyaWQgaXMgZ29pbmcgdG8gYmUgbWluaXNjdWxlIG9uIHRoZSBzY3JlZW4gKGJhc2ljYWxseSBqdXN0IGNvdmVyaW5nL2ludmVydGluZyB0aGUgZW50aXJlIGFydHdvcmssXG4gICAgICAgICAgICAgKiBkbyBub3QgcGFpbnQgaXQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGlmIChncmlkVmlzdWFsUGl0Y2ggPiAyKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBsaW5lc1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSBncmlkU2l6ZSAtIDE7IGkgPCBib3VuZHMucmlnaHQ7IGkgKz0gZ3JpZFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBwMSA9IGNvb3JkVG9EaXNwbGF5KHt4OiBpLCB5OiBib3VuZHMudG9wfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBwMiA9IGNvb3JkVG9EaXNwbGF5KHt4OiBpLCB5OiBib3VuZHMuYm90dG9tfSk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0Lm1vdmVUbyhwMS54ICsgMC41LCBwMS55ICsgMC41KTtcbiAgICAgICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5saW5lVG8ocDIueCArIDAuNSwgcDIueSArIDAuNSk7XG4gICAgICAgICAgICAgICAgfVxuICAgIFxuICAgICAgICAgICAgICAgIC8vIEhvcml6b250YWwgbGluZXNcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gZ3JpZFNpemUgLSAxOyBpIDwgYm91bmRzLmJvdHRvbTsgaSArPSBncmlkU2l6ZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHAxID0gY29vcmRUb0Rpc3BsYXkoe3g6IDAsIHk6IGl9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHAyID0gY29vcmRUb0Rpc3BsYXkoe3g6IGJvdW5kcy5yaWdodCwgeTogaX0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQubW92ZVRvKHAxLnggKyAwLjUsIHAxLnkgKyAwLjUpO1xuICAgICAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0LmxpbmVUbyhwMi54ICsgMC41LCBwMi55ICsgMC41KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgXG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gQWRkaXRpb25hbCBkcmF3aW5nIGJ5IHRoZSBjdXJyZW50IG1vZGVcbiAgICAgICAgbW9kZVN0YWNrLnBhaW50KGNhbnZhc0NvbnRleHQpO1xuICAgICAgICBcbiAgICAgICAgY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgICAgICBcbiAgICAgICAgaWYgKGRyYXdpbmdXYXNDbGlwcGVkKSB7XG4gICAgICAgICAgICByZXBhaW50UmVnaW9uLm1ha2VFbXB0eSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgdGhpcy5zaG93R3JpZCA9IGZ1bmN0aW9uKHNob3cpIHtcbiAgICAgICAgc2hvd0dyaWQgPSBzaG93O1xuICAgICAgICB0aGlzLnJlcGFpbnRBbGwoKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogUmVzaXplIHRoZSBjYW52YXMgYXJlYSB0byB0aGUgZ2l2ZW4gaGVpZ2h0IChpbiBwaXhlbHMpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2ludH0gaGVpZ2h0IE5ldyBjYW52YXMgYXJlYSBoZWlnaHQgaW4gQ1NTIHBpeGVsc1xuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gc2tpcENlbnRlciBUcnVlIGlmIHRoZSBjYW52YXMgc2hvdWxkIG5vdCBiZSByZS1jZW50ZXJlZFxuICAgICAqL1xuICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24oaGVpZ2h0LCBza2lwQ2VudGVyKSB7XG4gICAgICAgIC8vIExlYXZlIHJvb20gZm9yIHRoZSBib3R0b20gc2Nyb2xsYmFyXG4gICAgICAgIGhlaWdodCAtPSAkKGNhbnZhc0NvbnRhaW5lckJvdHRvbSkub3V0ZXJIZWlnaHQoKTtcblxuICAgICAgICAkKGNhbnZhcykuY3NzKCdoZWlnaHQnLCBoZWlnaHQgKyBcInB4XCIpO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9ICQoY2FudmFzKS53aWR0aCgpO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIGNhbnZhc0NsaWVudFJlY3QgPSBudWxsO1xuXG4gICAgICAgIGlmICghc2tpcENlbnRlcikge1xuICAgICAgICAgICAgY2VudGVyQ2FudmFzKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJbnRlcnBvbGF0aW9uIHByb3BlcnR5IGdldHMgcmVzZXQgd2hlbiBjYW52YXMgcmVzaXplc1xuICAgICAgICB0aGlzLnNldEludGVycG9sYXRpb24oaW50ZXJwb2xhdGlvbik7XG5cbiAgICAgICAgdGhpcy5yZXBhaW50QWxsKCk7XG4gICAgfTtcblxuICAgIGNvbnRyb2xsZXIub24oXCJ0b29sQ2hhbmdlXCIsIGZ1bmN0aW9uKHRvb2wsIHRvb2xJbmZvKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbmV3TW9kZSA9IGRyYXdpbmdNb2Rlc1t0b29sSW5mby5zdHJva2VNb2RlXTtcblxuICAgICAgICAvLyBJZiB3ZSBjdXJyZW50bHkgaGF2ZSBhbnkgZHJhd2luZyBtb2RlcyBhY3RpdmUsIHN3aXRjaCB0aGVtIHRvIHRoZSBkcmF3aW5nIG1vZGUgb2YgdGhlIG5ldyB0b29sXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbW9kZVN0YWNrLm1vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAobW9kZVN0YWNrLm1vZGVzW2ldIGluc3RhbmNlb2YgQ1BEcmF3aW5nTW9kZSkge1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5tb2Rlc1tpXS5sZWF2ZSgpO1xuICAgICAgICAgICAgICAgIG1vZGVTdGFjay5tb2Rlc1tpXSA9IG5ld01vZGU7XG4gICAgICAgICAgICAgICAgbW9kZVN0YWNrLm1vZGVzW2ldLmVudGVyKCk7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGN1ckRyYXdNb2RlID0gbmV3TW9kZTtcbiAgICB9KTtcbiAgICBcbiAgICBjb250cm9sbGVyLm9uKFwibW9kZUNoYW5nZVwiLCBmdW5jdGlvbihtb2RlKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbmV3TW9kZTtcblxuICAgICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgICAgIGNhc2UgQ2hpY2tlblBhaW50Lk1fRFJBVzpcbiAgICAgICAgICAgICAgICBuZXdNb2RlID0gY3VyRHJhd01vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgXG4gICAgICAgICAgICBjYXNlIENoaWNrZW5QYWludC5NX0ZMT09ERklMTDpcbiAgICAgICAgICAgICAgICBuZXdNb2RlID0gZmxvb2RGaWxsTW9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSBDaGlja2VuUGFpbnQuTV9HUkFESUVOVEZJTEw6XG4gICAgICAgICAgICAgICAgbmV3TW9kZSA9IGdyYWRpZW50RmlsbE1vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ2hpY2tlblBhaW50Lk1fUkVDVF9TRUxFQ1RJT046XG4gICAgICAgICAgICAgICAgbmV3TW9kZSA9IHJlY3RTZWxlY3Rpb25Nb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgIFxuICAgICAgICAgICAgY2FzZSBDaGlja2VuUGFpbnQuTV9NT1ZFX1RPT0w6XG4gICAgICAgICAgICAgICAgbmV3TW9kZSA9IG1vdmVUb29sTW9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICBcbiAgICAgICAgICAgIGNhc2UgQ2hpY2tlblBhaW50Lk1fUk9UQVRFX0NBTlZBUzpcbiAgICAgICAgICAgICAgICBuZXdNb2RlID0gcm90YXRlQ2FudmFzTW9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICBcbiAgICAgICAgICAgIGNhc2UgQ2hpY2tlblBhaW50Lk1fQ09MT1JfUElDS0VSOlxuICAgICAgICAgICAgICAgIG5ld01vZGUgPSBjb2xvclBpY2tlck1vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgQ2hpY2tlblBhaW50Lk1fVFJBTlNGT1JNOlxuICAgICAgICAgICAgICAgIG5ld01vZGUgPSB0cmFuc2Zvcm1Nb2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgbW9kZVN0YWNrLnNldFVzZXJNb2RlKG5ld01vZGUpO1xuICAgIH0pO1xuICAgIFxuICAgIC8vXG4gICAgLy8gTW9kZXMgc3lzdGVtOiBtb2RlcyBjb250cm9sIHRoZSB3YXkgdGhlIEdVSSBpcyByZWFjdGluZyB0byB0aGUgdXNlciBpbnB1dFxuICAgIC8vIEFsbCB0aGUgdG9vbHMgYXJlIGltcGxlbWVudGVkIHRocm91Z2ggbW9kZXNcbiAgICAvL1xuICAgIFxuICAgIGRlZmF1bHRNb2RlID0gbmV3IENQRGVmYXVsdE1vZGUoKTtcbiAgICBjb2xvclBpY2tlck1vZGUgPSBuZXcgQ1BDb2xvclBpY2tlck1vZGUoKTtcbiAgICBwYW5Nb2RlID0gbmV3IENQUGFuTW9kZSgpO1xuICAgIHJvdGF0ZUNhbnZhc01vZGUgPSBuZXcgQ1BSb3RhdGVDYW52YXNNb2RlKCk7XG4gICAgZmxvb2RGaWxsTW9kZSA9IG5ldyBDUEZsb29kRmlsbE1vZGUoKTtcbiAgICBncmFkaWVudEZpbGxNb2RlID0gbmV3IENQR3JhZGllbnRGaWxsTW9kZSgpO1xuICAgIHJlY3RTZWxlY3Rpb25Nb2RlID0gbmV3IENQUmVjdFNlbGVjdGlvbk1vZGUoKTtcbiAgICBtb3ZlVG9vbE1vZGUgPSBuZXcgQ1BNb3ZlVG9vbE1vZGUoKTtcbiAgICB0cmFuc2Zvcm1Nb2RlID0gbmV3IENQVHJhbnNmb3JtTW9kZSgpO1xuXG4gICAgLy8gdGhpcyBtdXN0IGNvcnJlc3BvbmQgdG8gdGhlIHN0cm9rZSBtb2RlcyBkZWZpbmVkIGluIENQVG9vbEluZm9cbiAgICBkcmF3aW5nTW9kZXMgPSBbbmV3IENQRnJlZWhhbmRNb2RlKCksIG5ldyBDUExpbmVNb2RlKCksIG5ldyBDUEJlemllck1vZGUoKV07XG5cbiAgICBjdXJEcmF3TW9kZSA9IGRyYXdpbmdNb2Rlc1tDUEJydXNoSW5mby5TTV9GUkVFSEFORF07XG5cbiAgICAvLyBUaGUgZGVmYXVsdCBtb2RlIHdpbGwgaGFuZGxlIHRoZSBldmVudHMgdGhhdCBubyBvdGhlciBtb2RlcyBhcmUgaW50ZXJlc3RlZCBpblxuICAgIG1vZGVTdGFjay5zZXREZWZhdWx0TW9kZShkZWZhdWx0TW9kZSk7XG4gICAgbW9kZVN0YWNrLnNldFVzZXJNb2RlKGN1ckRyYXdNb2RlKTtcblxuICAgIGFydHdvcmtDYW52YXMud2lkdGggPSBhcnR3b3JrLndpZHRoO1xuICAgIGFydHdvcmtDYW52YXMuaGVpZ2h0ID0gYXJ0d29yay5oZWlnaHQ7XG4gICAgXG4gICAgY2FudmFzLndpZHRoID0gODAwO1xuICAgIGNhbnZhcy5oZWlnaHQgPSA5MDA7XG4gICAgY2FudmFzLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LWNhbnZhc1wiO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuICAgIFxuICAgIGlmICghY2FudmFzQ29udGV4dC5zZXRMaW5lRGFzaCkgeyBcbiAgICAgICAgY2FudmFzQ29udGV4dC5zZXRMaW5lRGFzaCA9IGZ1bmN0aW9uICgpIHt9OyAvLyBGb3IgSUUgMTAgYW5kIG9sZGVyXG4gICAgfVxuICAgIFxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG4gICAgXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBtb3VzZUluID0gdHJ1ZTtcbiAgICB9KTtcbiAgICBcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIG1vdXNlSW4gPSBmYWxzZTtcbiAgICAgICAgXG4gICAgICAgIGlmICghbW91c2VEb3duW0JVVFRPTl9QUklNQVJZXSAmJiAhbW91c2VEb3duW0JVVFRPTl9TRUNPTkRBUlldICYmICFtb3VzZURvd25bQlVUVE9OX1dIRUVMXSkge1xuICAgICAgICAgICAgdGhhdC5yZXBhaW50QWxsKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIGhhbmRsZVBvaW50ZXJEb3duKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGhhbmRsZVBvaW50ZXJNb3ZlKTtcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBoYW5kbGVQb2ludGVyVXApO1xuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwid2hlZWxcIiwgaGFuZGxlTW91c2VXaGVlbCk7XG4gICAgXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgaGFuZGxlS2V5RG93bik7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGhhbmRsZUtleVVwKTtcblxuICAgIC8qIFdvcmthcm91bmQgZm9yIENocm9tZSBNYWMgYnVnIHRoYXQgY2F1c2VzIGNhbnZhcyB0byBiZSBkaXNwb3NlZCBhbmQgbmV2ZXIgcmVjcmVhdGVkIHdoZW4gdGFiIGlzIHN3aXRjaGVkIGludG8gdGhlIFxuICAgICAqIGJhY2tncm91bmQgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NTg4NDM0XG4gICAgICovXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgb2xkSGVpZ2h0ID0gY2FudmFzLmhlaWdodCArICQoY2FudmFzQ29udGFpbmVyQm90dG9tKS5vdXRlckhlaWdodCgpO1xuXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuXG4gICAgICAgIHRoYXQucmVzaXplKG9sZEhlaWdodCwgdHJ1ZSk7XG4gICAgfSwgZmFsc2UpO1xuICAgIFxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwic2Nyb2xsXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICBjYW52YXNDbGllbnRSZWN0ID0gbnVsbDtcbiAgICB9KTtcbiAgICBcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChlLmJ1dHRvbiA9PSBCVVRUT05fV0hFRUwpIHtcbiAgICAgICAgICAgIC8vIFByZXZlbnQgbWlkZGxlLW1vdXNlIHNjcm9sbGluZyBpbiBGaXJlZm94XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGFydHdvcmsub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFdlIGNvdWxkIGtlZXAgdHJhY2sgb2Ygb3VyIGxhc3QtcGFpbnRlZCBzZWxlY3Rpb24gcmVjdCBhbmQgb25seSBpbnZhbGlkYXRlIHRoYXQgaGVyZVxuICAgICAgICB0aGF0LnJlcGFpbnRBbGwoKTtcbiAgICB9KTtcbiAgICBcbiAgICBhcnR3b3JrLm9uKFwidXBkYXRlUmVnaW9uXCIsIGZ1bmN0aW9uKHJlZ2lvbikge1xuICAgICAgICBhcnR3b3JrVXBkYXRlUmVnaW9uLnVuaW9uKHJlZ2lvbik7XG4gICAgICAgIFxuICAgICAgICByZXBhaW50UmVjdChnZXRSZWZyZXNoQXJlYShhcnR3b3JrVXBkYXRlUmVnaW9uKSk7XG4gICAgfSk7XG4gICAgXG4gICAgaG9yelNjcm9sbC5vbihcInZhbHVlQ2hhbmdlZFwiLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBwID0gdGhhdC5nZXRPZmZzZXQoKTtcbiAgICAgICAgXG4gICAgICAgIHRoYXQuc2V0T2Zmc2V0KC12YWx1ZSwgcC55KTtcbiAgICB9KTtcbiAgICBcbiAgICB2ZXJ0U2Nyb2xsLm9uKFwidmFsdWVDaGFuZ2VkXCIsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIHAgPSB0aGF0LmdldE9mZnNldCgpO1xuICAgICAgICBcbiAgICAgICAgdGhhdC5zZXRPZmZzZXQocC54LCAtdmFsdWUpO1xuICAgIH0pO1xuICAgIFxuICAgIHRoaXMuc2V0SW50ZXJwb2xhdGlvbihmYWxzZSk7XG5cbiAgICB2YXJcbiAgICAgICAgY2FudmFzU3BhY2luZ1dyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIFxuICAgIGNhbnZhc1NwYWNpbmdXcmFwcGVyLmNsYXNzTmFtZSA9ICdjaGlja2VucGFpbnQtY2FudmFzLWNvbnRhaW5lci13cmFwcGVyJztcbiAgICBjYW52YXNTcGFjaW5nV3JhcHBlci5hcHBlbmRDaGlsZChjYW52YXMpO1xuICAgIFxuICAgIGNhbnZhc0NvbnRhaW5lclRvcC5jbGFzc05hbWUgPSAnY2hpY2tlbnBhaW50LWNhbnZhcy1jb250YWluZXItdG9wJztcbiAgICBjYW52YXNDb250YWluZXJUb3AuYXBwZW5kQ2hpbGQoY2FudmFzU3BhY2luZ1dyYXBwZXIpO1xuICAgIGNhbnZhc0NvbnRhaW5lclRvcC5hcHBlbmRDaGlsZCh2ZXJ0U2Nyb2xsLmdldEVsZW1lbnQoKSk7XG4gICAgXG4gICAgY2FudmFzQ29udGFpbmVyQm90dG9tLmNsYXNzTmFtZSA9ICdjaGlja2VucGFpbnQtY2FudmFzLWNvbnRhaW5lci1ib3R0b20nO1xuICAgIGNhbnZhc0NvbnRhaW5lckJvdHRvbS5hcHBlbmRDaGlsZChob3J6U2Nyb2xsLmdldEVsZW1lbnQoKSk7XG4gICAgXG4gICAgY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhc0NvbnRhaW5lclRvcCk7XG4gICAgY2FudmFzQ29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhc0NvbnRhaW5lckJvdHRvbSk7XG4gICAgXG4gICAgY29udHJvbGxlci5zZXRDYW52YXModGhpcyk7XG59IiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQ2hlY2tib3goc3RhdGUsIHRpdGxlKSB7XG4gICAgdmFyXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpLFxuICAgICAgICBjYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG4gICAgICAgIFxuICAgICAgICB0aGF0ID0gdGhpcztcbiAgICBcbiAgICB0aGlzLnN0YXRlID0gc3RhdGUgfHwgZmFsc2U7XG4gICAgXG4gICAgZnVuY3Rpb24gcGFpbnQoKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIHdpZHRoID0gY2FudmFzLndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcblxuICAgICAgICBjYW52YXNDb250ZXh0LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuYXJjKHdpZHRoIC8gMiArIDEsIHdpZHRoIC8gMiArIDEsIE1hdGgubWF4KHdpZHRoIC8gMiwgMSkgLSAyLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgIFxuICAgICAgICBpZiAodGhhdC5zdGF0ZSkge1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LnN0cm9rZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uKGIpIHtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT0gYikge1xuICAgICAgICAgICAgdGhpcy5zdGF0ZSA9IGI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KCd2YWx1ZUNoYW5nZScsIFtiXSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhaW50KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH1cbiAgICBcbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoYXQuc2V0VmFsdWUoIXRoYXQuc3RhdGUpO1xuICAgIH0pO1xuICAgIFxuICAgIGNhbnZhcy50aXRsZSA9IHRpdGxlIHx8IFwiXCI7XG4gICAgY2FudmFzLmNsYXNzTmFtZSA9ICdjaGlja2VucGFpbnQtY2hlY2tib3gnO1xuICAgIFxuICAgIGNhbnZhcy53aWR0aCA9IDIwO1xuICAgIGNhbnZhcy5oZWlnaHQgPSAyMDtcbiAgICBcbiAgICBjYW52YXMuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICBjYW52YXMuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgIFxuICAgIHBhaW50KCk7XG59O1xuXG5DUENoZWNrYm94LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5DUENoZWNrYm94LnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQQ2hlY2tib3g7IiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBDUFBhbGV0dGUgZnJvbSAnLi9DUFBhbGV0dGUnO1xuaW1wb3J0IENQQ29sb3JTZWxlY3QgZnJvbSAnLi9DUENvbG9yU2VsZWN0JztcbmltcG9ydCBDUENvbG9yU2xpZGVyIGZyb20gJy4vQ1BDb2xvclNsaWRlcic7XG5cbmltcG9ydCBDUENvbG9yIGZyb20gXCIuLi91dGlsL0NQQ29sb3JcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BDb2xvclBhbGV0dGUoY3BDb250cm9sbGVyKSB7XG4gICAgQ1BQYWxldHRlLmNhbGwodGhpcywgY3BDb250cm9sbGVyLCBcImNvbG9yXCIsIFwiQ29sb3JcIik7XG4gICAgXG4gICAgdmFyIFxuICAgICAgICBjb2xvclNlbGVjdCA9IG5ldyBDUENvbG9yU2VsZWN0KGNwQ29udHJvbGxlciksXG4gICAgICAgIGNvbG9yU2xpZGVyID0gbmV3IENQQ29sb3JTbGlkZXIoY3BDb250cm9sbGVyLCBjb2xvclNlbGVjdCksXG4gICAgICAgIGNvbG9yU2hvdyA9IG5ldyBDUENvbG9yU2hvdyhjcENvbnRyb2xsZXIpLFxuICAgIFxuICAgICAgICBib2R5ID0gdGhpcy5nZXRCb2R5RWxlbWVudCgpLFxuICAgICAgICB0b3BTZWN0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBcbiAgICB0b3BTZWN0aW9uLmNsYXNzTmFtZSA9ICdjaGlja2VucGFpbnQtY29sb3JwaWNrZXItdG9wJztcbiAgICBcbiAgICB0b3BTZWN0aW9uLmFwcGVuZENoaWxkKGNvbG9yU2VsZWN0LmdldEVsZW1lbnQoKSk7XG4gICAgdG9wU2VjdGlvbi5hcHBlbmRDaGlsZChjb2xvclNsaWRlci5nZXRFbGVtZW50KCkpO1xuICAgIFxuICAgIGJvZHkuYXBwZW5kQ2hpbGQodG9wU2VjdGlvbik7XG4gICAgYm9keS5hcHBlbmRDaGlsZChjb2xvclNob3cuZ2V0RWxlbWVudCgpKTtcbn1cblxuZnVuY3Rpb24gQ1BDb2xvclNob3coY3BDb250cm9sbGVyKSB7XG4gICAgdmFyXG4gICAgICAgIGNvbG9yID0gMCxcbiAgICAgICAgXG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG4gICAgZnVuY3Rpb24gcGFkTGVmdChzdHJpbmcsIHBhZGRpbmcsIGxlbikge1xuICAgICAgICB3aGlsZSAoc3RyaW5nLmxlbmd0aCA8IGxlbikge1xuICAgICAgICAgICAgc3RyaW5nID0gcGFkZGluZyArIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBwYWludCgpIHtcbiAgICAgICAgZWxlbWVudC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnIycgKyBwYWRMZWZ0KE51bWJlcihjb2xvcikudG9TdHJpbmcoMTYpLCBcIjBcIiwgNik7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIG1vdXNlQ2xpY2soZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgXG4gICAgICAgICAgICBjb2xIZXggPSBcIiNcIiArIHBhZExlZnQoTnVtYmVyKGNvbG9yKS50b1N0cmluZygxNiksIFwiMFwiLCA2KTtcblxuICAgICAgICBjb2xIZXggPSB3aW5kb3cucHJvbXB0KFwiUGxlYXNlIGVudGVyIGEgY29sb3IgaW4gaGV4IGZvcm1hdFwiLCBjb2xIZXgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNvbEhleCAhPSBudWxsKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChjb2xIZXgubWF0Y2goL14jLykgfHwgY29sSGV4Lm1hdGNoKC9eJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbEhleCA9IGNvbEhleC5zdWJzdHJpbmcoMSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgICAgICBuZXdDb2xvciA9IHBhcnNlSW50KGNvbEhleCwgMTYpO1xuXG4gICAgICAgICAgICAgICAgY3BDb250cm9sbGVyLnNldEN1ckNvbG9yKG5ldyBDUENvbG9yKG5ld0NvbG9yKSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG4gICAgXG4gICAgY3BDb250cm9sbGVyLm9uKFwiY29sb3JDaGFuZ2VcIiwgZnVuY3Rpb24oX2NvbG9yKSB7XG4gICAgICAgIGNvbG9yID0gX2NvbG9yLmdldFJnYigpO1xuICAgICAgICBwYWludCgpO1xuICAgIH0pO1xuICAgIFxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ2NoaWNrZW5wYWludC1jb2xvcnBpY2tlci1zaG93JztcbiAgICBcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBtb3VzZUNsaWNrKTtcblxuICAgIHBhaW50KCk7XG59XG5cbkNQQ29sb3JQYWxldHRlLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoQ1BQYWxldHRlLnByb3RvdHlwZSk7XG5DUENvbG9yUGFsZXR0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUENvbG9yUGFsZXR0ZTtcbiIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG5cbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IENQQ29sb3IgZnJvbSBcIi4uL3V0aWwvQ1BDb2xvclwiO1xuaW1wb3J0IENQQ29sb3JCbXAgZnJvbSBcIi4uL2VuZ2luZS9DUENvbG9yQm1wXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQ29sb3JTZWxlY3QoY3BDb250cm9sbGVyLCBpbml0aWFsQ29sb3IpIHtcbiAgICB2YXJcbiAgICAgICAgdyA9IDEyOCwgaCA9IDEyOCxcblxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICBjYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcblxuICAgICAgICBpbWFnZURhdGEgPSBjYW52YXNDb250ZXh0LmNyZWF0ZUltYWdlRGF0YSh3LCBoKSxcbiAgICAgICAgZGF0YSA9IGltYWdlRGF0YS5kYXRhLFxuICAgICAgICBjb2xvciA9IG5ldyBDUENvbG9yKCksXG5cbiAgICAgICAgbmVlZFJlZnJlc2ggPSB0cnVlLFxuXG4gICAgICAgIGNhcHR1cmVkTW91c2UgPSBmYWxzZTtcblxuICAgIGZ1bmN0aW9uIG1ha2VCaXRtYXAoKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgY29sID0gY29sb3IuY2xvbmUoKSxcbiAgICAgICAgICAgIHBpeEluZGV4ID0gMDtcblxuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8IGg7IHkrKykge1xuICAgICAgICAgICAgY29sLnNldFZhbHVlKDI1NSAtICh5ICogMjU1KSAvIGgpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHc7IHgrKykge1xuICAgICAgICAgICAgICAgIGNvbC5zZXRTYXR1cmF0aW9uKCh4ICogMjU1KSAvIHcpO1xuXG4gICAgICAgICAgICAgICAgZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuUkVEX0JZVEVfT0ZGU0VUXSA9IChjb2wucmdiID4+IDE2KSAmIDB4RkY7XG4gICAgICAgICAgICAgICAgZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuR1JFRU5fQllURV9PRkZTRVRdID0gKGNvbC5yZ2IgPj4gOCkgJiAweEZGXG4gICAgICAgICAgICAgICAgZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVF0gPSBjb2wucmdiICYgMHhGRlxuICAgICAgICAgICAgICAgIGRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkFMUEhBX0JZVEVfT0ZGU0VUXSA9IDB4RkY7XG5cbiAgICAgICAgICAgICAgICBwaXhJbmRleCArPSBDUENvbG9yQm1wLkJZVEVTX1BFUl9QSVhFTDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG5lZWRSZWZyZXNoID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFpbnQoKSB7XG4gICAgICAgIGlmIChuZWVkUmVmcmVzaCkge1xuICAgICAgICAgICAgbWFrZUJpdG1hcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzQ29udGV4dC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCAwLCAwLCAwLCAwLCB3LCBoKTtcblxuICAgICAgICB2YXJcbiAgICAgICAgICAgIHggPSBjb2xvci5nZXRTYXR1cmF0aW9uKCkgKiB3IC8gMjU1LFxuICAgICAgICAgICAgeSA9ICgyNTUgLSBjb2xvci5nZXRWYWx1ZSgpKSAqIGggLyAyNTU7XG5cbiAgICAgICAgY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnZXhjbHVzaW9uJztcbiAgICAgICAgY2FudmFzQ29udGV4dC5zdHJva2VTdHlsZSA9ICd3aGl0ZSc7XG4gICAgICAgIGNhbnZhc0NvbnRleHQubGluZVdpZHRoID0gMS41O1xuXG4gICAgICAgIGNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuYXJjKHgsIHksIDUsIDAsIE1hdGguUEkgKiAyKTtcbiAgICAgICAgY2FudmFzQ29udGV4dC5zdHJva2UoKTtcblxuICAgICAgICBjYW52YXNDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdzb3VyY2Utb3Zlcic7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2VQaWNrQ29sb3IoZSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHggPSBlLnBhZ2VYIC0gJChjYW52YXMpLm9mZnNldCgpLmxlZnQsXG4gICAgICAgICAgICB5ID0gZS5wYWdlWSAtICQoY2FudmFzKS5vZmZzZXQoKS50b3AsXG5cbiAgICAgICAgICAgIHNhdCA9IHggKiAyNTUgLyB3LFxuICAgICAgICAgICAgdmFsdWUgPSAyNTUgLSB5ICogMjU1IC8gaDtcblxuICAgICAgICBjb2xvci5zZXRTYXR1cmF0aW9uKE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgc2F0KSkpO1xuICAgICAgICBjb2xvci5zZXRWYWx1ZShNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIHZhbHVlKSkpO1xuXG4gICAgICAgIHBhaW50KCk7XG4gICAgICAgIGNwQ29udHJvbGxlci5zZXRDdXJDb2xvcihjb2xvcik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGludWVEcmFnKGUpIHtcbiAgICAgICAgbW91c2VQaWNrQ29sb3IoZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kRHJhZyhlKSB7XG4gICAgICAgIGNhbnZhcy5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xuICAgICAgICBjYXB0dXJlZE1vdXNlID0gZmFsc2U7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGVuZERyYWcpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGNvbnRpbnVlRHJhZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnREcmFnKGUpIHtcbiAgICAgICAgaWYgKCFjYXB0dXJlZE1vdXNlKSB7XG4gICAgICAgICAgICBjYXB0dXJlZE1vdXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBlbmREcmFnKTtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgY29udGludWVEcmFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdXNlUGlja0NvbG9yKGUpO1xuICAgIH1cblxuICAgIHRoaXMuc2V0SHVlID0gZnVuY3Rpb24oaHVlKSB7XG4gICAgICAgIGlmIChjb2xvci5nZXRIdWUoKSAhPSBodWUpIHtcbiAgICAgICAgICAgIGNvbG9yLnNldEh1ZShodWUpO1xuICAgICAgICAgICAgY3BDb250cm9sbGVyLnNldEN1ckNvbG9yKGNvbG9yKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuXG4gICAgY3BDb250cm9sbGVyLm9uKFwiY29sb3JDaGFuZ2VcIiwgZnVuY3Rpb24oYykge1xuICAgICAgICBjb2xvci5jb3B5RnJvbShjKTtcblxuICAgICAgICBuZWVkUmVmcmVzaCA9IHRydWU7XG4gICAgICAgIHBhaW50KCk7XG4gICAgfSk7XG5cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHN0YXJ0RHJhZyk7XG5cbiAgICBjYW52YXMuY2xhc3NOYW1lID0gJ2NoaWNrZW5wYWludC1jb2xvcnBpY2tlci1zZWxlY3QnO1xuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuXG4gICAgY2FudmFzLndpZHRoID0gdztcbiAgICBjYW52YXMuaGVpZ2h0ID0gaDtcblxuICAgIGlmIChpbml0aWFsQ29sb3IpIHtcbiAgICAgICAgY29sb3IuY29weUZyb20oaW5pdGlhbENvbG9yKTtcbiAgICB9XG5cbiAgICBwYWludCgpO1xufSIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG5cbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IENQQ29sb3IgZnJvbSBcIi4uL3V0aWwvQ1BDb2xvclwiO1xuaW1wb3J0IENQQ29sb3JCbXAgZnJvbSBcIi4uL2VuZ2luZS9DUENvbG9yQm1wXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQ29sb3JTbGlkZXIoY3BDb250cm9sbGVyLCBzZWxlY3RlciwgaW5pdGlhbEh1ZSkge1xuICAgIHZhclxuICAgICAgICB0aGF0ID0gdGhpcyxcblxuICAgICAgICB3ID0gMjQsIGggPSAxMjgsXG5cbiAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgY2FudmFzQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksXG5cbiAgICAgICAgaW1hZ2VEYXRhID0gY2FudmFzQ29udGV4dC5jcmVhdGVJbWFnZURhdGEodywgaCksXG4gICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcblxuICAgICAgICBjYXB0dXJlZE1vdXNlID0gZmFsc2UsXG5cbiAgICAgICAgaHVlID0gaW5pdGlhbEh1ZSB8fCAwO1xuXG4gICAgZnVuY3Rpb24gbWFrZUJpdG1hcCgpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBjb2xvciA9IG5ldyBDUENvbG9yKCksXG4gICAgICAgICAgICBwaXhJbmRleCA9IDA7XG5cbiAgICAgICAgY29sb3Iuc2V0UmdiQ29tcG9uZW50cygwLCAyNTUsIDI1NSk7XG5cbiAgICAgICAgZm9yICh2YXIgeSA9IDA7IHkgPCBoOyB5KyspIHtcbiAgICAgICAgICAgIGNvbG9yLnNldEh1ZSgoeSAqIDM1OSkgLyBoKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgeCA9IDA7IHggPCB3OyB4KyspIHtcbiAgICAgICAgICAgICAgICBkYXRhW3BpeEluZGV4ICsgQ1BDb2xvckJtcC5SRURfQllURV9PRkZTRVRdID0gKGNvbG9yLnJnYiA+PiAxNikgJiAweEZGO1xuICAgICAgICAgICAgICAgIGRhdGFbcGl4SW5kZXggKyBDUENvbG9yQm1wLkdSRUVOX0JZVEVfT0ZGU0VUXSA9IChjb2xvci5yZ2IgPj4gOCkgJiAweEZGXG4gICAgICAgICAgICAgICAgZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuQkxVRV9CWVRFX09GRlNFVF0gPSBjb2xvci5yZ2IgJiAweEZGXG4gICAgICAgICAgICAgICAgZGF0YVtwaXhJbmRleCArIENQQ29sb3JCbXAuQUxQSEFfQllURV9PRkZTRVRdID0gMHhGRjtcblxuICAgICAgICAgICAgICAgIHBpeEluZGV4ICs9IENQQ29sb3JCbXAuQllURVNfUEVSX1BJWEVMO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFpbnQoKSB7XG4gICAgICAgIGNhbnZhc0NvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCwgMCwgMCwgdywgaCk7XG5cbiAgICAgICAgdmFyXG4gICAgICAgICAgICB5ID0gKGh1ZSAqIGgpIC8gMzYwO1xuXG4gICAgICAgIGNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2V4Y2x1c2lvbic7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICBjYW52YXNDb250ZXh0LmxpbmVXaWR0aCA9IDEuNTtcblxuICAgICAgICBjYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICBjYW52YXNDb250ZXh0Lm1vdmVUbygwLCB5KTtcbiAgICAgICAgY2FudmFzQ29udGV4dC5saW5lVG8odywgeSk7XG4gICAgICAgIGNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgY2FudmFzQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSAnc291cmNlLW92ZXInO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlUGlja0NvbG9yKGUpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICB5ID0gZS5wYWdlWSAtICQoY2FudmFzKS5vZmZzZXQoKS50b3AsXG5cbiAgICAgICAgICAgIF9odWUgPSB+fih5ICogMzYwIC8gaCk7XG5cbiAgICAgICAgaHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4oMzU5LCBfaHVlKSk7XG4gICAgICAgIHBhaW50KCk7XG5cbiAgICAgICAgaWYgKHNlbGVjdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHNlbGVjdGVyLnNldEh1ZShodWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29udGludWVEcmFnKGUpIHtcbiAgICAgICAgbW91c2VQaWNrQ29sb3IoZSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZW5kRHJhZyhlKSB7XG4gICAgICAgIGNhbnZhcy5yZWxlYXNlUG9pbnRlckNhcHR1cmUoZS5wb2ludGVySWQpO1xuICAgICAgICBjYXB0dXJlZE1vdXNlID0gZmFsc2U7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIGVuZERyYWcpO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIGNvbnRpbnVlRHJhZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3RhcnREcmFnKGUpIHtcbiAgICAgICAgaWYgKCFjYXB0dXJlZE1vdXNlKSB7XG4gICAgICAgICAgICBjYXB0dXJlZE1vdXNlID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbnZhcy5zZXRQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBlbmREcmFnKTtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgY29udGludWVEcmFnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1vdXNlUGlja0NvbG9yKGUpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEh1ZSA9IGZ1bmN0aW9uKGgpIHtcbiAgICAgICAgaHVlID0gaDtcbiAgICAgICAgcGFpbnQoKTtcbiAgICB9O1xuXG4gICAgY3BDb250cm9sbGVyLm9uKFwiY29sb3JDaGFuZ2VcIiwgZnVuY3Rpb24oY29sb3IpIHtcbiAgICAgICAgdGhhdC5zZXRIdWUoY29sb3IuZ2V0SHVlKCkpO1xuICAgIH0pO1xuXG4gICAgY2FudmFzLnNldEF0dHJpYnV0ZShcInRvdWNoLWFjdGlvblwiLCBcIm5vbmVcIik7XG5cbiAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHN0YXJ0RHJhZyk7XG5cbiAgICBjYW52YXMud2lkdGggPSB3O1xuICAgIGNhbnZhcy5oZWlnaHQgPSBoO1xuXG4gICAgY2FudmFzLmNsYXNzTmFtZSA9ICdjaGlja2VucGFpbnQtY29sb3JwaWNrZXItc2xpZGVyJztcblxuICAgIG1ha2VCaXRtYXAoKTtcbiAgICBwYWludCgpO1xuXG59IiwiLypcbiAgICBDaGlja2VuUGFpbnRcblxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG5cbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ1BDb2xvciBmcm9tICcuLi91dGlsL0NQQ29sb3InO1xuXG5pbXBvcnQgQ1BTbGlkZXIgZnJvbSAnLi9DUFNsaWRlcic7XG5pbXBvcnQgQ1BDb2xvclNlbGVjdCBmcm9tICcuL0NQQ29sb3JTZWxlY3QnO1xuaW1wb3J0IENQQ29sb3JTbGlkZXIgZnJvbSAnLi9DUENvbG9yU2xpZGVyJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BDb2xvclN3YXRjaChpbml0aWFsQ29sb3IsIGluaXRpYWxBbHBoYSkge1xuICAgIHZhclxuICAgICAgICB0aGF0ID0gdGhpcyxcbiAgICAgICAgY29sb3IgPSBuZXcgQ1BDb2xvcigwKSxcbiAgICAgICAgYWxwaGEgPSAyNTUsXG5cbiAgICAgICAgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG5cbiAgICBmdW5jdGlvbiBwYWRMZWZ0KHN0cmluZywgcGFkZGluZywgbGVuKSB7XG4gICAgICAgIHdoaWxlIChzdHJpbmcubGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgICAgICBzdHJpbmcgPSBwYWRkaW5nICsgc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGFpbnQoKSB7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyMnICsgcGFkTGVmdChOdW1iZXIoY29sb3IuZ2V0UmdiKCkpLnRvU3RyaW5nKDE2KSwgXCIwXCIsIDYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIG1vdXNlQ2xpY2soZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH07XG5cbiAgICB0aGlzLnNldENvbG9yID0gZnVuY3Rpb24oX2NvbG9yKSB7XG4gICAgICAgIGlmICghY29sb3IuaXNFcXVhbChfY29sb3IpKSB7XG4gICAgICAgICAgICBjb2xvci5jb3B5RnJvbShfY29sb3IpO1xuXG4gICAgICAgICAgICBwYWludCgpO1xuXG4gICAgICAgICAgICB0aGlzLmVtaXRFdmVudChcImNvbG9yQ2hhbmdlXCIsIFtjb2xvcl0pO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc2V0QWxwaGEgPSBmdW5jdGlvbihfYWxwaGEpIHtcbiAgICAgICAgaWYgKF9hbHBoYSAhPSBhbHBoYSkge1xuICAgICAgICAgICAgYWxwaGEgPSBfYWxwaGE7XG5cbiAgICAgICAgICAgIHBhaW50KCk7XG5cbiAgICAgICAgICAgIHRoaXMuZW1pdEV2ZW50KFwiYWxwaGFDaGFuZ2VcIiwgW2FscGhhXSk7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5nZXRDb2xvclJnYiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gY29sb3IuZ2V0UmdiKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0QWxwaGEgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGFscGhhO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEN1ckNvbG9yID0gdGhpcy5zZXRDb2xvcjtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkQ29sb3JFZGl0UGFuZWwoKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgcGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgZ3JvdXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgc2VsZWN0ID0gbmV3IENQQ29sb3JTZWxlY3QodGhhdCwgY29sb3IpLFxuICAgICAgICAgICAgc2xpZGVyID0gbmV3IENQQ29sb3JTbGlkZXIodGhhdCwgc2VsZWN0LCBjb2xvci5nZXRIdWUoKSksXG4gICAgICAgICAgICBhbHBoYVNsaWRlciA9IG5ldyBDUFNsaWRlcigwLCAyNTUpO1xuXG4gICAgICAgIHBhbmVsLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LWNvbG9yLXBpY2stcGFuZWxcIjtcblxuICAgICAgICBncm91cC5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC1jb2xvcnBpY2tlci10b3BcIjtcblxuICAgICAgICBncm91cC5hcHBlbmRDaGlsZChzZWxlY3QuZ2V0RWxlbWVudCgpKTtcbiAgICAgICAgZ3JvdXAuYXBwZW5kQ2hpbGQoc2xpZGVyLmdldEVsZW1lbnQoKSk7XG5cbiAgICAgICAgcGFuZWwuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuXG4gICAgICAgIGFscGhhU2xpZGVyLnZhbHVlID0gYWxwaGE7XG4gICAgICAgIGFscGhhU2xpZGVyLnRpdGxlID0gZnVuY3Rpb24oYWxwaGEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIk9wYWNpdHk6IFwiICsgYWxwaGE7XG4gICAgICAgIH07XG4gICAgICAgIGFscGhhU2xpZGVyLm9uKFwidmFsdWVDaGFuZ2VcIiwgZnVuY3Rpb24oYWxwaGEpIHtcbiAgICAgICAgICAgIHRoYXQuc2V0QWxwaGEoYWxwaGEpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwYW5lbC5hcHBlbmRDaGlsZChhbHBoYVNsaWRlci5nZXRFbGVtZW50KCkpO1xuXG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhbHBoYVNsaWRlci5yZXNpemUoKTtcbiAgICAgICAgfSwgMCk7XG5cbiAgICAgICAgcmV0dXJuIHBhbmVsO1xuICAgIH1cblxuICAgIGVsZW1lbnQuY2xhc3NOYW1lID0gJ2NoaWNrZW5wYWludC1jb2xvci1waWNrLXN3YXRjaCc7XG5cbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBtb3VzZUNsaWNrKTtcblxuICAgIGlmIChpbml0aWFsQ29sb3IpIHtcbiAgICAgICAgY29sb3IuY29weUZyb20oaW5pdGlhbENvbG9yKTtcbiAgICB9XG5cbiAgICBpZiAoaW5pdGlhbEFscGhhKSB7XG4gICAgICAgIGFscGhhID0gaW5pdGlhbEFscGhhO1xuICAgIH1cblxuICAgIC8vIENsaWNraW5nIG91dHNpZGUgdGhlIHBvcG92ZXIgd2lsbCBkaXNtaXNzIGl0XG4gICAgZnVuY3Rpb24gY2xvc2VDbGlja0hhbmRsZXIoZSkge1xuICAgICAgICBpZiAoJChlLnRhcmdldCkuY2xvc2VzdChcIi5wb3BvdmVyXCIpLmxlbmd0aCA9PSAwICYmICQoZS50YXJnZXQpLmNsb3Nlc3QoXCIuY2hpY2tlbnBhaW50LWNvbG9yLXBpY2stc3dhdGNoXCIpWzBdICE9IGVsZW1lbnQpIHtcbiAgICAgICAgICAgICQoZWxlbWVudCkucG9wb3ZlcihcImhpZGVcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAkKGVsZW1lbnQpXG4gICAgICAgIC5wb3BvdmVyKHtcbiAgICAgICAgICAgIGh0bWw6IHRydWUsXG4gICAgICAgICAgICBjb250ZW50OiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBjbG9zZUNsaWNrSGFuZGxlcik7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gYnVpbGRDb2xvckVkaXRQYW5lbCgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRyaWdnZXI6IFwibWFudWFsXCIsXG4gICAgICAgICAgICBwbGFjZW1lbnQ6IFwiYm90dG9tXCIsXG5cbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAkKHRoaXMpLnBvcG92ZXIoXCJ0b2dnbGVcIik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcImhpZGRlbi5icy5wb3BvdmVyXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgY2xvc2VDbGlja0hhbmRsZXIpO1xuICAgICAgICB9KTtcblxuICAgIHBhaW50KCk7XG59XG5cbkNQQ29sb3JTd2F0Y2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbkNQQ29sb3JTd2F0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BDb2xvclN3YXRjaDsiLCIvKlxuXHRDaGlja2VuUGFpbnRcblxuXHRDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG5cdGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cblxuXHRDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG5cdENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG5cdGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG5cdHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG5cdChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cblx0Q2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG5cdGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG5cdE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcblx0R05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuXHRZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuXHRhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQQ29uZmlybVRyYW5zZm9ybURpYWxvZyhwYXJlbnQsIGNvbnRyb2xsZXIpIHtcblx0dmFyXG5cdFx0ZGlhbG9nID1cblx0XHRcdCQoYDxkaXYgY2xhc3M9XCJtb2RhbCBmYWRlXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJkaWFsb2dcIj5cblx0ICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZ1wiPlxuXHQgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWNvbnRlbnRcIj5cblx0ICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtaGVhZGVyXCI+XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+Q29tcGxldGUgdHJhbnNmb3JtPC9oND5cblx0ICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cblx0ICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxuXHQgICAgICAgICAgICAgICAgICAgICAgICA8cD5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgIFlvdSBuZWVkIHRvIGZpbmlzaCB0cmFuc2Zvcm1pbmcgdGhpcyBsYXllciBiZWZvcmUgeW91IGNhbiBkbyB0aGF0LiBXaGF0IHdvdWxkIHlvdSBsaWtlIHRvIGRvIHdpdGggdGhlIHRyYW5zZm9ybT9cblx0XHRcdFx0XHRcdFx0PC9wPlxuXHQgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXHQgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHRcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiPkNhbmNlbDwvYnV0dG9uPlxuXHQgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBjaGlja2VucGFpbnQtcmVqZWN0LXRyYW5zZm9ybVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+VW5kbyB0cmFuc2Zvcm08L2J1dHRvbj5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgY2hpY2tlbnBhaW50LWFjY2VwdC10cmFuc2Zvcm1cIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiPkFwcGx5IHRyYW5zZm9ybTwvYnV0dG9uPlxuXHQgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXHQgICAgICAgICAgICAgICAgPC9kaXY+XG5cdCAgICAgICAgICAgIDwvZGl2PlxuXHQgICAgICAgIDwvZGl2PlxuXHQgICAgYCksXG5cblx0XHR0aGF0ID0gdGhpcyxcblxuXHRcdGFwcGx5QnV0dG9uID0gJChcIi5jaGlja2VucGFpbnQtYWNjZXB0LXRyYW5zZm9ybVwiLCBkaWFsb2cpLFxuXHRcdHJlamVjdEJ1dHRvbiA9ICQoXCIuY2hpY2tlbnBhaW50LXJlamVjdC10cmFuc2Zvcm1cIiwgZGlhbG9nKTtcblxuXHRhcHBseUJ1dHRvbi5jbGljayhmdW5jdGlvbihlKSB7XG5cdFx0Y29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogXCJDUFRyYW5zZm9ybUFjY2VwdFwifSk7XG5cdFx0dGhhdC5lbWl0RXZlbnQoXCJhY2NlcHRcIik7XG5cdH0pO1xuXG5cdHJlamVjdEJ1dHRvbi5jbGljayhmdW5jdGlvbihlKSB7XG5cdFx0Y29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogXCJDUFRyYW5zZm9ybVJlamVjdFwifSk7XG5cdFx0dGhhdC5lbWl0RXZlbnQoXCJyZWplY3RcIik7XG5cdH0pO1xuXG5cdGRpYWxvZ1xuXHRcdC5tb2RhbCh7XG5cdFx0XHRzaG93OiBmYWxzZVxuXHRcdH0pXG5cdFx0Lm9uKCdzaG93bi5icy5tb2RhbCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YXBwbHlCdXR0b24uZm9jdXMoKTtcblx0XHR9KVxuXHRcdC5vbihcImhpZGRlbi5icy5tb2RhbFwiLCBmdW5jdGlvbihlKSB7XG5cdFx0XHQvLyBEZXN0cm95IHRoZSBtb2RhbCB1cG9uIGNsb3NlXG5cdFx0XHRkaWFsb2cucmVtb3ZlKCk7XG5cdFx0fSlcblx0XHQub24oJ2tleXByZXNzJywgZnVuY3Rpb24oZSkge1xuXHRcdFx0aWYgKGUua2V5Q29kZSA9PSAxMykge1xuXHRcdFx0XHRhcHBseUJ1dHRvbi5jbGljaygpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdC8vIEZpeCB0aGUgYmFja2Ryb3AgbG9jYXRpb24gaW4gdGhlIERPTSBieSByZXBhcmVudGluZyBpdCB0byB0aGUgY2hpY2tlbnBhaW50IGNvbnRhaW5lclxuXHRkaWFsb2cuZGF0YShcImJzLm1vZGFsXCIpLiRib2R5ID0gJChwYXJlbnQpO1xuXG5cdHBhcmVudC5hcHBlbmRDaGlsZChkaWFsb2dbMF0pO1xuXG5cdHRoaXMuc2hvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdGRpYWxvZy5tb2RhbChcInNob3dcIik7XG5cdH07XG59XG5cbkNQQ29uZmlybVRyYW5zZm9ybURpYWxvZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuQ1BDb25maXJtVHJhbnNmb3JtRGlhbG9nLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQQ29uZmlybVRyYW5zZm9ybURpYWxvZzsiLCIvKipcbiAqIENyZWF0ZSBhIGNoZWNrZXJib2FyZCBIVE1MNSBDYW52YXNQYXR0ZXJuICh3aGljaCBjYW4gYmUgdXNlZCBmb3IgZmlsbFN0eWxlKSB1c2luZyB0aGUgZ2l2ZW4gY2FudmFzIGNvbnRleHQuXG4gKiBcbiAqIEBwYXJhbSBjYW52YXNDb250ZXh0XG4gKiBAcmV0dXJucyB7Q2FudmFzUGF0dGVybn1cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNyZWF0ZUNoZWNrZXJib2FyZFBhdHRlcm4oY2FudmFzQ29udGV4dCkge1xuICAgIHZhclxuICAgICAgICBjaGVja2VyYm9hcmRDYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICBjaGVja2VyYm9hcmRDb250ZXh0ID0gY2hlY2tlcmJvYXJkQ2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcbiAgICAgICAgXG4gICAgICAgIGltYWdlRGF0YSA9IGNoZWNrZXJib2FyZENvbnRleHQuY3JlYXRlSW1hZ2VEYXRhKDY0LCA2NCksXG4gICAgICAgIGRhdGEgPSBpbWFnZURhdGEuZGF0YSxcbiAgICAgICAgXG4gICAgICAgIHBpeGVsT2Zmc2V0ID0gMDtcblxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgNjQ7IGorKykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcbiAgICAgICAgICAgIGlmICgoaSAmIDB4OCkgIT0gMCBeIChqICYgMHg4KSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgLy8gV2hpdGVcbiAgICAgICAgICAgICAgICBkYXRhW3BpeGVsT2Zmc2V0KytdID0gMHhmZjtcbiAgICAgICAgICAgICAgICBkYXRhW3BpeGVsT2Zmc2V0KytdID0gMHhmZjtcbiAgICAgICAgICAgICAgICBkYXRhW3BpeGVsT2Zmc2V0KytdID0gMHhmZjtcbiAgICAgICAgICAgICAgICBkYXRhW3BpeGVsT2Zmc2V0KytdID0gMHhmZjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gR3JleVxuICAgICAgICAgICAgICAgIGRhdGFbcGl4ZWxPZmZzZXQrK10gPSAweGNjO1xuICAgICAgICAgICAgICAgIGRhdGFbcGl4ZWxPZmZzZXQrK10gPSAweGNjO1xuICAgICAgICAgICAgICAgIGRhdGFbcGl4ZWxPZmZzZXQrK10gPSAweGNjO1xuICAgICAgICAgICAgICAgIGRhdGFbcGl4ZWxPZmZzZXQrK10gPSAweGZmO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2hlY2tlcmJvYXJkQ2FudmFzLndpZHRoID0gNjQ7XG4gICAgY2hlY2tlcmJvYXJkQ2FudmFzLmhlaWdodCA9IDY0O1xuICAgIGNoZWNrZXJib2FyZENvbnRleHQucHV0SW1hZ2VEYXRhKGltYWdlRGF0YSwgMCwgMCk7XG5cbiAgICByZXR1cm4gY2FudmFzQ29udGV4dC5jcmVhdGVQYXR0ZXJuKGNoZWNrZXJib2FyZENhbnZhcywgJ3JlcGVhdCcpO1xufSIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUEdyaWREaWFsb2cocGFyZW50LCBjYW52YXMpIHtcbiAgICB2YXJcbiAgICAgICAgZGlhbG9nID0gXG4gICAgICAgICAgICAkKGA8ZGl2IGNsYXNzPVwibW9kYWwgZmFkZVwiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiZGlhbG9nXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZ1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+R3JpZCBvcHRpb25zPC9oND5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8Zm9ybT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImZvcm0tZ3JvdXBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsYWJlbD5HcmlkIHNpemU8L2xhYmVsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJ0ZXh0XCIgY2xhc3M9XCJmb3JtLWNvbnRyb2wgY2hpY2tlbnBhaW50LWdyaWQtc2l6ZVwiIHZhbHVlPVwiXCIgYXV0b2ZvY3VzPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Zvcm0+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdFwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLXByaW1hcnkgY2hpY2tlbnBhaW50LWFwcGx5LWdyaWQtc2V0dGluZ3NcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiPk9rPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYCksXG4gICAgICAgIFxuICAgICAgICBncmlkU2l6ZUVsZW0gPSAkKFwiLmNoaWNrZW5wYWludC1ncmlkLXNpemVcIiwgZGlhbG9nKSxcbiAgICAgICAgYXBwbHlCdXR0b24gPSAkKFwiLmNoaWNrZW5wYWludC1hcHBseS1ncmlkLXNldHRpbmdzXCIsIGRpYWxvZyk7XG4gICAgXG4gICAgZ3JpZFNpemVFbGVtLnZhbChjYW52YXMuZ2V0R3JpZFNpemUoKSk7XG4gICAgXG4gICAgJChcIi5jaGlja2VucGFpbnQtYXBwbHktZ3JpZC1zZXR0aW5nc1wiLCBkaWFsb2cpLmNsaWNrKGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBncmlkU2l6ZSA9IHBhcnNlSW50KGdyaWRTaXplRWxlbS52YWwoKSwgMTApO1xuICAgICAgICBcbiAgICAgICAgY2FudmFzLnNldEdyaWRTaXplKGdyaWRTaXplKTtcbiAgICB9KTtcbiBcbiAgICBkaWFsb2dcbiAgICAgICAgLm1vZGFsKHtcbiAgICAgICAgICAgIHNob3c6IGZhbHNlXG4gICAgICAgIH0pXG4gICAgICAgIC5vbignc2hvd24uYnMubW9kYWwnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGdyaWRTaXplRWxlbS5mb2N1cygpO1xuICAgICAgICB9KS5vbigna2V5cHJlc3MnLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlID09IDEzKSB7XG4gICAgICAgICAgICAgICAgYXBwbHlCdXR0b24uY2xpY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgXG4gICAgLy8gRml4IHRoZSBiYWNrZHJvcCBsb2NhdGlvbiBpbiB0aGUgRE9NIGJ5IHJlcGFyZW50aW5nIGl0IHRvIHRoZSBjaGlja2VucGFpbnQgY29udGFpbmVyXG4gICAgZGlhbG9nLmRhdGEoXCJicy5tb2RhbFwiKS4kYm9keSA9ICQocGFyZW50KTtcbiAgICBcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZGlhbG9nWzBdKTtcbiAgICBcbiAgICB0aGlzLnNob3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgZGlhbG9nLm1vZGFsKFwic2hvd1wiKTtcbiAgICB9O1xufSIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ1BQYWxldHRlIGZyb20gXCIuL0NQUGFsZXR0ZVwiO1xuaW1wb3J0IENQU2xpZGVyIGZyb20gXCIuL0NQU2xpZGVyXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQTGF5ZXJzUGFsZXR0ZShjb250cm9sbGVyKSB7XG4gICAgQ1BQYWxldHRlLmNhbGwodGhpcywgY29udHJvbGxlciwgXCJsYXllcnNcIiwgXCJMYXllcnNcIiwgdHJ1ZSk7XG4gICAgXG4gICAgY29uc3RcbiAgICAgICAgTU9ERV9OQU1FUyA9IFtcbiAgICAgICAgICAgICAgXCJOb3JtYWxcIiwgXCJNdWx0aXBseVwiLCBcIkFkZFwiLCBcIlNjcmVlblwiLCBcIkxpZ2h0ZW5cIiwgXCJEYXJrZW5cIiwgXCJTdWJ0cmFjdFwiLCBcIkRvZGdlXCIsIFwiQnVyblwiLFxuICAgICAgICAgICAgICBcIk92ZXJsYXlcIiwgXCJIYXJkIExpZ2h0XCIsIFwiU29mdCBMaWdodFwiLCBcIlZpdmlkIExpZ2h0XCIsIFwiTGluZWFyIExpZ2h0XCIsIFwiUGluIExpZ2h0XCJcbiAgICAgICAgXTtcbiAgICBcbiAgICB2YXJcbiAgICAgICAgcGFsZXR0ZSA9IHRoaXMsXG4gICAgICAgIGxheWVySCA9IDMyLCBleWVXID0gMjQsXG4gICAgICAgIFxuICAgICAgICBib2R5ID0gdGhpcy5nZXRCb2R5RWxlbWVudCgpLFxuXG4gICAgICAgIGxheWVyV2lkZ2V0ID0gbmV3IENQTGF5ZXJXaWRnZXQoKSxcbiAgICAgICAgYWxwaGFTbGlkZXIgPSBuZXcgQ1BTbGlkZXIoMCwgMTAwKSxcbiAgICAgICAgYmxlbmRDb21ibyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzZWxlY3RcIiksXG4gICAgXG4gICAgICAgIHJlbmFtZUZpZWxkID0gbmV3IENQUmVuYW1lRmllbGQoKSxcbiAgICBcbiAgICAgICAgY2JTYW1wbGVBbGxMYXllcnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIiksXG4gICAgICAgIGNiTG9ja0FscGhhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICBcbiAgICAgICAgYWRkQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpLFxuICAgICAgICByZW1vdmVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlcIik7XG4gICAgXG4gICAgZnVuY3Rpb24gZmlsbENvbWJvYm94KGNvbWJvLCBvcHRpb25OYW1lcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbk5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgb3B0aW9uLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKG9wdGlvbk5hbWVzW2ldKSk7XG4gICAgICAgICAgICBvcHRpb24udmFsdWUgPSBpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb21iby5hcHBlbmRDaGlsZChvcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHdyYXBDaGVja2JveFdpdGhMYWJlbChjaGVja2JveCwgdGl0bGUpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgbGFiZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGFiZWxcIik7XG5cbiAgICAgICAgZGl2LmNsYXNzTmFtZSA9IFwiY2hlY2tib3hcIjtcbiAgICAgICAgXG4gICAgICAgIGxhYmVsLmFwcGVuZENoaWxkKGNoZWNrYm94KTtcbiAgICAgICAgbGFiZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGl0bGUpKTtcbiAgICAgICAgXG4gICAgICAgIGRpdi5hcHBlbmRDaGlsZChsYWJlbCk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gZGl2O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNob3dSZW5hbWVDb250cm9sKGxheWVySW5kZXgpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBkID0gbGF5ZXJXaWRnZXQuZ2V0Q1NTU2l6ZSgpLFxuICAgICAgICAgICAgYXJ0d29yayA9IGNvbnRyb2xsZXIuZ2V0QXJ0d29yaygpLFxuICAgICAgICAgICAgbGF5ZXIgPSBhcnR3b3JrLmdldExheWVyKGxheWVySW5kZXgpO1xuXG4gICAgICAgIHJlbmFtZUZpZWxkLnNob3coXG4gICAgICAgICAgICBleWVXIC8gd2luZG93LmRldmljZVBpeGVsUmF0aW8sIFxuICAgICAgICAgICAgZC5oZWlnaHQgLSAobGF5ZXJJbmRleCArIDEpICogbGF5ZXJIIC8gd2luZG93LmRldmljZVBpeGVsUmF0aW8sXG4gICAgICAgICAgICBsYXllckluZGV4LFxuICAgICAgICAgICAgbGF5ZXIubmFtZVxuICAgICAgICk7XG4gICAgfVxuICAgIFxuICAgIHZhclxuICAgICAgICBwYXJlbnRTZXRTaXplID0gdGhpcy5zZXRTaXplLFxuICAgICAgICBwYXJlbnRTZXRIZWlnaHQgPSB0aGlzLnNldEhlaWdodDtcbiAgICBcbiAgICB0aGlzLnNldFNpemUgPSBmdW5jdGlvbih3LCBoKSB7XG4gICAgICAgIHBhcmVudFNldFNpemUuY2FsbCh0aGlzLCB3LCBoKTtcbiAgICAgICAgXG4gICAgICAgIGxheWVyV2lkZ2V0LnJlc2l6ZSgpO1xuICAgICAgICBhbHBoYVNsaWRlci5yZXNpemUoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRIZWlnaHQgPSBmdW5jdGlvbihoKSB7XG4gICAgICAgIHBhcmVudFNldEhlaWdodC5jYWxsKHRoaXMsIGgpO1xuICAgICAgICBcbiAgICAgICAgbGF5ZXJXaWRnZXQucmVzaXplKCk7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIENQTGF5ZXJXaWRnZXQoKSB7XG4gICAgICAgIGNvbnN0XG4gICAgICAgICAgICBOT1RJRklDQVRJT05fSElERV9ERUxBWV9NU19QRVJfQ0hBUiA9IDcwLFxuICAgICAgICAgICAgTk9USUZJQ0FUSU9OX0hJREVfREVMQVlfTUlOID0gMzAwMDtcblxuICAgICAgICB2YXIgXG4gICAgICAgICAgICBsYXllckRyYWcsIGxheWVyRHJhZ1JlYWxseSxcbiAgICAgICAgICAgIGxheWVyRHJhZ0luZGV4LCBsYXllckRyYWdZLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIiksXG5cbiAgICAgICAgICAgIG9sZEFwcGx5UGxhY2VtZW50LFxuICAgICAgICAgICAgbm90aWZpY2F0aW9uTWVzc2FnZSA9IFwiXCIsXG4gICAgICAgICAgICBub3RpZmljYXRpb25MYXllckluZGV4ID0gLTEsXG4gICAgICAgICAgICBub3RpZmljYXRpb25Mb2NhdGlvbiA9IFwiXCIsXG5cbiAgICAgICAgICAgIGRpc21pc3NUaW1lciA9IGZhbHNlLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0IHRoZSBzaXplIG9mIHRoZSBjb21wb25lbnQgb24gc2NyZWVuIGluIENTUyBwaXhlbHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdldENTU1NpemUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiB7d2lkdGg6ICQoY2FudmFzKS53aWR0aCgpLCBoZWlnaHQ6ICQoY2FudmFzKS5oZWlnaHQoKX07XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiBnZXRMYXllckluZGV4KHBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gTWF0aC5mbG9vcigoY2FudmFzLmhlaWdodCAtIHBvaW50LnkgLyAkKGNhbnZhcykuaGVpZ2h0KCkgKiBjYW52YXMuaGVpZ2h0KSAvIGxheWVySCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0gbGF5ZXIgQ1BMYXllclxuICAgICAgICAgKiBAcGFyYW0gc2VsZWN0ZWQgYm9vbGVhblxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZHJhd0xheWVyKGxheWVyLCBzZWxlY3RlZCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgZCA9IHt3aWR0aDogY2FudmFzLndpZHRoLCBoZWlnaHQ6IGNhbnZhcy5oZWlnaHR9O1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9ICcjQjBCMEMwJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsUmVjdCgwLCAwLCBkLndpZHRoLCBsYXllckgpO1xuXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0Lm1vdmVUbygwLCAwKTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQubGluZVRvKGQud2lkdGgsIDApO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0Lm1vdmVUbyhleWVXLCAwKTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQubGluZVRvKGV5ZVcsIGxheWVySCk7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQubW92ZVRvKGV5ZVcgKyA2ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8sIGxheWVySCAvIDIpO1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5saW5lVG8oZC53aWR0aCAtIDYgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgbGF5ZXJIIC8gMik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsVGV4dChsYXllci5uYW1lLCBleWVXICsgNiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAxMiAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFRleHQoTU9ERV9OQU1FU1tsYXllci5ibGVuZE1vZGVdICsgXCI6IFwiICsgbGF5ZXIuYWxwaGEgKyBcIiVcIiwgZXllVyArIDYgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgbGF5ZXJIIC0gNSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKTtcblxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGlmIChsYXllci52aXNpYmxlKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5hcmMoZXllVyAvIDIsIGxheWVySCAvIDIsIDkgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbywgMCwgTWF0aC5QSSAqIDIpO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYW52YXNDb250ZXh0LmFyYyhleWVXIC8gMiwgbGF5ZXJIIC8gMiwgOSAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvLCAwLCBNYXRoLlBJICogMik7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gbW91c2VVcChlKSB7XG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT0gMCkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQgPSAkKGNhbnZhcykub2Zmc2V0KCksXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBhcnR3b3JrID0gY29udHJvbGxlci5nZXRBcnR3b3JrKCksXG4gICAgICAgICAgICAgICAgICAgIGxheWVycyA9IGFydHdvcmsuZ2V0TGF5ZXJzKCksXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBtb3VzZUxvYyA9IHt4OiBlLnBhZ2VYIC0gb2Zmc2V0LmxlZnQsIHk6IGUucGFnZVkgLSBvZmZzZXQudG9wfSxcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJPdmVyID0gZ2V0TGF5ZXJJbmRleChtb3VzZUxvYyk7XG5cbiAgICAgICAgICAgICAgICAvL2xheWVyRHJhZ1kgPSBlLnBhZ2VZIC0gb2Zmc2V0LnRvcDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJPdmVyID49IDAgJiYgbGF5ZXJPdmVyIDw9IGxheWVycy5sZW5ndGggJiYgbGF5ZXJPdmVyICE9IGxheWVyRHJhZ0luZGV4ICYmIGxheWVyT3ZlciAhPSBsYXllckRyYWdJbmRleCArIDEpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogXCJDUE1vdmVMYXllclwiLCBmcm9tSW5kZXg6IGxheWVyRHJhZ0luZGV4LCB0b0luZGV4OiBsYXllck92ZXJ9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBEbyB3ZSBuZWVkIHRvIHJlcGFpbnQgdG8gZXJhc2UgZHJhZ2xpbmVzP1xuICAgICAgICAgICAgICAgIGlmIChsYXllckRyYWdSZWFsbHkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJEcmFnUmVhbGx5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQucGFpbnQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbGF5ZXJEcmFnID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgbW91c2VEcmFnZ2VkKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgbW91c2VVcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBtb3VzZURyYWdnZWQoZSkge1xuICAgICAgICAgICAgaWYgKGxheWVyRHJhZykge1xuICAgICAgICAgICAgICAgIGxheWVyRHJhZ1JlYWxseSA9IHRydWU7XG4gICAgICAgICAgICAgICAgbGF5ZXJEcmFnWSA9IGUucGFnZVkgLSAkKGNhbnZhcykub2Zmc2V0KCkudG9wO1xuICAgICAgICAgICAgICAgIHRoYXQucGFpbnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXBhaW50IGp1c3QgdGhlIGxheWVyIHdpdGggdGhlIHNwZWNpZmllZCBpbmRleFxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wYWludExheWVyID0gZnVuY3Rpb24obGF5ZXJJbmRleCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgbGF5ZXIgPSBhcnR3b3JrLmdldExheWVyKGxheWVySW5kZXgpLFxuICAgICAgICAgICAgICAgIGxheWVyVG9wID0gY2FudmFzLmhlaWdodCAtIGxheWVySCAqIChsYXllckluZGV4ICsgMSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9ICcjNjA2MDYwJztcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFJlY3QoMCwgbGF5ZXJUb3AsIGNhbnZhcy53aWR0aCwgbGF5ZXJIKTtcblxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5zdHJva2VTdHlsZSA9ICdibGFjayc7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQudHJhbnNsYXRlKDAsIGxheWVyVG9wKTtcbiAgICAgICAgICAgIGRyYXdMYXllcihsYXllciwgbGF5ZXJJbmRleCA9PSBhcnR3b3JrLmdldEFjdGl2ZUxheWVySW5kZXgoKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlcGFpbnQgdGhlIGVudGlyZSBjb250cm9sXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhaW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBhcnR3b3JrID0gY29udHJvbGxlci5nZXRBcnR3b3JrKCksXG4gICAgICAgICAgICAgICAgbGF5ZXJzID0gYXJ0d29yay5nZXRMYXllcnMoKSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkID0ge3dpZHRoOiBjYW52YXMud2lkdGgsIGhlaWdodDogY2FudmFzLmhlaWdodH0sXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2FudmFzU2NhbGVGYWN0b3IgPSBjYW52YXMuaGVpZ2h0IC8gJChjYW52YXMpLmhlaWdodCgpO1xuXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LnNhdmUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSAnIzYwNjA2MCc7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmZpbGxSZWN0KDAsIDAsIGQud2lkdGgsIGQuaGVpZ2h0IC0gbGF5ZXJzLmxlbmd0aCAqIGxheWVySCk7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuXG4gICAgICAgICAgICAvLyBEcmF3IHRoZSBsaXN0IG9mIGxheWVycywgd2l0aCB0aGUgZmlyc3QgbGF5ZXIgYXQgdGhlIGJvdHRvbSBvZiB0aGUgY29udHJvbFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC50cmFuc2xhdGUoMCwgZC5oZWlnaHQgLSBsYXllckgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGRyYXdMYXllcihsYXllcnNbaV0sIGkgPT0gYXJ0d29yay5nZXRBY3RpdmVMYXllckluZGV4KCkpO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQudHJhbnNsYXRlKDAsIC1sYXllckgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobGF5ZXJEcmFnUmVhbGx5KSB7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC50cmFuc2xhdGUoMCwgbGF5ZXJzLmxlbmd0aCAqIGxheWVySCAtIChkLmhlaWdodCAtIGxheWVySCkpO1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuc3Ryb2tlUmVjdCgwLCBsYXllckRyYWdZICogY2FudmFzU2NhbGVGYWN0b3IgIC0gbGF5ZXJIIC8gMiwgZC53aWR0aCwgbGF5ZXJIKTtcblxuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBsYXllck92ZXIgPSBnZXRMYXllckluZGV4KHt4OiAwLCB5OiBsYXllckRyYWdZfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGxheWVyT3ZlciA8PSBsYXllcnMubGVuZ3RoICYmIGxheWVyT3ZlciAhPSBsYXllckRyYWdJbmRleCAmJiBsYXllck92ZXIgIT0gbGF5ZXJEcmFnSW5kZXggKyAxKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFJlY3QoMCwgZC5oZWlnaHQgLSBsYXllck92ZXIgKiBsYXllckggLSAyLCBkLndpZHRoLCA0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnJlc2l6ZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgYXJ0d29yayA9IGNvbnRyb2xsZXIuZ2V0QXJ0d29yaygpLFxuXG4gICAgICAgICAgICAgICAgLy8gT3VyIHBhcmVudCBjb250YWluZXIgd2lsbCBhY3QgYXMgb3VyIHNjcm9sbGJhciBjbGlwIGFyZWFcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSAkKGNhbnZhcykucGFyZW50KCksXG4gICAgICAgICAgICAgICAgcGFyZW50SGVpZ2h0ID0gcGFyZW50LmhlaWdodCgpLFxuICAgICAgICAgICAgICAgIHBhcmVudFdpZHRoID0gcGFyZW50LndpZHRoKCksXG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgbmV3V2lkdGgsIG5ld0hlaWdodDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgbGF5ZXJIID0gMzQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGV5ZVcgPSAyNCAqIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBuZXdXaWR0aCA9IHBhcmVudFdpZHRoICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSBNYXRoLm1heChsYXllckggKiBhcnR3b3JrLmdldExheWVyQ291bnQoKSwgcGFyZW50SGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBTaG91bGQgd2UgdHJpZ2dlciBhIHNjcm9sbGJhciB0byBhcHBlYXI/XG4gICAgICAgICAgICBpZiAobmV3SGVpZ2h0ID4gcGFyZW50SGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8pIHtcbiAgICAgICAgICAgICAgICAvLyBUYWtlIHRoZSBzY3JvbGxiYXIgd2lkdGggaW50byBhY2NvdW50IGluIG91ciB3aWR0aFxuICAgICAgICAgICAgICAgIG5ld1dpZHRoIC09IDE1ICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgICAgICAgICAgcGFyZW50WzBdLnN0eWxlLm92ZXJmbG93WSA9ICdzY3JvbGwnO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYXJlbnRbMF0uc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbnZhcy53aWR0aCA9IG5ld1dpZHRoO1xuICAgICAgICAgICAgY2FudmFzLmhlaWdodCA9IG5ld0hlaWdodDtcblxuICAgICAgICAgICAgY2FudmFzLnN0eWxlLndpZHRoID0gKG5ld1dpZHRoIC8gd2luZG93LmRldmljZVBpeGVsUmF0aW8pICsgXCJweFwiO1xuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IChuZXdIZWlnaHQgLyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgKyBcInB4XCI7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZm9udCA9IChsYXllckggKiAwLjI1KSArIFwicHQgc2Fucy1zZXJpZlwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnBhaW50KCk7XG4gICAgICAgICAgICB0aGlzLmRpc21pc3NOb3RpZmljYXRpb24oKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHJlbmFtZUZpZWxkLmlzVmlzaWJsZSgpKSB7XG4gICAgICAgICAgICAgICAgcmVuYW1lRmllbGQucmVuYW1lQW5kSGlkZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgIG9mZnNldCA9ICQoY2FudmFzKS5vZmZzZXQoKSxcbiAgICAgICAgICAgICAgICBtb3VzZUxvYyA9IHt4OiBlLnBhZ2VYIC0gb2Zmc2V0LmxlZnQsIHk6IGUucGFnZVkgLSBvZmZzZXQudG9wfSxcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsYXllckluZGV4ID0gZ2V0TGF5ZXJJbmRleChtb3VzZUxvYyk7XG5cbiAgICAgICAgICAgIGlmIChtb3VzZUxvYy54ICogd2luZG93LmRldmljZVBpeGVsUmF0aW8gPiBleWVXICYmIGxheWVySW5kZXggPj0gMCAmJiBsYXllckluZGV4IDwgYXJ0d29yay5nZXRMYXllckNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICBzaG93UmVuYW1lQ29udHJvbChsYXllckluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgb2Zmc2V0ID0gJChjYW52YXMpLm9mZnNldCgpLFxuICAgICAgICAgICAgICAgIG1vdXNlTG9jID0ge3g6IGUucGFnZVggLSBvZmZzZXQubGVmdCwgeTogZS5wYWdlWSAtIG9mZnNldC50b3B9O1xuXG4gICAgICAgICAgICAvKiBDbGljaywgbW92ZWQgZnJvbSBtb3VzZUNsaWNrZWQgZHVlIHRvIHByb2JsZW1zIHdpdGggZm9jdXMgYW5kIHN0dWZmICovXG4gICAgICAgICAgICBpZiAoZS5idXR0b24gPT0gMCkgeyAvKiBMZWZ0IGJ1dHRvbiAqL1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBhcnR3b3JrID0gY29udHJvbGxlci5nZXRBcnR3b3JrKCksXG4gICAgICAgICAgICAgICAgICAgIGxheWVycyA9IGFydHdvcmsuZ2V0TGF5ZXJzKCksXG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBsYXllckluZGV4ID0gZ2V0TGF5ZXJJbmRleChtb3VzZUxvYyk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKGxheWVySW5kZXggPj0gMCAmJiBsYXllckluZGV4IDwgYXJ0d29yay5nZXRMYXllckNvdW50KCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllciA9IGFydHdvcmsuZ2V0TGF5ZXIobGF5ZXJJbmRleCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICBpZiAobW91c2VMb2MueCAvICQoY2FudmFzKS53aWR0aCgpICogY2FudmFzLndpZHRoIDwgZXllVykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogXCJDUFNldExheWVyVmlzaWJpbGl0eVwiLCBsYXllckluZGV4OiBsYXllckluZGV4LCB2aXNpYmxlOiAhbGF5ZXIudmlzaWJsZX0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGFydHdvcmsuZ2V0QWN0aXZlTGF5ZXJJbmRleCgpICE9IGxheWVySW5kZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWN0aW9uUGVyZm9ybWVkKHthY3Rpb246IFwiQ1BTZXRBY3RpdmVMYXllckluZGV4XCIsIGxheWVySW5kZXg6IGxheWVySW5kZXh9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobGF5ZXJJbmRleCA8IGxheWVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJEcmFnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbGF5ZXJEcmFnWSA9IG1vdXNlTG9jLnk7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyRHJhZ0luZGV4ID0gbGF5ZXJJbmRleDtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlRHJhZ2dlZCk7XG4gICAgICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBtb3VzZVVwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTY3JvbGwgdGhlIGxheWVyIHdpZGdldCB1bnRpbCB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gaW5kZXggaXMgZnVsbHkgdmlzaWJsZS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGxheWVySW5kZXhcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHJldmVhbExheWVyKGxheWVySW5kZXgpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGxheWVyV2lkZ2V0UG9zID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuXG4gICAgICAgICAgICAgICAgc2Nyb2xsQm94UG9zID0gY29udGFpbmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgIHNjcm9sbEJveEhlaWdodCA9IHNjcm9sbEJveFBvcy5ib3R0b20gLSBzY3JvbGxCb3hQb3MudG9wLFxuXG4gICAgICAgICAgICAgICAgbGF5ZXJIZWlnaHQgPSBsYXllckggLyB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyxcblxuICAgICAgICAgICAgICAgIGxheWVyVG9wID0gbGF5ZXJXaWRnZXRQb3MuYm90dG9tIC0gbGF5ZXJIZWlnaHQgKiAobGF5ZXJJbmRleCArIDEpLFxuICAgICAgICAgICAgICAgIGxheWVyQm90dG9tID0gbGF5ZXJUb3AgKyBsYXllckhlaWdodDtcblxuICAgICAgICAgICAgY29udGFpbmVyLnNjcm9sbFRvcCA9IE1hdGgubWF4KE1hdGgubWluKE1hdGgubWF4KGNvbnRhaW5lci5zY3JvbGxUb3AsIGxheWVyQm90dG9tIC0gbGF5ZXJXaWRnZXRQb3MudG9wIC0gc2Nyb2xsQm94SGVpZ2h0KSwgbGF5ZXJUb3AgLSBsYXllcldpZGdldFBvcy50b3ApLCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGlzbWlzc05vdGlmaWNhdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgJChjYW52YXMpLnBvcG92ZXIoJ2hpZGUnKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNob3dOb3RpZmljYXRpb24gPSBmdW5jdGlvbihsYXllckluZGV4LCBtZXNzYWdlLCB3aGVyZSkge1xuICAgICAgICAgICAgbm90aWZpY2F0aW9uTWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgICAgICBub3RpZmljYXRpb25MYXllckluZGV4ID0gbGF5ZXJJbmRleDtcblxuICAgICAgICAgICAgaWYgKGFydHdvcmsuZ2V0QWN0aXZlTGF5ZXJJbmRleCgpID09IGxheWVySW5kZXggJiYgd2hlcmUgPT0gXCJvcGFjaXR5XCIpIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25Mb2NhdGlvbiA9IFwib3BhY2l0eVwiO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb25Mb2NhdGlvbiA9IFwibGF5ZXJcIjtcbiAgICAgICAgICAgICAgICByZXZlYWxMYXllcihsYXllckluZGV4KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgJChjYW52YXMpLnBvcG92ZXIoXCJzaG93XCIpO1xuXG4gICAgICAgICAgICBpZiAoZGlzbWlzc1RpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGRpc21pc3NUaW1lcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkaXNtaXNzVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGRpc21pc3NUaW1lciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHRoYXQuZGlzbWlzc05vdGlmaWNhdGlvbigpXG4gICAgICAgICAgICB9LCBNYXRoLm1heChNYXRoLnJvdW5kKG5vdGlmaWNhdGlvbk1lc3NhZ2UubGVuZ3RoICogTk9USUZJQ0FUSU9OX0hJREVfREVMQVlfTVNfUEVSX0NIQVIpLCBOT1RJRklDQVRJT05fSElERV9ERUxBWV9NSU4pKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvKiBSZXBvc2l0aW9uIHRoZSBwb3BvdmVyIHRvIHRoZSBsYXllci9sb2NhdGlvbiB0aGF0IHRoZSBub3RpZmljYXRpb24gYXBwbGllcyB0byAqL1xuICAgICAgICBmdW5jdGlvbiBhcHBseU5vdGlmaWNhdGlvblBsYWNlbWVudChvZmZzZXQsIHBsYWNlbWVudCkge1xuICAgICAgICAgICAgb2xkQXBwbHlQbGFjZW1lbnQuY2FsbCh0aGlzLCBvZmZzZXQsIHBsYWNlbWVudCk7XG5cbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICR0aXAgPSB0aGlzLnRpcCgpLFxuICAgICAgICAgICAgICAgICRhcnJvdyA9IHRoaXMuYXJyb3coKSxcbiAgICAgICAgICAgICAgICBsYXllcldpZGdldFBvcyA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICBzY3JvbGxCb3hQb3MgPSBjb250YWluZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cbiAgICAgICAgICAgIHN3aXRjaCAobm90aWZpY2F0aW9uTG9jYXRpb24pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwibGF5ZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBsYXllck1pZGRsZSA9IGxheWVyV2lkZ2V0UG9zLmJvdHRvbSAtIGxheWVySCAvIHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvICogKG5vdGlmaWNhdGlvbkxheWVySW5kZXggKyAwLjUpO1xuXG4gICAgICAgICAgICAgICAgICAgIGxheWVyTWlkZGxlID0gTWF0aC5taW4oTWF0aC5tYXgobGF5ZXJNaWRkbGUsIHNjcm9sbEJveFBvcy50b3ApLCBzY3JvbGxCb3hQb3MuYm90dG9tKTtcblxuICAgICAgICAgICAgICAgICAgICAkdGlwLm9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IGxheWVyTWlkZGxlICsgZG9jdW1lbnQuYm9keS5zY3JvbGxUb3AgLSAkdGlwLmhlaWdodCgpIC8gMixcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGxheWVyV2lkZ2V0UG9zLmxlZnQgLSAkdGlwLm91dGVyV2lkdGgoKSAtICRhcnJvdy5vdXRlcldpZHRoKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIm9wYWNpdHlcIjpcbiAgICAgICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgICAgICBhbHBoYVNsaWRlclBvcyA9IGFscGhhU2xpZGVyLmdldEVsZW1lbnQoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICAgICAgICAgICAgICAgICAgICAkdGlwLm9mZnNldCh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3A6IChhbHBoYVNsaWRlclBvcy50b3AgKyBhbHBoYVNsaWRlclBvcy5ib3R0b20gLSAkdGlwLmhlaWdodCgpKSAvIDIgKyBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlZnQ6IGFscGhhU2xpZGVyUG9zLmxlZnQgLSAkdGlwLm91dGVyV2lkdGgoKSAtICRhcnJvdy5vdXRlcldpZHRoKClcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICRhcnJvdy5jc3MoXCJ0b3BcIiwgXCI1MCVcIik7XG4gICAgICAgIH1cblxuICAgICAgICBjb250cm9sbGVyLm9uKFwibGF5ZXJOb3RpZmljYXRpb25cIiwgdGhpcy5zaG93Tm90aWZpY2F0aW9uLmJpbmQodGhpcykpO1xuXG4gICAgICAgICQoY2FudmFzKVxuICAgICAgICAgICAgLnBvcG92ZXIoe1xuICAgICAgICAgICAgICAgIGh0bWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm90aWZpY2F0aW9uTWVzc2FnZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHBsYWNlbWVudDogXCJsZWZ0XCIsXG4gICAgICAgICAgICAgICAgdHJpZ2dlcjogXCJtYW51YWxcIixcbiAgICAgICAgICAgICAgICBjb250YWluZXI6IHBhbGV0dGUuZ2V0RWxlbWVudCgpXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB2YXJcbiAgICAgICAgICAgIHBvcG92ZXIgPSAkKGNhbnZhcykuZGF0YSgnYnMucG9wb3ZlcicpO1xuXG4gICAgICAgIC8vIFNhdmUgdGhlIG9sZCBwb3NpdGlvbmluZyByb3V0aW5lIHNvIHdlIGNhbiBjYWxsIGl0IGxhdGVyXG4gICAgICAgIG9sZEFwcGx5UGxhY2VtZW50ID0gcG9wb3Zlci5hcHBseVBsYWNlbWVudDtcblxuICAgICAgICBwb3BvdmVyLmFwcGx5UGxhY2VtZW50ID0gYXBwbHlOb3RpZmljYXRpb25QbGFjZW1lbnQ7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICAgICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA9IDEuMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSAnYmxhY2snO1xuICAgICAgICBcbiAgICAgICAgY29udGFpbmVyLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LWxheWVycy13aWRnZXRcIjtcbiAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGNhbnZhcyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gQ1BSZW5hbWVGaWVsZCgpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBsYXllckluZGV4ID0gLTEsXG4gICAgICAgICAgICB0ZXh0Qm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgICAgICB0aGlzLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxheWVySW5kZXggPSAtMTtcbiAgICAgICAgICAgIHRleHRCb3guc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnJlbmFtZUFuZEhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChhcnR3b3JrLmdldExheWVyKGxheWVySW5kZXgpLm5hbWUgIT0gdGV4dEJveC52YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuYWN0aW9uUGVyZm9ybWVkKHthY3Rpb246IFwiQ1BTZXRMYXllck5hbWVcIiwgbGF5ZXJJbmRleDogbGF5ZXJJbmRleCwgbmFtZTogdGV4dEJveC52YWx1ZX0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLmlzVmlzaWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRleHRCb3guc3R5bGUuZGlzcGxheSAhPSAnbm9uZSc7XG4gICAgICAgIH07XG4gICAgICAgIFxuICAgICAgICB0aGlzLnNldExvY2F0aW9uID0gZnVuY3Rpb24ocG9zaXRpb25YLCBwb3NpdGlvblkpIHtcbiAgICAgICAgICAgIHRleHRCb3guc3R5bGUubGVmdCA9IHBvc2l0aW9uWCArIFwicHhcIjtcbiAgICAgICAgICAgIHRleHRCb3guc3R5bGUudG9wID0gcG9zaXRpb25ZICsgXCJweFwiO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zaG93ID0gZnVuY3Rpb24oeCwgeSwgX2xheWVySW5kZXgsIGxheWVyTmFtZSkge1xuICAgICAgICAgICAgbGF5ZXJJbmRleCA9IF9sYXllckluZGV4O1xuICAgICAgICAgICAgdGV4dEJveC52YWx1ZSA9IGxheWVyTmFtZTtcbiAgICAgICAgICAgIHRoaXMuc2V0TG9jYXRpb24oeCwgeSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRleHRCb3guc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgICAgICB0ZXh0Qm94LnNlbGVjdCgpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gdGV4dEJveDtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRleHRCb3gudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICB0ZXh0Qm94LmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LWxheWVyLW5ldy1uYW1lIGZvcm0tY29udHJvbCBpbnB1dC1zbVwiO1xuICAgICAgICB0ZXh0Qm94LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgdGV4dEJveC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAvLyBQcmV2ZW50IG90aGVyIGtleWhhbmRsZXJzIChDUENhbnZhcykgZnJvbSBnZXR0aW5nIHRoZWlyIGdydWJieSBoYW5kcyBvbiB0aGUgaW5wdXRcbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRleHRCb3guYWRkRXZlbnRMaXN0ZW5lcihcImtleXByZXNzXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMTMpIHsgLy8gRW50ZXJcbiAgICAgICAgICAgICAgICB0aGF0LnJlbmFtZUFuZEhpZGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRleHRCb3guYWRkRXZlbnRMaXN0ZW5lcihcImtleXVwXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmtleUNvZGUgPT0gMjcpIHsgLy8gRXNjYXBlXG4gICAgICAgICAgICAgICAgdGhhdC5oaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICB9KTtcblxuICAgICAgICB0ZXh0Qm94LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChsYXllckluZGV4ICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5yZW5hbWVBbmRIaWRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGJsZW5kQ29tYm8uY2xhc3NOYW1lID0gXCJmb3JtLWNvbnRyb2xcIjtcbiAgICBibGVuZENvbWJvLnRpdGxlID0gXCJMYXllciBibGVuZGluZyBtb2RlXCI7XG4gICAgYmxlbmRDb21iby5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgY29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogXCJDUFNldExheWVyQmxlbmRNb2RlXCIsIGxheWVySW5kZXg6IGFydHdvcmsuZ2V0QWN0aXZlTGF5ZXJJbmRleCgpLCBibGVuZE1vZGU6IHBhcnNlSW50KGJsZW5kQ29tYm8udmFsdWUsIDEwKX0pO1xuICAgIH0pO1xuICAgIFxuICAgIGZpbGxDb21ib2JveChibGVuZENvbWJvLCBNT0RFX05BTUVTKTtcblxuICAgIGJvZHkuYXBwZW5kQ2hpbGQoYmxlbmRDb21ibyk7XG4gICAgXG4gICAgYWxwaGFTbGlkZXIudGl0bGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gXCJPcGFjaXR5OiBcIiArIHZhbHVlICsgXCIlXCI7XG4gICAgfTtcbiAgICBcbiAgICBhbHBoYVNsaWRlci5vbihcInZhbHVlQ2hhbmdlXCIsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWN0aW9uUGVyZm9ybWVkKHthY3Rpb246IFwiQ1BTZXRMYXllckFscGhhXCIsIGxheWVySW5kZXg6IGFydHdvcmsuZ2V0QWN0aXZlTGF5ZXJJbmRleCgpLCBhbHBoYTogdmFsdWV9KTtcbiAgICB9KTtcbiAgICBcbiAgICBib2R5LmFwcGVuZENoaWxkKGFscGhhU2xpZGVyLmdldEVsZW1lbnQoKSk7XG5cbiAgICBjYlNhbXBsZUFsbExheWVycy50eXBlID0gXCJjaGVja2JveFwiO1xuICAgIGNiU2FtcGxlQWxsTGF5ZXJzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgYXJ0d29yayA9IGNvbnRyb2xsZXIuZ2V0QXJ0d29yaygpO1xuICAgICAgICBcbiAgICAgICAgYXJ0d29yay5zZXRTYW1wbGVBbGxMYXllcnMoY2JTYW1wbGVBbGxMYXllcnMuY2hlY2tlZCk7XG4gICAgfSk7XG4gICAgXG4gICAgYm9keS5hcHBlbmRDaGlsZCh3cmFwQ2hlY2tib3hXaXRoTGFiZWwoY2JTYW1wbGVBbGxMYXllcnMsIFwiU2FtcGxlIGFsbCBsYXllcnNcIikpO1xuICAgIFxuICAgIGNiTG9ja0FscGhhLnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgY2JMb2NrQWxwaGEuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBhcnR3b3JrID0gY29udHJvbGxlci5nZXRBcnR3b3JrKCk7XG4gICAgICAgIFxuICAgICAgIGFydHdvcmsuc2V0TG9ja0FscGhhKGNiTG9ja0FscGhhLmNoZWNrZWQpO1xuICAgIH0pO1xuICAgICAgICBcbiAgICBib2R5LmFwcGVuZENoaWxkKHdyYXBDaGVja2JveFdpdGhMYWJlbChjYkxvY2tBbHBoYSwgXCJMb2NrIGFscGhhXCIpKTtcblxuICAgIGxheWVyV2lkZ2V0LmdldEVsZW1lbnQoKS5hcHBlbmRDaGlsZChyZW5hbWVGaWVsZC5nZXRFbGVtZW50KCkpO1xuXG4gICAgYm9keS5hcHBlbmRDaGlsZChsYXllcldpZGdldC5nZXRFbGVtZW50KCkpO1xuXG4gICAgLy8gQWRkL1JlbW92ZSBsYXllciBidXR0b25zXG4gICAgdmFyXG4gICAgICAgIGFkZFJlbW92ZUNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiKTtcbiAgICBcbiAgICBhZGRSZW1vdmVDb250YWluZXIuY2xhc3NOYW1lID0gJ2NoaWNrZW5wYWludC1sYXllci1hZGQtcmVtb3ZlIGxpc3QtdW5zdHlsZWQnO1xuICAgIFxuICAgIGFkZEJ1dHRvbi5jbGFzc05hbWUgPSAnY2hpY2tlbnBhaW50LXNtYWxsLXRvb2xiYXItYnV0dG9uIGNoaWNrZW5wYWludC1hZGQtbGF5ZXInO1xuICAgIGFkZEJ1dHRvbi50aXRsZSA9ICdBZGQgbGF5ZXInO1xuICAgIGFkZEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWN0aW9uUGVyZm9ybWVkKHthY3Rpb246IFwiQ1BBZGRMYXllclwifSk7XG4gICAgfSk7XG5cbiAgICByZW1vdmVCdXR0b24uY2xhc3NOYW1lID0gJ2NoaWNrZW5wYWludC1zbWFsbC10b29sYmFyLWJ1dHRvbiBjaGlja2VucGFpbnQtcmVtb3ZlLWxheWVyJztcbiAgICByZW1vdmVCdXR0b24udGl0bGUgPSBcIkRlbGV0ZSBsYXllclwiO1xuICAgIHJlbW92ZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWN0aW9uUGVyZm9ybWVkKHthY3Rpb246IFwiQ1BSZW1vdmVMYXllclwifSk7XG4gICAgfSk7XG4gICAgXG4gICAgYWRkUmVtb3ZlQ29udGFpbmVyLmFwcGVuZENoaWxkKGFkZEJ1dHRvbik7XG4gICAgYWRkUmVtb3ZlQ29udGFpbmVyLmFwcGVuZENoaWxkKHJlbW92ZUJ1dHRvbik7XG5cbiAgICBib2R5LmFwcGVuZENoaWxkKGFkZFJlbW92ZUNvbnRhaW5lcik7XG4gICAgXG4gICAgdmFyXG4gICAgICAgIGFydHdvcmsgPSBjb250cm9sbGVyLmdldEFydHdvcmsoKTtcblxuICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xuICAgIGFscGhhU2xpZGVyLnNldFZhbHVlKGFydHdvcmsuZ2V0QWN0aXZlTGF5ZXIoKS5nZXRBbHBoYSgpKTtcbiAgICBibGVuZENvbWJvLnZhbHVlID0gYXJ0d29yay5nZXRBY3RpdmVMYXllcigpLmdldEJsZW5kTW9kZSgpO1xuXG4gICAgYXJ0d29yay5vbihcImNoYW5nZUxheWVyXCIsIGZ1bmN0aW9uKGxheWVySW5kZXgpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBhcnR3b3JrID0gdGhpcztcbiAgICAgICAgXG4gICAgICAgIGlmIChhcnR3b3JrLmdldEFjdGl2ZUxheWVyKCkuZ2V0QWxwaGEoKSAhPSBhbHBoYVNsaWRlci52YWx1ZSkge1xuICAgICAgICAgICAgYWxwaGFTbGlkZXIuc2V0VmFsdWUoYXJ0d29yay5nZXRBY3RpdmVMYXllcigpLmdldEFscGhhKCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGFydHdvcmsuZ2V0QWN0aXZlTGF5ZXIoKS5nZXRCbGVuZE1vZGUoKSAhPSBwYXJzZUludChibGVuZENvbWJvLnZhbHVlLCAxMCkpIHtcbiAgICAgICAgICAgIGJsZW5kQ29tYm8udmFsdWUgPSBhcnR3b3JrLmdldEFjdGl2ZUxheWVyKCkuZ2V0QmxlbmRNb2RlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5ZXJJbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsYXllcldpZGdldC5wYWludExheWVyKGxheWVySW5kZXgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gV2UgbWF5IGhhdmUgYWRkZWQgb3IgcmVtb3ZlZCBsYXllcnMsIHJlc2l6ZSBhcyBhcHByb3ByaWF0ZVxuICAgICAgICAgICAgbGF5ZXJXaWRnZXQucmVzaXplKCk7XG4gICAgICAgIH1cblxuICAgICAgICBsYXllcldpZGdldC5kaXNtaXNzTm90aWZpY2F0aW9uKCk7XG4gICAgfSk7XG59XG5cbkNQTGF5ZXJzUGFsZXR0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQUGFsZXR0ZS5wcm90b3R5cGUpO1xuQ1BMYXllcnNQYWxldHRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQTGF5ZXJzUGFsZXR0ZTsiLCIvKlxuICAgIENoaWNrZW5QYWludFxuICAgIFxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG4gICAgXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IENQQ2FudmFzIGZyb20gXCIuL0NQQ2FudmFzXCI7XG5pbXBvcnQgQ1BQYWxldHRlTWFuYWdlciBmcm9tIFwiLi9DUFBhbGV0dGVNYW5hZ2VyXCI7XG5pbXBvcnQgQ1BNYWluTWVudSBmcm9tIFwiLi9DUE1haW5NZW51XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQTWFpbkdVSShjb250cm9sbGVyLCB1aUVsZW0pIHtcbiAgICB2YXJcbiAgICAgICAgbG93ZXJBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgY2FudmFzID0gbmV3IENQQ2FudmFzKGNvbnRyb2xsZXIpLFxuICAgICAgICBwYWxldHRlTWFuYWdlciA9IG5ldyBDUFBhbGV0dGVNYW5hZ2VyKGNvbnRyb2xsZXIpLFxuICAgICAgICBtZW51QmFyLFxuXG4gICAgICAgIGZ1bGxTY3JlZW5Nb2RlID0gZmFsc2UsXG4gICAgICAgIFxuICAgICAgICB0aGF0ID0gdGhpcztcbiAgICBcbiAgICB0aGlzLnRvZ2dsZVBhbGV0dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhbGV0dGVNYW5hZ2VyLnRvZ2dsZVBhbGV0dGVzKCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmFycmFuZ2VQYWxldHRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBHaXZlIHRoZSBicm93c2VyIGEgY2hhbmNlIHRvIGRvIHRoZSBzaXppbmcgb2YgdGhlIHBhbGV0dGVzIGJlZm9yZSB3ZSB0cnkgdG8gcmVhcnJhbmdlIHRoZW1cbiAgICAgICAgc2V0VGltZW91dChwYWxldHRlTWFuYWdlci5hcnJhbmdlUGFsZXR0ZXMuYmluZChwYWxldHRlTWFuYWdlciksIDApO1xuICAgIH07XG5cbiAgICB0aGlzLmNvbnN0cmFpblBhbGV0dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHBhbGV0dGVNYW5hZ2VyLmNvbnN0cmFpblBhbGV0dGVzKCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNob3dQYWxldHRlID0gZnVuY3Rpb24ocGFsZXR0ZU5hbWUsIHNob3cpIHtcbiAgICAgICAgcGFsZXR0ZU1hbmFnZXIuc2hvd1BhbGV0dGVCeU5hbWUocGFsZXR0ZU5hbWUsIHNob3cpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRTd2F0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcGFsZXR0ZU1hbmFnZXIucGFsZXR0ZXMuc3dhdGNoZXMuZ2V0U3dhdGNoZXMoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTd2F0Y2hlcyA9IGZ1bmN0aW9uKHN3YXRjaGVzKSB7XG4gICAgICAgIHBhbGV0dGVNYW5hZ2VyLnBhbGV0dGVzLnN3YXRjaGVzLnNldFN3YXRjaGVzKHN3YXRjaGVzKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0UGFsZXR0ZU1hbmFnZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhbGV0dGVNYW5hZ2VyO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXRSb3RhdGlvbiA9IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG4gICAgICAgIGNhbnZhcy5zZXRSb3RhdGlvbihyb3RhdGlvbik7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0RnVsbFNjcmVlbk1vZGUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBmdWxsU2NyZWVuTW9kZSA9IHZhbHVlO1xuXG4gICAgICAgIHRoYXQucmVzaXplKCk7XG4gICAgICAgIHRoYXQuYXJyYW5nZVBhbGV0dGVzKCk7XG4gICAgfTtcblxuICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbmV3SGVpZ2h0O1xuXG4gICAgICAgIGlmIChmdWxsU2NyZWVuTW9kZSkge1xuICAgICAgICAgICAgbmV3SGVpZ2h0ID0gJCh3aW5kb3cpLmhlaWdodCgpIC0gJChtZW51QmFyLmdldEVsZW1lbnQoKSkuaGVpZ2h0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdIZWlnaHQgPSBNYXRoLm1pbihNYXRoLm1heCgoJCh3aW5kb3cpLmhlaWdodCgpIC0gJChtZW51QmFyLmdldEVsZW1lbnQoKSkuaGVpZ2h0KCkgLSA2NSksIDUwMCksIDc1MCk7XG4gICAgICAgIH1cblxuICAgICAgICBjYW52YXMucmVzaXplKG5ld0hlaWdodCk7XG4gICAgICAgIHRoYXQuY29uc3RyYWluUGFsZXR0ZXMoKTtcbiAgICB9O1xuXG4gICAgbWVudUJhciA9IG5ldyBDUE1haW5NZW51KGNvbnRyb2xsZXIsIHRoaXMpXG5cbiAgICB1aUVsZW0uYXBwZW5kQ2hpbGQobWVudUJhci5nZXRFbGVtZW50KCkpO1xuICAgIFxuICAgIGxvd2VyQXJlYS5jbGFzc05hbWUgPSAnY2hpY2tlbnBhaW50LW1haW4tc2VjdGlvbic7XG4gICAgXG4gICAgbG93ZXJBcmVhLmFwcGVuZENoaWxkKGNhbnZhcy5nZXRFbGVtZW50KCkpO1xuICAgIGxvd2VyQXJlYS5hcHBlbmRDaGlsZChwYWxldHRlTWFuYWdlci5nZXRFbGVtZW50KCkpO1xuICAgIFxuICAgIHVpRWxlbS5hcHBlbmRDaGlsZChsb3dlckFyZWEpO1xuXG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdGhpcy5yZXNpemUuYmluZCh0aGlzKSk7XG5cbiAgICBzZXRUaW1lb3V0KHRoaXMucmVzaXplLmJpbmQodGhpcyksIDApO1xufVxuXG5DUE1haW5HVUkucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbkNQTWFpbkdVSS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUE1haW5HVUk7IiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbnZhclxuICAgIE1FTlVfRU5UUklFUyA9IFtcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJGaWxlXCIsXG4gICAgICAgICAgICBtbmVtb25pYzogXCJGXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTYXZlIHRvIG15IGNvbXB1dGVyXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUFNhdmVcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiU1wiLFxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dDogXCJjdHJsK3NcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNhdmUgT2VrYWtpXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUFNlbmRcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiU1wiLFxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dDogXCJjdHJsK3NcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIkVkaXRcIixcbiAgICAgICAgICAgIG1uZW1vbmljOiBcIkVcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlVuZG9cIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQVW5kb1wiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJVXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcImN0cmwrelwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJVbmRvZXMgdGhlIG1vc3QgcmVjZW50IGFjdGlvblwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUmVkb1wiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BSZWRvXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIlJcIixcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRjdXQ6IFwic2hpZnQrY3RybCt6XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlJlZG9lcyBhIHByZXZpb3VzbHkgdW5kb25lIGFjdGlvblwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQ2xlYXIgaGlzdG9yeVwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BDbGVhckhpc3RvcnlcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiSFwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJSZW1vdmVzIGFsbCB1bmRvL3JlZG8gaW5mb3JtYXRpb24gdG8gcmVnYWluIG1lbW9yeVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiLVwiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkN1dFwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BDdXRcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiVFwiLFxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dDogXCJjdHJsK3hcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvcHlcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQQ29weVwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJDXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcImN0cmwrY1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiQ29weSBtZXJnZWRcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQQ29weU1lcmdlZFwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJZXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcInNoaWZ0K2N0cmwrY1wiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiUGFzdGVcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQUGFzdGVcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiUFwiLFxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dDogXCJjdHJsK3ZcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIi1cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNlbGVjdCBhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQU2VsZWN0QWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIkFcIixcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRjdXQ6IFwiY3RybCthXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJEZXNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BEZXNlbGVjdEFsbFwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJEXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcImN0cmwrZFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiLVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVHJhbnNmb3JtXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUFRyYW5zZm9ybVwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJUXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcImN0cmwreVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJMYXllcnNcIixcbiAgICAgICAgICAgIG1uZW1vbmljOiBcIkxcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkR1cGxpY2F0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BMYXllckR1cGxpY2F0ZVwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJEXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcInNoaWZ0K2N0cmwrZFwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJDcmVhdGVzIGEgY29weSBvZiB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGxheWVyXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCItXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJNZXJnZSBkb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUExheWVyTWVyZ2VEb3duXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIkVcIixcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRjdXQ6IFwiY3RybCtlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIk1lcmdlcyB0aGUgY3VycmVudGx5IHNlbGVjdGVkIGxheWVyIHdpdGggdGhlIG9uZSBkaXJlY3RseSBiZWxvdyBpdFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTWVyZ2UgYWxsIGxheWVyc1wiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BMYXllck1lcmdlQWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIkFcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiTWVyZ2VzIGFsbCB0aGUgbGF5ZXJzXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgICAgbmFtZTogXCJFZmZlY3RzXCIsXG4gICAgICAgICAgICBtbmVtb25pYzogXCJFXCIsXG4gICAgICAgICAgICBjaGlsZHJlbjogW1xuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJDbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BDbGVhclwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJEXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcImRlbCxiYWNrc3BhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiQ2xlYXJzIHRoZSBzZWxlY3RlZCBhcmVhXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJGaWxsXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUEZpbGxcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiRlwiLFxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dDogXCJjdHJsK2ZcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRmlsbHMgdGhlIHNlbGVjdGVkIGFyZWEgd2l0aCB0aGUgY3VycmVudCBjb2xvclwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiRmxpcCBob3Jpem9udGFsXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUEhGbGlwXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIkhcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRmxpcHMgdGhlIGN1cnJlbnQgc2VsZWN0ZWQgYXJlYSBob3Jpem9udGFsbHlcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkZsaXAgdmVydGljYWxcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQVkZsaXBcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiVlwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJGbGlwcyB0aGUgY3VycmVudCBzZWxlY3RlZCBhcmVhIHZlcnRpY2FsbHlcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BGWEludmVydFwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJJXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkludmVydCB0aGUgaW1hZ2UgY29sb3JzXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCItXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJCb3ggYmx1ci4uLlwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BGWEJveEJsdXJcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiQlwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJCbHVyIGVmZmVjdFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiLVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiTW9ub2Nocm9tYXRpYyBub2lzZVwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BNTm9pc2VcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiTVwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJGaWxscyB0aGUgc2VsZWN0aW9uIHdpdGggbm9pc2VcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkNvbG9yIG5vaXNlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUENOb2lzZVwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJDXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIkZpbGxzIHRoZSBzZWxlY3Rpb24gd2l0aCBjb2xvcmVkIG5vaXNlXCJcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIlZpZXdcIixcbiAgICAgICAgICAgIG1uZW1vbmljOiBcIlZcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkZ1bGwtc2NyZWVuIG1vZGVcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQRnVsbFNjcmVlblwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJGXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIi1cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlpvb20gaW5cIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQWm9vbUluXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIklcIixcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRjdXQ6IFwiY3RybCs9XCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlpvb21zIGluXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJab29tIG91dFwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1Bab29tT3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIk9cIixcbiAgICAgICAgICAgICAgICAgICAgc2hvcnRjdXQ6IFwiY3RybCstXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlpvb21zIG91dFwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiWm9vbSAxMDAlXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUFpvb20xMDBcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiMVwiLFxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dDogXCJjdHJsKzBcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiUmVzZXRzIHRoZSB6b29tIGZhY3RvciB0byAxMDAlXCJcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQTGluZWFySW50ZXJwb2xhdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIi1cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNtb290aC1vdXQgem9vbWVkIGNhbnZhc1wiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BMaW5lYXJJbnRlcnBvbGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIkxcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiTGluZWFyIGludGVycG9sYXRpb24gaXMgdXNlZCB0byBnaXZlIGEgc21vb3RoZWQgbG9va2VkIHRvIHRoZSBwaWN0dXJlIHdoZW4gem9vbWVkIGluXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94OiB0cnVlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiLVwiXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiU2hvdyBncmlkXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUFRvZ2dsZUdyaWRcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiR1wiLFxuICAgICAgICAgICAgICAgICAgICBzaG9ydGN1dDogXCJjdHJsK2dcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRGlzcGxheXMgYSBncmlkIG92ZXIgdGhlIGltYWdlXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiBmYWxzZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkdyaWQgb3B0aW9ucy4uLlwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BHcmlkT3B0aW9uc1wiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJEXCIsXG4gICAgICAgICAgICAgICAgICAgIHRpdGxlOiBcIlNob3dzIHRoZSBncmlkIG9wdGlvbnMgZGlhbG9nIGJveFwiLFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIG5hbWU6IFwiUGFsZXR0ZXNcIixcbiAgICAgICAgICAgIG1uZW1vbmljOiBcIlBcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlJlYXJyYW5nZVwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BBcnJhbmdlUGFsZXR0ZXNcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiUmVhcnJhbmdlIHRoZSBwYWxldHRlIHdpbmRvd3NcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRvZ2dsZSBwYWxldHRlc1wiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BUb2dnbGVQYWxldHRlc1wiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJQXCIsXG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcInRhYlwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJIaWRlcyBvciBzaG93cyBhbGwgcGFsZXR0ZXNcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIi1cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNob3cgdG9vbCBvcHRpb25zXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUFBhbEJydXNoXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIkJcIixcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTaG93IGNvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUFBhbENvbG9yXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIkNcIixcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTaG93IGxheWVyc1wiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BQYWxMYXllcnNcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiWVwiLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2JveDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNob3cgbWlzY1wiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BQYWxNaXNjXCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIk1cIixcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tib3g6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrZWQ6IHRydWVcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJTaG93IHN0cm9rZVwiLFxuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiQ1BQYWxTdHJva2VcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiU1wiLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2JveDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNob3cgc3dhdGNoZXNcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQUGFsU3dhdGNoZXNcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiV1wiLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2JveDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNob3cgdGV4dHVyZXNcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQUGFsVGV4dHVyZXNcIixcbiAgICAgICAgICAgICAgICAgICAgbW5lbW9uaWM6IFwiWFwiLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2JveDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgY2hlY2tlZDogdHJ1ZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNob3cgdG9vbHNcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQUGFsVG9vbFwiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJUXCIsXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrYm94OiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBjaGVja2VkOiB0cnVlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBuYW1lOiBcIkhlbHBcIixcbiAgICAgICAgICAgIG1uZW1vbmljOiBcIkhcIixcbiAgICAgICAgICAgIGNoaWxkcmVuOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRhYmxldCBzdXBwb3J0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIlRcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQVGFibGV0U3VwcG9ydFwiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJIZWxwIHdpdGggZ2V0dGluZyBhIGRyYXdpbmcgdGFibGV0IHdvcmtpbmdcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlNob3J0Y3V0c1wiLFxuICAgICAgICAgICAgICAgICAgICBtbmVtb25pYzogXCJTXCIsXG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJDUFNob3J0Y3V0c1wiLFxuICAgICAgICAgICAgICAgICAgICB0aXRsZTogXCJMaXN0IG9mIGtleWJvYXJkIGFuZCBtb3VzZSBzaG9ydGN1dHNcIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIi1cIlxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIkFib3V0XCIsXG4gICAgICAgICAgICAgICAgICAgIG1uZW1vbmljOiBcIkFcIixcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcIkNQQWJvdXRcIixcbiAgICAgICAgICAgICAgICAgICAgdGl0bGU6IFwiRGlzcGxheXMgc29tZSBpbmZvcm1hdGlvbiBhYm91dCBDaGlja2VuUGFpbnRcIlxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICBdO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUE1haW5NZW51KGNvbnRyb2xsZXIsIG1haW5HVUkpIHtcbiAgICB2YXJcbiAgICAgICAgYmFyID0gJChcbiAgICAgICAgICAgICc8bmF2IGNsYXNzPVwibmF2YmFyIG5hdmJhci1kZWZhdWx0XCI+J1xuICAgICAgICAgICAgICAgICsgJzxkaXYgY2xhc3M9XCJjb250YWluZXItZmx1aWRcIj4nXG4gICAgICAgICAgICAgICAgICAgICsgJzxkaXYgY2xhc3M9XCJuYXZiYXItaGVhZGVyXCI+J1xuICAgICAgICAgICAgICAgICAgICAgICAgKyAnPGEgY2xhc3M9XCJuYXZiYXItYnJhbmRcIiBocmVmPVwiI1wiPkNoaWNrZW5QYWludDwvYT4nXG4gICAgICAgICAgICAgICAgICAgICsgJzwvZGl2PidcbiAgICAgICAgICAgICAgICAgICAgKyAnPHVsIGNsYXNzPVwibmF2IG5hdmJhci1uYXZcIj4nXG4gICAgICAgICAgICAgICAgICAgICsgJzwvdWw+J1xuICAgICAgICAgICAgICAgICsgJzwvZGl2PidcbiAgICAgICAgICAgICsgJzwvbmF2PidcbiAgICAgICAgKSxcbiAgICAgICAgbWFjUGxhdGZvcm0gPSAvXk1hYy9pLnRlc3QobmF2aWdhdG9yLnBsYXRmb3JtKTtcbiAgICBcbiAgICBmdW5jdGlvbiBtZW51SXRlbUNsaWNrZWQodGFyZ2V0KSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgYWN0aW9uID0gdGFyZ2V0LmRhdGEoJ2FjdGlvbicpLFxuICAgICAgICAgICAgY2hlY2tib3ggPSB0YXJnZXQuZGF0YSgnY2hlY2tib3gnKSxcbiAgICAgICAgICAgIHNlbGVjdGVkO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoZWNrYm94KSB7XG4gICAgICAgICAgICB0YXJnZXQudG9nZ2xlQ2xhc3MoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgIHNlbGVjdGVkID0gdGFyZ2V0Lmhhc0NsYXNzKFwic2VsZWN0ZWRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBjb250cm9sbGVyLmFjdGlvblBlcmZvcm1lZCh7XG4gICAgICAgICAgICBhY3Rpb246IGFjdGlvbixcbiAgICAgICAgICAgIGNoZWNrYm94OiBjaGVja2JveCxcbiAgICAgICAgICAgIHNlbGVjdGVkOiBzZWxlY3RlZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gcHJlc2VudFNob3J0Y3V0VGV4dChzaG9ydGN1dCkge1xuICAgICAgICBzaG9ydGN1dCA9IHNob3J0Y3V0LnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyBPbmx5IHNob3cgdGhlIGZpcnN0IHBvdGVudGlhbCBzaG9ydGN1dCBvdXQgb2YgdGhlIGNvbW1hLXNlcGFyYXRlZCBsaXN0XG4gICAgICAgIHNob3J0Y3V0ID0gc2hvcnRjdXQucmVwbGFjZSgvKCwuKykkLywgXCJcIik7XG4gICAgICAgIFxuICAgICAgICAvLyBBbHRob3VnaCB0aGUga2V5Y29kZSBmb3Igem9vbSBpbiBpcyBcIj1cIiwgd2UnbGwgcHJlc2VudCBpdCB0byB0aGUgdXNlciBhcyBcIitcIlxuICAgICAgICBzaG9ydGN1dCA9IHNob3J0Y3V0LnJlcGxhY2UoXCJjdHJsKz1cIiwgXCJjdHJsKytcIik7XG4gICAgICAgIHNob3J0Y3V0ID0gc2hvcnRjdXQucmVwbGFjZShcIuKMmCs9XCIsIFwi4oyYKytcIik7XG4gICAgICAgIFxuICAgICAgICBpZiAobWFjUGxhdGZvcm0pIHtcbiAgICAgICAgICAgIHNob3J0Y3V0ID0gc2hvcnRjdXQucmVwbGFjZSgvKFteK10pXFwrL2csIFwiJDFcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzaG9ydGN1dCA9IHNob3J0Y3V0LnJlcGxhY2UoLyhbXitdKVxcKy9nLCBcIiQxIFwiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHNob3J0Y3V0O1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiByZWN1cnNlRmlsbE1lbnUobWVudUVsZW0sIGVudHJpZXMpIHtcbiAgICAgICAgbWVudUVsZW0uYXBwZW5kKGVudHJpZXMubWFwKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgZW50cnlFbGVtO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZW50cnkuYWN0aW9uICYmICFjb250cm9sbGVyLmlzQWN0aW9uU3VwcG9ydGVkKGVudHJ5LmFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChlbnRyeS5hY3Rpb24gPT0gXCJDUFNlbmRcIiAmJiAhY29udHJvbGxlci5pc0FjdGlvblN1cHBvcnRlZChcIkNQQ29udGludWVcIikpIHtcbiAgICAgICAgICAgICAgICAvLyBVc2VyIHdvbid0IGJlIGFibGUgdG8gY29tZSBiYWNrIGFmdGVyIHNhdmluZywgc28gbWFrZSBpdCBzb3VuZCBtb3JlIGZpbmFsXG4gICAgICAgICAgICAgICAgZW50cnkubmFtZSA9IFwiUG9zdCBPZWtha2lcIjtcbiAgICAgICAgICAgICAgICBlbnRyeS5zaG9ydGN1dCA9IFwiY3RybCtwXCI7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChlbnRyeS5jaGlsZHJlbikge1xuICAgICAgICAgICAgICAgIGVudHJ5RWxlbSA9ICQoXG4gICAgICAgICAgICAgICAgICAgICc8bGkgY2xhc3M9XCJkcm9wZG93blwiPidcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJzxhIGhyZWY9XCIjXCIgY2xhc3M9XCJkcm9wZG93bi10b2dnbGVcIiBkYXRhLXRvZ2dsZT1cImRyb3Bkb3duXCIgcm9sZT1cImJ1dHRvblwiIGFyaWEtaGFzcG9wdXA9XCJ0cnVlXCIgYXJpYS1leHBhbmRlZD1cImZhbHNlXCI+JyArIGVudHJ5Lm5hbWUgKyAnIDxzcGFuIGNsYXNzPVwiY2FyZXRcIj48L3NwYW4+PC9hPidcbiAgICAgICAgICAgICAgICAgICAgICAgICsgJzx1bCBjbGFzcz1cImRyb3Bkb3duLW1lbnVcIj4nXG4gICAgICAgICAgICAgICAgICAgICAgICArICc8L3VsPidcbiAgICAgICAgICAgICAgICAgICAgKyAnPC9saT4nXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgICQoXCIuZHJvcGRvd24tdG9nZ2xlXCIsIGVudHJ5RWxlbSkuZHJvcGRvd24oKTtcblxuICAgICAgICAgICAgICAgIGVudHJ5RWxlbS5vbihcInNob3cuYnMuZHJvcGRvd25cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEluc3RlYWQgb2YgQm9vdHN0cmFwJ3MgZXh0cmVtZWx5IGV4cGVuc2l2ZSBkYXRhIEFQSSwgd2UnbGwgb25seSBsaXN0ZW4gZm9yIGRpc21pc3MgY2xpY2tzIG9uIHRoZVxuICAgICAgICAgICAgICAgICAgICAgKiBkb2N1bWVudCAqd2hpbGUgdGhlIG1lbnUgaXMgb3BlbiEqXG4gICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAkKGRvY3VtZW50KS5vbmUoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlbnRyeUVsZW0uaGFzQ2xhc3MoXCJvcGVuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJChcIi5kcm9wZG93bi10b2dnbGVcIiwgZW50cnlFbGVtKS5kcm9wZG93bihcInRvZ2dsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcmVjdXJzZUZpbGxNZW51KCQoXCIuZHJvcGRvd24tbWVudVwiLCBlbnRyeUVsZW0pLCBlbnRyeS5jaGlsZHJlbik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVudHJ5Lm5hbWUgPT0gJy0nKSB7XG4gICAgICAgICAgICAgICAgZW50cnlFbGVtID0gJCgnPGxpIHJvbGU9XCJzZXBhcmF0b3JcIiBjbGFzcz1cImRpdmlkZXJcIj48L2xpPicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBlbnRyeUVsZW0gPSAkKCc8bGk+PGEgaHJlZj1cIiNcIiBkYXRhLWFjdGlvbj1cIicgKyBlbnRyeS5hY3Rpb24gKyAnXCI+PHNwYW4+JyArIGVudHJ5Lm5hbWUgKyAnPC9zcGFuPjwvYT48L2xpPicpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5jaGVja2JveCkge1xuICAgICAgICAgICAgICAgICAgICAkKFwiYVwiLCBlbnRyeUVsZW0pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZGF0YShcImNoZWNrYm94XCIsIHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAudG9nZ2xlQ2xhc3MoXCJzZWxlY3RlZFwiLCAhIWVudHJ5LmNoZWNrZWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGVudHJ5LnRpdGxlKSB7XG4gICAgICAgICAgICAgICAgZW50cnlFbGVtLmF0dHIoJ3RpdGxlJywgZW50cnkudGl0bGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZW50cnkuc2hvcnRjdXQpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgbWVudUxpbmsgPSAkKFwiPiBhXCIsIGVudHJ5RWxlbSksXG4gICAgICAgICAgICAgICAgICAgIHNob3J0Y3V0RGVzYyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzbWFsbFwiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBSZXdyaXRlIHRoZSBzaG9ydGN1dHMgdG8gTWFjLXN0eWxlXG4gICAgICAgICAgICAgICAgaWYgKG1hY1BsYXRmb3JtKSB7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnNob3J0Y3V0ID0gZW50cnkuc2hvcnRjdXQucmVwbGFjZSgvU0hJRlQvaW0sIFwi4oenXCIpO1xuICAgICAgICAgICAgICAgICAgICBlbnRyeS5zaG9ydGN1dCA9IGVudHJ5LnNob3J0Y3V0LnJlcGxhY2UoL0FMVC9pbSwgXCLijKVcIik7XG4gICAgICAgICAgICAgICAgICAgIGVudHJ5LnNob3J0Y3V0ID0gZW50cnkuc2hvcnRjdXQucmVwbGFjZSgvQ1RSTC9pbSwgXCLijJhcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNob3J0Y3V0RGVzYy5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC1zaG9ydGN1dFwiO1xuICAgICAgICAgICAgICAgIHNob3J0Y3V0RGVzYy5pbm5lckhUTUwgPSBwcmVzZW50U2hvcnRjdXRUZXh0KGVudHJ5LnNob3J0Y3V0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBtZW51TGluay5hcHBlbmQoc2hvcnRjdXREZXNjKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBrZXkoZW50cnkuc2hvcnRjdXQsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVudUl0ZW1DbGlja2VkKG1lbnVMaW5rKTtcblxuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gZW50cnlFbGVtO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmFyWzBdO1xuICAgIH07XG4gICAgXG4gICAgcmVjdXJzZUZpbGxNZW51KCQoXCIubmF2YmFyLW5hdlwiLCBiYXIpLCBNRU5VX0VOVFJJRVMpO1xuXG4gICAgJChiYXIpLm9uKCdjbGljaycsICdhOm5vdCguZHJvcGRvd24tdG9nZ2xlKScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgbWVudUl0ZW1DbGlja2VkKCQodGhpcykpO1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfSk7XG4gICAgXG4gICAgZnVuY3Rpb24gb25QYWxldHRlVmlzQ2hhbmdlKHBhbGV0dGVOYW1lLCBzaG93KSB7XG4gICAgICAgIC8vIFRvZ2dsZSB0aGUgdGlja2JveCBvZiB0aGUgY29ycmVzcG9uZGluZyBtZW51IGVudHJ5IHRvIG1hdGNoIHRoZSBuZXcgcGFsZXR0ZSB2aXNpYmlsaXR5XG4gICAgICAgIHZhclxuICAgICAgICAgICAgcGFsTWVudUVudHJ5ID0gJCgnW2RhdGEtYWN0aW9uPVxcXCJDUFBhbCcgKyBwYWxldHRlTmFtZS5zdWJzdHJpbmcoMCwgMSkudG9VcHBlckNhc2UoKSArIHBhbGV0dGVOYW1lLnN1YnN0cmluZygxKSArICdcXFwiXScsIGJhcik7XG4gICAgICAgIFxuICAgICAgICBwYWxNZW51RW50cnkudG9nZ2xlQ2xhc3MoXCJzZWxlY3RlZFwiLCBzaG93KTtcbiAgICB9XG5cbiAgICBtYWluR1VJLmdldFBhbGV0dGVNYW5hZ2VyKCkub24oXCJwYWxldHRlVmlzQ2hhbmdlXCIsIG9uUGFsZXR0ZVZpc0NoYW5nZSk7XG59IiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBDUFBhbGV0dGUgZnJvbSAnLi9DUFBhbGV0dGUnO1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUE1pc2NQYWxldHRlKGNwQ29udHJvbGxlcikge1xuICAgIENQUGFsZXR0ZS5jYWxsKHRoaXMsIGNwQ29udHJvbGxlciwgXCJtaXNjXCIsIFwiTWlzY1wiKTtcbiAgICBcbiAgICB2YXIgXG4gICAgICAgIHRoYXQgPSB0aGlzLFxuXG4gICAgICAgIGJ1dHRvbnMgPSBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLXpvb20taW5cIixcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBcIkNQWm9vbUluXCIsXG4gICAgICAgICAgICAgICAgdG9vbFRpcDogXCJab29tIGluXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLXpvb20tb3V0XCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogXCJDUFpvb21PdXRcIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIlpvb20gb3V0XCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLXpvb20tMTAwXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogXCJDUFpvb20xMDBcIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIlpvb20gMTAwJVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGlja2VucGFpbnQtdG9vbC11bmRvXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogXCJDUFVuZG9cIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIlVuZG9cIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiY2hpY2tlbnBhaW50LXRvb2wtcmVkb1wiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BSZWRvXCIsXG4gICAgICAgICAgICAgICAgdG9vbFRpcDogXCJSZWRvXCJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLXNlbmRcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBcIkNQU2VuZFwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiU2F2ZSBwaWNcIlxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcblxuICAgIGZ1bmN0aW9uIGJ1aWxkQnV0dG9ucygpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBib2R5ID0gdGhhdC5nZXRCb2R5RWxlbWVudCgpLFxuICAgICAgICAgICAgbGlzdEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIFxuICAgICAgICBsaXN0RWxlbS5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC1taXNjLXRvb2xzIGxpc3QtdW5zdHlsZWRcIjtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgaW4gYnV0dG9ucykge1xuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgIGJ1dHRvbiA9IGJ1dHRvbnNbaV0sXG4gICAgICAgICAgICAgICAgYnV0dG9uRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGJ1dHRvbi5jb21tYW5kID09ICdDUFNlbmQnICYmICFjcENvbnRyb2xsZXIuaXNBY3Rpb25TdXBwb3J0ZWQoXCJDUENvbnRpbnVlXCIpKSB7XG4gICAgICAgICAgICAgICAgYnV0dG9uLnRvb2xUaXAgPSBcIlNlbmQgcGljdHVyZSB0byBzZXJ2ZXJcIjtcbiAgICAgICAgICAgICAgICBidXR0b24uY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtdG9vbC1zZW5kLWFuZC1lbmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYnV0dG9uRWxlbS5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC10b29sYmFyLWJ1dHRvbiBcIiArIGJ1dHRvbi5jbGFzc05hbWU7XG4gICAgICAgICAgICBidXR0b25FbGVtLnNldEF0dHJpYnV0ZShcImRhdGEtYnV0dG9uSW5kZXhcIiwgaSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxpc3RFbGVtLmFwcGVuZENoaWxkKGJ1dHRvbkVsZW0pO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBsaXN0RWxlbS5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vkb3duXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldC5ub2RlTmFtZSA9PSBcIkxJXCIpIHtcbiAgICAgICAgICAgICAgICAkKGUudGFyZ2V0KS5hZGRDbGFzcyhcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgIGxpc3RFbGVtLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldC5ub2RlTmFtZSA9PSBcIkxJXCIpIHtcbiAgICAgICAgICAgICAgICAkKGUudGFyZ2V0KS5yZW1vdmVDbGFzcyhcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBsaXN0RWxlbS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKGUudGFyZ2V0ICYmIGUudGFyZ2V0Lm5vZGVOYW1lID09IFwiTElcIikge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBidXR0b24gPSBidXR0b25zW3BhcnNlSW50KGUudGFyZ2V0LmdldEF0dHJpYnV0ZShcImRhdGEtYnV0dG9uSW5kZXhcIiksIDEwKV07XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY3BDb250cm9sbGVyLmFjdGlvblBlcmZvcm1lZCh7YWN0aW9uOiBidXR0b24uY29tbWFuZH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQobGlzdEVsZW0pO1xuICAgIH1cbiAgICBcbiAgICBidWlsZEJ1dHRvbnMoKTtcbn1cblxuQ1BNaXNjUGFsZXR0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQUGFsZXR0ZS5wcm90b3R5cGUpO1xuQ1BNaXNjUGFsZXR0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUE1pc2NQYWxldHRlO1xuIiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQUGFsZXR0ZShjcENvbnRyb2xsZXIsIGNsYXNzTmFtZSwgdGl0bGUsIHJlc2l6ZVZlcnQpIHtcbiAgICB0aGlzLnRpdGxlID0gdGl0bGU7XG4gICAgdGhpcy5uYW1lID0gY2xhc3NOYW1lO1xuICAgIHRoaXMucmVzaXplVmVydCA9IHJlc2l6ZVZlcnQgfHwgZmFsc2U7XG4gICAgXG4gICAgdmFyXG4gICAgICAgIGNvbnRhaW5lckVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBoZWFkRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGNsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSxcbiAgICAgICAgYm9keUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBcbiAgICAgICAgdmVydEhhbmRsZSA9IG51bGwsXG4gICAgICAgIFxuICAgICAgICBkcmFnT2Zmc2V0LFxuICAgICAgICBcbiAgICAgICAgdGhhdCA9IHRoaXM7XG4gICAgXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBjb250YWluZXJFbGVtZW50O1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRCb2R5RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYm9keUVsZW1lbnQ7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmdldFdpZHRoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkKGNvbnRhaW5lckVsZW1lbnQpLm91dGVyV2lkdGgoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0SGVpZ2h0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiAkKGNvbnRhaW5lckVsZW1lbnQpLm91dGVySGVpZ2h0KCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmdldFggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbnRhaW5lckVsZW1lbnQuc3R5bGUubGVmdCwgMTApIHx8IDA7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmdldFkgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlSW50KGNvbnRhaW5lckVsZW1lbnQuc3R5bGUudG9wLCAxMCkgfHwgMDtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0TG9jYXRpb24gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUubGVmdCA9IHggKyBcInB4XCI7XG4gICAgICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUudG9wID0geSArIFwicHhcIjtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0V2lkdGggPSBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgICBjb250YWluZXJFbGVtZW50LnN0eWxlLndpZHRoID0gd2lkdGggKyBcInB4XCI7XG4gICAgfTtcblxuICAgIHRoaXMuc2V0SGVpZ2h0ID0gZnVuY3Rpb24oaGVpZ2h0KSB7XG4gICAgICAgIGNvbnRhaW5lckVsZW1lbnQuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgXCJweFwiO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXRTaXplID0gZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLnNldFdpZHRoKHdpZHRoKTtcbiAgICAgICAgdGhpcy5zZXRIZWlnaHQoaGVpZ2h0KTtcbiAgICB9O1xuICAgIFxuICAgIGZ1bmN0aW9uIG1vdXNlRHJhZyhlKSB7XG4gICAgICAgIHRoYXQuc2V0TG9jYXRpb24oZS5wYWdlWCAtIGRyYWdPZmZzZXQueCwgZS5wYWdlWSAtIGRyYWdPZmZzZXQueSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2VEcmFnUmVsZWFzZShlKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG1vdXNlRHJhZyk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBtb3VzZURyYWdSZWxlYXNlKTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gdmVydEhhbmRsZURyYWcoZSkge1xuICAgICAgICB0aGF0LnNldEhlaWdodChlLnBhZ2VZIC0gJChjb250YWluZXJFbGVtZW50KS5vZmZzZXQoKS50b3ApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZlcnRIYW5kbGVSZWxlYXNlKGUpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdmVydEhhbmRsZURyYWcpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdmVydEhhbmRsZVJlbGVhc2UpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiB2ZXJ0SGFuZGxlTW91c2VEb3duKGUpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZW1vdmVcIiwgdmVydEhhbmRsZURyYWcpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgdmVydEhhbmRsZVJlbGVhc2UpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBhZGRWZXJ0UmVzaXplSGFuZGxlKCkge1xuICAgICAgICB2ZXJ0SGFuZGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgXG4gICAgICAgIHZlcnRIYW5kbGUuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtcmVzaXplLWhhbmRsZS12ZXJ0XCI7XG4gICAgICAgIFxuICAgICAgICB2ZXJ0SGFuZGxlLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdmVydEhhbmRsZU1vdXNlRG93bik7XG4gICAgICAgIFxuICAgICAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKHZlcnRIYW5kbGUpO1xuICAgIH1cblxuICAgIGNsb3NlQnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiO1xuICAgIGNsb3NlQnV0dG9uLmNsYXNzTmFtZSA9IFwiY2xvc2VcIjtcbiAgICBjbG9zZUJ1dHRvbi5pbm5lckhUTUwgPSBcIiZ0aW1lcztcIjtcbiAgICBcbiAgICBjb250YWluZXJFbGVtZW50LmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LXBhbGV0dGUgY2hpY2tlbnBhaW50LXBhbGV0dGUtXCIgKyBjbGFzc05hbWU7XG4gICAgXG4gICAgaGVhZEVsZW1lbnQuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtcGFsZXR0ZS1oZWFkXCI7XG5cbiAgICB2YXJcbiAgICAgICAgaGVhZFRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImg0XCIpO1xuICAgIFxuICAgIGhlYWRUaXRsZS5jbGFzc05hbWUgPSAnbW9kYWwtdGl0bGUnO1xuICAgIGhlYWRUaXRsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0aGlzLnRpdGxlKSlcbiAgICBcbiAgICBoZWFkRWxlbWVudC5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbik7XG4gICAgaGVhZEVsZW1lbnQuYXBwZW5kQ2hpbGQoaGVhZFRpdGxlKTtcbiAgICBcbiAgICBib2R5RWxlbWVudC5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC1wYWxldHRlLWJvZHlcIjtcbiAgICBcbiAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGhlYWRFbGVtZW50KTtcbiAgICBjb250YWluZXJFbGVtZW50LmFwcGVuZENoaWxkKGJvZHlFbGVtZW50KTtcblxuICAgIGlmICh0aGlzLnJlc2l6ZVZlcnQpIHtcbiAgICAgICAgYWRkVmVydFJlc2l6ZUhhbmRsZSgpO1xuICAgIH1cblxuICAgIGhlYWRFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5idXR0b24gPT0gMCkgey8qIExlZnQgKi9cbiAgICAgICAgICAgIGlmIChlLnRhcmdldC5ub2RlTmFtZSA9PSBcIkJVVFRPTlwiKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbWl0RXZlbnQoXCJwYWxldHRlVmlzQ2hhbmdlXCIsIFt0aGF0LCBmYWxzZV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBtb3VzZURyYWcpO1xuICAgICAgICAgICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBtb3VzZURyYWdSZWxlYXNlKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBkcmFnT2Zmc2V0ID0ge3g6IGUucGFnZVggLSAkKGNvbnRhaW5lckVsZW1lbnQpLnBvc2l0aW9uKCkubGVmdCwgeTogZS5wYWdlWSAtICQoY29udGFpbmVyRWxlbWVudCkucG9zaXRpb24oKS50b3B9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbkNQUGFsZXR0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuQ1BQYWxldHRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEV2ZW50RW1pdHRlcjsiLCIvKlxuICAgIENoaWNrZW5QYWludFxuICAgIFxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG4gICAgXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IENQVG9vbFBhbGV0dGUgZnJvbSBcIi4vQ1BUb29sUGFsZXR0ZVwiO1xuaW1wb3J0IENQTWlzY1BhbGV0dGUgZnJvbSBcIi4vQ1BNaXNjUGFsZXR0ZVwiO1xuaW1wb3J0IENQU3Ryb2tlUGFsZXR0ZSBmcm9tIFwiLi9DUFN0cm9rZVBhbGV0dGVcIjtcbmltcG9ydCBDUENvbG9yUGFsZXR0ZSBmcm9tIFwiLi9DUENvbG9yUGFsZXR0ZVwiO1xuaW1wb3J0IENQQnJ1c2hQYWxldHRlIGZyb20gXCIuL0NQQnJ1c2hQYWxldHRlXCI7XG5pbXBvcnQgQ1BMYXllcnNQYWxldHRlIGZyb20gXCIuL0NQTGF5ZXJzUGFsZXR0ZVwiO1xuaW1wb3J0IENQVGV4dHVyZVBhbGV0dGUgZnJvbSBcIi4vQ1BUZXh0dXJlUGFsZXR0ZVwiO1xuaW1wb3J0IENQU3dhdGNoZXNQYWxldHRlIGZyb20gXCIuL0NQU3dhdGNoZXNQYWxldHRlXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQUGFsZXR0ZU1hbmFnZXIoY3BDb250cm9sbGVyKSB7XG4gICAgdmFyXG4gICAgICAgIHBhbGV0dGVzID0ge1xuICAgICAgICAgICAgdG9vbDogbmV3IENQVG9vbFBhbGV0dGUoY3BDb250cm9sbGVyKSxcbiAgICAgICAgICAgIG1pc2M6IG5ldyBDUE1pc2NQYWxldHRlKGNwQ29udHJvbGxlciksXG4gICAgICAgICAgICBzdHJva2U6IG5ldyBDUFN0cm9rZVBhbGV0dGUoY3BDb250cm9sbGVyKSxcbiAgICAgICAgICAgIGNvbG9yOiBuZXcgQ1BDb2xvclBhbGV0dGUoY3BDb250cm9sbGVyKSxcbiAgICAgICAgICAgIGJydXNoOiBuZXcgQ1BCcnVzaFBhbGV0dGUoY3BDb250cm9sbGVyKSxcbiAgICAgICAgICAgIGxheWVyczogbmV3IENQTGF5ZXJzUGFsZXR0ZShjcENvbnRyb2xsZXIpLFxuICAgICAgICAgICAgdGV4dHVyZXM6IG5ldyBDUFRleHR1cmVQYWxldHRlKGNwQ29udHJvbGxlciksXG4gICAgICAgICAgICBzd2F0Y2hlczogbmV3IENQU3dhdGNoZXNQYWxldHRlKGNwQ29udHJvbGxlcilcbiAgICAgICAgfSxcbiAgICAgICAgXG4gICAgICAgIHBhbGV0dGVGcmFtZXMgPSBbXSxcbiAgICAgICAgaGlkZGVuRnJhbWVzID0gW10sXG4gICAgICAgIFxuICAgICAgICBwYXJlbnRFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgXG4gICAgICAgIHRoYXQgPSB0aGlzO1xuICAgIFxuICAgIHRoaXMucGFsZXR0ZXMgPSBwYWxldHRlcztcblxuICAgIGZ1bmN0aW9uIHNob3dQYWxldHRlKHBhbGV0dGUsIHNob3cpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBwYWxFbGVtZW50ID0gcGFsZXR0ZS5nZXRFbGVtZW50KCk7XG4gICAgICAgIFxuICAgICAgICBpZiAoc2hvdykge1xuICAgICAgICAgICAgcGFyZW50RWxlbS5hcHBlbmRDaGlsZChwYWxFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhcmVudEVsZW0ucmVtb3ZlQ2hpbGQocGFsRWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5lbWl0RXZlbnQoXCJwYWxldHRlVmlzQ2hhbmdlXCIsIFtwYWxldHRlLm5hbWUsIHNob3ddKTtcblxuICAgICAgICAvLyBGSVhNRTogZm9jdXMgaGFja1xuICAgICAgICAvLyBjb250cm9sbGVyLmNhbnZhcy5ncmFiRm9jdXMoKTsgVE9ET1xuICAgIH1cbiAgICBcbiAgICB0aGlzLnNob3dQYWxldHRlQnlOYW1lID0gZnVuY3Rpb24ocGFsZXR0ZU5hbWUsIHNob3cpIHtcbiAgICAgICAgdmFyIFxuICAgICAgICAgICAgcGFsZXR0ZSA9IHBhbGV0dGVzW3BhbGV0dGVOYW1lXTtcbiAgICAgICAgXG4gICAgICAgIGlmIChwYWxldHRlKSB7XG4gICAgICAgICAgICBzaG93UGFsZXR0ZShwYWxldHRlLCBzaG93KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMudG9nZ2xlUGFsZXR0ZXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGhpZGRlbkZyYW1lcy5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgJChcIj4gLmNoaWNrZW5wYWludC1wYWxldHRlXCIsIHBhcmVudEVsZW0pLmVhY2goZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdGhhdC5zaG93UGFsZXR0ZUJ5TmFtZSh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtcGFsZXR0ZU5hbWVcIiksIGZhbHNlKTtcbiAgICAgICAgICAgICAgICBoaWRkZW5GcmFtZXMucHVzaCh0aGlzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoaWRkZW5GcmFtZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgICAgIGZyYW1lID0gaGlkZGVuRnJhbWVzW2ldO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRoYXQuc2hvd1BhbGV0dGVCeU5hbWUoZnJhbWUuZ2V0QXR0cmlidXRlKFwiZGF0YS1wYWxldHRlTmFtZVwiKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoaWRkZW5GcmFtZXMgPSBbXTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBQb3AgcGFsZXR0ZXMgdGhhdCBhcmUgY3VycmVudGx5IG91dHNpZGUgdGhlIHZpc2libGUgYXJlYSBiYWNrIGludG8gdmlldy5cbiAgICAgKi9cbiAgICB0aGlzLmNvbnN0cmFpblBhbGV0dGVzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgd2luZG93V2lkdGggPSAkKHBhcmVudEVsZW0pLnBhcmVudHMoXCIuY2hpY2tlbnBhaW50LW1haW4tc2VjdGlvblwiKS53aWR0aCgpLFxuICAgICAgICAgICAgd2luZG93SGVpZ2h0ID0gJChwYXJlbnRFbGVtKS5wYXJlbnRzKFwiLmNoaWNrZW5wYWludC1tYWluLXNlY3Rpb25cIikuaGVpZ2h0KCk7XG5cbiAgICAgICAgZm9yICh2YXIgaSBpbiBwYWxldHRlcykge1xuICAgICAgICAgICAgdmFyIHBhbGV0dGUgPSBwYWxldHRlc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogTW92ZSBwYWxldHRlcyB0aGF0IGFyZSBtb3JlIHRoYW4gaGFsZiBvdXQgb2YgdGhlIGZyYW1lIGJhY2sgaW50byBpdCAqL1xuICAgICAgICAgICAgaWYgKHBhbGV0dGUuZ2V0WCgpICsgcGFsZXR0ZS5nZXRXaWR0aCgpIC8gMiA+IHdpbmRvd1dpZHRoKSB7XG4gICAgICAgICAgICAgICAgcGFsZXR0ZS5zZXRMb2NhdGlvbih3aW5kb3dXaWR0aCAtIHBhbGV0dGUuZ2V0V2lkdGgoKSwgcGFsZXR0ZS5nZXRZKCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFsZXR0ZS5nZXRZKCkgKyBwYWxldHRlLmdldEhlaWdodCgpIC8gMiA+IHdpbmRvd0hlaWdodCkge1xuICAgICAgICAgICAgICAgIHBhbGV0dGUuc2V0TG9jYXRpb24ocGFsZXR0ZS5nZXRYKCksIHdpbmRvd0hlaWdodCAtIHBhbGV0dGUuZ2V0SGVpZ2h0KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAvL01vdmUgc21hbGwgcGFsZXR0ZXMgdG8gdGhlIGZyb250IHNvIHRoYXQgdGhleSBhcmVuJ3QgY29tcGxldGVseSBoaWRkZW5cbiAgICAgICAgLy9wYWxldHRlcy5zd2F0Y2hlcy5tb3ZlVG9Gcm9udCgpO1xuICAgICAgICBcbiAgICAgICAgLy9TcGVjaWFsIGhhbmRsaW5nIGZvciB0aGUgc3dhdGNoZXMgcGFsZXR0ZSBiZWluZyB1bmRlciB0aGUgYnJ1c2ggcGFsZXR0ZTpcbiAgICAgICAgdmFyXG4gICAgICAgICAgICB3aWR0aFRvU3BhcmUgPSB3aW5kb3dXaWR0aCAtIHBhbGV0dGVzLnRvb2wuZ2V0V2lkdGgoKSAtIHBhbGV0dGVzLm1pc2MuZ2V0V2lkdGgoKSAtIHBhbGV0dGVzLnN0cm9rZS5nZXRXaWR0aCgpIC0gcGFsZXR0ZXMuY29sb3IuZ2V0V2lkdGgoKSAtIHBhbGV0dGVzLmJydXNoLmdldFdpZHRoKCkgLSAxNSA+IDA7XG5cbiAgICAgICAgaWYgKHBhbGV0dGVzLnN3YXRjaGVzLmdldFgoKSArIHBhbGV0dGVzLnN3YXRjaGVzLmdldFdpZHRoKCkgPT0gIHBhbGV0dGVzLmJydXNoLmdldFgoKSArIHBhbGV0dGVzLmJydXNoLmdldFdpZHRoKCkgJiZcbiAgICAgICAgICAgICAgICBNYXRoLmFicyhwYWxldHRlcy5zd2F0Y2hlcy5nZXRZKCkgLSBwYWxldHRlcy5icnVzaC5nZXRZKCkpIDwgMjApIHtcbiAgICAgICAgICAgIHBhbGV0dGVzLnN3YXRjaGVzLnNldExvY2F0aW9uKHBhbGV0dGVzLmJydXNoLmdldFgoKSAtIHBhbGV0dGVzLnN3YXRjaGVzLmdldFdpZHRoKCkgLSAod2lkdGhUb1NwYXJlID8gNSA6IDEpLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy9TcGVjaWFsIGhhbmRsaW5nIGZvciBsYXllcnMgcGFsZXR0ZSBiZWluZyB0b28gZGFtbiB0YWxsOlxuICAgICAgICBpZiAocGFsZXR0ZXMubGF5ZXJzLmdldFkoKSArIHBhbGV0dGVzLmxheWVycy5nZXRIZWlnaHQoKSA+IHdpbmRvd0hlaWdodCkge1xuICAgICAgICAgICAgcGFsZXR0ZXMubGF5ZXJzLnNldEhlaWdodChNYXRoLm1heCh3aW5kb3dIZWlnaHQgLSBwYWxldHRlcy5sYXllcnMuZ2V0WSgpLCAyMDApKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgXG4gICAgLyoqXG4gICAgICogUmVhcnJhbmdlIHRoZSBwYWxldHRlcyBmcm9tIHNjcmF0Y2ggaW50byBhIHVzZWZ1bCBhcnJhbmdlbWVudC5cbiAgICAgKi9cbiAgICB0aGlzLmFycmFuZ2VQYWxldHRlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHdpbmRvd1dpZHRoID0gJChwYXJlbnRFbGVtKS5wYXJlbnRzKFwiLmNoaWNrZW5wYWludC1tYWluLXNlY3Rpb25cIikud2lkdGgoKSxcbiAgICAgICAgICAgIHdpbmRvd0hlaWdodCA9ICQocGFyZW50RWxlbSkucGFyZW50cyhcIi5jaGlja2VucGFpbnQtbWFpbi1zZWN0aW9uXCIpLmhlaWdodCgpLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBoYXZlV2lkdGhUb1NwYXJlID0gd2luZG93V2lkdGggLSBwYWxldHRlcy50b29sLmdldFdpZHRoKCkgLSBwYWxldHRlcy5taXNjLmdldFdpZHRoKCkgLSBwYWxldHRlcy5zdHJva2UuZ2V0V2lkdGgoKSAtIHBhbGV0dGVzLmNvbG9yLmdldFdpZHRoKCkgLSBwYWxldHRlcy5icnVzaC5nZXRXaWR0aCgpIC0gMTUgPiAwO1xuXG4gICAgICAgIHBhbGV0dGVzLmJydXNoLnNldExvY2F0aW9uKHdpbmRvd1dpZHRoIC0gcGFsZXR0ZXMuYnJ1c2guZ2V0V2lkdGgoKSAtIDE1LCAwKTtcblxuICAgICAgICB2YXIgXG4gICAgICAgICAgICBib3R0b21PZkJydXNoID0gcGFsZXR0ZXMuYnJ1c2guZ2V0WSgpICsgcGFsZXR0ZXMuYnJ1c2guZ2V0SGVpZ2h0KCk7XG5cbiAgICAgICAgcGFsZXR0ZXMubGF5ZXJzLnNldExvY2F0aW9uKHBhbGV0dGVzLmJydXNoLmdldFgoKSwgd2luZG93SGVpZ2h0IC0gYm90dG9tT2ZCcnVzaCA+IDMwMCA/IGJvdHRvbU9mQnJ1c2ggKyAyIDogYm90dG9tT2ZCcnVzaCk7XG4gICAgICAgIHBhbGV0dGVzLmxheWVycy5zZXRTaXplKHBhbGV0dGVzLmJydXNoLmdldFdpZHRoKCksIHdpbmRvd0hlaWdodCAtIHBhbGV0dGVzLmxheWVycy5nZXRZKCkpO1xuXG4gICAgICAgIHBhbGV0dGVzLnRvb2wuc2V0TG9jYXRpb24oMCwgMCk7XG4gICAgICAgIFxuICAgICAgICBwYWxldHRlcy5taXNjLnNldExvY2F0aW9uKHBhbGV0dGVzLnRvb2wuZ2V0WCgpICsgcGFsZXR0ZXMudG9vbC5nZXRXaWR0aCgpICsgKGhhdmVXaWR0aFRvU3BhcmUgPyA1IDogMSksIDApO1xuICAgICAgICBcbiAgICAgICAgaWYgKGhhdmVXaWR0aFRvU3BhcmUpIHtcbiAgICAgICAgICAgIHBhbGV0dGVzLnN0cm9rZS5zZXRMb2NhdGlvbihwYWxldHRlcy5taXNjLmdldFgoKSArIHBhbGV0dGVzLm1pc2MuZ2V0V2lkdGgoKSArIChoYXZlV2lkdGhUb1NwYXJlID8gNSA6IDEpLCAwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHBhbGV0dGVzLnN0cm9rZS5zZXRMb2NhdGlvbihwYWxldHRlcy5taXNjLmdldFgoKSwgcGFsZXR0ZXMubWlzYy5nZXRZKCkgKyBwYWxldHRlcy5taXNjLmdldEhlaWdodCgpICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHBhbGV0dGVzLnN3YXRjaGVzLnNldExvY2F0aW9uKHBhbGV0dGVzLmJydXNoLmdldFgoKSAtIHBhbGV0dGVzLnN3YXRjaGVzLmdldFdpZHRoKCkgLSAoaGF2ZVdpZHRoVG9TcGFyZSA/IDUgOiAxKSwgMCk7XG5cbiAgICAgICAgcGFsZXR0ZXMudGV4dHVyZXMuc2V0V2lkdGgoTWF0aC5taW4ocGFsZXR0ZXMubGF5ZXJzLmdldFgoKSAtIHBhbGV0dGVzLnRleHR1cmVzLmdldFgoKSwgNDkwKSk7XG4gICAgICAgIHBhbGV0dGVzLnRleHR1cmVzLnNldExvY2F0aW9uKHBhbGV0dGVzLmNvbG9yLmdldFgoKSArIHBhbGV0dGVzLmNvbG9yLmdldFdpZHRoKCkgKyA0LCB3aW5kb3dIZWlnaHQgLSBwYWxldHRlcy50ZXh0dXJlcy5nZXRIZWlnaHQoKSk7XG5cbiAgICAgICAgcGFsZXR0ZXMuY29sb3Iuc2V0TG9jYXRpb24oMCwgTWF0aC5tYXgocGFsZXR0ZXMudG9vbC5nZXRZKCkgKyBwYWxldHRlcy50b29sLmdldEhlaWdodCgpLCB3aW5kb3dIZWlnaHQgLSBwYWxldHRlcy5jb2xvci5nZXRIZWlnaHQoKSkpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBwYXJlbnRFbGVtO1xuICAgIH07XG5cbiAgICBwYXJlbnRFbGVtLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LXBhbGV0dGVzXCI7XG5cbiAgICBmb3IgKHZhciBwYWxldHRlTmFtZSBpbiBwYWxldHRlcykge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBwYWxldHRlID0gcGFsZXR0ZXNbcGFsZXR0ZU5hbWVdLFxuICAgICAgICAgICAgcGFsRWxlbWVudCA9IHBhbGV0dGUuZ2V0RWxlbWVudCgpO1xuICAgICAgICBcbiAgICAgICAgcGFsZXR0ZS5vbihcInBhbGV0dGVWaXNDaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBzaG93UGFsZXR0ZSh0aGlzLCBmYWxzZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgcGFsRWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLXBhbGV0dGVOYW1lXCIsIHBhbGV0dGVOYW1lKTtcbiAgICAgICAgcGFsZXR0ZUZyYW1lcy5wdXNoKHBhbEVsZW1lbnQpO1xuICAgIH1cbiAgICBcbiAgICBmb3IgKHZhciBwYWxldHRlTmFtZSBpbiBwYWxldHRlcykge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICBwYWxFbGVtZW50ID0gcGFsZXR0ZXNbcGFsZXR0ZU5hbWVdLmdldEVsZW1lbnQoKTtcblxuICAgICAgICBwYXJlbnRFbGVtLmFwcGVuZENoaWxkKHBhbEVsZW1lbnQpO1xuICAgIH1cbn1cblxuQ1BQYWxldHRlTWFuYWdlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuQ1BQYWxldHRlTWFuYWdlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFBhbGV0dGVNYW5hZ2VyOyIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG4vKipcbiAqIEBwYXJhbSB2ZXJ0aWNhbCBib29sZWFuXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQU2Nyb2xsYmFyKHZlcnRpY2FsKSB7XG4gICAgdmFyXG4gICAgICAgIGJhciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGhhbmRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGhhbmRsZUlubmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgXG4gICAgICAgIG1pbiA9IDAsIG1heCA9IDEsIG9mZnNldCA9IDAsIHZpc2libGVSYW5nZSA9IDEsXG4gICAgICAgIFxuICAgICAgICBibG9ja0luY3JlbWVudCA9IDEwLCB1bml0SW5jcmVtZW50ID0gMSxcbiAgICAgICAgXG4gICAgICAgIHZhbHVlSXNBZGp1c3RpbmcgPSBmYWxzZSxcbiAgICAgICAgXG4gICAgICAgIGhhbmRsZVNpemUgPSAxLFxuICAgICAgICBcbiAgICAgICAgZHJhZ0xhc3RPZmZzZXQsXG4gICAgICAgIFxuICAgICAgICB0aGF0ID0gdGhpcztcbiAgICBcbiAgICBmdW5jdGlvbiB1cGRhdGVCYXIoKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbG9uZ0RpbWVuc2lvbiA9IHZlcnRpY2FsID8gJChiYXIpLmhlaWdodCgpIDogJChiYXIpLndpZHRoKCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgLyogQXMgdGhlIHNpemUgb2YgdGhlIGRvY3VtZW50IGFwcHJvYWNoZXMgdGhlIHNpemUgb2YgdGhlIGNvbnRhaW5lciwgaGFuZGxlIHNpemUgZ3Jvd3MgdG8gZmlsbCB0aGUgXG4gICAgICAgICAgICAgKiB3aG9sZSB0cmFjazpcbiAgICAgICAgICAgICAqL1xuICAgICAgICBoYW5kbGVTaXplID0gdmlzaWJsZVJhbmdlIC8gKG1heCAtIG1pbikgKiBsb25nRGltZW5zaW9uOyBcbiAgICAgICAgXG4gICAgICAgIHZhclxuICAgICAgICAgICAgaGFuZGxlT2Zmc2V0ID0gKG9mZnNldCAtIG1pbikgLyAobWF4IC0gbWluKSAqIChsb25nRGltZW5zaW9uIC0gaGFuZGxlU2l6ZSk7XG4gICAgICAgIFxuICAgICAgICBoYW5kbGVJbm5lci5zdHlsZVt2ZXJ0aWNhbCA/IFwiaGVpZ2h0XCIgOiBcIndpZHRoXCJdID0gaGFuZGxlU2l6ZSArIFwicHhcIjtcbiAgICAgICAgaGFuZGxlLnN0eWxlW3ZlcnRpY2FsID8gXCJoZWlnaHRcIiA6IFwid2lkdGhcIl0gPSBoYW5kbGVTaXplICsgXCJweFwiO1xuICAgICAgICBcbiAgICAgICAgaGFuZGxlLnN0eWxlW3ZlcnRpY2FsID8gXCJ0b3BcIiA6IFwibGVmdFwiXSA9IGhhbmRsZU9mZnNldCArIFwicHhcIjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5zZXRWYWx1ZXMgPSBmdW5jdGlvbihfb2Zmc2V0LCBfdmlzaWJsZVJhbmdlLCBfbWluLCBfbWF4KSB7XG4gICAgICAgIG9mZnNldCA9IF9vZmZzZXQ7XG4gICAgICAgIHZpc2libGVSYW5nZSA9IF92aXNpYmxlUmFuZ2U7XG4gICAgICAgIG1pbiA9IF9taW47XG4gICAgICAgIG1heCA9IF9tYXg7XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVCYXIoKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuc2V0QmxvY2tJbmNyZW1lbnQgPSBmdW5jdGlvbihpbmNyZW1lbnQpIHtcbiAgICAgICAgYmxvY2tJbmNyZW1lbnQgPSBpbmNyZW1lbnQ7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldFVuaXRJbmNyZW1lbnQgPSBmdW5jdGlvbihpbmNyZW1lbnQpIHtcbiAgICAgICAgdW5pdEluY3JlbWVudCA9IGluY3JlbWVudDtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gYmFyO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRWYWx1ZUlzQWRqdXN0aW5nID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZUlzQWRqdXN0aW5nO1xuICAgIH07XG4gICAgXG4gICAgZnVuY3Rpb24gb25CYXJDbGljayhlKSB7XG4gICAgICAgIGlmICh0aGlzID09IGJhcikge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgY2xpY2tQb3MgPSB2ZXJ0aWNhbCA/IGUucGFnZVkgLSAkKGJhcikub2Zmc2V0KCkudG9wIDogZS5wYWdlWCAtICQoYmFyKS5vZmZzZXQoKS5sZWZ0LFxuICAgICAgICAgICAgICAgIGJhclBvcyA9IHBhcnNlSW50KGhhbmRsZS5zdHlsZVt2ZXJ0aWNhbCA/IFwidG9wXCIgOiBcImxlZnRcIl0sIDEwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGNsaWNrUG9zIDwgYmFyUG9zKSB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0IC09IGJsb2NrSW5jcmVtZW50O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBvZmZzZXQgKz0gYmxvY2tJbmNyZW1lbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoYXQuZW1pdEV2ZW50KFwidmFsdWVDaGFuZ2VkXCIsIFtvZmZzZXRdKTtcbiAgICAgICAgICAgIHVwZGF0ZUJhcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIG9uSGFuZGxlUHJlc3MoZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBkcmFnTGFzdE9mZnNldCA9IHZlcnRpY2FsID8gZS5wYWdlWSAtICQoYmFyKS5vZmZzZXQoKS50b3AgOiBlLnBhZ2VYIC0gJChiYXIpLm9mZnNldCgpLmxlZnQ7XG4gICAgICAgIFxuICAgICAgICAkKGhhbmRsZSkuYWRkQ2xhc3MoXCJkcmFnZ2luZ1wiKTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uSGFuZGxlUmVsZWFzZSk7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwibW91c2Vtb3ZlXCIsIG9uSGFuZGxlRHJhZyk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIG9uSGFuZGxlQ2xpY2soZSkge1xuICAgICAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBvbkhhbmRsZURyYWcoZSkge1xuICAgICAgICB2YWx1ZUlzQWRqdXN0aW5nID0gdHJ1ZTtcbiAgICAgICAgXG4gICAgICAgIHZhclxuICAgICAgICAgICAgbG9uZ0RpbWVuc2lvbiA9IHZlcnRpY2FsID8gJChiYXIpLmhlaWdodCgpIDogJChiYXIpLndpZHRoKCksXG4gICAgICAgICAgICBtb3VzZU9mZnNldCA9IHZlcnRpY2FsID8gZS5wYWdlWSAtICQoYmFyKS5vZmZzZXQoKS50b3AgOiBlLnBhZ2VYIC0gJChiYXIpLm9mZnNldCgpLmxlZnQ7XG4gICAgICAgIFxuICAgICAgICBvZmZzZXQgPSBvZmZzZXQgKyAobW91c2VPZmZzZXQgLSBkcmFnTGFzdE9mZnNldCkgKiAobWF4IC0gbWluKSAvIChsb25nRGltZW5zaW9uIC0gaGFuZGxlU2l6ZSk7XG4gICAgICAgIFxuICAgICAgICBvZmZzZXQgPSBNYXRoLm1pbihNYXRoLm1heChvZmZzZXQsIG1pbiksIG1heCk7XG4gICAgICAgIFxuICAgICAgICBkcmFnTGFzdE9mZnNldCA9IG1vdXNlT2Zmc2V0O1xuICAgICAgICBcbiAgICAgICAgdGhhdC5lbWl0RXZlbnQoXCJ2YWx1ZUNoYW5nZWRcIiwgW29mZnNldF0pO1xuICAgICAgICB1cGRhdGVCYXIoKTtcbiAgICAgICAgXG4gICAgICAgIHZhbHVlSXNBZGp1c3RpbmcgPSBmYWxzZTtcbiAgICB9XG4gICAgXG4gICAgZnVuY3Rpb24gb25IYW5kbGVSZWxlYXNlKGUpIHtcbiAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgJChoYW5kbGUpLnJlbW92ZUNsYXNzKFwiZHJhZ2dpbmdcIik7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbkhhbmRsZVJlbGVhc2UpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm1vdXNlbW92ZVwiLCBvbkhhbmRsZURyYWcpO1xuICAgIH1cbiAgICBcbiAgICBiYXIuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtc2Nyb2xsYmFyIFwiICArICh2ZXJ0aWNhbCA/IFwiY2hpY2tlbnBhaW50LXNjcm9sbGJhci12ZXJ0aWNhbFwiIDogXCJjaGlja2VucGFpbnQtc2Nyb2xsYmFyLWhvcml6b250YWxcIik7XG4gICAgaGFuZGxlLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LXNjcm9sbGJhci1oYW5kbGVcIjtcbiAgICBoYW5kbGVJbm5lci5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC1zY3JvbGxiYXItaGFuZGxlLWlubmVyXCI7XG4gICAgXG4gICAgaGFuZGxlLmFwcGVuZENoaWxkKGhhbmRsZUlubmVyKTtcbiAgICBiYXIuYXBwZW5kQ2hpbGQoaGFuZGxlKTtcbiAgICBcbiAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlZG93blwiLCBvbkhhbmRsZVByZXNzKTtcbiAgICBoYW5kbGUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIG9uSGFuZGxlQ2xpY2spO1xuICAgIFxuICAgIGJhci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgb25CYXJDbGljayk7XG59XG5cbkNQU2Nyb2xsYmFyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5DUFNjcm9sbGJhci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFNjcm9sbGJhcjsiLCIvKlxuICAgIENoaWNrZW5QYWludFxuICAgIFxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG4gICAgXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BTZW5kRGlhbG9nKGNvbnRyb2xsZXIsIHBhcmVudCwgcmVzb3VyY2VTYXZlcikge1xuICAgIHZhclxuICAgICAgICBkaWFsb2cgPSBcbiAgICAgICAgICAgICQoYDxkaXYgY2xhc3M9XCJtb2RhbCBmYWRlXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJkaWFsb2dcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZGlhbG9nXCI+XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCIgZGF0YS1zdGFnZT1cInNhdmluZ1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+U2F2aW5nIGRyYXdpbmcuLi48L2g0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNhdmluZy1wcm9ncmVzcy1tZXNzYWdlXCI+UHJlcGFyaW5nIHlvdXIgZHJhd2luZyB0byBiZSBzYXZlZCwgcGxlYXNlIHdhaXQuLi48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHByZSBjbGFzcz1cImNoaWNrZW5wYWludC1zYXZpbmctZXJyb3ItbWVzc2FnZSBwcmUtc2Nyb2xsYWJsZVwiPjwvcHJlPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJwcm9ncmVzc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwicHJvZ3Jlc3MtYmFyXCIgcm9sZT1cInByb2dyZXNzYmFyXCIgYXJpYS12YWx1ZW5vdz1cIjBcIiBhcmlhLXZhbHVlbWluPVwiMFwiIGFyaWEtdmFsdWVtYXg9XCIxMDBcIiBzdHlsZT1cIndpZHRoOiAwJTtcIj48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGNoaWNrZW5wYWludC1zZW5kLWNhbmNlbFwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+Q2FuY2VsPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCIgZGF0YS1zdGFnZT1cInN1Y2Nlc3Mtbm90LXByZXZpb3VzbHktcG9zdGVkXCIgc3R5bGU9XCJkaXNwbGF5Om5vbmVcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1oZWFkZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImNsb3NlXCIgZGF0YS1kaXNtaXNzPVwibW9kYWxcIiBhcmlhLWxhYmVsPVwiQ2xvc2VcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gYXJpYS1oaWRkZW49XCJ0cnVlXCI+JnRpbWVzOzwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJtb2RhbC10aXRsZVwiPkRyYXdpbmcgc2F2ZWQhPC9oND5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD5Zb3VyIGRyYXdpbmcgaGFzIGJlZW4gc2F2ZWQsIHdvdWxkIHlvdSBsaWtlIHRvIHBvc3QgaXQgdG8gdGhlIGZvcnVtIG5vdz88L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1mb290ZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tcHJpbWFyeSBjaGlja2VucGFpbnQtcG9zdC1kcmF3aW5nXCIgZGF0YS1kaXNtaXNzPVwibW9kYWxcIj5ZZXMsIHBvc3QgaXQgbm93PC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJidG4gYnRuLWRlZmF1bHQgY2hpY2tlbnBhaW50LWNvbnRpbnVlLWRyYXdpbmdcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiPk5vLCBrZWVwIGRyYXdpbmc8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIHR5cGU9XCJidXR0b25cIiBjbGFzcz1cImJ0biBidG4tZGVmYXVsdCBjaGlja2VucGFpbnQtZXhpdFwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCI+Tm8sIHF1aXQgYW5kIEknbGwgZmluaXNoIGl0IGxhdGVyPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCIgZGF0YS1zdGFnZT1cInN1Y2Nlc3MtYWxyZWFkeS1wb3N0ZWRcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+RHJhd2luZyBzYXZlZCE8L2g0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPllvdXIgZHJhd2luZyBoYXMgYmVlbiBzYXZlZCwgd291bGQgeW91IGxpa2UgdG8gdmlldyBpdCBvbiB0aGUgZm9ydW0gbm93PzwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWZvb3RlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1wcmltYXJ5IGNoaWNrZW5wYWludC1wb3N0LWRyYXdpbmdcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiPlllcywgdmlldyB0aGUgcG9zdDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiYnRuIGJ0bi1kZWZhdWx0IGNoaWNrZW5wYWludC1jb250aW51ZS1kcmF3aW5nXCIgZGF0YS1kaXNtaXNzPVwibW9kYWxcIj5Obywga2VlcCBkcmF3aW5nPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCIgZGF0YS1zdGFnZT1cInN1Y2Nlc3MtcmVkaXJlY3RcIiBzdHlsZT1cImRpc3BsYXk6bm9uZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+RHJhd2luZyBzYXZlZCE8L2g0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtYm9keVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwPllvdXIgZHJhd2luZyBoYXMgYmVlbiBzYXZlZCwgcmVkaXJlY3RpbmcgeW91IHRvIHZpZXcgeW91ciBuZXcgcG9zdCBub3cuLi48L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgYCksXG4gICAgICAgIHByb2dyZXNzTWVzc2FnZUVsZW0gPSAkKFwiLmNoaWNrZW5wYWludC1zYXZpbmctcHJvZ3Jlc3MtbWVzc2FnZVwiLCBkaWFsb2cpLFxuICAgICAgICBwcm9ncmVzc0Vycm9yID0gJChcIi5jaGlja2VucGFpbnQtc2F2aW5nLWVycm9yLW1lc3NhZ2VcIiwgZGlhbG9nKSxcbiAgICAgICAgcHJvZ3Jlc3NFbGVtID0gJChcIi5wcm9ncmVzcy1iYXJcIiwgZGlhbG9nKSxcblxuICAgICAgICB0aGF0ID0gdGhpcztcbiAgICBcbiAgICByZXNvdXJjZVNhdmVyLm9uKFwic2F2aW5nUHJvZ3Jlc3NcIiwgZnVuY3Rpb24ocHJvZ3Jlc3MsIG1lc3NhZ2UpIHtcbiAgICAgICAgcHJvZ3Jlc3MgKj0gMTAwO1xuICAgICAgICBcbiAgICAgICAgcHJvZ3Jlc3NNZXNzYWdlRWxlbS50ZXh0KG1lc3NhZ2UpO1xuICAgICAgICBcbiAgICAgICAgJChwcm9ncmVzc0VsZW0pXG4gICAgICAgICAgICAuYXR0cihcImFyaWEtdmFsdWVub3dcIiwgcHJvZ3Jlc3MpXG4gICAgICAgICAgICAuY3NzKFwid2lkdGhcIiwgcHJvZ3Jlc3MgKyBcIiVcIik7XG4gICAgfSk7XG4gXG4gICAgcmVzb3VyY2VTYXZlci5vbihcInNhdmluZ0NvbXBsZXRlXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAkKFwiLm1vZGFsLWNvbnRlbnRbZGF0YS1zdGFnZT0nc2F2aW5nJ11cIiwgZGlhbG9nKS5oaWRlKCk7XG5cbiAgICAgICAgaWYgKGNvbnRyb2xsZXIuaXNBY3Rpb25TdXBwb3J0ZWQoXCJDUENvbnRpbnVlXCIpKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5pc0FjdGlvblN1cHBvcnRlZChcIkNQRXhpdFwiKSkge1xuICAgICAgICAgICAgICAgICQoXCIubW9kYWwtY29udGVudFtkYXRhLXN0YWdlPSdzdWNjZXNzLW5vdC1wcmV2aW91c2x5LXBvc3RlZCddXCIsIGRpYWxvZykuc2hvdygpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAkKFwiLm1vZGFsLWNvbnRlbnRbZGF0YS1zdGFnZT0nc3VjY2Vzcy1hbHJlYWR5LXBvc3RlZCddXCIsIGRpYWxvZykuc2hvdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgJChcIi5tb2RhbC1jb250ZW50W2RhdGEtc3RhZ2U9J3N1Y2Nlc3MtcmVkaXJlY3QnXVwiLCBkaWFsb2cpLnNob3coKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmVzb3VyY2VTYXZlci5vbihcInNhdmluZ0ZhaWx1cmVcIiwgZnVuY3Rpb24oc2VydmVyTWVzc2FnZSkge1xuICAgICAgICBwcm9ncmVzc0VsZW0uYWRkQ2xhc3MoXCJwcm9ncmVzcy1iYXItZGFuZ2VyXCIpO1xuICAgICAgICBcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBlcnJvck1lc3NhZ2UgPSBcIlNvcnJ5LCB5b3VyIGRyYXdpbmcgY291bGQgbm90IGJlIHNhdmVkLCBwbGVhc2UgdHJ5IGFnYWluIGxhdGVyLlwiO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNlcnZlck1lc3NhZ2UpIHtcbiAgICAgICAgICAgIHNlcnZlck1lc3NhZ2UgPSBzZXJ2ZXJNZXNzYWdlLnJlcGxhY2UoL15DSElCSUVSUk9SXFxzKi8sIFwiXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoc2VydmVyTWVzc2FnZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlICs9IFwiPGJyPjxicj5UaGUgZXJyb3IgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIHdhczpcIjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwcm9ncmVzc0Vycm9yXG4gICAgICAgICAgICAgICAgICAgIC50ZXh0KHNlcnZlck1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIC5zaG93KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHByb2dyZXNzTWVzc2FnZUVsZW0uaHRtbChlcnJvck1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgIH0pO1xuICAgIFxuICAgICQoXCIuY2hpY2tlbnBhaW50LXBvc3QtZHJhd2luZ1wiLCBkaWFsb2cpLmNsaWNrKGZ1bmN0aW9uKCkge1xuICAgICAgICBjb250cm9sbGVyLmFjdGlvblBlcmZvcm1lZCh7YWN0aW9uOiBcIkNQUG9zdFwifSk7XG4gICAgfSk7XG5cbiAgICAkKFwiLmNoaWNrZW5wYWludC1leGl0XCIsIGRpYWxvZylcbiAgICAgICAgLnRvZ2dsZShjb250cm9sbGVyLmlzQWN0aW9uU3VwcG9ydGVkKFwiQ1BFeGl0XCIpKVxuICAgICAgICAuY2xpY2soZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBhbGVydChcIldoZW4geW91IHdhbnQgdG8gY29tZSBiYWNrIGFuZCBmaW5pc2ggeW91ciBkcmF3aW5nLCBqdXN0IGNsaWNrIHRoZSAnbmV3IGRyYXdpbmcnIGJ1dHRvbiBhZ2FpbiBhbmQgXCJcbiAgICAgICAgICAgICAgICArIFwieW91IGNhbiBjaG9vc2UgdG8gY29udGludWUgdGhpcyBkcmF3aW5nLlwiKTtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuYWN0aW9uUGVyZm9ybWVkKHthY3Rpb246IFwiQ1BFeGl0XCJ9KTtcbiAgICAgICAgfSk7XG4gICAgXG4gICAgJChcIi5jaGlja2VucGFpbnQtc2VuZC1jYW5jZWxcIiwgZGlhbG9nKS5jbGljayhmdW5jdGlvbigpIHtcbiAgICAgICAgcmVzb3VyY2VTYXZlci5jYW5jZWwoKTtcbiAgICB9KTtcbiAgICBcbiAgICAvLyBEZXN0cm95IHRoZSBtb2RhbCB1cG9uIGNsb3NlXG4gICAgZGlhbG9nLm9uKFwiaGlkZGVuLmJzLm1vZGFsXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgZGlhbG9nLnJlbW92ZSgpO1xuICAgIH0pO1xuICAgIFxuICAgIGRpYWxvZy5tb2RhbCh7XG4gICAgICAgIHNob3c6IGZhbHNlXG4gICAgfSk7XG5cbiAgICBkaWFsb2cub24oJ3Nob3duLmJzLm1vZGFsJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZW1pdEV2ZW50KFwic2hvd25cIik7XG4gICAgfSk7XG4gICAgXG4gICAgLy8gRml4IHRoZSBiYWNrZHJvcCBsb2NhdGlvbiBpbiB0aGUgRE9NIGJ5IHJlcGFyZW50aW5nIGl0IHRvIHRoZSBjaGlja2VucGFpbnQgY29udGFpbmVyXG4gICAgZGlhbG9nLmRhdGEoXCJicy5tb2RhbFwiKS4kYm9keSA9ICQocGFyZW50KTtcbiAgICBcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZGlhbG9nWzBdKTtcblxuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkaWFsb2cubW9kYWwoXCJzaG93XCIpO1xuICAgIH07XG59XG5cbkNQU2VuZERpYWxvZy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEV2ZW50RW1pdHRlci5wcm90b3R5cGUpO1xuQ1BTZW5kRGlhbG9nLnByb3RvdHlwZS5jb250cnVjdG9yID0gQ1BTZW5kRGlhbG9nOyIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUFNob3J0Y3V0c0RpYWxvZyhwYXJlbnQpIHtcbiAgICB2YXJcbiAgICAgICAgZGlhbG9nID0gXG4gICAgICAgICAgICAkKGA8ZGl2IGNsYXNzPVwibW9kYWwgZmFkZSBjaGlja2VucGFpbnQtc2hvcnRjdXRzLWRpYWxvZ1wiIHRhYmluZGV4PVwiLTFcIiByb2xlPVwiZGlhbG9nXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWRpYWxvZyBtb2RhbC1sZ1wiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtY29udGVudFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWhlYWRlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gdHlwZT1cImJ1dHRvblwiIGNsYXNzPVwiY2xvc2VcIiBkYXRhLWRpc21pc3M9XCJtb2RhbFwiIGFyaWEtbGFiZWw9XCJDbG9zZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBhcmlhLWhpZGRlbj1cInRydWVcIj4mdGltZXM7PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cIm1vZGFsLXRpdGxlXCI+U2hvcnRjdXRzPC9oND5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWFueSBvZiB0aGUgbWVudSBvcHRpb25zIGFuZCBwYWludGluZyB0b29scyBoYXZlIGtleWJvYXJkIHNob3J0Y3V0cyB3aGljaCBhcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd3JpdHRlbiBuZXh0IHRvIHRoZW0gb3IgYXBwZWFyIHdoZW4geW91IGhvdmVyLlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgSGVyZSBhcmUgc29tZSBvdGhlciBzaG9ydGN1dHMgd2hpY2ggYXJlIG5vdCBhcyBvYnZpb3VzIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0cy1zZWN0aW9uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0cy1zZWN0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDU+Q29sb3Igc3dhdGNoZXMgcGFsZXR0ZTwvaDU+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8dWwgY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXRzLWxpc3QgbGlzdC11bnN0eWxlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxsaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGR0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0XCI+PHNwYW4gY2xhc3M9XCJmYSBmYS1tb3VzZS1wb2ludGVyXCI+PC9zcGFuPiBMZWZ0PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVc2UgYXMgdGhlIGRyYXdpbmcgY29sb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXRcIj48c3BhbiBjbGFzcz1cImZhIGZhLW1vdXNlLXBvaW50ZXJcIj48L3NwYW4+IFJpZ2h0PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZW1vdmUgb3IgcmVwbGFjZSBhIGNvbG9yIHN3YXRjaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0cy1zZWN0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDU+TGluZSBkcmF3aW5nIG1vZGU8L2g1PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0cy1saXN0IGxpc3QtdW5zdHlsZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dFwiPjxzcGFuIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0LWtleVwiPlNoaWZ0PC9zcGFuPiArIDxzcGFuIGNsYXNzPVwiZmEgZmEtbW91c2UtcG9pbnRlclwiPjwvc3Bhbj4gTGVmdDwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgU25hcCBsaW5lIHRvIG5lYXJlc3QgNDUgZGVncmVlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0cy1zZWN0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDU+UGFpbnRpbmcgdG9vbHM8L2g1PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0cy1saXN0IGxpc3QtdW5zdHlsZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dFwiPjxzcGFuIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0LWtleVwiPjE8L3NwYW4+IC0gPHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXQta2V5XCI+OTwvc3Bhbj4gLCA8c3BhbiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dC1rZXlcIj4wPC9zcGFuPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQ2hhbmdlIGJydXNoIG9wYWNpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXRcIj48c3BhbiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dC1rZXlcIj5bPC9zcGFuPiAsIDxzcGFuIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0LWtleVwiPl08L3NwYW4+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDaGFuZ2UgYnJ1c2ggc2l6ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC91bD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXRzLXNlY3Rpb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNT5CcnVzaCBwYWxldHRlPC9oNT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dHMtbGlzdCBsaXN0LXVuc3R5bGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXRcIj48c3BhbiBjbGFzcz1cImZhIGZhLW1vdXNlLXBvaW50ZXJcIj48L3NwYW4+IFJpZ2h0IGRyYWc8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2R0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEFkanVzdCBicnVzaCBzbGlkZXJzIG1vcmUgcHJlY2lzZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2RsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dHMtc2VjdGlvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg1PkRyYXdpbmcgY2FudmFzPC9oNT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDx1bCBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dHMtbGlzdCBsaXN0LXVuc3R5bGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGxpPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZHQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXRcIj48c3BhbiBjbGFzcz1cImZhIGZhLW1vdXNlLXBvaW50ZXJcIj48L3NwYW4+IE1pZGRsZTwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXQtYWx0ZXJuYXRlXCI+b3I8L3NwYW4+IDxzcGFuIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0XCI+PHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXQta2V5XCI+U3BhY2U8L3NwYW4+ICsgPHNwYW4gY2xhc3M9XCJmYSBmYS1tb3VzZS1wb2ludGVyXCI+PC9zcGFuPiBMZWZ0PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNb3ZlIHRoZSBjYW52YXMgYXJvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2RkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGR0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0XCI+PHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXQta2V5XCI+QWx0PC9zcGFuPiArIDxzcGFuIGNsYXNzPVwiZmEgZmEtbW91c2UtcG9pbnRlclwiPjwvc3Bhbj4gTWlkZGxlPC9zcGFuPiA8c3BhbiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dC1hbHRlcm5hdGVcIj5vcjwvc3Bhbj4gPHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXRcIj48c3BhbiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dC1rZXlcIj5BbHQ8L3NwYW4+ICsgPHNwYW4gY2xhc3M9XCJjaGlja2VucGFpbnQtc2hvcnRjdXQta2V5XCI+U3BhY2U8L3NwYW4+ICsgPHNwYW4gY2xhc3M9XCJmYSBmYS1tb3VzZS1wb2ludGVyXCI+PC9zcGFuPiBMZWZ0PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSb3RhdGUgdGhlIGNhbnZhc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dFwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtbW91c2UtcG9pbnRlclwiPjwvc3Bhbj4gUmlnaHQ8L3NwYW4+IDxzcGFuIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0LWFsdGVybmF0ZVwiPm9yPC9zcGFuPiA8c3BhbiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dFwiPjxzcGFuIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0LWtleVwiPkFsdDwvc3Bhbj4gKyA8c3BhbiBjbGFzcz1cImZhIGZhLW1vdXNlLXBvaW50ZXJcIj48L3NwYW4+IExlZnQ8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2R0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRkPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNhbXBsZSB0aGUgY29sb3IgdW5kZXIgdGhlIGN1cnNvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvdWw+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0cy1zZWN0aW9uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDU+TGF5ZXJzIHBhbGV0dGU8L2g1PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHVsIGNsYXNzPVwiY2hpY2tlbnBhaW50LXNob3J0Y3V0cy1saXN0IGxpc3QtdW5zdHlsZWRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8bGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImNoaWNrZW5wYWludC1zaG9ydGN1dFwiPjxzcGFuIGNsYXNzPVwiZmEgZmEtbW91c2UtcG9pbnRlclwiPjwvc3Bhbj4gRG91YmxlIGNsaWNrPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kdD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkZD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZW5hbWUgbGF5ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2RsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvbGk+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3VsPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIGApO1xuICAgIFxuICAgIC8vIERlc3Ryb3kgdGhlIG1vZGFsIHVwb24gY2xvc2VcbiAgICBkaWFsb2cub24oXCJoaWRkZW4uYnMubW9kYWxcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBkaWFsb2cucmVtb3ZlKCk7XG4gICAgfSk7XG4gICAgXG4gICAgZGlhbG9nLm1vZGFsKHtcbiAgICAgICAgc2hvdzogZmFsc2VcbiAgICB9KTtcbiAgICBcbiAgICAvLyBGaXggdGhlIGJhY2tkcm9wIGxvY2F0aW9uIGluIHRoZSBET00gYnkgcmVwYXJlbnRpbmcgaXQgdG8gdGhlIGNoaWNrZW5wYWludCBjb250YWluZXJcbiAgICBkaWFsb2cuZGF0YShcImJzLm1vZGFsXCIpLiRib2R5ID0gJChwYXJlbnQpO1xuICAgIFxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChkaWFsb2dbMF0pO1xuXG4gICAgdGhpcy5zaG93ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGRpYWxvZy5tb2RhbChcInNob3dcIik7XG4gICAgfTtcbn0iLCIvKlxuICAgIENoaWNrZW5QYWludFxuICAgIFxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG4gICAgXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuLyoqXG4gKiBBIHNpbXBsZSBzbGlkZXIgY29udHJvbC5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BTbGlkZXIobWluVmFsdWUsIG1heFZhbHVlLCBjZW50ZXJNb2RlLCBleHBNb2RlKSB7XG4gICAgY29uc3RcbiAgICAgICAgUFJFQ0lTRV9EUkFHX1NDQUxFID0gNCxcbiAgICAgICAgRVhQX01PREVfRkFDVE9SID0gMS41O1xuXG4gICAgdmFyIFxuICAgICAgICBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuICAgICAgICBjYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcbiAgICAgICAgXG4gICAgICAgIHZhbHVlUmFuZ2UgPSBtYXhWYWx1ZSAtIG1pblZhbHVlLFxuICAgICAgICBcbiAgICAgICAgZHJhZ05vcm1hbCA9IGZhbHNlLCBkcmFnUHJlY2lzZSA9IGZhbHNlLFxuICAgICAgICBkcmFnUHJlY2lzZVgsXG4gICAgICAgIFxuICAgICAgICBkb25lSW5pdGlhbFBhaW50ID0gZmFsc2UsXG4gICAgICAgIFxuICAgICAgICB0aGF0ID0gdGhpcztcbiAgICBcbiAgICB0aGlzLnZhbHVlID0gdW5kZWZpbmVkO1xuXG4gICAgLyoqXG4gICAgICogRWl0aGVyIGEgc3RyaW5nIHRvIGRyYXcgb24gdGhlIHNsaWRlciwgb3IgYSBmdW5jdGlvbih2YWx1ZSkgd2hpY2ggcmVjZWl2ZXMgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIHNsaWRlciBhbmRcbiAgICAgKiBzaG91bGQgcmV0dXJuIHRoZSBzdHJpbmcgdG8gYmUgcGFpbnRlZCB0byB0aGUgc2xpZGVyLlxuICAgICAqXG4gICAgICogQG5hbWUgQ1BTbGlkZXIjdGl0bGVcbiAgICAgKiBAZGVmYXVsdCBcIlwiXG4gICAgICovXG4gICAgdGhpcy50aXRsZSA9IFwiXCI7XG4gICAgXG4gICAgY2VudGVyTW9kZSA9IGNlbnRlck1vZGUgfHwgZmFsc2U7XG5cbiAgICBmdW5jdGlvbiBwYWludCgpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICB3aWR0aCA9IGNhbnZhcy53aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCA9IGNhbnZhcy5oZWlnaHQsXG4gICAgICAgICAgICB0aXRsZSA9IHR5cGVvZiB0aGF0LnRpdGxlID09PSBcInN0cmluZ1wiID8gdGhhdC50aXRsZSA6IHRoYXQudGl0bGUodGhhdC52YWx1ZSksXG4gICAgICAgICAgICB0ZXh0WCA9IDIgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyxcbiAgICAgICAgICAgIHRleHRZID0gY2FudmFzLmhlaWdodCAqIDAuNzU7XG5cbiAgICAgICAgaWYgKGNlbnRlck1vZGUpIHtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmZpbGxTdHlsZSA9ICd3aGl0ZSc7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFJlY3QoMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcblxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsVGV4dCh0aXRsZSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmICh0aGF0LnZhbHVlID49IHZhbHVlUmFuZ2UgLyAyKSB7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5yZWN0KHdpZHRoIC8gMiwgMCwgKHRoYXQudmFsdWUgLSB2YWx1ZVJhbmdlIC8gMikgKiB3aWR0aCAvIHZhbHVlUmFuZ2UsIGhlaWdodCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQucmVjdCh0aGF0LnZhbHVlICogd2lkdGggLyB2YWx1ZVJhbmdlLCAwLCAodmFsdWVSYW5nZSAvIDIgLSB0aGF0LnZhbHVlKSAqIHdpZHRoIC8gdmFsdWVSYW5nZSwgaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsKCk7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmNsaXAoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsVGV4dCh0aXRsZSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBiYXJQcm9wID0gKHRoYXQudmFsdWUgLSBtaW5WYWx1ZSkgLyB2YWx1ZVJhbmdlLFxuICAgICAgICAgICAgICAgIGJhcldpZHRoO1xuXG4gICAgICAgICAgICBpZiAoZXhwTW9kZSkge1xuICAgICAgICAgICAgICAgIGJhclByb3AgPSBNYXRoLnBvdyhiYXJQcm9wLCAxIC8gRVhQX01PREVfRkFDVE9SKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYmFyV2lkdGggPSBiYXJQcm9wICogd2lkdGg7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuc2F2ZSgpO1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5zYXZlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcblxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQucmVjdCgwLCAwLCBiYXJXaWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmNsaXAoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsVGV4dCh0aXRsZSwgdGV4dFgsIHRleHRZKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSBjbGlwIHJlZ2lvblxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5yZXN0b3JlKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcblxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQucmVjdChiYXJXaWR0aCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmZpbGwoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5jbGlwKCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ2JsYWNrJztcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFRleHQodGl0bGUsIHRleHRYLCB0ZXh0WSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2VTZWxlY3QoZSkge1xuICAgICAgICB2YXIgXG4gICAgICAgICAgICB3aWR0aCA9ICQoY2FudmFzKS53aWR0aCgpLFxuICAgICAgICAgICAgbGVmdCA9ICQoY2FudmFzKS5vZmZzZXQoKS5sZWZ0LFxuXG4gICAgICAgICAgICBwcm9wb3J0aW9uID0gKGUucGFnZVggLSBsZWZ0KSAvIHdpZHRoO1xuXG4gICAgICAgIGlmIChleHBNb2RlKSB7XG4gICAgICAgICAgICAvLyBHaXZlIHRoZSB1c2VyIGZpbmVyIGNvbnRyb2wgb3ZlciB0aGUgbG93IHZhbHVlc1xuICAgICAgICAgICAgcHJvcG9ydGlvbiA9IE1hdGgucG93KE1hdGgubWF4KHByb3BvcnRpb24sIDAuMCksIEVYUF9NT0RFX0ZBQ1RPUik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGF0LnNldFZhbHVlKHByb3BvcnRpb24gKiB2YWx1ZVJhbmdlICsgbWluVmFsdWUpO1xuICAgIH1cbiAgICAgICAgXG4gICAgZnVuY3Rpb24gbW91c2VEcmFnZ2VkKGUpIHtcbiAgICAgICAgaWYgKGRyYWdOb3JtYWwpIHtcbiAgICAgICAgICAgIG1vdXNlU2VsZWN0KGUpO1xuICAgICAgICB9IGVsc2UgaWYgKGRyYWdQcmVjaXNlKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBkaWZmID0gKGUucGFnZVggLSBkcmFnUHJlY2lzZVgpIC8gUFJFQ0lTRV9EUkFHX1NDQUxFO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoZGlmZiAhPSAwKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIHVucm91bmRlZCA9IHRoYXQudmFsdWUgKyBkaWZmLFxuICAgICAgICAgICAgICAgICAgICByb3VuZGVkID0gdW5yb3VuZGVkIHwgMDtcblxuICAgICAgICAgICAgICAgIHRoYXQuc2V0VmFsdWUocm91bmRlZCk7XG5cbiAgICAgICAgICAgICAgICAvKiBUd2VhayB0aGUgXCJvbGQgbW91c2VYXCIgcG9zaXRpb24gc3VjaCB0aGF0IHRoZSBmcmFjdGlvbmFsIHBhcnQgb2YgdGhlIHZhbHVlIHdlIHdlcmUgdW5hYmxlIHRvIHNldFxuICAgICAgICAgICAgICAgICAqIHdpbGwgYmUgYWNjdW11bGF0ZWRcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBkcmFnUHJlY2lzZVggPSBlLnBhZ2VYIC0gKHVucm91bmRlZCAtIHJvdW5kZWQpICogUFJFQ0lTRV9EUkFHX1NDQUxFO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbW91c2VVcChlKSB7XG4gICAgICAgIGlmIChkcmFnTm9ybWFsICYmIGUuYnV0dG9uID09IDApIHtcbiAgICAgICAgICAgIGRyYWdOb3JtYWwgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChkcmFnUHJlY2lzZSAmJiBlLmJ1dHRvbiA9PSAyKSB7XG4gICAgICAgICAgICBkcmFnUHJlY2lzZSA9IGZhbHNlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzLnJlbGVhc2VQb2ludGVyQ2FwdHVyZShlLnBvaW50ZXJJZCk7XG4gICAgICAgIGNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIG1vdXNlVXApO1xuICAgICAgICBjYW52YXMucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIG1vdXNlRHJhZ2dlZCk7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2V0VmFsdWUgPSBmdW5jdGlvbihfdmFsdWUpIHtcbiAgICAgICAgX3ZhbHVlID0gfn5NYXRoLm1heChtaW5WYWx1ZSwgTWF0aC5taW4obWF4VmFsdWUsIF92YWx1ZSkpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMudmFsdWUgIT0gX3ZhbHVlKSB7XG4gICAgICAgICAgICB0aGlzLnZhbHVlID0gX3ZhbHVlO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICAvLyBUaGUgZXZlbnQgbGlzdGVuZXJzIG1pZ2h0IGxpa2UgdG8gdXBkYXRlIG91ciB0aXRsZSBwcm9wZXJ0eSBhdCB0aGlzIHBvaW50IHRvIHJlZmxlY3QgdGhlIG5ldyB2YWx1ZVxuICAgICAgICAgICAgdGhpcy5lbWl0RXZlbnQoJ3ZhbHVlQ2hhbmdlJywgW3RoaXMudmFsdWVdKTtcbiAgICAgICAgXG4gICAgICAgICAgICBpZiAoZG9uZUluaXRpYWxQYWludCkge1xuICAgICAgICAgICAgICAgIHBhaW50KCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFdlIGRvbid0IGJvdGhlciB0byBkbyBvdXIgY2FudmFzIGRpbWVuc2lvbmluZyB1bnRpbCB3ZSdyZSBzdXBwbGllZCB3aXRoIGFuIGluaXRpYWwgdmFsdWVcbiAgICAgICAgICAgICAgICBkb25lSW5pdGlhbFBhaW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIERPTSBlbGVtZW50IGZvciB0aGUgc2xpZGVyIGNvbXBvbmVudC5cbiAgICAgKi9cbiAgICB0aGlzLmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNhbnZhcztcbiAgICB9O1xuICAgIFxuICAgIHRoaXMucmVzaXplID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNhbnZhcy53aWR0aCA9ICQoY2FudmFzKS53aWR0aCgpIHx8IDE1MDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9ICQoY2FudmFzKS5oZWlnaHQoKSB8fCAyMDtcbiAgICAgICAgXG4gICAgICAgIGlmICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA+IDEpIHtcbiAgICAgICAgICAgIC8vIEFzc3VtZSBvdXIgd2lkdGggaXMgc2V0IHRvIDEwMCUgb3Igc2ltaWxhciwgc28gd2Ugb25seSBuZWVkIHRvIHRoZSBmaXggdGhlIGhlaWdodFxuICAgICAgICAgICAgY2FudmFzLnN0eWxlLmhlaWdodCA9IGNhbnZhcy5oZWlnaHQgKyAncHgnO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMud2lkdGggKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNhbnZhc0NvbnRleHQuZm9udCA9IChjYW52YXMuaGVpZ2h0ICogMC40NykgKyAncHQgc2Fucy1zZXJpZic7XG4gICAgICAgIFxuICAgICAgICBwYWludCgpO1xuICAgIH07XG4gICAgXG4gICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgZHJhZ2dpbmcgPSBkcmFnTm9ybWFsIHx8IGRyYWdQcmVjaXNlO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFkcmFnZ2luZykge1xuICAgICAgICAgICAgY2FudmFzLnNldFBvaW50ZXJDYXB0dXJlKGUucG9pbnRlcklkKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc3dpdGNoIChlLmJ1dHRvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgMDogLy8gTGVmdFxuICAgICAgICAgICAgICAgICAgICBkcmFnTm9ybWFsID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbW91c2VTZWxlY3QoZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAyOiAvLyBSaWdodFxuICAgICAgICAgICAgICAgICAgICBkcmFnUHJlY2lzZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGRyYWdQcmVjaXNlWCA9IGUucGFnZVg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBjYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBtb3VzZVVwKTtcbiAgICAgICAgICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcm1vdmVcIiwgbW91c2VEcmFnZ2VkKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIGNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICB9KTtcblxuICAgIGNhbnZhcy5zZXRBdHRyaWJ1dGUoXCJ0b3VjaC1hY3Rpb25cIiwgXCJub25lXCIpO1xuXG4gICAgY2FudmFzLmNsYXNzTmFtZSA9ICdjaGlja2VucGFpbnQtc2xpZGVyJztcbiAgICBcbiAgICBpZiAoIXdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvKSB7XG4gICAgICAgIC8vIE9sZCBicm93c2Vyc1xuICAgICAgICB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyA9IDEuMDtcbiAgICB9XG59XG5cbkNQU2xpZGVyLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoRXZlbnRFbWl0dGVyLnByb3RvdHlwZSk7XG5DUFNsaWRlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFNsaWRlcjtcbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQU3BsYXNoU2NyZWVuKHVpUGFyZW50LCBsb2FkZXIsIHJlc291cmNlc1Jvb3QpIHtcbiAgICBjb25zdFxuICAgICAgICBNQVhfU01PT1RISUVfT0ZGU0VUID0gMTcwO1xuXG4gICAgdmFyXG4gICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgIGNhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpLFxuXG4gICAgICAgIGN1cCA9IG5ldyBJbWFnZSgpLFxuICAgICAgICBsaWQgPSBuZXcgSW1hZ2UoKSxcbiAgICAgICAgb3V0bGluZXMgPSBuZXcgSW1hZ2UoKSxcbiAgICAgICAgdGV4dCA9IG5ldyBJbWFnZSgpLFxuXG4gICAgICAgIHNoYWRpbmcgPSBuZXcgSW1hZ2UoKSxcbiAgICAgICAgaGlnaGxpZ2h0cyA9IG5ldyBJbWFnZSgpLFxuICAgICAgICBzbW9vdGhpZSA9IG5ldyBJbWFnZSgpLFxuXG4gICAgICAgIGltYWdlcyA9IFtjdXAsIGxpZCwgb3V0bGluZXMsIHRleHQsIHNoYWRpbmcsIGhpZ2hsaWdodHMsIHNtb290aGllXSxcbiAgICAgICAgbG9hZGVkQ291bnQgPSAwLFxuXG4gICAgICAgIGN1cENvbXBvc2l0ZSwgc21vb3RoaWVDb21wb3NpdGUsXG4gICAgICAgIGN1cENvbXBvc2l0ZUNvbnRleHQsIHNtb290aGllQ29tcG9zaXRlQ29udGV4dCxcblxuICAgICAgICBwcm9ncmVzcyA9IDAuMCxcbiAgICAgICAgbWVzc2FnZSA9IFwiXCIsXG5cbiAgICAgICAgZm9udEhlaWdodCA9IDE0O1xuXG4gICAgdmFyIGltYWdlUm9vdCA9IHJlc291cmNlc1Jvb3QgKyBcInNwbGFzaC9cIjtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGltYWdlc1tpXS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGxvYWRlZENvdW50Kys7XG5cbiAgICAgICAgICAgIGlmIChsb2FkZWRDb3VudCA9PSBpbWFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmVwYWludCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY3VwLnNyYyA9IGltYWdlUm9vdCArIFwiY3VwLnBuZ1wiO1xuICAgIGhpZ2hsaWdodHMuc3JjID0gaW1hZ2VSb290ICsgXCJoaWdobGlnaHRzLnBuZ1wiO1xuICAgIGxpZC5zcmMgPSBpbWFnZVJvb3QgKyBcImxpZC5wbmdcIjtcbiAgICBvdXRsaW5lcy5zcmMgPSBpbWFnZVJvb3QgKyBcImxpbmVzLnBuZ1wiO1xuICAgIHNoYWRpbmcuc3JjID0gaW1hZ2VSb290ICsgXCJzaGFkaW5nLnBuZ1wiO1xuICAgIHNtb290aGllLnNyYyA9IGltYWdlUm9vdCArIFwic21vb3RoaWUucG5nXCI7XG4gICAgdGV4dC5zcmMgPSBpbWFnZVJvb3QgKyBcInRleHQucG5nXCI7XG5cbiAgICBmdW5jdGlvbiBidWlsZFNtb290aGllQ29tcG9zaXRlKGltZ1dpZHRoLCBpbWdIZWlnaHQsIHByb2dyZXNzKSB7XG4gICAgICAgIGlmICghc21vb3RoaWVDb21wb3NpdGUpIHtcbiAgICAgICAgICAgIHNtb290aGllQ29tcG9zaXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcblxuICAgICAgICAgICAgc21vb3RoaWVDb21wb3NpdGUud2lkdGggPSBpbWdXaWR0aDtcbiAgICAgICAgICAgIHNtb290aGllQ29tcG9zaXRlLmhlaWdodCA9IGltZ0hlaWdodDtcblxuICAgICAgICAgICAgc21vb3RoaWVDb21wb3NpdGVDb250ZXh0ID0gc21vb3RoaWVDb21wb3NpdGUuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlyc3QgZHJhdyB0aGUgc21vb3RoaWUgaW4gaXRzIG1hc2sgcG9zaXRpb246XG4gICAgICAgIHNtb290aGllQ29tcG9zaXRlQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImNvcHlcIjtcbiAgICAgICAgc21vb3RoaWVDb21wb3NpdGVDb250ZXh0LmRyYXdJbWFnZShzbW9vdGhpZSwgMCwgMCk7XG5cbiAgICAgICAgLy8gTm93IHNoaWZ0IHRoZSBzbW9vdGhpZSBkb3dud2FyZHMgYW5kIHVzZSB0aGUgb3JpZ2luYWwgcG9zaXRpb24gYXMgYSBtYXNrXG4gICAgICAgIHNtb290aGllQ29tcG9zaXRlQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgICBzbW9vdGhpZUNvbXBvc2l0ZUNvbnRleHQuZHJhd0ltYWdlKHNtb290aGllLCAwLCBNYXRoLnJvdW5kKHByb2dyZXNzICogTUFYX1NNT09USElFX09GRlNFVCkpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkQ3VwQ29tcG9zaXRlKGltZ1dpZHRoLCBpbWdIZWlnaHQsIHByb2dyZXNzKSB7XG4gICAgICAgIGlmICghY3VwQ29tcG9zaXRlKSB7XG4gICAgICAgICAgICBjdXBDb21wb3NpdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuXG4gICAgICAgICAgICBjdXBDb21wb3NpdGUud2lkdGggPSBpbWdXaWR0aDtcbiAgICAgICAgICAgIGN1cENvbXBvc2l0ZS5oZWlnaHQgPSBpbWdIZWlnaHQ7XG5cbiAgICAgICAgICAgIGN1cENvbXBvc2l0ZUNvbnRleHQgPSBjdXBDb21wb3NpdGUuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY3VwQ29tcG9zaXRlQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcImNvcHlcIjtcbiAgICAgICAgY3VwQ29tcG9zaXRlQ29udGV4dC5kcmF3SW1hZ2UoY3VwLCAwLCAwKTtcblxuICAgICAgICBidWlsZFNtb290aGllQ29tcG9zaXRlKGltZ1dpZHRoLCBpbWdIZWlnaHQsIHByb2dyZXNzKTtcblxuICAgICAgICBjdXBDb21wb3NpdGVDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwic291cmNlLW92ZXJcIjtcbiAgICAgICAgY3VwQ29tcG9zaXRlQ29udGV4dC5kcmF3SW1hZ2Uoc21vb3RoaWVDb21wb3NpdGUsIDAsIDApO1xuXG4gICAgICAgIGN1cENvbXBvc2l0ZUNvbnRleHQuZHJhd0ltYWdlKGxpZCwgMCwgMCk7XG5cbiAgICAgICAgY3VwQ29tcG9zaXRlQ29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNjcmVlblwiO1xuICAgICAgICBjdXBDb21wb3NpdGVDb250ZXh0LmRyYXdJbWFnZShoaWdobGlnaHRzLCAwLCAwKTtcblxuICAgICAgICBjdXBDb21wb3NpdGVDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IFwibXVsdGlwbHlcIjtcbiAgICAgICAgY3VwQ29tcG9zaXRlQ29udGV4dC5kcmF3SW1hZ2Uoc2hhZGluZywgMCwgMCk7XG5cbiAgICAgICAgcmV0dXJuIGN1cENvbXBvc2l0ZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXBhaW50KCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGNlbnRlclggPSBjYW52YXMud2lkdGggLyAyLFxuICAgICAgICAgICAgY2VudGVyWSA9IGNhbnZhcy5oZWlnaHQgLyAyO1xuXG4gICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gJ3doaXRlJztcbiAgICAgICAgY2FudmFzQ29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuXG4gICAgICAgIGlmIChsb2FkZWRDb3VudCA9PSBpbWFnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBpbWdXaWR0aCA9IHRleHQud2lkdGgsXG4gICAgICAgICAgICAgICAgaW1nSGVpZ2h0ID0gdGV4dC5oZWlnaHQsXG4gICAgICAgICAgICAgICAgbGVmdCA9IE1hdGgucm91bmQoY2VudGVyWCAtIGltZ1dpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgdG9wID0gTWF0aC5yb3VuZChjZW50ZXJZIC0gaW1nSGVpZ2h0IC8gMik7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHRleHQsIGxlZnQsIHRvcCk7XG5cbiAgICAgICAgICAgIGJ1aWxkQ3VwQ29tcG9zaXRlKGltZ1dpZHRoLCBpbWdIZWlnaHQsIHByb2dyZXNzKTtcblxuICAgICAgICAgICAgLy9UaGUgd2hvbGUgY3VwIGNvbXBvc2l0ZSBpcyBzbGlnaHRseSB0cmFuc3BhcmVudFxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5nbG9iYWxBbHBoYSA9IDAuODg7XG4gICAgICAgICAgICBjYW52YXNDb250ZXh0LmRyYXdJbWFnZShjdXBDb21wb3NpdGUsIGxlZnQsIHRvcCk7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZ2xvYmFsQWxwaGEgPSAxLjA7XG5cbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKG91dGxpbmVzLCBsZWZ0LCB0b3ApO1xuXG4gICAgICAgICAgICBjZW50ZXJZID0gTWF0aC5yb3VuZChjZW50ZXJZICsgaW1nSGVpZ2h0IC8gMiArIDIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKG1lc3NhZ2UgIT0gXCJcIikge1xuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSBcImJsYWNrXCI7XG5cbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGxpbmVzID0gbWVzc2FnZS5zcGxpdChcIlxcblwiKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBsaW5lID0gbGluZXNbaV0sXG4gICAgICAgICAgICAgICAgICAgIGxpbmVXaWR0aCA9IGNhbnZhc0NvbnRleHQubWVhc3VyZVRleHQobGluZSkud2lkdGg7XG5cbiAgICAgICAgICAgICAgICBjZW50ZXJZICs9IGZvbnRIZWlnaHQgKiAyO1xuXG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsVGV4dChsaW5lLCBjZW50ZXJYIC0gbGluZVdpZHRoIC8gMiwgY2VudGVyWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiByZXNpemUoKSB7XG4gICAgICAgIC8vIFVzZSB0aGUgY2FudmFzIGRpbWVuc2lvbnMgc2V0IGJ5IHRoZSBDU1Mgc3R5bGVzXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IGNhbnZhcy5jbGllbnRXaWR0aDtcbiAgICAgICAgY2FudmFzLmhlaWdodCA9IGNhbnZhcy5jbGllbnRIZWlnaHQ7XG5cbiAgICAgICAgY2FudmFzQ29udGV4dC5mb250ID0gZm9udEhlaWdodCArIFwicHQgc2Fucy1zZXJpZlwiO1xuXG4gICAgICAgIHJlcGFpbnQoKTtcbiAgICB9XG5cbiAgICBsb2FkZXIub24oXCJsb2FkaW5nUHJvZ3Jlc3NcIiwgZnVuY3Rpb24oX3Byb2dyZXNzLCBfbWVzc2FnZSkge1xuICAgICAgICBwcm9ncmVzcyA9IF9wcm9ncmVzcztcbiAgICAgICAgbWVzc2FnZSA9IF9tZXNzYWdlO1xuXG4gICAgICAgIHJlcGFpbnQoKTtcbiAgICB9KTtcblxuICAgIGxvYWRlci5vbihcImxvYWRpbmdGYWlsdXJlXCIsIGZ1bmN0aW9uKF9tZXNzYWdlKSB7XG4gICAgICAgIHByb2dyZXNzID0gMDtcbiAgICAgICAgbWVzc2FnZSA9IF9tZXNzYWdlO1xuXG4gICAgICAgIHJlcGFpbnQoKTtcbiAgICB9KTtcblxuICAgIGxvYWRlci5vbihcImxvYWRpbmdDb21wbGV0ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgcmVzaXplKTtcbiAgICAgICAgdWlQYXJlbnQucmVtb3ZlQ2hpbGQoY2FudmFzKTtcbiAgICB9KTtcblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHJlc2l6ZSk7XG5cbiAgICBjYW52YXMuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtc3BsYXNoLXNjcmVlblwiO1xuXG4gICAgdWlQYXJlbnQuYXBwZW5kQ2hpbGQoY2FudmFzKTtcblxuICAgIHJlc2l6ZSgpO1xufVxuIiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBDUFBhbGV0dGUgZnJvbSAnLi9DUFBhbGV0dGUnO1xuXG5pbXBvcnQgQ1BCcnVzaEluZm8gZnJvbSAnLi4vZW5naW5lL0NQQnJ1c2hJbmZvJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BTdHJva2VQYWxldHRlKGNwQ29udHJvbGxlcikge1xuICAgIENQUGFsZXR0ZS5jYWxsKHRoaXMsIGNwQ29udHJvbGxlciwgXCJzdHJva2VcIiwgXCJTdHJva2VcIik7XG4gICAgXG4gICAgdmFyIFxuICAgICAgICB0aGF0ID0gdGhpcyxcblxuICAgICAgICBidXR0b25zID0gW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGlja2VucGFpbnQtdG9vbC1mcmVlaGFuZFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BGcmVlSGFuZFwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiRnJlZS1oYW5kXCIsXG4gICAgICAgICAgICAgICAgc2VsZWN0ZWQ6IHRydWVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLWxpbmVcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBcIkNQTGluZVwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiU3RyYWlnaHQgbGluZVwiXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGlja2VucGFpbnQtdG9vbC1iZXppZXJcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBcIkNQQmV6aWVyXCIsXG4gICAgICAgICAgICAgICAgdG9vbFRpcDogXCJCZXppZXIgY3VydmVcIlxuICAgICAgICAgICAgfVxuICAgICAgICBdLFxuXG4gICAgICAgIGJvZHkgPSB0aGF0LmdldEJvZHlFbGVtZW50KCk7XG5cbiAgICBmdW5jdGlvbiBidWlsZEJ1dHRvbnMoKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgbGlzdEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgICAgIFxuICAgICAgICBsaXN0RWxlbS5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC1zdHJva2UtdG9vbHMgbGlzdC11bnN0eWxlZFwiO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSBpbiBidXR0b25zKSB7XG4gICAgICAgICAgICB2YXIgXG4gICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uc1tpXSxcbiAgICAgICAgICAgICAgICBidXR0b25FbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBidXR0b25FbGVtLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LXRvb2xiYXItYnV0dG9uIFwiICsgYnV0dG9uLmNsYXNzTmFtZTtcbiAgICAgICAgICAgIGJ1dHRvbkVsZW0uc2V0QXR0cmlidXRlKFwiZGF0YS1idXR0b25JbmRleFwiLCBpKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGJ1dHRvbi5zZWxlY3RlZCkge1xuICAgICAgICAgICAgICAgIGJ1dHRvbkVsZW0uY2xhc3NOYW1lID0gYnV0dG9uRWxlbS5jbGFzc05hbWUgKyBcIiBzZWxlY3RlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBsaXN0RWxlbS5hcHBlbmRDaGlsZChidXR0b25FbGVtKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgbGlzdEVsZW0uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGlmIChlLnRhcmdldCAmJiBlLnRhcmdldC5ub2RlTmFtZSA9PSBcIkxJXCIpIHtcbiAgICAgICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uc1twYXJzZUludChlLnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJ1dHRvbkluZGV4XCIpLCAxMCldO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICQoXCJsaVwiLCBsaXN0RWxlbSkucmVtb3ZlQ2xhc3MoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgICAgICAgICAkKGUudGFyZ2V0KS5hZGRDbGFzcyhcInNlbGVjdGVkXCIpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNwQ29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogYnV0dG9uLmNvbW1hbmR9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGxpc3RFbGVtKTtcbiAgICB9XG4gICAgXG4gICAgYnVpbGRCdXR0b25zKCk7XG4gICAgXG4gICAgY3BDb250cm9sbGVyLm9uKFwidG9vbENoYW5nZVwiLCBmdW5jdGlvbih0b29sLCB0b29sSW5mbykge1xuICAgICAgICAkKFwiLmNoaWNrZW5wYWludC10b29sLWZyZWVoYW5kXCIsIGJvZHkpLnRvZ2dsZUNsYXNzKFwic2VsZWN0ZWRcIiwgdG9vbEluZm8uc3Ryb2tlTW9kZSA9PSBDUEJydXNoSW5mby5TTV9GUkVFSEFORCk7XG4gICAgICAgICQoXCIuY2hpY2tlbnBhaW50LXRvb2wtbGluZVwiLCBib2R5KS50b2dnbGVDbGFzcyhcInNlbGVjdGVkXCIsIHRvb2xJbmZvLnN0cm9rZU1vZGUgPT0gQ1BCcnVzaEluZm8uU01fTElORSk7XG4gICAgICAgICQoXCIuY2hpY2tlbnBhaW50LXRvb2wtYmV6aWVyXCIsIGJvZHkpLnRvZ2dsZUNsYXNzKFwic2VsZWN0ZWRcIiwgdG9vbEluZm8uc3Ryb2tlTW9kZSA9PSBDUEJydXNoSW5mby5TTV9CRVpJRVIpO1xuICAgIH0pO1xufVxuXG5DUFN0cm9rZVBhbGV0dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUFBhbGV0dGUucHJvdG90eXBlKTtcbkNQU3Ryb2tlUGFsZXR0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFN0cm9rZVBhbGV0dGU7XG4iLCIvKlxuICAgIENoaWNrZW5QYWludFxuICAgIFxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG4gICAgXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuaW1wb3J0IENQUGFsZXR0ZSBmcm9tICcuL0NQUGFsZXR0ZSc7XG5cbmltcG9ydCBDUENvbG9yIGZyb20gJy4uL3V0aWwvQ1BDb2xvcic7XG5pbXBvcnQgQWRvYmVDb2xvclRhYmxlIGZyb20gJy4uL3V0aWwvQWRvYmVDb2xvclRhYmxlJztcblxuZnVuY3Rpb24gcGFkTGVmdChzdHJpbmcsIHBhZGRpbmcsIGxlbikge1xuICAgIHdoaWxlIChzdHJpbmcubGVuZ3RoIDwgbGVuKSB7XG4gICAgICAgIHN0cmluZyA9IHBhZGRpbmcgKyBzdHJpbmc7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG59XG5cbmZ1bmN0aW9uIHdyYXBXaXRoRWxlbShlLCB3cmFwV2l0aE5hbWUpIHtcbiAgICB2YXJcbiAgICAgICAgcGFyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh3cmFwV2l0aE5hbWUpO1xuICAgIFxuICAgIHBhcmVudC5hcHBlbmRDaGlsZChlKTtcbiAgICBcbiAgICByZXR1cm4gcGFyZW50O1xufVxuXG5mdW5jdGlvbiBmaWxlQVBJc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gd2luZG93LkZpbGUgJiYgd2luZG93LkZpbGVSZWFkZXIgJiYgd2luZG93LkZpbGVMaXN0ICYmIHdpbmRvdy5CbG9iO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUFN3YXRjaGVzUGFsZXR0ZShjb250cm9sbGVyKSB7XG4gICAgQ1BQYWxldHRlLmNhbGwodGhpcywgY29udHJvbGxlciwgXCJzd2F0Y2hlc1wiLCBcIkNvbG9yIHN3YXRjaGVzXCIpO1xuICAgIFxuICAgIHZhclxuICAgICAgICBJTklUX0NPTE9SUyA9IFsweGZmZmZmZiwgMHgwMDAwMDAsIDB4ZmYwMDAwLCAweDAwZmYwMCwgMHgwMDAwZmYsIDB4ZmZmZjAwXSxcbiAgICAgICAgXG4gICAgICAgIG1vZGlmaWVkID0gZmFsc2UsXG4gICAgICAgIHN3YXRjaFBhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInVsXCIpLFxuICAgICAgICBidXR0b25QYW5lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIFxuICAgICAgICBmaWxlSW5wdXQsXG4gICAgICAgIFxuICAgICAgICB0aGF0ID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIENQQ29sb3JTd2F0Y2goY29sb3IpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICB3cmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgICAgIHN3YXRjaEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSxcbiAgICAgICAgICAgIHN3YXRjaE1lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIiksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1udVJlbW92ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpLFxuICAgICAgICAgICAgbW51U2V0VG9DdXJyZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIiksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoYXQgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2V0Q29sb3IgPSBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICAgICAgc3dhdGNoRWxlbS5zZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIsIGNvbG9yKTtcbiAgICAgICAgICAgIHN3YXRjaEVsZW0uc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyMnICsgcGFkTGVmdChcIlwiICsgTnVtYmVyKGNvbG9yKS50b1N0cmluZygxNiksIFwiMFwiLCA2KTtcbiAgICAgICAgfTtcblxuICAgICAgICB0aGlzLnNldENvbG9yKGNvbG9yKTtcbiAgICAgICAgXG4gICAgICAgIHN3YXRjaEVsZW0uaHJlZiA9IFwiI1wiO1xuICAgICAgICBzd2F0Y2hFbGVtLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LWNvbG9yLXN3YXRjaCBkcm9wZG93bi10b2dnbGVcIjtcbiAgICAgICAgc3dhdGNoRWxlbS5zZXRBdHRyaWJ1dGUoXCJkYXRhLXRvZ2dsZVwiLCBcImRyb3Bkb3duXCIpO1xuICAgICAgICBcbiAgICAgICAgbW51UmVtb3ZlLmhyZWYgPSBcIiNcIjtcbiAgICAgICAgbW51UmVtb3ZlLmlubmVySFRNTCA9IFwiUmVtb3ZlXCI7XG4gICAgICAgIFxuICAgICAgICBtbnVSZW1vdmUuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICQod3JhcHBlcikucmVtb3ZlKCk7XG5cbiAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgbW51U2V0VG9DdXJyZW50LmhyZWYgPSBcIiNcIjtcbiAgICAgICAgbW51U2V0VG9DdXJyZW50LmlubmVySFRNTCA9IFwiUmVwbGFjZSB3aXRoIGN1cnJlbnQgY29sb3JcIjtcbiAgICAgICAgXG4gICAgICAgIG1udVNldFRvQ3VycmVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGF0LnNldENvbG9yKGNvbnRyb2xsZXIuZ2V0Q3VyQ29sb3IoKS5nZXRSZ2IoKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBzd2F0Y2hNZW51LmNsYXNzTmFtZSA9IFwiZHJvcGRvd24tbWVudVwiO1xuICAgICAgICBcbiAgICAgICAgc3dhdGNoTWVudS5hcHBlbmRDaGlsZCh3cmFwV2l0aEVsZW0obW51UmVtb3ZlLCBcImxpXCIpKTtcbiAgICAgICAgc3dhdGNoTWVudS5hcHBlbmRDaGlsZCh3cmFwV2l0aEVsZW0obW51U2V0VG9DdXJyZW50LCBcImxpXCIpKTtcbiAgICAgICAgXG4gICAgICAgIHdyYXBwZXIuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtY29sb3Itc3dhdGNoLXdyYXBwZXJcIjtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzd2F0Y2hFbGVtKTtcbiAgICAgICAgd3JhcHBlci5hcHBlbmRDaGlsZChzd2F0Y2hNZW51KTtcbiAgICAgICAgXG4gICAgICAgICQod3JhcHBlcikub24oXCJzaG93LmJzLmRyb3Bkb3duXCIsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgICRidG5Ecm9wRG93biA9ICQodGhpcykuZmluZChcIi5kcm9wZG93bi10b2dnbGVcIiksXG4gICAgICAgICAgICAgICAgJGxpc3RIb2xkZXIgPSAkKHRoaXMpLmZpbmQoXCIuZHJvcGRvd24tbWVudVwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgJGxpc3RIb2xkZXIuY3NzKHtcbiAgICAgICAgICAgICAgICBcInRvcFwiOiAoJGJ0bkRyb3BEb3duLnBvc2l0aW9uKCkudG9wICsgJGJ0bkRyb3BEb3duLm91dGVySGVpZ2h0KHRydWUpKSArIFwicHhcIixcbiAgICAgICAgICAgICAgICBcImxlZnRcIjogJGJ0bkRyb3BEb3duLnBvc2l0aW9uKCkubGVmdCArIFwicHhcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBjbGVhclN3YXRjaGVzKCkge1xuICAgICAgICB3aGlsZSAoc3dhdGNoUGFuZWwubGFzdENoaWxkKSB7XG4gICAgICAgICAgICBzd2F0Y2hQYW5lbC5yZW1vdmVDaGlsZChzd2F0Y2hQYW5lbC5sYXN0Q2hpbGQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkU3dhdGNoKGNvbG9yKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgc3dhdGNoID0gbmV3IENQQ29sb3JTd2F0Y2goY29sb3IpO1xuXG4gICAgICAgIHN3YXRjaFBhbmVsLmFwcGVuZENoaWxkKHN3YXRjaC5nZXRFbGVtZW50KCkpO1xuICAgIH1cbiAgICBcbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGNvbG9ycyBpbiBSR0IgMzItYml0IGludGVnZXIgZm9ybWF0XG4gICAgICovXG4gICAgdGhpcy5nZXRTd2F0Y2hlcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHN3YXRjaGVzID0gJChcIi5jaGlja2VucGFpbnQtY29sb3Itc3dhdGNoXCIsIHN3YXRjaFBhbmVsKSxcbiAgICAgICAgICAgIGNvbG9ycyA9IG5ldyBBcnJheShzd2F0Y2hlcy5sZW5ndGgpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3dhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbG9yc1tpXSA9IHBhcnNlSW50KHN3YXRjaGVzLmdldChpKS5nZXRBdHRyaWJ1dGUoXCJkYXRhLWNvbG9yXCIpLCAxMCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY29sb3JzO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFN3YXRjaGVzID0gZnVuY3Rpb24oc3dhdGNoZXMpIHtcbiAgICAgICAgY2xlYXJTd2F0Y2hlcygpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3dhdGNoZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFkZFN3YXRjaChzd2F0Y2hlc1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIG1vZGlmaWVkID0gdHJ1ZTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuaXNNb2RpZmllZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gbW9kaWZpZWQ7XG4gICAgfTtcbiAgICBcbiAgICBmdW5jdGlvbiBsb2FkU3dhdGNoZXMoKSB7XG4gICAgICAgIGZpbGVJbnB1dC5vbmNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgIGZpbGVMaXN0ID0gdGhpcy5maWxlcztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGZpbGVMaXN0Lmxlbmd0aCA8IDEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBmaWxlID0gZmlsZUxpc3RbMF0sXG4gICAgICAgICAgICAgICAgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgICAgICBzd2F0Y2hlcyA9IG5ldyBBZG9iZUNvbG9yVGFibGUoKS5yZWFkKHRoaXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoc3dhdGNoZXMgIT0gbnVsbCAmJiBzd2F0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuc2V0U3dhdGNoZXMoc3dhdGNoZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGFsZXJ0KFwiVGhlIHN3YXRjaGVzIGNvdWxkIG5vdCBiZSByZWFkLCBkaWQgeW91IHNlbGVjdCBhbiAuYWNvIGZpbGU/XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihmaWxlKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZmlsZUlucHV0LmNsaWNrKCk7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIHNhdmVTd2F0Y2hlcygpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBhY28gPSBuZXcgQWRvYmVDb2xvclRhYmxlKCkud3JpdGUodGhhdC5nZXRTd2F0Y2hlcygpKSxcbiAgICAgICAgICAgIGJsb2IgPSBuZXcgQmxvYihbYWNvXSwge3R5cGU6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCJ9KTtcbiAgICAgICAgXG4gICAgICAgIHdpbmRvdy5zYXZlQXMoYmxvYiwgXCJvZWtha2lzd2F0Y2hlcy5hY29cIik7XG4gICAgfVxuICAgIFxuICAgIGZ1bmN0aW9uIGluaXRTd2F0Y2hQYW5lbCgpIHtcbiAgICAgICAgc3dhdGNoUGFuZWwuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtY29sb3Itc3dhdGNoZXMgbGlzdC11bnN0eWxlZFwiO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBJTklUX0NPTE9SUy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc3dhdGNoUGFuZWwuYXBwZW5kQ2hpbGQobmV3IENQQ29sb3JTd2F0Y2goSU5JVF9DT0xPUlNbaV0pLmdldEVsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHN3YXRjaFBhbmVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBzd2F0Y2ggPSBlLnRhcmdldDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCEvY2hpY2tlbnBhaW50LWNvbG9yLXN3YXRjaC8udGVzdChzd2F0Y2guY2xhc3NOYW1lKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGUuYnV0dG9uID09IDAgLyogTGVmdCAqLyAmJiBzd2F0Y2guZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5zZXRDdXJDb2xvcihuZXcgQ1BDb2xvcihwYXJzZUludChzd2F0Y2guZ2V0QXR0cmlidXRlKFwiZGF0YS1jb2xvclwiKSwgMTApKSk7XG4gICAgICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBcbiAgICAgICAgc3dhdGNoUGFuZWwuYWRkRXZlbnRMaXN0ZW5lcihcImNvbnRleHRtZW51XCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHN3YXRjaCA9IGUudGFyZ2V0O1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAoIS9jaGlja2VucGFpbnQtY29sb3Itc3dhdGNoLy50ZXN0KHN3YXRjaC5jbGFzc05hbWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgICQoc3dhdGNoKVxuICAgICAgICAgICAgICAgIC5kcm9wZG93bihcInRvZ2dsZVwiKVxuICAgICAgICAgICAgICAgIC5vZmYoXCJjbGljay5icy5kcm9wZG93blwiKTsgLy8gUmVtb3ZlIEJvb3RzdHJhcCdzIGxlZnQtY2xpY2sgaGFuZGxlciBpbnN0YWxsZWQgYnkgdG9nZ2xlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBpbml0QnV0dG9uc1BhbmVsKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGJ0blNldHRpbmdzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSwgXG4gICAgICAgICAgICBidG5BZGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzZXR0aW5nc01lbnUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIiksXG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG1udVNhdmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKSxcbiAgICAgICAgICAgIG1udUxvYWQgID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImFcIik7XG4gICAgICAgIFxuICAgICAgICBidG5BZGQudGl0bGUgPSBcIkFkZCB0aGUgY3VycmVudCBicnVzaCBjb2xvciBhcyBhIG5ldyBzd2F0Y2hcIjtcbiAgICAgICAgYnRuQWRkLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LXNtYWxsLXRvb2xiYXItYnV0dG9uIGNoaWNrZW5wYWludC1jb2xvci1zd2F0Y2gtYWRkXCI7XG4gICAgICAgIFxuICAgICAgICBidG5TZXR0aW5ncy5jbGFzc05hbWUgPSBcImNoaWNrZW5wYWludC1zbWFsbC10b29sYmFyLWJ1dHRvbiBjaGlja2VucGFpbnQtY29sb3Itc3dhdGNoLXNldHRpbmdzXCI7XG4gICAgICAgIGJ0blNldHRpbmdzLnNldEF0dHJpYnV0ZShcImRhdGEtdG9nZ2xlXCIsIFwiZHJvcGRvd25cIik7XG4gICAgICAgICQoYnRuU2V0dGluZ3MpLmRyb3Bkb3duKCk7XG5cbiAgICAgICAgbW51U2F2ZS5ocmVmID0gXCIjXCI7XG4gICAgICAgIG1udVNhdmUuaW5uZXJIVE1MID0gXCJTYXZlIHN3YXRjaGVzIHRvIHlvdXIgY29tcHV0ZXIuLi5cIjtcbiAgICAgICAgbW51U2F2ZS5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzYXZlU3dhdGNoZXMoKTtcbiAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgbW51TG9hZC5ocmVmID0gXCIjXCI7XG4gICAgICAgIG1udUxvYWQuaW5uZXJIVE1MID0gXCJMb2FkIHN3YXRjaGVzIGZyb20geW91ciBjb21wdXRlci4uLlwiO1xuICAgICAgICBtbnVMb2FkLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGxvYWRTd2F0Y2hlcygpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHNldHRpbmdzTWVudS5jbGFzc05hbWUgPSBcImRyb3Bkb3duLW1lbnUgZHJvcGRvd24tbWVudS1yaWdodFwiO1xuICAgICAgICBcbiAgICAgICAgc2V0dGluZ3NNZW51LmFwcGVuZENoaWxkKHdyYXBXaXRoRWxlbShtbnVTYXZlLCBcImxpXCIpKTtcbiAgICAgICAgc2V0dGluZ3NNZW51LmFwcGVuZENoaWxkKHdyYXBXaXRoRWxlbShtbnVMb2FkLCBcImxpXCIpKTtcbiAgICAgICAgXG4gICAgICAgIHZhclxuICAgICAgICAgICAgYnRuU2V0dGluZ3NDb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICBcbiAgICAgICAgYnRuU2V0dGluZ3NDb250YWluZXIuY2xhc3NOYW1lID0gJ2Ryb3Bkb3duJztcbiAgICAgICAgYnRuU2V0dGluZ3NDb250YWluZXIuYXBwZW5kQ2hpbGQoYnRuU2V0dGluZ3MpO1xuICAgICAgICBidG5TZXR0aW5nc0NvbnRhaW5lci5hcHBlbmRDaGlsZChzZXR0aW5nc01lbnUpO1xuXG4gICAgICAgICQoYnRuU2V0dGluZ3NDb250YWluZXIpLm9uKFwic2hvdy5icy5kcm9wZG93blwiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIC8qIEluc3RlYWQgb2YgQm9vdHN0cmFwJ3MgZXh0cmVtZWx5IGV4cGVuc2l2ZSBkYXRhIEFQSSwgd2UnbGwgb25seSBsaXN0ZW4gZm9yIGRpc21pc3MgY2xpY2tzIG9uIHRoZVxuICAgICAgICAgICAgICogZG9jdW1lbnQgKndoaWxlIHRoZSBtZW51IGlzIG9wZW4hKlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICAkKGRvY3VtZW50KS5vbmUoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoJChidG5TZXR0aW5nc0NvbnRhaW5lcikuaGFzQ2xhc3MoXCJvcGVuXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICQoYnRuU2V0dGluZ3MpLmRyb3Bkb3duKFwidG9nZ2xlXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBidG5BZGQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGFkZFN3YXRjaChjb250cm9sbGVyLmdldEN1ckNvbG9yKCkuZ2V0UmdiKCkpO1xuICAgICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGJ1dHRvblBhbmVsLmNsYXNzTmFtZSA9ICdjaGlja2VucGFpbnQtY29sb3Itc3dhdGNoZXMtYnV0dG9ucyc7XG4gICAgICAgIFxuICAgICAgICAvLyBEb24ndCBvZmZlciB0byBsb2FkL3NhdmUgc3dhdGNoZXMgaWYgd2UgZG9uJ3QgaGF2ZSB0aGUgZmlsZSBBUEkgbmVlZGVkIGZvciByZWFkaW5nIHRoZW1cbiAgICAgICAgaWYgKGZpbGVBUElzU3VwcG9ydGVkKCkpIHtcbiAgICAgICAgICAgIGZpbGVJbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZmlsZUlucHV0LnR5cGUgPSBcImZpbGVcIjtcbiAgICAgICAgICAgIGZpbGVJbnB1dC5tdWx0aXBsZSA9IGZhbHNlO1xuICAgICAgICAgICAgZmlsZUlucHV0LnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIGJ1dHRvblBhbmVsLmFwcGVuZENoaWxkKGJ0blNldHRpbmdzQ29udGFpbmVyKTtcbiAgICAgICAgICAgIGJ1dHRvblBhbmVsLmFwcGVuZENoaWxkKGZpbGVJbnB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGJ1dHRvblBhbmVsLmFwcGVuZENoaWxkKGJ0bkFkZCk7XG4gICAgfVxuICAgIFxuICAgIGluaXRTd2F0Y2hQYW5lbCgpO1xuICAgIHRoaXMuZ2V0Qm9keUVsZW1lbnQoKS5hcHBlbmRDaGlsZChzd2F0Y2hQYW5lbCk7XG5cbiAgICBpbml0QnV0dG9uc1BhbmVsKCk7XG4gICAgdGhpcy5nZXRCb2R5RWxlbWVudCgpLmFwcGVuZENoaWxkKGJ1dHRvblBhbmVsKTtcbn1cblxuQ1BTd2F0Y2hlc1BhbGV0dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUFBhbGV0dGUucHJvdG90eXBlKTtcbkNQU3dhdGNoZXNQYWxldHRlLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IENQU3dhdGNoZXNQYWxldHRlOyIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ1BXYWNvbVRhYmxldCBmcm9tIFwiLi4vdXRpbC9DUFdhY29tVGFibGV0XCI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQVGFibGV0RGlhbG9nKHBhcmVudCkge1xuICAgIHZhclxuICAgICAgICBkaWFsb2cgPSBcbiAgICAgICAgICAgICQoYDxkaXYgY2xhc3M9XCJtb2RhbCBmYWRlXCIgdGFiaW5kZXg9XCItMVwiIHJvbGU9XCJkaWFsb2dcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtZGlhbG9nXCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtb2RhbC1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibW9kYWwtaGVhZGVyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgY2xhc3M9XCJjbG9zZVwiIGRhdGEtZGlzbWlzcz1cIm1vZGFsXCIgYXJpYS1sYWJlbD1cIkNsb3NlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGFyaWEtaGlkZGVuPVwidHJ1ZVwiPiZ0aW1lczs8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVwibW9kYWwtdGl0bGVcIj5EcmF3aW5nIHRhYmxldCBzdXBwb3J0PC9oND5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1vZGFsLWJvZHlcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImNoaWNrZW5wYWludC10YWJsZXQtdGhlcmUtYXJlLXR3by1vcHRpb25zXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZXJlIGFyZSB0d28gd2F5cyB5b3UgY291bGQgdXNlIHlvdXIgdGFibGV0J3MgcGVuIHByZXNzdXJlIHN1cHBvcnQgd2l0aCBDaGlja2VuUGFpbnQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGlja2VucGFpbnQtdGFibGV0LXN1cHBvcnQgY2hpY2tlbnBhaW50LXdhY29tLXN1cHBvcnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGx1Z2luIGZvciBXYWNvbSB0YWJsZXRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGlja2VucGFpbnQtc3VwcG9ydGVkLWJyb3dzZXJzXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hpY2tlbnBhaW50LXN1cHBvcnRlZC1icm93c2VyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYSBmYS1pbnRlcm5ldC1leHBsb3JlclwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJRSAxMCwgMTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoaWNrZW5wYWludC1zdXBwb3J0ZWQtYnJvd3NlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmEgZmEtZmlyZWZveFwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBGaXJlZm94ICgzMi1iaXQgb25seSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoaWNrZW5wYWludC1zdXBwb3J0ZWQtYnJvd3NlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmEgZmEtc2FmYXJpXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFNhZmFyaVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoaWNrZW5wYWludC1zdXBwb3J0ZWQtYnJvd3NlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmEgZmEtb3BlcmFcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgT3BlcmFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJjaGlja2VucGFpbnQtbm90LWluc3RhbGxlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVGhlIHBsdWdpbiBmb3IgV2Fjb20gdGFibGV0cyBkb2Vzbid0IHNlZW0gdG8gYmUgaW5zdGFsbGVkIGluIHlvdXIgYnJvd3NlciB5ZXQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJjaGlja2VucGFpbnQtbm90LWluc3RhbGxlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUGxlYXNlIG1ha2Ugc3VyZSB0aGF0IHlvdSd2ZSBpbnN0YWxsZWQgdGhlIGxhdGVzdCBkcml2ZXJzIGZvciB5b3VyIHRhYmxldCBmcm9tIHRoZSBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxhIGhyZWY9XCJodHRwOi8vd3d3LndhY29tLmNvbS9lbi11cy9zdXBwb3J0L3Byb2R1Y3Qtc3VwcG9ydC9kcml2ZXJzXCIgdGFyZ2V0PVwiX2JsYW5rXCI+V2Fjb20gZHJpdmVycyBwYWdlPC9hPixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gcmVzdGFydCB5b3VyIGJyb3dzZXIuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJjaGlja2VucGFpbnQtbm90LXN1cHBvcnRlZFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgWW91ciBicm93c2VyIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgV2Fjb20gdGFibGV0IHBsdWdpbiwgcGxlYXNlIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IG9uZSBvZiB0aGUgYnJvd3NlcnMgbGlzdGVkIGFib3ZlIGluc3RlYWQuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJjaGlja2VucGFpbnQtc3VwcG9ydGVkIGFsZXJ0IGFsZXJ0LXN1Y2Nlc3NcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFRoZSBXYWNvbSB0YWJsZXQgcGx1Z2luIGlzIGluc3RhbGxlZCBhbmQgd29ya2luZy5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGlja2VucGFpbnQtdGFibGV0LXN1cHBvcnQgY2hpY2tlbnBhaW50LXBvaW50ZXJldmVudHMtc3VwcG9ydFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBCdWlsdC1pbiBzdXBwb3J0IGZvciBtb3N0IHRhYmxldHMgPHNtYWxsPmluY2x1ZGluZyBXYWNvbSB0YWJsZXRzPC9zbWFsbD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9oND5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoaWNrZW5wYWludC1zdXBwb3J0ZWQtYnJvd3NlcnNcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGlja2VucGFpbnQtc3VwcG9ydGVkLWJyb3dzZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhIGZhLWludGVybmV0LWV4cGxvcmVyXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElFIChXaW5kb3dzIDgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY2hpY2tlbnBhaW50LXN1cHBvcnRlZC1icm93c2VyXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJmYSBmYS1lZGdlXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIEVkZ2UgKFdpbmRvd3MgMTApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjaGlja2VucGFpbnQtc3VwcG9ydGVkLWJyb3dzZXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImZhIGZhLWZpcmVmb3hcIj48L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgRmlyZWZveCAoPGEgaHJlZj1cImh0dHBzOi8vZ2l0aHViLmNvbS90aGVuaWNrZHVkZS9jaGlja2VucGFpbnQvYmxvYi9tYXN0ZXIvaGVscC9GaXJlZm94IHByZXNzdXJlIHN1cHBvcnQubWRcIiB0YXJnZXQ9XCJfYmxhbmtcIj5leHBlcmltZW50YWwgPGkgY2xhc3M9XCJnbHlwaGljb24gZ2x5cGhpY29uLW5ldy13aW5kb3dcIj48L2k+PC9hPilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNoaWNrZW5wYWludC1zdXBwb3J0ZWQtYnJvd3NlclwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiZmEgZmEtY2hyb21lXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIENocm9tZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cImNoaWNrZW5wYWludC1ub3Qtc3VwcG9ydGVkXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBZb3VyIGJyb3dzZXIgZG9lc24ndCBoYXZlIGJ1aWx0LWluIHN1cHBvcnQgZm9yIGRyYXdpbmcgdGFibGV0cywgcGxlYXNlIHRyeVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lIG9mIHRoZSBvdGhlciBicm93c2VycyBsaXN0ZWQgYWJvdmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvcD5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJjaGlja2VucGFpbnQtc3VwcG9ydGVkIGFsZXJ0IGFsZXJ0LXN1Y2Nlc3NcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFlvdXIgYnJvd3NlciBoYXMgYnVpbHQtaW4gc3VwcG9ydCBmb3IgZHJhd2luZyB0YWJsZXRzIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3A+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICBgKTtcbiAgICBcbiAgICB2YXJcbiAgICAgICAgd2Fjb21TdXBwb3J0RWxlbSA9ICQoXCIuY2hpY2tlbnBhaW50LXdhY29tLXN1cHBvcnRcIiwgZGlhbG9nKSxcbiAgICAgICAgcGVTdXBwb3J0RWxlbSA9ICQoXCIuY2hpY2tlbnBhaW50LXBvaW50ZXJldmVudHMtc3VwcG9ydFwiLCBkaWFsb2cpLFxuICAgICAgICBib3RoT3B0aW9uc0VsZW0gPSAkKFwiLmNoaWNrZW5wYWludC10YWJsZXQtdGhlcmUtYXJlLXR3by1vcHRpb25zXCIsIGRpYWxvZyksXG4gICAgICAgIFxuICAgICAgICB3YWNvbVByZXNlbnQgPSBDUFdhY29tVGFibGV0LmdldFJlZigpLmlzVGFibGV0UHJlc2VudCgpLFxuICAgICAgICBwZVN1cHBvcnRlZCA9ICEhd2luZG93Lmhhc05hdGl2ZVBvaW50ZXJFdmVudHM7XG4gICAgXG4gICAgd2Fjb21TdXBwb3J0RWxlbS50b2dnbGVDbGFzcyhcInN1cHBvcnRlZFwiLCB3YWNvbVByZXNlbnQpO1xuICAgIFxuICAgIGlmICh3YWNvbVByZXNlbnQpIHtcbiAgICAgICAgLy8gRG9uJ3QgYm90aGVyIGRpc3BsYXlpbmcgaW5mbyBhYm91dCBQb2ludGVyIEV2ZW50cyBpZiB3ZSBoYXZlIHRoZSBXYWNvbSBwbHVnaW4gaW5zdGFsbGVkXG4gICAgICAgIHBlU3VwcG9ydEVsZW0uaGlkZSgpO1xuICAgICAgICBib3RoT3B0aW9uc0VsZW0uaGlkZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIENocm9tZSBoYXMgZHJvcHBlZCBOUEFQSSBzdXBwb3J0LCBzbyB0aGUgV2Fjb20gcGx1Z2luIGNhbm5vdCBiZSBpbnN0YWxsZWRcbiAgICAgICAgaWYgKC9DaHJvbWUvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpICYmICEvT1BSLy50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpXG4gICAgICAgICAgICAgICAgfHwgL2lQYWQvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL2lQaG9uZS8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgd2Fjb21TdXBwb3J0RWxlbS5hZGRDbGFzcyhcIm5vdC1zdXBwb3J0ZWRcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIERvbid0IGJvdGhlciBzaG93aW5nIHRoZSBXYWNvbSBwbHVnaW4gZGV0YWlscyBpZiB0aGlzIGJyb3dzZXIgc3VwcG9ydHMgcG9pbnRlciBldmVudHNcbiAgICAgICAgaWYgKHBlU3VwcG9ydGVkKSB7XG4gICAgICAgICAgICB3YWNvbVN1cHBvcnRFbGVtLmhpZGUoKTtcbiAgICAgICAgICAgIGJvdGhPcHRpb25zRWxlbS5oaWRlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgcGVTdXBwb3J0RWxlbS50b2dnbGVDbGFzcyhcInN1cHBvcnRlZFwiLCBwZVN1cHBvcnRlZCk7XG4gICAgcGVTdXBwb3J0RWxlbS50b2dnbGVDbGFzcyhcIm5vdC1zdXBwb3J0ZWRcIiwgIXBlU3VwcG9ydGVkKTtcblxuICAgIGRpYWxvZy5tb2RhbCh7XG4gICAgICAgIHNob3c6IGZhbHNlXG4gICAgfSk7XG4gICAgXG4gICAgLy8gRml4IHRoZSBiYWNrZHJvcCBsb2NhdGlvbiBpbiB0aGUgRE9NIGJ5IHJlcGFyZW50aW5nIGl0IHRvIHRoZSBjaGlja2VucGFpbnQgY29udGFpbmVyXG4gICAgZGlhbG9nLmRhdGEoXCJicy5tb2RhbFwiKS4kYm9keSA9ICQocGFyZW50KTtcbiAgICBcbiAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoZGlhbG9nWzBdKTtcblxuICAgIHRoaXMuc2hvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBkaWFsb2cubW9kYWwoXCJzaG93XCIpO1xuICAgIH07XG59IiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBDUEdyZXlCbXAgZnJvbSAnLi4vZW5naW5lL0NQR3JleUJtcCc7XG5pbXBvcnQgQ1BMb29rVXBUYWJsZSBmcm9tICcuLi9lbmdpbmUvQ1BMb29rVXBUYWJsZSc7XG5cbmltcG9ydCBDUFBhbGV0dGUgZnJvbSAnLi9DUFBhbGV0dGUnO1xuaW1wb3J0IENQU2xpZGVyIGZyb20gJy4vQ1BTbGlkZXInO1xuXG5mdW5jdGlvbiB3cmFwQ2hlY2tib3hXaXRoTGFiZWwoY2hlY2tib3gsIHRpdGxlKSB7XG4gICAgdmFyXG4gICAgICAgIGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiksXG4gICAgICAgIGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxhYmVsXCIpO1xuXG4gICAgZGl2LmNsYXNzTmFtZSA9IFwiY2hlY2tib3hcIjtcbiAgICBcbiAgICBsYWJlbC5hcHBlbmRDaGlsZChjaGVja2JveCk7XG4gICAgbGFiZWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodGl0bGUpKTtcbiAgICBcbiAgICBkaXYuYXBwZW5kQ2hpbGQobGFiZWwpO1xuICAgIFxuICAgIHJldHVybiBkaXY7XG59XG5cbmZ1bmN0aW9uIGxvYWRUZXh0dXJlcyh0ZXh0dXJlRmlsZW5hbWUsIHdpZHRoLCBoZWlnaHQsIHRleHR1cmVDb3VudCwgdGhlbikge1xuICAgIHZhclxuICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKSxcbiAgICAgICAgdGV4dHVyZXMgPSBbXTtcbiAgICBcbiAgICBpbWcub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKSxcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgICBcbiAgICAgICAgY2FudmFzLndpZHRoID0gaW1nLndpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaW1nLmhlaWdodDtcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dHVyZUNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKGltZywgMCwgaSAqIGhlaWdodCwgd2lkdGgsIGhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGltYWdlRGF0YSA9IGNhbnZhc0NvbnRleHQuZ2V0SW1hZ2VEYXRhKDAsIDAsIHdpZHRoLCBoZWlnaHQpLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlID0gbmV3IENQR3JleUJtcCh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBUYWtlIGp1c3QgdGhlIHJlZCBjaGFubmVsIGZyb20gdGhlIGltYWdlIHRvIGZvcm0gdGhlIG5ldyBncmF5c2NhbGUgdGV4dHVyZVxuICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgd2lkdGggKiBoZWlnaHQ7IGorKykge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0dXJlLmRhdGFbal0gPSBpbWFnZURhdGEuZGF0YVtqICogNF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRleHR1cmVzLnB1c2godGV4dHVyZSk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgLy8gUXVpZXRseSBpZ25vcmUgZXJyb3JzIHRoYXQgb2NjdXIgd2hpbGUgbG9hZGluZyB0aGUgaW1hZ2UgKGUuZy4gY3Jvc3Mtb3JpZ2luIHNlY3VyaXR5IGZhaWx1cmVzKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGVuKHRleHR1cmVzKTtcbiAgICB9O1xuICAgIFxuICAgIGltZy5zcmMgPSB0ZXh0dXJlRmlsZW5hbWU7XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIENQVGV4dHVyZVBhbGV0dGUoY29udHJvbGxlcikge1xuICAgIENQUGFsZXR0ZS5jYWxsKHRoaXMsIGNvbnRyb2xsZXIsIFwidGV4dHVyZXNcIiwgXCJUZXh0dXJlc1wiKTtcbiAgICBcbiAgICB2YXJcbiAgICAgICAgVEVYVFVSRV9QUkVWSUVXX1NJWkUgPSA2NCxcbiAgICAgICAgVEVYVFVSRV9TV0FUQ0hfQlVUVE9OX1NJWkUgPSAzMixcbiAgICBcbiAgICAgICAgdGV4dHVyZXMgPSBbXSwgLy8gQXJyYXkgb2YgQ1BHcmV5Qm1wXG4gICAgICAgIHNlbGVjdGVkVGV4dHVyZSwgcHJvY2Vzc2VkVGV4dHVyZSwgLy9Cb3RoIENQR3JleUJtcFxuXG4gICAgICAgIG1pcnJvciA9IGZhbHNlLCBpbnZlcnNlID0gZmFsc2UsXG4gICAgICAgIFxuICAgICAgICBicmlnaHRuZXNzID0gMC4wLCBjb250cmFzdCA9IDAuMCxcbiAgICAgICAgb3B0aW9uc1BhbmVsLFxuICAgICAgICB0ZXh0dXJlc1BhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKSxcbiAgICAgICAgXG4gICAgICAgIGJvZHkgPSB0aGlzLmdldEJvZHlFbGVtZW50KCk7XG5cbiAgICAvKipcbiAgICAgKiBBZGQgYW4gYXJyYXkgb2YgdGV4dHVyZXMgdG8gdGhlIGdsb2JhbCB0ZXh0dXJlIGxpc3QsIGFuZCBhZGQgc3dhdGNoZXMgZm9yIHRoZW0gdG8gdGhlIFVJLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFkZFRleHR1cmVzKG5ld1RleHR1cmVzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmV3VGV4dHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHRleHR1cmUgPSBuZXdUZXh0dXJlc1tpXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGV4dHVyZXMucHVzaCh0ZXh0dXJlKTtcbiAgICBcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIGJ1dHRvbiA9IG5ldyBDUFRleHR1cmVTd2F0Y2godGV4dHVyZSwgVEVYVFVSRV9TV0FUQ0hfQlVUVE9OX1NJWkUsIFRFWFRVUkVfU1dBVENIX0JVVFRPTl9TSVpFKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgYnV0dG9uLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0ZWRUZXh0dXJlID0gdGhpcy50ZXh0dXJlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGVkVGV4dHVyZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRleHR1cmVzUGFuZWwuYXBwZW5kQ2hpbGQoYnV0dG9uLmdldEVsZW1lbnQoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgXG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgYW5kIHJldHVybiBhbiBhcnJheSBvZiBwcm9jZWR1cmFsbHktZ2VuZXJhdGVkIHRleHR1cmVzXG4gICAgICogXG4gICAgICogQHJldHVybnMgQ1BHcmV5Qm1wW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlUHJvY2VkdXJhbFRleHR1cmVzKCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHJlc3VsdCA9IFtudWxsXTtcbiAgICAgICAgXG4gICAgICAgIHZhclxuICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyBDUEdyZXlCbXAoMiwgMik7XG4gICAgICAgIHRleHR1cmUuZGF0YVswXSA9IDB4RkY7XG4gICAgICAgIHRleHR1cmUuZGF0YVszXSA9IDB4RkY7XG4gICAgICAgIHJlc3VsdC5wdXNoKHRleHR1cmUpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKG1ha2VEb3RUZXh0dXJlKDIpKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobWFrZURvdFRleHR1cmUoMykpO1xuICAgICAgICByZXN1bHQucHVzaChtYWtlRG90VGV4dHVyZSg0KSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ha2VEb3RUZXh0dXJlKDYpKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobWFrZURvdFRleHR1cmUoOCkpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKG1ha2VWZXJ0TGluZXNUZXh0dXJlKDEsIDIpKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobWFrZVZlcnRMaW5lc1RleHR1cmUoMiwgNCkpO1xuXG4gICAgICAgIHJlc3VsdC5wdXNoKG1ha2VIb3JpekxpbmVzVGV4dHVyZSgxLCAyKSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ha2VIb3JpekxpbmVzVGV4dHVyZSgyLCA0KSk7XG5cbiAgICAgICAgcmVzdWx0LnB1c2gobWFrZUNoZWNrZXJCb2FyZFRleHR1cmUoMikpO1xuICAgICAgICByZXN1bHQucHVzaChtYWtlQ2hlY2tlckJvYXJkVGV4dHVyZSg0KSk7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1ha2VDaGVja2VyQm9hcmRUZXh0dXJlKDgpKTtcbiAgICAgICAgcmVzdWx0LnB1c2gobWFrZUNoZWNrZXJCb2FyZFRleHR1cmUoMTYpKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNpemUgaW50XG4gICAgICogXG4gICAgICogQHJldHVybnMgQ1BHcmV5Qm1wXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFrZURvdFRleHR1cmUoc2l6ZSkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgQ1BHcmV5Qm1wKHNpemUsIHNpemUpO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBzaXplICogc2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICB0ZXh0dXJlLmRhdGFbaV0gPSAweEZGO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIE1ha2UgYSBjaGVja2VyYm9hcmQgdGV4dHVyZSBvZiB0aGUgZ2l2ZW4gZGltZW5zaW9ucy5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0gc2l6ZSBpbnRcbiAgICAgKiBcbiAgICAgKiBAcmV0dXJucyBDUEdyZXlCbXBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYWtlQ2hlY2tlckJvYXJkVGV4dHVyZShzaXplKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgdGV4dHVyZVNpemUgPSAyICogc2l6ZSxcbiAgICAgICAgICAgIHRleHR1cmUgPSBuZXcgQ1BHcmV5Qm1wKHRleHR1cmVTaXplLCB0ZXh0dXJlU2l6ZSk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRleHR1cmVTaXplOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGV4dHVyZVNpemU7IGorKykge1xuICAgICAgICAgICAgICAgIHRleHR1cmUuZGF0YVtpICsgaiAqIHRleHR1cmVTaXplXSA9ICgofn4oaSAvIHNpemUpICsgfn4oaiAvIHNpemUpKSAlIDIgPT0gMCkgPyAwIDogMHhGRjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHRleHR1cmU7XG4gICAgfVxuXG4gICAgIC8qKlxuICAgICAgKiBNYWtlIGEgdGV4dHVyZSBjb25zaXN0aW5nIG9mIGEgc2VyaWVzIG9mIGV2ZW5seS1zcGFjZWQgdmVydGljYWwgbGluZXNcbiAgICAgICogXG4gICAgICAqIEBwYXJhbSBsaW5lU2l6ZSBpbnRcbiAgICAgICogQHBhcmFtIHNpemUgaW50XG4gICAgICAqIFxuICAgICAgKiBAcmV0dXJucyBDUEdyZXlCbXBcbiAgICAgICovXG4gICAgIGZ1bmN0aW9uIG1ha2VWZXJ0TGluZXNUZXh0dXJlKGxpbmVTaXplLCBzaXplKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyBDUEdyZXlCbXAoc2l6ZSwgc2l6ZSk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemUgKiBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIGlmICh+fihpICUgc2l6ZSkgPj0gbGluZVNpemUpIHtcbiAgICAgICAgICAgICAgICB0ZXh0dXJlLmRhdGFbaV0gPSAweEZGO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdGV4dHVyZTtcbiAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIE1ha2UgYSB0ZXh0dXJlIGNvbnNpc3Rpbmcgb2YgYSBzZXJpZXMgb2YgZXZlbmx5LXNwYWNlZCBob3Jpem9udGFsIGxpbmVzXG4gICAgICAqXG4gICAgICAqIEBwYXJhbSBsaW5lU2l6ZSBpbnRcbiAgICAgICogQHBhcmFtIHNpemUgaW50XG4gICAgICAqIFxuICAgICAgKiBAcmV0dXJucyBDUEdyZXlCbXBcbiAgICAgICovXG4gICAgZnVuY3Rpb24gbWFrZUhvcml6TGluZXNUZXh0dXJlKGxpbmVTaXplLCBzaXplKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgdGV4dHVyZSA9IG5ldyBDUEdyZXlCbXAoc2l6ZSwgc2l6ZSk7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemUgKiBzaXplOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpIC8gc2l6ZSA+PSBsaW5lU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRleHR1cmUuZGF0YVtpXSA9IDB4RkY7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB0ZXh0dXJlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHVwZGF0ZVNlbGVjdGVkVGV4dHVyZSgpIHtcbiAgICAgICAgaWYgKHNlbGVjdGVkVGV4dHVyZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRUZXh0dXJlID0gc2VsZWN0ZWRUZXh0dXJlLmNsb25lKCk7XG5cbiAgICAgICAgICAgIGlmIChtaXJyb3IpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzZWRUZXh0dXJlLm1pcnJvckhvcml6b250YWxseSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICBsdXQgPSBuZXcgQ1BMb29rVXBUYWJsZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBsdXQubG9hZEJyaWdodG5lc3NDb250cmFzdChicmlnaHRuZXNzLCBjb250cmFzdCk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChpbnZlcnNlKSB7XG4gICAgICAgICAgICAgICAgbHV0LmludmVydCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwcm9jZXNzZWRUZXh0dXJlLmFwcGx5TFVUKGx1dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm9jZXNzZWRUZXh0dXJlID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRyb2xsZXIuZ2V0QXJ0d29yaygpLnNldEJydXNoVGV4dHVyZShwcm9jZXNzZWRUZXh0dXJlKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChvcHRpb25zUGFuZWwgIT0gbnVsbCkge1xuICAgICAgICAgICAgb3B0aW9uc1BhbmVsLnVwZGF0ZVRleHR1cmUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBcbiAgICBmdW5jdGlvbiBDUFRleHR1cmVPcHRpb25zUGFuZWwoKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgcGFuZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpLFxuICAgICAgICBcbiAgICAgICAgICAgIGNiSW52ZXJzZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKSxcbiAgICAgICAgICAgIGNiTWlycm9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpLFxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzbEJyaWdodG5lc3MgPSBuZXcgQ1BTbGlkZXIoMCwgMjAwLCB0cnVlKSxcbiAgICAgICAgICAgIHNsQ29udHJhc3QgPSBuZXcgQ1BTbGlkZXIoMCwgMjAwLCB0cnVlKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2FtcGxlU3dhdGNoID0gbmV3IENQVGV4dHVyZVN3YXRjaChudWxsLCBURVhUVVJFX1BSRVZJRVdfU0laRSwgVEVYVFVSRV9QUkVWSUVXX1NJWkUpLFxuICAgICAgICAgICAgYnRuQ3VzdG9taXplID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGV4dHVyZUNvbnRyb2xzUGFuZWw7XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiB1cGRhdGVQb3BvdmVyQ29udHJvbHMoKSB7XG4gICAgICAgICAgICBjYkludmVyc2UuY2hlY2tlZCA9IGludmVyc2U7XG4gICAgICAgICAgICBjYk1pcnJvci5jaGVja2VkID0gbWlycm9yO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBzbEJyaWdodG5lc3Muc2V0VmFsdWUoYnJpZ2h0bmVzcyAqIDEwMCArIDEwMCk7XG4gICAgICAgICAgICBzbENvbnRyYXN0LnNldFZhbHVlKGNvbnRyYXN0ICogMTAwICsgMTAwKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gYnVpbGRUZXh0dXJlQ29udHJvbHNQYW5lbCgpIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHBhbmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcblxuICAgICAgICAgICAgY2JJbnZlcnNlLnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgICAgICBjYkludmVyc2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICBpbnZlcnNlID0gdGhpcy5jaGVja2VkO1xuICAgICAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGVkVGV4dHVyZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhbmVsLmFwcGVuZENoaWxkKHdyYXBDaGVja2JveFdpdGhMYWJlbChjYkludmVyc2UsIFwiSW52ZXJzZVwiKSk7XG5cbiAgICAgICAgICAgIGNiTWlycm9yLnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgICAgICAgICBjYk1pcnJvci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgICAgIG1pcnJvciA9IHRoaXMuY2hlY2tlZDtcbiAgICAgICAgICAgICAgICB1cGRhdGVTZWxlY3RlZFRleHR1cmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW5lbC5hcHBlbmRDaGlsZCh3cmFwQ2hlY2tib3hXaXRoTGFiZWwoY2JNaXJyb3IsIFwiTWlycm9yXCIpKTtcblxuICAgICAgICAgICAgc2xCcmlnaHRuZXNzLnRpdGxlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJCcmlnaHRuZXNzOiBcIiArICh2YWx1ZSAtIDEwMCkgKyBcIiVcIjtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHNsQnJpZ2h0bmVzcy5vbihcInZhbHVlQ2hhbmdlXCIsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgYnJpZ2h0bmVzcyA9ICh2YWx1ZSAtIDEwMCkgLyAxMDAuMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB1cGRhdGVTZWxlY3RlZFRleHR1cmUoKTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBwYW5lbC5hcHBlbmRDaGlsZChzbEJyaWdodG5lc3MuZ2V0RWxlbWVudCgpKTtcblxuICAgICAgICAgICAgc2xDb250cmFzdC50aXRsZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiQ29udHJhc3Q6IFwiICsgKHZhbHVlIC0gMTAwKSArIFwiJVwiO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgc2xDb250cmFzdC5vbihcInZhbHVlQ2hhbmdlXCIsIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY29udHJhc3QgPSAodmFsdWUgLSAxMDApIC8gMTAwO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHVwZGF0ZVNlbGVjdGVkVGV4dHVyZSgpO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHBhbmVsLmFwcGVuZENoaWxkKHNsQ29udHJhc3QuZ2V0RWxlbWVudCgpKTtcblxuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgb2theUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIiksXG4gICAgICAgICAgICAgICAgcmVzZXRCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBva2F5QnV0dG9uLmlubmVySFRNTCA9IFwiT2tcIjtcbiAgICAgICAgICAgIG9rYXlCdXR0b24uY2xhc3NOYW1lID0gXCJidG4gYnRuLXByaW1hcnkgYnRuLXNtXCI7XG4gICAgICAgICAgICBva2F5QnV0dG9uLnR5cGUgPSBcImJ1dHRvblwiO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBva2F5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgJChidG5DdXN0b21pemUpLnBvcG92ZXIoJ2hpZGUnKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW5lbC5hcHBlbmRDaGlsZChva2F5QnV0dG9uKTtcbiAgICAgICAgICAgIHBhbmVsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKFwiIFwiKSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJlc2V0QnV0dG9uLmlubmVySFRNTCA9IFwiUmVzZXRcIjtcbiAgICAgICAgICAgIHJlc2V0QnV0dG9uLmNsYXNzTmFtZSA9IFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbVwiO1xuICAgICAgICAgICAgcmVzZXRCdXR0b24udHlwZSA9IFwiYnV0dG9uXCI7XG5cbiAgICAgICAgICAgIHJlc2V0QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgYnJpZ2h0bmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgY29udHJhc3QgPSAwO1xuICAgICAgICAgICAgICAgIG1pcnJvciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGludmVyc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB1cGRhdGVQb3BvdmVyQ29udHJvbHMoKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVTZWxlY3RlZFRleHR1cmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYW5lbC5hcHBlbmRDaGlsZChyZXNldEJ1dHRvbik7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHVwZGF0ZVBvcG92ZXJDb250cm9scygpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICByZXR1cm4gcGFuZWw7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIFRPRE8gdXNlIGV2ZW50cyBpbnN0ZWFkXG4gICAgICAgIHRoaXMudXBkYXRlVGV4dHVyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgYnRuQ3VzdG9taXplLmRpc2FibGVkID0gKHByb2Nlc3NlZFRleHR1cmUgPT0gbnVsbCk7XG4gICAgICAgICAgICBzYW1wbGVTd2F0Y2guc2V0VGV4dHVyZShwcm9jZXNzZWRUZXh0dXJlKTtcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuZ2V0RWxlbWVudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgcmV0dXJuIHBhbmVsO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFuZWwuY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtdGV4dHVyZS1vcHRpb25zXCI7XG4gICAgICAgIHBhbmVsLmFwcGVuZENoaWxkKHNhbXBsZVN3YXRjaC5nZXRFbGVtZW50KCkpO1xuXG4gICAgICAgIGJ0bkN1c3RvbWl6ZS50eXBlID0gXCJidXR0b25cIjtcbiAgICAgICAgYnRuQ3VzdG9taXplLmNsYXNzTmFtZSA9IFwiYnRuIGJ0bi1kZWZhdWx0IGJ0bi1zbVwiO1xuICAgICAgICBidG5DdXN0b21pemUuaW5uZXJIVE1MID0gXCJDdXN0b21pemVcIjtcblxuICAgICAgICB0ZXh0dXJlQ29udHJvbHNQYW5lbCA9IGJ1aWxkVGV4dHVyZUNvbnRyb2xzUGFuZWwoKTtcbiAgICAgICAgXG4gICAgICAgICQoYnRuQ3VzdG9taXplKVxuICAgICAgICAgICAgLnBvcG92ZXIoe1xuICAgICAgICAgICAgICAgIGh0bWw6IHRydWUsXG4gICAgICAgICAgICAgICAgY29udGVudDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0ZXh0dXJlQ29udHJvbHNQYW5lbDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHRyaWdnZXI6IFwibWFudWFsXCJcbiAgICAgICAgICAgIH0pLlxuICAgICAgICAgICAgb24oXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAkKHRoaXMpLnBvcG92ZXIoXCJ0b2dnbGVcIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIHBhbmVsLmFwcGVuZENoaWxkKGJ0bkN1c3RvbWl6ZSk7XG4gICAgICAgIFxuICAgICAgICB0aGlzLnVwZGF0ZVRleHR1cmUoKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBDUFRleHR1cmVTd2F0Y2godGV4dHVyZSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIiksXG4gICAgICAgICAgICBjYW52YXNDb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKSxcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlID0gZnVuY3Rpb24odGV4dHVyZSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0dXJlID0gdGV4dHVyZTtcblxuICAgICAgICAgICAgdGhpcy5wYWludCgpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5nZXRFbGVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5wYWludCA9IGZ1bmN0aW9uKCkgIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnRleHR1cmUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gY2FudmFzQ29udGV4dC5jcmVhdGVQYXR0ZXJuKHRoaXMudGV4dHVyZS50b0NhbnZhcygpLCBcInJlcGVhdFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSAnd2hpdGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FudmFzQ29udGV4dC5maWxsUmVjdCgwLCAwLCBjYW52YXMud2lkdGgsIGNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHRoYXQuZW1pdChcImNsaWNrXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgXG4gICAgICAgIGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICBcbiAgICAgICAgdGhpcy5zZXRUZXh0dXJlKHRleHR1cmUpO1xuICAgIH1cbiAgICBcbiAgICBDUFRleHR1cmVTd2F0Y2gucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShFdmVudEVtaXR0ZXIucHJvdG90eXBlKTtcbiAgICBDUFRleHR1cmVTd2F0Y2gucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BUZXh0dXJlU3dhdGNoO1xuICAgIFxuICAgIG9wdGlvbnNQYW5lbCA9IG5ldyBDUFRleHR1cmVPcHRpb25zUGFuZWwoKVxuICAgIFxuICAgIGJvZHkuYXBwZW5kQ2hpbGQob3B0aW9uc1BhbmVsLmdldEVsZW1lbnQoKSk7XG5cbiAgICB0ZXh0dXJlc1BhbmVsLmNsYXNzTmFtZSA9ICdjaGlja2VucGFpbnQtdGV4dHVyZS1zd2F0Y2hlcyc7XG5cbiAgICBib2R5LmFwcGVuZENoaWxkKHRleHR1cmVzUGFuZWwpO1xuICAgIFxuICAgIGFkZFRleHR1cmVzKG1ha2VQcm9jZWR1cmFsVGV4dHVyZXMoKSk7XG4gICAgXG4gICAgbG9hZFRleHR1cmVzKGNvbnRyb2xsZXIuZ2V0UmVzb3VyY2VzUm9vdCgpICsgXCJnZngvdGV4dHVyZXMzMi5wbmdcIiwgMzIsIDMyLCAyLCBmdW5jdGlvbihsb2FkZWRUZXh0dXJlcykge1xuICAgICAgICBhZGRUZXh0dXJlcyhsb2FkZWRUZXh0dXJlcyk7XG4gICAgfSk7XG59XG5cbkNQVGV4dHVyZVBhbGV0dGUucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShDUFBhbGV0dGUucHJvdG90eXBlKTtcbkNQVGV4dHVyZVBhbGV0dGUucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gQ1BUZXh0dXJlUGFsZXR0ZTtcbiIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5pbXBvcnQgQ1BQYWxldHRlIGZyb20gJy4vQ1BQYWxldHRlJztcbmltcG9ydCBDaGlja2VuUGFpbnQgZnJvbSAnLi4vQ2hpY2tlblBhaW50JztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BUb29sUGFsZXR0ZShjcENvbnRyb2xsZXIpIHtcbiAgICBDUFBhbGV0dGUuY2FsbCh0aGlzLCBjcENvbnRyb2xsZXIsIFwidG9vbFwiLCBcIlRvb2xzXCIpO1xuICAgIFxuICAgIHZhciBcbiAgICAgICAgdGhhdCA9IHRoaXMsXG5cbiAgICAgICAgYnV0dG9ucyA9IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiY2hpY2tlbnBhaW50LXRvb2wtcmVjdC1zZWxlY3Rpb25cIixcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBcIkNQUmVjdFNlbGVjdGlvblwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiTWFycXVlZVwiLFxuICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcIm1cIixcbiAgICAgICAgICAgICAgICBtb2RlOiBDaGlja2VuUGFpbnQuTV9SRUNUX1NFTEVDVElPTlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiY2hpY2tlbnBhaW50LXRvb2wtbW92ZVwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BNb3ZlVG9vbFwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiTW92ZSB0b29sXCIsXG4gICAgICAgICAgICAgICAgc2hvcnRjdXQ6IFwidlwiLFxuICAgICAgICAgICAgICAgIG1vZGU6IENoaWNrZW5QYWludC5NX01PVkVfVE9PTFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiY2hpY2tlbnBhaW50LXRvb2wtZmxvb2QtZmlsbFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BGbG9vZEZpbGxcIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIkZsb29kIGZpbGxcIixcbiAgICAgICAgICAgICAgICBzaG9ydGN1dDogXCJmXCIsXG4gICAgICAgICAgICAgICAgbW9kZTogQ2hpY2tlblBhaW50Lk1fRkxPT0RGSUxMXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGlja2VucGFpbnQtdG9vbC1ncmFkaWVudC1maWxsXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogXCJDUEdyYWRpZW50RmlsbFwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiR3JhZGllbnQgZmlsbFwiLFxuICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcImdcIixcbiAgICAgICAgICAgICAgICBtb2RlOiBDaGlja2VuUGFpbnQuTV9HUkFESUVOVEZJTExcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLWNvbG9yLXBpY2tlclwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BDb2xvclBpY2tlclwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiQ29sb3IgcGlja2VyXCIsXG4gICAgICAgICAgICAgICAgc2hvcnRjdXQ6IFwiaVwiLFxuICAgICAgICAgICAgICAgIG1vZGU6IENoaWNrZW5QYWludC5NX0NPTE9SX1BJQ0tFUlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiY2hpY2tlbnBhaW50LXRvb2wtcm90YXRlLWNhbnZhc1wiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BSb3RhdGVDYW52YXNcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kRG91YmxlQ2xpY2s6IFwiQ1BSZXNldENhbnZhc1JvdGF0aW9uXCIsXG4gICAgICAgICAgICAgICAgdG9vbFRpcDogXCJSb3RhdGUgY2FudmFzXCIsXG4gICAgICAgICAgICAgICAgbW9kZTogQ2hpY2tlblBhaW50Lk1fUk9UQVRFX0NBTlZBU1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiY2hpY2tlbnBhaW50LXRvb2wtcGVuY2lsXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogXCJDUFBlbmNpbFwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiUGVuY2lsXCIsXG4gICAgICAgICAgICAgICAgbW9kZTogQ2hpY2tlblBhaW50Lk1fRFJBVyxcbiAgICAgICAgICAgICAgICB0b29sOiBDaGlja2VuUGFpbnQuVF9QRU5DSUxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLXBlblwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BQZW5cIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIlBlblwiLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkOiB0cnVlLCAvLyBUT0RPIGEgYmV0dGVyIG1lY2hhbmlzbSBmb3IgdGhlIGNvbnRyb2xsZXIgdG8gbGV0IHVzIGtub3cgdGhlIGluaXRpYWwgdG9vbFxuICAgICAgICAgICAgICAgIG1vZGU6IENoaWNrZW5QYWludC5NX0RSQVcsXG4gICAgICAgICAgICAgICAgdG9vbDogQ2hpY2tlblBhaW50LlRfUEVOXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGlja2VucGFpbnQtdG9vbC1haXJicnVzaFwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BBaXJicnVzaFwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiQWlyYnJ1c2hcIixcbiAgICAgICAgICAgICAgICBtb2RlOiBDaGlja2VuUGFpbnQuTV9EUkFXLFxuICAgICAgICAgICAgICAgIHRvb2w6IENoaWNrZW5QYWludC5UX0FJUkJSVVNIXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGlja2VucGFpbnQtdG9vbC13YXRlclwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BXYXRlclwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiV2F0ZXJwYWludFwiLFxuICAgICAgICAgICAgICAgIG1vZGU6IENoaWNrZW5QYWludC5NX0RSQVcsXG4gICAgICAgICAgICAgICAgdG9vbDogQ2hpY2tlblBhaW50LlRfV0FURVJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLWVyYXNlclwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BFcmFzZXJcIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIkVyYXNlclwiLFxuICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcImVcIixcbiAgICAgICAgICAgICAgICBtb2RlOiBDaGlja2VuUGFpbnQuTV9EUkFXLFxuICAgICAgICAgICAgICAgIHRvb2w6IENoaWNrZW5QYWludC5UX0VSQVNFUlxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwiY2hpY2tlbnBhaW50LXRvb2wtc29mdC1lcmFzZXJcIixcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBcIkNQU29mdEVyYXNlclwiLFxuICAgICAgICAgICAgICAgIHRvb2xUaXA6IFwiU29mdCBlcmFzZXJcIixcbiAgICAgICAgICAgICAgICBtb2RlOiBDaGlja2VuUGFpbnQuTV9EUkFXLFxuICAgICAgICAgICAgICAgIHRvb2w6IENoaWNrZW5QYWludC5UX1NPRlRFUkFTRVJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLXNtdWRnZVwiLFxuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IFwiQ1BTbXVkZ2VcIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIlNtdWRnZVwiLFxuICAgICAgICAgICAgICAgIG1vZGU6IENoaWNrZW5QYWludC5NX0RSQVcsXG4gICAgICAgICAgICAgICAgdG9vbDogQ2hpY2tlblBhaW50LlRfU01VREdFXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGlja2VucGFpbnQtdG9vbC1ibGVuZGVyXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogXCJDUEJsZW5kZXJcIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIkJsZW5kZXJcIixcbiAgICAgICAgICAgICAgICBtb2RlOiBDaGlja2VuUGFpbnQuTV9EUkFXLFxuICAgICAgICAgICAgICAgIHRvb2w6IENoaWNrZW5QYWludC5UX0JMRU5ERVJcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImNoaWNrZW5wYWludC10b29sLWRvZGdlXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogXCJDUERvZGdlXCIsXG4gICAgICAgICAgICAgICAgdG9vbFRpcDogXCJEb2RnZVwiLFxuICAgICAgICAgICAgICAgIHNob3J0Y3V0OiBcIm9cIixcbiAgICAgICAgICAgICAgICBtb2RlOiBDaGlja2VuUGFpbnQuTV9EUkFXLFxuICAgICAgICAgICAgICAgIHRvb2w6IENoaWNrZW5QYWludC5UX0RPREdFXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGlja2VucGFpbnQtdG9vbC1idXJuXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogXCJDUEJ1cm5cIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIkJ1cm5cIixcbiAgICAgICAgICAgICAgICBzaG9ydGN1dDogXCJwXCIsXG4gICAgICAgICAgICAgICAgbW9kZTogQ2hpY2tlblBhaW50Lk1fRFJBVyxcbiAgICAgICAgICAgICAgICB0b29sOiBDaGlja2VuUGFpbnQuVF9CVVJOXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogXCJjaGlja2VucGFpbnQtdG9vbC1ibHVyXCIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogXCJDUEJsdXJcIixcbiAgICAgICAgICAgICAgICB0b29sVGlwOiBcIkJsdXJcIixcbiAgICAgICAgICAgICAgICBtb2RlOiBDaGlja2VuUGFpbnQuTV9EUkFXLFxuICAgICAgICAgICAgICAgIHRvb2w6IENoaWNrZW5QYWludC5UX0JMVVJcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgbGlzdEVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidWxcIik7XG4gICAgXG4gICAgZnVuY3Rpb24gYnV0dG9uQ2xpY2tlZChlKSB7XG4gICAgICAgIGlmICh0aGlzLm5vZGVOYW1lID09IFwiTElcIikge1xuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uc1twYXJzZUludCh0aGlzLmdldEF0dHJpYnV0ZShcImRhdGEtYnV0dG9uSW5kZXhcIiksIDEwKV07XG5cbiAgICAgICAgICAgIGNwQ29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogYnV0dG9uLmNvbW1hbmR9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJ1aWxkQnV0dG9ucygpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBib2R5ID0gdGhhdC5nZXRCb2R5RWxlbWVudCgpO1xuICAgICAgICBcbiAgICAgICAgbGlzdEVsZW0uY2xhc3NOYW1lID0gXCJjaGlja2VucGFpbnQtdG9vbHMgbGlzdC11bnN0eWxlZFwiO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSBpbiBidXR0b25zKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24oaSkge1xuICAgICAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uID0gYnV0dG9uc1tpXSxcbiAgICAgICAgICAgICAgICAgICAgYnV0dG9uRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJsaVwiKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBidXR0b25FbGVtLmNsYXNzTmFtZSA9IFwiY2hpY2tlbnBhaW50LXRvb2xiYXItYnV0dG9uIFwiICsgYnV0dG9uLmNsYXNzTmFtZTtcbiAgICAgICAgICAgICAgICBidXR0b25FbGVtLnNldEF0dHJpYnV0ZShcImRhdGEtYnV0dG9uSW5kZXhcIiwgaSk7XG5cbiAgICAgICAgICAgICAgICBidXR0b25FbGVtLnNldEF0dHJpYnV0ZSgnZGF0YS1tb2RlJywgYnV0dG9uLm1vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChidXR0b24udG9vbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsZW0uc2V0QXR0cmlidXRlKCdkYXRhLXRvb2wnLCBidXR0b24udG9vbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGJ1dHRvbkVsZW0udGl0bGUgPSBidXR0b24udG9vbFRpcDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uLnNob3J0Y3V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsZW0udGl0bGUgKz0gXCIgKFwiICsgYnV0dG9uLnNob3J0Y3V0LnRvVXBwZXJDYXNlKCkgKyBcIilcIjtcbiAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgIGtleShidXR0b24uc2hvcnRjdXQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uQ2xpY2tlZC5jYWxsKGJ1dHRvbkVsZW0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAoYnV0dG9uLnNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbkVsZW0uY2xhc3NOYW1lID0gYnV0dG9uRWxlbS5jbGFzc05hbWUgKyBcIiBzZWxlY3RlZFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBsaXN0RWxlbS5hcHBlbmRDaGlsZChidXR0b25FbGVtKTtcbiAgICAgICAgICAgIH0pKGkpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICAkKGxpc3RFbGVtKS5vbihcImNsaWNrXCIsIFwibGlcIiwgYnV0dG9uQ2xpY2tlZCk7XG4gICAgICAgIFxuICAgICAgICBsaXN0RWxlbS5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMubm9kZU5hbWUgPT0gXCJMSVwiKSB7XG4gICAgICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgICAgIGJ1dHRvbiA9IGJ1dHRvbnNbcGFyc2VJbnQodGhpcy5nZXRBdHRyaWJ1dGUoXCJkYXRhLWJ1dHRvbkluZGV4XCIpLCAxMCldO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGlmIChidXR0b24uY29tbWFuZERvdWJsZUNsaWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNwQ29udHJvbGxlci5hY3Rpb25QZXJmb3JtZWQoe2FjdGlvbjogYnV0dG9uLmNvbW1hbmREb3VibGVDbGlja30pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIFxuICAgICAgICBib2R5LmFwcGVuZENoaWxkKGxpc3RFbGVtKTtcbiAgICB9XG5cbiAgICBjcENvbnRyb2xsZXIub24oXCJtb2RlQ2hhbmdlXCIsIGZ1bmN0aW9uKG5ld01vZGUpIHtcbiAgICAgICAgdmFyXG4gICAgICAgICAgICBib2R5ID0gdGhhdC5nZXRCb2R5RWxlbWVudCgpO1xuXG4gICAgICAgICQoXCJsaVwiLCBib2R5KS5yZW1vdmVDbGFzcyhcInNlbGVjdGVkXCIpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG5ld01vZGUgPT0gQ2hpY2tlblBhaW50Lk1fRFJBVykge1xuICAgICAgICAgICAgJChcImxpW2RhdGEtdG9vbD1cIiArIGNwQ29udHJvbGxlci5nZXRDdXJUb29sKCkgKyBcIl1cIiwgYm9keSkuYWRkQ2xhc3MoXCJzZWxlY3RlZFwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICQoXCJsaVtkYXRhLW1vZGU9XCIgKyBuZXdNb2RlICsgXCJdXCIsIGJvZHkpLmFkZENsYXNzKFwic2VsZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIGNwQ29udHJvbGxlci5vbihcInRvb2xDaGFuZ2VcIiwgZnVuY3Rpb24obmV3VG9vbCkge1xuICAgICAgICB2YXJcbiAgICAgICAgICAgIGJvZHkgPSB0aGF0LmdldEJvZHlFbGVtZW50KCk7XG5cbiAgICAgICAgaWYgKGNwQ29udHJvbGxlci5nZXRDdXJNb2RlKCkgPT0gQ2hpY2tlblBhaW50Lk1fRFJBVykge1xuICAgICAgICAgICAgJChcImxpXCIsIGJvZHkpLnJlbW92ZUNsYXNzKFwic2VsZWN0ZWRcIik7XG5cbiAgICAgICAgICAgICQoXCJsaVtkYXRhLXRvb2w9XCIgKyBuZXdUb29sICsgXCJdXCIsIGJvZHkpLmFkZENsYXNzKFwic2VsZWN0ZWRcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICBidWlsZEJ1dHRvbnMoKTtcbn1cblxuQ1BUb29sUGFsZXR0ZS5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKENQUGFsZXR0ZS5wcm90b3R5cGUpO1xuQ1BUb29sUGFsZXR0ZS5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBDUFRvb2xQYWxldHRlO1xuIiwiLyogXG4gKiBCeSBOaWNob2xhcyBTaGVybG9jayA8bi5zaGVybG9ja0BnbWFpbC5jb20+XG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBXVEZQTHYyIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1dURlBMXG4gKi9cblxuaW1wb3J0IEFycmF5RGF0YVN0cmVhbSBmcm9tIFwiLi9BcnJheURhdGFTdHJlYW1cIjtcblxudmFyIFxuICAgIEFDT19DT0xPUlNQQUNFX1JHQiA9IDAsXG4gICAgQUNPX0NPTE9SU1BBQ0VfSFNCID0gMSxcbiAgICBBQ09fQ09MT1JTUEFDRV9DTVlLID0gMixcbiAgICBBQ09fQ09MT1JTUEFDRV9MQUIgPSA3LFxuICAgIEFDT19DT0xPUlNQQUNFX0dSQVlTQ0FMRSA9IDg7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIEFkb2JlQ29sb3JUYWJsZSgpIHtcbn1cblxuLyoqXG4gKiBSZWFkIGFuIC5hY28gKEFkb2JlIENPbG9yKSBzd2F0Y2hlcyBmaWxlIGFuZCByZXR1cm4gYW4gYXJyYXkgb2YgUkdCIGNvbG9ycy5cbiAqIFxuICogU3VwcG9ydHMgdmVyc2lvbiAxIHBhbGV0dGVzLCBvbmx5IFJHQiBmb3JtYXQuXG4gKiBcbiAqIEBwYXJhbSBpbnB1dCBBIFVpbnQ4QXJyYXkgb2YgdGhlIC5hY28gZmlsZSBjb250ZW50c1xuICogQHJldHVybiBBbiBhcnJheSBvZiBjb2xvdXJzLCBvciBudWxsIGlmIHRoZSBmaWxlIHdhcyBub3Qgc3VwcG9ydGVkLlxuICovXG5BZG9iZUNvbG9yVGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbihpbnB1dCkge1xuICAgIGlmIChpbnB1dCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBcbiAgICB2YXJcbiAgICAgICAgc3RyZWFtID0gbmV3IEFycmF5RGF0YVN0cmVhbShuZXcgVWludDhBcnJheShpbnB1dCkpLFxuICAgICAgICB2ZXJzaW9uLCBjb3VudCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB2ZXJzaW9uID0gc3RyZWFtLnJlYWRVMTZCRSgpO1xuICAgIGlmICh2ZXJzaW9uICE9IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvdW50ID0gc3RyZWFtLnJlYWRVMTZCRSgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgY29sb3Vyc3BhY2UgPSBzdHJlYW0ucmVhZFUxNkJFKCk7XG5cbiAgICAgICAgaWYgKGNvbG91cnNwYWNlICE9IEFDT19DT0xPUlNQQUNFX1JHQikge1xuICAgICAgICAgICAgY29udGludWU7IC8vIERyb3AgdW5zdXBwb3J0ZWQgY29sb3VycyBzaWxlbnRseVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gU2NhbGUgYmFjayBkb3duIGZyb20gMTYtYml0IHRvIDgtYml0XG4gICAgICAgIHZhclxuICAgICAgICAgICAgciA9IChzdHJlYW0ucmVhZFUxNkJFKCkgKiAyNTUpIC8gNjU1MzUsXG4gICAgICAgICAgICBnID0gKHN0cmVhbS5yZWFkVTE2QkUoKSAqIDI1NSkgLyA2NTUzNSxcbiAgICAgICAgICAgIGIgPSAoc3RyZWFtLnJlYWRVMTZCRSgpICogMjU1KSAvIDY1NTM1O1xuICAgICAgICBcbiAgICAgICAgc3RyZWFtLnJlYWRVMTZCRSgpOyAvLyB0aGlyZCB2YWx1ZSB1bnVzZWRcblxuICAgICAgICByZXN1bHQucHVzaChyIDw8IDE2IHwgZyA8PCA4IHwgYik7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKlxuICogV3JpdGUgYW4gLmFjbyAoQWRvYmUgQ09sb3IpIHN3YXRjaGVzIGZpbGUgb2YgdGhlIGdpdmVuIGFycmF5IG9mIFJHQiBjb2xvdXJzIChjb2xvcnMgYXJlIGludGVnZXJzIHdpdGggdGhlXG4gKiBibHVlIGNoYW5uZWwgaW4gdGhlIGxlYXN0LXNpZ25pZmljYW50IHBvc2l0aW9uKS5cbiAqL1xuQWRvYmVDb2xvclRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uKGNvbG91cnMpIHtcbiAgICB2YXJcbiAgICAgICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoMiAqIDIgKyBjb2xvdXJzLmxlbmd0aCAqIDEwKSxcbiAgICAgICAgc3RyZWFtID0gbmV3IEFycmF5RGF0YVN0cmVhbShidWZmZXIpO1xuICAgIFxuICAgIHN0cmVhbS53cml0ZVUxNkJFKDEpOyAvLyBWZXJzaW9uIDFcbiAgICBzdHJlYW0ud3JpdGVVMTZCRShjb2xvdXJzLmxlbmd0aCk7IC8vIE51bWJlciBvZiBjb2xvdXJzXG4gICAgXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb2xvdXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgY29sb3VyID0gY29sb3Vyc1tpXTtcbiAgICAgICAgXG4gICAgICAgIHN0cmVhbS53cml0ZVUxNkJFKEFDT19DT0xPUlNQQUNFX1JHQik7XG5cbiAgICAgICAgLy8gU2NhbGUgdXAgY29sb3VycyB0byAxNi1iaXRzICg2NTUzNS8yNTUgPSAyNTcpXG4gICAgICAgIHN0cmVhbS53cml0ZVUxNkJFKCgoY29sb3VyID4+IDE2KSAmIDB4RkYpICogMjU3KTtcbiAgICAgICAgc3RyZWFtLndyaXRlVTE2QkUoKChjb2xvdXIgPj4gOCkgJiAweEZGKSAqIDI1Nyk7XG4gICAgICAgIHN0cmVhbS53cml0ZVUxNkJFKChjb2xvdXIgJiAweEZGKSAqIDI1Nyk7XG4gICAgICAgIHN0cmVhbS53cml0ZVUxNkJFKDApO1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gc3RyZWFtLmdldEFzRGF0YUFycmF5KCk7XG59O1xuIiwiLyoqXG4gKiBBIHRvb2wgZm9yIHByZXNlbnRpbmcgYSBVaW50OEFycmF5IGFzIGEgc3RyZWFtIGZvciByZWFkaW5nIGFuZCB3cml0aW5nIHNvbWUgc2ltcGxlIGRhdGEgdHlwZXMuXG4gKiBcbiAqIEJ5IE5pY2hvbGFzIFNoZXJsb2NrIDxuLnNoZXJsb2NrQGdtYWlsLmNvbT4gMjAxNiwgcmVsZWFzZWQgdW5kZXIgdGhlIFdURlBMIGxpY2Vuc2UuXG4gKi9cblxudmFyIEVPRiA9IC0xO1xuXG5mdW5jdGlvbiBzaWduRXh0ZW5kMTZCaXQod29yZCkge1xuICAgIC8vSWYgc2lnbiBiaXQgaXMgc2V0LCBmaWxsIHRoZSB0b3AgYml0cyB3aXRoIDFzIHRvIHNpZ24tZXh0ZW5kXG4gICAgcmV0dXJuICh3b3JkICYgMHg4MDAwKSA/ICh3b3JkIHwgMHhGRkZGMDAwMCkgOiB3b3JkO1xufVxuXG5mdW5jdGlvbiBzaWduRXh0ZW5kOEJpdChieXRlKSB7XG4gICAgLy9JZiBzaWduIGJpdCBpcyBzZXQsIGZpbGwgdGhlIHRvcCBiaXRzIHdpdGggMXMgdG8gc2lnbi1leHRlbmRcbiAgICByZXR1cm4gKGJ5dGUgJiAweDgwKSA/IChieXRlIHwgMHhGRkZGRkYwMCkgOiBieXRlO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIHN0cmVhbSBvbiBleGlzdGluZyBhcnJheSBvZiB1bnNpZ25lZCBieXRlIGRhdGEgKGkuZS4gaG9wZWZ1bGx5IFVpbnQ4QXJyYXkpLlxuICogXG4gKiBAcGFyYW0gZGF0YSBVaW50OEFycmF5IHRvIHN0cmVhbSBkYXRhIGZyb21cbiAqIEBwYXJhbSBzdGFydCBUaGUgaW5kZXggb2YgdGhlIGJ5dGUgaW4gdGhlIGFycmF5IHRoYXQgd2lsbCBiZSByZWFkIGZpcnN0LCBvciBsZWF2ZSB1bmRlZmluZWQgdG8gYmVnaW4gYXQgdGhlXG4gKiAgICAgICAgICAgICAgYmVnaW5uaW5nIG9mIHRoZSBhcnJheVxuICogQHBhcmFtIGVuZCBUaGUgaW5kZXggb2YgdGhlIGVuZCBvZiB0aGUgc3RyZWFtLCBvciBsZWF2ZSB1bmRlZmluZWQgdG8gdXNlIHRoZSBlbmQgb2YgdGhlIGFycmF5IGFzIHRoZSBlbmQgb2ZcbiAqICAgICAgICAgICAgdGhlIHN0cmVhbS5cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXJyYXlEYXRhU3RyZWFtKGRhdGEsIHN0YXJ0LCBlbmQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZW9mID0gZmFsc2U7XG4gICAgdGhpcy5zdGFydCA9IHN0YXJ0ID09PSB1bmRlZmluZWQgPyAwIDogc3RhcnQ7XG4gICAgdGhpcy5lbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGRhdGEubGVuZ3RoIDogZW5kO1xuICAgIHRoaXMucG9zID0gdGhpcy5zdGFydDtcbn07XG5cbi8qKlxuICogUmVhZCBhIHNpbmdsZSBieXRlIGZyb20gdGhlIHN0cmVhbSBhbmQgdHVybiBpdCBpbnRvIGEgSmF2YVNjcmlwdCBzdHJpbmcgKGFzc3VtaW5nIEFTQ0lJKS5cbiAqIFxuICogQHJldHVybnMgU3RyaW5nIGNvbnRhaW5pbmcgb25lIGNoYXJhY3Rlciwgb3IgRU9GIGlmIHRoZSBlbmQgb2YgZmlsZSB3YXMgcmVhY2hlZCAoZW9mIGZsYWdcbiAqIGlzIHNldCkuXG4gKi9cbkFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZENoYXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wb3MgPCB0aGlzLmVuZCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmRhdGFbdGhpcy5wb3MrK10pO1xuICAgIH1cblxuICAgIHRoaXMuZW9mID0gdHJ1ZTtcbiAgICByZXR1cm4gRU9GO1xufTtcblxuLyoqXG4gKiBSZWFkIG9uZSB1bnNpZ25lZCBieXRlIGZyb20gdGhlIHN0cmVhbVxuICogXG4gKiBAcmV0dXJucyBVbnNpZ25lZCBieXRlLCBvciBFT0YgaWYgdGhlIGVuZCBvZiBmaWxlIHdhcyByZWFjaGVkIChlb2YgZmxhZyBpcyBzZXQpLlxuICovXG5BcnJheURhdGFTdHJlYW0ucHJvdG90eXBlLnJlYWRCeXRlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucG9zIDwgdGhpcy5lbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YVt0aGlzLnBvcysrXTtcbiAgICB9XG5cbiAgICB0aGlzLmVvZiA9IHRydWU7XG4gICAgcmV0dXJuIEVPRjtcbn07XG5cbi8vU3lub255bTpcbkFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZFU4ID0gQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkQnl0ZTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkUzggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gc2lnbkV4dGVuZDhCaXQodGhpcy5yZWFkQnl0ZSgpKTtcbn07XG5cbkFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUudW5yZWFkQ2hhciA9IGZ1bmN0aW9uKGMpIHtcbiAgICB0aGlzLnBvcy0tO1xufTtcbiAgICBcbkFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUucGVla0NoYXIgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAodGhpcy5wb3MgPCB0aGlzLmVuZCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLmRhdGFbdGhpcy5wb3NdKTtcbiAgICB9XG5cbiAgICB0aGlzLmVvZiA9IHRydWU7XG4gICAgcmV0dXJuIEVPRjtcbn07XG5cbkFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUucmVhZFN0cmluZyA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuICAgIHZhciBcbiAgICAgICAgY2hhcnMgPSBuZXcgQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgaTtcbiAgICBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2hhcnNbaV0gPSB0aGlzLnJlYWRDaGFyKCk7XG4gICAgfVxuICAgIFxuICAgIHJldHVybiBjaGFycy5qb2luKFwiXCIpO1xufTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkUzE2ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIFxuICAgICAgICBiMSA9IHRoaXMucmVhZEJ5dGUoKSxcbiAgICAgICAgYjIgPSB0aGlzLnJlYWRCeXRlKCk7XG4gICAgXG4gICAgcmV0dXJuIHNpZ25FeHRlbmQxNkJpdCgoYjEgPDwgOCkgfCBiMik7IFxufTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkVTE2QkUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgXG4gICAgICAgIGIxID0gdGhpcy5yZWFkQnl0ZSgpLFxuICAgICAgICBiMiA9IHRoaXMucmVhZEJ5dGUoKTtcbiAgICBcbiAgICByZXR1cm4gKGIxIDw8IDgpIHwgYjI7IFxufTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkVTE2TEUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgXG4gICAgICAgIGIxID0gdGhpcy5yZWFkQnl0ZSgpLFxuICAgICAgICBiMiA9IHRoaXMucmVhZEJ5dGUoKTtcbiAgICBcbiAgICByZXR1cm4gKGIyIDw8IDgpIHwgYjE7IFxufTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkVTMyQkUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgXG4gICAgICAgIGIxID0gdGhpcy5yZWFkQnl0ZSgpLFxuICAgICAgICBiMiA9IHRoaXMucmVhZEJ5dGUoKSxcbiAgICAgICAgYjMgPSB0aGlzLnJlYWRCeXRlKCksXG4gICAgICAgIGI0ID0gdGhpcy5yZWFkQnl0ZSgpO1xuICAgIHJldHVybiAoKGIxIDw8IDI0KSB8IChiMiA8PCAxNikgfCAoYjMgPDwgOCkgfCBiNCkgPj4+IDA7IFxufTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkVTMyTEUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgXG4gICAgICAgIGIxID0gdGhpcy5yZWFkQnl0ZSgpLFxuICAgICAgICBiMiA9IHRoaXMucmVhZEJ5dGUoKSxcbiAgICAgICAgYjMgPSB0aGlzLnJlYWRCeXRlKCksXG4gICAgICAgIGI0ID0gdGhpcy5yZWFkQnl0ZSgpO1xuICAgIHJldHVybiAoKGI0IDw8IDI0KSB8IChiMyA8PCAxNikgfCAoYjIgPDwgOCkgfCBiMSkgPj4+IDA7IFxufTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5yZWFkQnl0ZXMgPSBmdW5jdGlvbihjb3VudCkge1xuICAgIHZhclxuICAgICAgICByZXN1bHQgPSB0aGlzLmRhdGEuc3ViYXJyYXkodGhpcy5wb3MsIHRoaXMucG9zICsgY291bnQpO1xuICAgIFxuICAgIHRoaXMucG9zICs9IGNvdW50O1xuICAgIFxuICAgIGlmICh0aGlzLnBvcyA+IHRoaXMuZW5kKSB7XG4gICAgICAgIHRoaXMuZW9mID0gdHJ1ZTtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24obnVtQnl0ZXMpIHtcbiAgICB0aGlzLnBvcyArPSBudW1CeXRlcztcbiAgICBcbiAgICBpZiAodGhpcy5wb3MgPiB0aGlzLmVuZCkge1xuICAgICAgICB0aGlzLmVvZiA9IHRydWU7XG4gICAgfVxufTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5zZWVrID0gZnVuY3Rpb24ob2Zmc2V0KSB7XG4gICAgdGhpcy5wb3MgPSBvZmZzZXQ7XG59O1xuXG5BcnJheURhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlQnl0ZXMgPSBmdW5jdGlvbihhcnIpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSBhcnJbaV07XG4gICAgfVxufTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZUJ5dGUgPSBmdW5jdGlvbihiKSB7XG4gICAgdGhpcy5kYXRhW3RoaXMucG9zKytdID0gYjtcbn07XG5cbi8vU3lub255bTpcbkFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVVOCA9IEFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVCeXRlO1xuXG5BcnJheURhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlVTE2TEUgPSBmdW5jdGlvbih1KSB7XG4gICAgdGhpcy5kYXRhW3RoaXMucG9zKytdID0gdTtcbiAgICB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSB1ID4+IDg7XG59O1xuXG5BcnJheURhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlVTE2QkUgPSBmdW5jdGlvbih1KSB7XG4gICAgdGhpcy5kYXRhW3RoaXMucG9zKytdID0gdSA+PiA4O1xuICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IHU7XG59O1xuXG5BcnJheURhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlVTMyQkUgPSBmdW5jdGlvbih1KSB7XG4gICAgdGhpcy5kYXRhW3RoaXMucG9zKytdID0gdSA+PiAyNDtcbiAgICB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSB1ID4+IDE2O1xuICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IHUgPj4gODtcbiAgICB0aGlzLmRhdGFbdGhpcy5wb3MrK10gPSB1O1xufTtcblxuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZVUzMkxFID0gZnVuY3Rpb24odSkge1xuICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IHU7XG4gICAgdGhpcy5kYXRhW3RoaXMucG9zKytdID0gdSA+PiA4O1xuICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IHUgPj4gMTY7XG4gICAgdGhpcy5kYXRhW3RoaXMucG9zKytdID0gdSA+PiAyNDtcbn07XG5cbkFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uKGQpIHtcbiAgICB2YXIgXG4gICAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobmV3IEZsb2F0NjRBcnJheShbZF0pLmJ1ZmZlcik7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IGJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud3JpdGVCeXRlKGJ5dGVzW2ldKTtcbiAgICB9XG59O1xuXG5BcnJheURhdGFTdHJlYW0ucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uKGQpIHtcbiAgICB2YXIgXG4gICAgICAgIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkobmV3IEZsb2F0MzJBcnJheShbZF0pLmJ1ZmZlcik7XG4gICAgXG4gICAgZm9yICh2YXIgaSA9IGJ5dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIHRoaXMud3JpdGVCeXRlKGJ5dGVzW2ldKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIGFuIEFTQ0lJIHN0cmluZyB0byB0aGUgc3RyZWFtXG4gKi9cbkFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUud3JpdGVTdHJpbmcgPSBmdW5jdGlvbihzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGF0YVt0aGlzLnBvcysrXSA9IHMuY2hhckNvZGVBdChpKTtcbiAgICB9XG59O1xuXG4vKipcbiAqIFdyaXRlIHRoZSBnaXZlbiB1bnNpZ25lZCAzMi1iaXQgaW50ZWdlciB0byB0aGUgc3RyZWFtIGluIGJpZy1lbmRpYW4gb3JkZXIgdXNpbmcgdGhlIGdpdmVuIGJ5dGUgd2lkdGguXG4gKiBObyBlcnJvciBjaGVja2luZyBpcyBwZXJmb3JtZWQgdG8gZW5zdXJlIHRoYXQgdGhlIHN1cHBsaWVkIHdpZHRoIGlzIGNvcnJlY3QgZm9yIHRoZSBpbnRlZ2VyLlxuICogXG4gKiBPbWl0IHRoZSB3aWR0aCBwYXJhbWV0ZXIgdG8gaGF2ZSBpdCBkZXRlcm1pbmVkIGF1dG9tYXRpY2FsbHkgZm9yIHlvdS5cbiAqIFxuICogQHBhcmFtIHUgVW5zaWduZWQgaW50ZWdlciB0byBiZSB3cml0dGVuXG4gKiBAcGFyYW0gd2lkdGggTnVtYmVyIG9mIGJ5dGVzIHRvIHdyaXRlIHRvIHRoZSBzdHJlYW1cbiAqL1xuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS53cml0ZVVuc2lnbmVkSW50QkUgPSBmdW5jdGlvbih1LCB3aWR0aCkge1xuICAgIGlmICh3aWR0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHdpZHRoID0gdGhpcy5tZWFzdXJlVW5zaWduZWRJbnQodSk7XG4gICAgfVxuICAgIFxuICAgIC8vIEVhY2ggY2FzZSBmYWxscyB0aHJvdWdoOlxuICAgIHN3aXRjaCAod2lkdGgpIHtcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgICAgdGhpcy53cml0ZVU4KE1hdGguZmxvb3IodSAvIDQyOTQ5NjcyOTYpKTsgLy8gTmVlZCB0byB1c2UgZGl2aXNpb24gdG8gYWNjZXNzID4zMiBiaXRzIG9mIGZsb2F0aW5nIHBvaW50IHZhclxuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgICB0aGlzLndyaXRlVTgodSA+PiAyNCk7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOCh1ID4+IDE2KTtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgdGhpcy53cml0ZVU4KHUgPj4gOCk7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHRoaXMud3JpdGVVOCh1KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUV4Y2VwdGlvbihcIkJhZCBVSU5UIHNpemUgXCIgKyB3aWR0aCk7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIG51bWJlciBvZiBieXRlcyBuZWVkZWQgdG8gaG9sZCB0aGUgbm9uLXplcm8gYml0cyBvZiB0aGUgZ2l2ZW4gdW5zaWduZWQgaW50ZWdlci5cbiAqL1xuQXJyYXlEYXRhU3RyZWFtLnByb3RvdHlwZS5tZWFzdXJlVW5zaWduZWRJbnQgPSBmdW5jdGlvbih2YWwpIHtcbiAgICAvLyBGb3JjZSB0byAzMi1iaXQgdW5zaWduZWQgaW50ZWdlclxuICAgIGlmICh2YWwgPCAoMSA8PCA4KSkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICB9IGVsc2UgaWYgKHZhbCA8ICgxIDw8IDE2KSkge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9IGVsc2UgaWYgKHZhbCA8ICgxIDw8IDI0KSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9IGVsc2UgaWYgKHZhbCA8IDQyOTQ5NjcyOTYpIHtcbiAgICAgICAgcmV0dXJuIDQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIDU7XG4gICAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm4gYSB2aWV3IG9uIHRoZSBwb3J0aW9uIG9mIHRoZSBidWZmZXIgZnJvbSB0aGUgYmVnaW5uaW5nIHRvIHRoZSBjdXJyZW50IHNlZWsgcG9zaXRpb24gYXMgYSBVaW50OEFycmF5LlxuICovXG5BcnJheURhdGFTdHJlYW0ucHJvdG90eXBlLmdldEFzRGF0YUFycmF5ID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMucG9zIDwgdGhpcy5kYXRhLmJ5dGVMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGF0YS5zdWJhcnJheSgwLCB0aGlzLnBvcyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLnBvcyA9PSB0aGlzLmRhdGEuYnl0ZUxlbmd0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5kYXRhO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IFwiQXJyYXlEYXRhU3RyZWFtJ3MgcG9zIGxpZXMgYmV5b25kIGVuZCBvZiBidWZmZXJcIjsgXG4gICAgICAgIC8vIENoYW5jZSBpcyBwcmV0dHkgZ29vZCB0aGF0IHlvdSBvdmVyZmxvd2VkIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlciBkdXJpbmcgd3JpdGluZyBhbmQgeW91ciBmaWxlIGlzIHRyYXNoIFxuICAgIH1cbn07XG5cbkFycmF5RGF0YVN0cmVhbS5wcm90b3R5cGUuRU9GID0gRU9GOyIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUEJlemllcigpIHtcblxuICAgIC8vIEhvdyB0byB1c2UgdGhpcyBjbGFzczpcbiAgICAvL1xuICAgIC8vIDEgLSBzZXQgdGhlIDQgcG9pbnRzIGNvb3JkaW5hdGVzICh4MC0zLCB5MC0zKVxuICAgIC8vIHR3byBvcHRpb25zOlxuICAgIC8vIDJhIC0gY2FsbCBpbml0KCkgd2l0aCBkZXNpcmVkIGR0IHRoZW4gcmVhZCB0aGUgY3VycmVudCBjb29yZGluYXRlIChCeCwgQnkpIGFuZCB1c2UgbmV4dFBvaW50KCkgdG8gY29tcHV0ZSB0aGVcbiAgICAvLyBuZXh0IHBvaW50XG4gICAgLy8gMmIgLSB1c2Ugb25lIG9mIHRoZSBcImNvbXB1dGVcIiBtZXRob2RzIHRvIGNvbXB1dGUgdGhlIHZhbHVlcyBmb3IgdGhlIHdob2xlIGN1cnZlIGluIG9uZSBzdGVwXG5cbiAgICAvLyBUaGUgNCBwb2ludHMgY29vcmRpbmF0ZXNcbiAgICB0aGlzLngwID0gdGhpcy55MCA9IHRoaXMueDEgPSB0aGlzLnkxID0gdGhpcy54MiA9IHRoaXMueTIgPSB0aGlzLngzID0gdGhpcy55MyA9IDAuMDtcblxuICAgIC8vIHVzZWQgdG8gY29tcHV0ZSB0aGUgQmV6aWVyIGN1cnZlIHdpdGggdGhlIGZvcndhcmQgZGlmZmVyZW5jZXMgbWV0aG9kXG4gICAgdmFyXG4gICAgICAgIEJ4LCBkQngsIGRkQngsIGRkZEJ4LFxuICAgICAgICBCeSwgZEJ5LCBkZEJ5LCBkZGRCeSxcbiAgICAgICAgXG4gICAgICAgIHRoYXQgPSB0aGlzO1xuXG4gICAgZnVuY3Rpb24gaW5pdChkdCkge1xuICAgICAgICAvLyBJbXBsZW1lbnRzIGEgZmFzdCBkZWdyZWUtMyBCZXppZXIgY3VydmUgdXNpbmcgdGhlIGZvcndhcmQgZGlmZmVyZW5jZXMgbWV0aG9kXG4gICAgICAgIC8vXG4gICAgICAgIC8vIFJlZmVyZW5jZSBmb3IgdGhpcyBhbGdvcml0aG06XG4gICAgICAgIC8vIFwiQ3VydmVzIGFuZCBTdXJmYWNlcyBmb3IgQ29tcHV0ZXIgR3JhcGhpY3NcIiBieSBEYXZpZCBTYWxvbW9uLCBwYWdlIDE4OVxuXG4gICAgICAgIHZhclxuICAgICAgICAgICAgcTEgPSAzLjAgKiBkdCxcbiAgICAgICAgICAgIHEyID0gcTEgKiBkdCxcbiAgICAgICAgICAgIHEzID0gZHQgKiBkdCAqIGR0LFxuICAgICAgICAgICAgcTQgPSAyLjAgKiBxMixcbiAgICAgICAgICAgIHE1ID0gNi4wICogcTMsXG4gICAgICAgICAgICBxNnggPSB0aGF0LngwIC0gMi4wICogdGhhdC54MSArIHRoYXQueDIsXG4gICAgICAgICAgICBxNnkgPSB0aGF0LnkwIC0gMi4wICogdGhhdC55MSArIHRoYXQueTIsXG4gICAgICAgICAgICBxN3ggPSAzLjAgKiAodGhhdC54MSAtIHRoYXQueDIpIC0gdGhhdC54MCArIHRoYXQueDMsXG4gICAgICAgICAgICBxN3kgPSAzLjAgKiAodGhhdC55MSAtIHRoYXQueTIpIC0gdGhhdC55MCArIHRoYXQueTM7XG5cbiAgICAgICAgQnggPSB0aGF0LngwO1xuICAgICAgICBCeSA9IHRoYXQueTA7XG5cbiAgICAgICAgZEJ4ID0gKHRoYXQueDEgLSB0aGF0LngwKSAqIHExICsgcTZ4ICogcTIgKyBxN3ggKiBxMztcbiAgICAgICAgZEJ5ID0gKHRoYXQueTEgLSB0aGF0LnkwKSAqIHExICsgcTZ5ICogcTIgKyBxN3kgKiBxMztcblxuICAgICAgICBkZEJ4ID0gcTZ4ICogcTQgKyBxN3ggKiBxNTtcbiAgICAgICAgZGRCeSA9IHE2eSAqIHE0ICsgcTd5ICogcTU7XG5cbiAgICAgICAgZGRkQnggPSBxN3ggKiBxNTtcbiAgICAgICAgZGRkQnkgPSBxN3kgKiBxNTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaWxsIHRoZSBnaXZlbiB4LHkgYXJyYXlzIHdpdGggYSBzZXJpZXMgb2YgcG9pbnRzIG9uIHRoZSBjdXJ2ZS5cbiAgICAgKiBcbiAgICAgKiBAcGFyYW0geCBpbnRbXVxuICAgICAqIEBwYXJhbSB5IGludFtdXG4gICAgICogQHBhcmFtIGVsZW1lbnRzIGludCBDb3VudCBvZiBlbGVtZW50cyB0byBmaWxsIHggYW5kIHkgYXJyYXlzXG4gICAgICovXG4gICAgdGhpcy5jb21wdXRlID0gZnVuY3Rpb24oeCwgeSwgZWxlbWVudHMpIHtcbiAgICAgICAgaW5pdCgxLjAgLyBlbGVtZW50cyk7XG5cbiAgICAgICAgeFswXSA9IH5+Qng7XG4gICAgICAgIHlbMF0gPSB+fkJ5O1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBlbGVtZW50czsgaSsrKSB7XG4gICAgICAgICAgICBCeCArPSBkQng7XG4gICAgICAgICAgICBCeSArPSBkQnk7XG4gICAgICAgICAgICBkQnggKz0gZGRCeDtcbiAgICAgICAgICAgIGRCeSArPSBkZEJ5O1xuICAgICAgICAgICAgZGRCeCArPSBkZGRCeDtcbiAgICAgICAgICAgIGRkQnkgKz0gZGRkQnk7XG5cbiAgICAgICAgICAgIHhbaV0gPSB+fkJ4O1xuICAgICAgICAgICAgeVtpXSA9IH5+Qnk7XG4gICAgICAgIH1cbiAgICB9O1xufSIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUENvbG9yKHJnYikge1xuICAgIHZhclxuICAgICAgICB0aGF0ID0gdGhpcztcbiAgICBcbiAgICB0aGlzLnJnYiA9IDA7IC8vIGluIFJHQiBieXRlIG9yZGVyXG4gICAgXG4gICAgdGhpcy5odWUgPSAwO1xuICAgIHRoaXMuc2F0dXJhdGlvbiA9IDA7XG4gICAgdGhpcy52YWx1ZSA9IDA7XG4gICAgXG4gICAgZnVuY3Rpb24gcmdiVG9Ic3YoKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgciA9ICh0aGF0LnJnYiA+PiAxNikgJiAweGZmLFxuICAgICAgICAgICAgZyA9ICh0aGF0LnJnYiA+PiA4KSAmIDB4ZmYsXG4gICAgICAgICAgICBiID0gdGhhdC5yZ2IgJiAweGZmO1xuXG4gICAgICAgIC8vIFZhbHVlXG4gICAgICAgIHRoYXQudmFsdWUgPSBNYXRoLm1heChyLCBNYXRoLm1heChnLCBiKSk7XG5cbiAgICAgICAgLy8gU2F0dXJhdGlvblxuICAgICAgICB2YXIgXG4gICAgICAgICAgICBtaW5pID0gTWF0aC5taW4ociwgTWF0aC5taW4oZywgYikpO1xuICAgICAgICBcbiAgICAgICAgaWYgKHRoYXQudmFsdWUgPT0gMCkge1xuICAgICAgICAgICAgdGhhdC5zYXR1cmF0aW9uID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoYXQuc2F0dXJhdGlvbiA9IH5+KCh0aGF0LnZhbHVlIC0gbWluaSkgLyB0aGF0LnZhbHVlICogMjU1KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEh1ZVxuICAgICAgICBpZiAodGhhdC5zYXR1cmF0aW9uID09IDApIHtcbiAgICAgICAgICAgIHRoYXQuaHVlID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICBjciA9ICh0aGF0LnZhbHVlIC0gcikgLyAodGhhdC52YWx1ZSAtIG1pbmkpLFxuICAgICAgICAgICAgICAgIGNnID0gKHRoYXQudmFsdWUgLSBnKSAvICh0aGF0LnZhbHVlIC0gbWluaSksXG4gICAgICAgICAgICAgICAgY2IgPSAodGhhdC52YWx1ZSAtIGIpIC8gKHRoYXQudmFsdWUgLSBtaW5pKTtcblxuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgIF9odWUgPSAwO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBpZiAodGhhdC52YWx1ZSA9PSByKSB7XG4gICAgICAgICAgICAgICAgX2h1ZSA9IGNiIC0gY2c7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhhdC52YWx1ZSA9PSBnKSB7XG4gICAgICAgICAgICAgICAgX2h1ZSA9IDIgKyBjciAtIGNiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoYXQudmFsdWUgPT0gYikge1xuICAgICAgICAgICAgICAgIF9odWUgPSA0ICsgY2cgLSBjcjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgX2h1ZSAqPSA2MDtcbiAgICAgICAgICAgIGlmIChfaHVlIDwgMCkge1xuICAgICAgICAgICAgICAgIF9odWUgKz0gMzYwO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGF0Lmh1ZSA9IH5+X2h1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGhzdlRvUmdiKCkge1xuICAgICAgICAvLyBubyBzYXR1cmF0aW9uIG1lYW5zIGl0J3MganVzdCBhIHNoYWRlIG9mIGdyZXlcbiAgICAgICAgaWYgKHRoYXQuc2F0dXJhdGlvbiA9PSAwKSB7XG4gICAgICAgICAgICB0aGF0LnJnYiA9ICh0aGF0LnZhbHVlIDw8IDE2KSB8ICh0aGF0LnZhbHVlIDw8IDgpIHwgdGhhdC52YWx1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBcbiAgICAgICAgICAgICAgICBmID0gdGhhdC5odWUgLyA2MDtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZiA9IGYgLSBNYXRoLmZsb29yKGYpO1xuICAgIFxuICAgICAgICAgICAgdmFyIFxuICAgICAgICAgICAgICAgIHMgPSB0aGF0LnNhdHVyYXRpb24gLyAyNTUsXG4gICAgICAgICAgICAgICAgbSA9IH5+KHRoYXQudmFsdWUgKiAoMSAtIHMpKSxcbiAgICAgICAgICAgICAgICBuID0gfn4odGhhdC52YWx1ZSAqICgxIC0gcyAqIGYpKSxcbiAgICAgICAgICAgICAgICBrID0gfn4odGhhdC52YWx1ZSAqICgxIC0gcyAqICgxIC0gZikpKTtcbiAgICBcbiAgICAgICAgICAgIHN3aXRjaCAofn4odGhhdC5odWUgLyA2MCkpIHtcbiAgICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgICAgICB0aGF0LnJnYiA9ICh0aGF0LnZhbHVlIDw8IDE2KSB8IChrIDw8IDgpIHwgbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgICAgICB0aGF0LnJnYiA9IChuIDw8IDE2KSB8ICh0aGF0LnZhbHVlIDw8IDgpIHwgbTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgICB0aGF0LnJnYiA9IChtIDw8IDE2KSB8ICh0aGF0LnZhbHVlIDw8IDgpIHwgaztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICB0aGF0LnJnYiA9IChtIDw8IDE2KSB8IChuIDw8IDgpIHwgdGhhdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGF0LnJnYiA9IChrIDw8IDE2KSB8IChtIDw8IDgpIHwgdGhhdC52YWx1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNTpcbiAgICAgICAgICAgICAgICB0aGF0LnJnYiA9ICh0aGF0LnZhbHVlIDw8IDE2KSB8IChtIDw8IDgpIHwgbjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhhdC5yZ2IgPSAwOyAvLyBpbnZhbGlkIGh1ZVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5nZXRSZ2IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmdiO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRTYXR1cmF0aW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhdHVyYXRpb247XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0SHVlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmh1ZTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMuZ2V0VmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWU7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnNldFJnYkNvbXBvbmVudHMgPSBmdW5jdGlvbihyLCBnLCBiKSB7XG4gICAgICAgIHRoaXMuc2V0UmdiKChyIDw8IDE2KSB8IChnIDw8IDgpIHwgYik7XG4gICAgfVxuICAgIFxuICAgIHRoaXMuc2V0UmdiID0gZnVuY3Rpb24ocmdiKSB7XG4gICAgICAgIHRoaXMucmdiID0gcmdiO1xuICAgICAgICByZ2JUb0hzdigpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEhzdiA9IGZ1bmN0aW9uKGh1ZSwgdmFsdWUsIHNhdHVyYXRpb24pIHtcbiAgICAgICAgdGhpcy5odWUgPSBodWU7XG4gICAgICAgIHRoaXMuc2F0dXJhdGlvbiA9IHNhdHVyYXRpb247XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcblxuICAgICAgICBoc3ZUb1JnYigpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldEh1ZSA9IGZ1bmN0aW9uKGh1ZSkge1xuICAgICAgICB0aGlzLmh1ZSA9IGh1ZTtcbiAgICAgICAgaHN2VG9SZ2IoKTtcbiAgICB9O1xuXG4gICAgdGhpcy5zZXRTYXR1cmF0aW9uID0gZnVuY3Rpb24oc2F0dXJhdGlvbikge1xuICAgICAgICB0aGlzLnNhdHVyYXRpb24gPSBzYXR1cmF0aW9uO1xuICAgICAgICBoc3ZUb1JnYigpO1xuICAgIH07XG5cbiAgICB0aGlzLnNldFZhbHVlID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICBoc3ZUb1JnYigpO1xuICAgIH07XG5cbiAgICB0aGlzLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBcbiAgICAgICAgICAgIHJlc3VsdCA9IG5ldyBDUENvbG9yKCk7XG4gICAgICAgIFxuICAgICAgICByZXN1bHQuY29weUZyb20odGhpcyk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aGlzLmNvcHlGcm9tID0gZnVuY3Rpb24oYykge1xuICAgICAgICB0aGlzLnJnYiA9IGMucmdiO1xuICAgICAgICB0aGlzLmh1ZSA9IGMuaHVlO1xuICAgICAgICB0aGlzLnNhdHVyYXRpb24gPSBjLnNhdHVyYXRpb247XG4gICAgICAgIHRoaXMudmFsdWUgPSBjLnZhbHVlO1xuICAgIH07XG5cbiAgICB0aGlzLmlzRXF1YWwgPSBmdW5jdGlvbihjb2xvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5yZ2IgPT0gY29sb3IucmdiICYmIHRoaXMuaHVlID09IGNvbG9yLmh1ZSAmJiB0aGlzLnNhdHVyYXRpb24gPT0gY29sb3Iuc2F0dXJhdGlvbiAmJiB0aGlzLnZhbHVlID09IGNvbG9yLnZhbHVlO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5zZXRSZ2IocmdiIHx8IDApO1xufVxuIiwiLypcbiAgICBDaGlja2VuUGFpbnRcbiAgICBcbiAgICBDaGlja2VuUGFpbnQgaXMgYSB0cmFuc2xhdGlvbiBvZiBDaGliaVBhaW50IGZyb20gSmF2YSB0byBKYXZhU2NyaXB0XG4gICAgYnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuICAgIFxuICAgIENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICAgIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gICAgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3JcbiAgICAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gICAgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gICAgYWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbi8vIEFuIFJHQiBjb2xvciB3aXRoIGZsb2F0aW5nIHBvaW50IHZhbHVlcyBmb3IgZWFjaCBjaGFubmVsIChiZXR3ZWVuIDAuMCBhbmQgMS4wKVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BDb2xvckZsb2F0KHIsIGcsIGIpIHtcbiAgICB0aGlzLnIgPSByO1xuICAgIHRoaXMuZyA9IGc7XG4gICAgdGhpcy5iID0gYjtcbn1cblxuQ1BDb2xvckZsb2F0LnByb3RvdHlwZS50b0ludCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAoTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCBNYXRoLnJvdW5kKHRoaXMuciAqIDI1NSkpKSA8PCAxNikgXG4gICAgICAgIHwgKE1hdGgubWF4KDAsIE1hdGgubWluKDI1NSwgTWF0aC5yb3VuZCh0aGlzLmcgKiAyNTUpKSkgPDwgOClcbiAgICAgICAgfCBNYXRoLm1heCgwLCBNYXRoLm1pbigyNTUsIE1hdGgucm91bmQodGhpcy5iICogMjU1KSkpO1xufTtcblxuQ1BDb2xvckZsb2F0LnByb3RvdHlwZS5taXhXaXRoID0gZnVuY3Rpb24oY29sb3IsIGFscGhhKSB7XG4gICAgdGhpcy5yID0gdGhpcy5yICogKDEuMCAtIGFscGhhKSArIGNvbG9yLnIgKiBhbHBoYTtcbiAgICB0aGlzLmcgPSB0aGlzLmcgKiAoMS4wIC0gYWxwaGEpICsgY29sb3IuZyAqIGFscGhhO1xuICAgIHRoaXMuYiA9IHRoaXMuYiAqICgxLjAgLSBhbHBoYSkgKyBjb2xvci5iICogYWxwaGE7XG59O1xuXG5DUENvbG9yRmxvYXQucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIG5ldyBDUENvbG9yRmxvYXQodGhpcy5yLCB0aGlzLmcsIHRoaXMuYik7XG59O1xuXG5DUENvbG9yRmxvYXQuY3JlYXRlRnJvbUludCA9IGZ1bmN0aW9uKGNvbG9yKSB7XG4gICAgcmV0dXJuIG5ldyBDUENvbG9yRmxvYXQoXG4gICAgICAgICgoY29sb3IgPj4+IDE2KSAmIDB4ZmYpIC8gMjU1LFxuICAgICAgICAoKGNvbG9yID4+PiA4KSAmIDB4ZmYpIC8gMjU1LFxuICAgICAgICAoY29sb3IgJiAweGZmKSAvIDI1NVxuICAgICk7XG59OyIsIi8qXG5cdENoaWNrZW5QYWludFxuXG5cdENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcblx0YnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuXG5cdENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cblx0Q2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcblx0aXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcblx0dGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcblx0KGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuXHRDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcblx0YnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcblx0TUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuXHRHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG5cdFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG5cdGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5mdW5jdGlvbiBnZXRDYW52YXNJbnRlcnBvbGF0aW9uUHJvcE5hbWUoY2FudmFzQ29udGV4dCkge1xuXHR2YXJcblx0XHRicm93c2VyUHJvcGVydGllcyA9IFtcblx0XHRcdFwiaW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIsIFwibW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIsIFwid2Via2l0SW1hZ2VTbW9vdGhpbmdFbmFibGVkXCIsXG5cdFx0XHRcIm1zSW1hZ2VTbW9vdGhpbmdFbmFibGVkXCJcblx0XHRdO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgYnJvd3NlclByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcblx0XHRpZiAoYnJvd3NlclByb3BlcnRpZXNbaV0gaW4gY2FudmFzQ29udGV4dCkge1xuXHRcdFx0cmV0dXJuIGJyb3dzZXJQcm9wZXJ0aWVzW2ldO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBudWxsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNDYW52YXNJbnRlcnBvbGF0aW9uU3VwcG9ydGVkKCkge1xuXHR2YXJcblx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpLFxuXHRcdGNhbnZhc0NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuXG5cdHJldHVybiAhIWdldENhbnZhc0ludGVycG9sYXRpb25Qcm9wTmFtZShjYW52YXNDb250ZXh0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNldENhbnZhc0ludGVycG9sYXRpb24oY2FudmFzQ29udGV4dCwgZW5hYmxlZCkge1xuXHR2YXJcblx0XHRwcm9wTmFtZSA9IGdldENhbnZhc0ludGVycG9sYXRpb25Qcm9wTmFtZShjYW52YXNDb250ZXh0KTtcblxuXHRpZiAocHJvcE5hbWUpIHtcblx0XHRjYW52YXNDb250ZXh0W3Byb3BOYW1lXSA9IGVuYWJsZWQ7XG5cdH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRXZlbnRTdXBwb3J0ZWQoZXZlbnROYW1lKSB7XG5cdHZhclxuXHRcdGlzU3VwcG9ydGVkID0gZXZlbnROYW1lIGluIHdpbmRvdztcblxuXHRpZiAoIWlzU3VwcG9ydGVkKSB7XG5cdFx0dmFyXG5cdFx0XHRlbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdGVsLnNldEF0dHJpYnV0ZShldmVudE5hbWUsICdyZXR1cm47Jyk7XG5cblx0XHRpc1N1cHBvcnRlZCA9IHR5cGVvZiBlbFtldmVudE5hbWVdID09ICdmdW5jdGlvbic7XG5cdH1cblxuXHRyZXR1cm4gaXNTdXBwb3J0ZWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0NhbnZhc1N1cHBvcnRlZCgpe1xuXHR2YXIgZWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXHRyZXR1cm4gISEoZWxlbS5nZXRDb250ZXh0ICYmIGVsZW0uZ2V0Q29udGV4dCgnMmQnKSk7XG59IiwiLypcblx0Q2hpY2tlblBhaW50XG5cblx0Q2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuXHRieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG5cblx0Q2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuXHRDaGlja2VuUGFpbnQgaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuXHRpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuXHR0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuXHQoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG5cdENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuXHRidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuXHRNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG5cdEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cblx0WW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcblx0YWxvbmcgd2l0aCBDaGlja2VuUGFpbnQuIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbiovXG5cbmltcG9ydCBDUFRyYW5zZm9ybSBmcm9tICcuL0NQVHJhbnNmb3JtJztcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BQb2x5Z29uKHBvaW50cykge1xuXHR0aGlzLnBvaW50cyA9IHBvaW50cyB8fCBbXTtcbn1cblxuQ1BQb2x5Z29uLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXJcblx0XHRyZXN1bHQgPSBuZXcgQ1BQb2x5Z29uKG5ldyBBcnJheSh0aGlzLnBvaW50cy5sZW5ndGgpKTtcblxuXHRmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaSsrKSB7XG5cdFx0Ly8gRGVlcCBjbG9uZVxuXHRcdHJlc3VsdC5wb2ludHNbaV0gPSB7eCA6IHRoaXMucG9pbnRzW2ldLngsIHkgOiB0aGlzLnBvaW50c1tpXS55fTtcblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIEdldCBhIG5ldyBwb2x5Z29uIHdoaWNoIGlzIHRoZSByZXN1bHQgb2YgdHJhbnNmb3JtaW5nIHRoZSBwb2ludHMgb2YgdGhpcyBwb2x5Z29uIHdpdGggdGhlIGdpdmVuIGFmZmluZSB0cmFuc2Zvcm0uXG4gKlxuICogQHBhcmFtIHtDUFRyYW5zZm9ybX0gYWZmaW5lVHJhbnNmb3JtXG4gKiBAcmV0dXJucyB7Q1BQb2x5Z29ufVxuICovXG5DUFBvbHlnb24ucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkID0gZnVuY3Rpb24oYWZmaW5lVHJhbnNmb3JtKSB7XG5cdHZhclxuXHRcdHJlc3VsdCA9IG5ldyBDUFBvbHlnb24obmV3IEFycmF5KHRoaXMucG9pbnRzLmxlbmd0aCkpO1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcblx0XHRyZXN1bHQucG9pbnRzW2ldID0gYWZmaW5lVHJhbnNmb3JtLmdldFRyYW5zZm9ybWVkUG9pbnQodGhpcy5wb2ludHNbaV0pO1xuXHR9XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbkNQUG9seWdvbi5wcm90b3R5cGUuZ2V0Q2VudGVyID0gZnVuY3Rpb24oKSB7XG5cdHZhclxuXHRcdGNlbnRlclggPSB0aGlzLnBvaW50c1swXS54LFxuXHRcdGNlbnRlclkgPSB0aGlzLnBvaW50c1swXS55O1xuXG5cdGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5wb2ludHMubGVuZ3RoOyBpKyspIHtcblx0XHRjZW50ZXJYICs9IHRoaXMucG9pbnRzW2ldLng7XG5cdFx0Y2VudGVyWSArPSB0aGlzLnBvaW50c1tpXS55O1xuXHR9XG5cblx0cmV0dXJuIHt4OiBjZW50ZXJYIC8gdGhpcy5wb2ludHMubGVuZ3RoLCB5OiBjZW50ZXJZIC8gdGhpcy5wb2ludHMubGVuZ3RofTtcbn07XG5cbi8qKlxuICogRnJvbSBodHRwczovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbFxuICpcbiAqIEBwYXJhbSBwb2ludFxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbkNQUG9seWdvbi5wcm90b3R5cGUuY29udGFpbnNQb2ludCA9IGZ1bmN0aW9uKHBvaW50KSB7XG5cdHZhciBpLCBqLCBjb250YWluZWQgPSBmYWxzZTtcblxuXHRmb3IgKGkgPSAwLCBqID0gdGhpcy5wb2ludHMubGVuZ3RoIC0gMTsgaSA8IHRoaXMucG9pbnRzLmxlbmd0aDsgaiA9IGkrKykge1xuXHRcdGlmICgoKHRoaXMucG9pbnRzW2ldLnkgPiBwb2ludC55KSAhPSAodGhpcy5wb2ludHNbal0ueSA+IHBvaW50LnkpKSAmJlxuXHRcdFx0XHQocG9pbnQueCA8ICh0aGlzLnBvaW50c1tqXS54IC0gdGhpcy5wb2ludHNbaV0ueCkgKiAocG9pbnQueSAtIHRoaXMucG9pbnRzW2ldLnkpIC8gKHRoaXMucG9pbnRzW2pdLnkgLSB0aGlzLnBvaW50c1tpXS55KSArIHRoaXMucG9pbnRzW2ldLngpKSB7XG5cdFx0XHRjb250YWluZWQgPSAhY29udGFpbmVkO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBjb250YWluZWQ7XG59OyIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUFJhbmRvbSgpIHtcbiAgICB2YXIgXG4gICAgICAgIG5leHROZXh0R2F1c3NpYW4sIFxuICAgICAgICBoYXZlTmV4dE5leHRHYXVzc2lhbiA9IGZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogRGVmaW5pdGlvbiBmcm9tIEphdmEsIG1lYW4gb2YgMC4wIGFuZCBzdGFuZGFyZCBkZXZpYXRpb24gMS4wLlxuICAgICAqL1xuICAgIHRoaXMubmV4dEdhdXNzaWFuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChoYXZlTmV4dE5leHRHYXVzc2lhbikge1xuICAgICAgICAgICAgaGF2ZU5leHROZXh0R2F1c3NpYW4gPSBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybiBuZXh0TmV4dEdhdXNzaWFuO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB2YXJcbiAgICAgICAgICAgICAgICB2MSwgdjIsIHM7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICB2MSA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTsgLy8gYmV0d2VlbiAtMS4wIGFuZCAxLjBcbiAgICAgICAgICAgICAgICB2MiA9IDIgKiBNYXRoLnJhbmRvbSgpIC0gMTsgLy8gYmV0d2VlbiAtMS4wIGFuZCAxLjBcbiAgICAgICAgICAgICAgICBzID0gdjEgKiB2MSArIHYyICogdjI7XG4gICAgICAgICAgICB9IHdoaWxlIChzID49IDEgfHwgcyA9PSAwKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdmFyXG4gICAgICAgICAgICAgICAgbXVsdGlwbGllciA9IE1hdGguc3FydCgtMiAqIE1hdGgubG9nKHMpIC8gcyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIG5leHROZXh0R2F1c3NpYW4gPSB2MiAqIG11bHRpcGxpZXI7XG4gICAgICAgICAgICBoYXZlTmV4dE5leHRHYXVzc2lhbiA9IHRydWU7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHJldHVybiB2MSAqIG11bHRpcGxpZXI7XG4gICAgICAgIH1cbiAgICB9O1xufTsiLCIvKlxuICAgIENoaWNrZW5QYWludFxuICAgIFxuICAgIENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcbiAgICBieSBOaWNob2xhcyBTaGVybG9jayAvIENoaWNrZW4gU21vb3RoaWUuXG4gICAgXG4gICAgQ2hpYmlQYWludCBpcyBDb3B5cmlnaHQgKGMpIDIwMDYtMjAwOCBNYXJjIFNjaGVmZXJcblxuICAgIENoaWNrZW5QYWludCBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gICAgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAgICB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuICAgIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgICBDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAgICBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAgICBhbG9uZyB3aXRoIENoaWNrZW5QYWludC4gSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQ1BSZWN0KGxlZnQsIHRvcCwgcmlnaHQsIGJvdHRvbSkge1xuICAgIC8qXG4gICAgaWYgKGxlZnQgPT09IHVuZGVmaW5lZCB8fCB0b3AgPT09IHVuZGVmaW5lZCB8fCByaWdodCA9PT0gdW5kZWZpbmVkIHx8IGJvdHRvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IFwiQmFkIHJlY3RcIjtcbiAgICB9XG4gICAgXG4gICAgaWYgKH5+bGVmdCAhPT0gbGVmdCB8fCB+fnRvcCAhPT0gdG9wIHx8IH5+cmlnaHQgIT09IHJpZ2h0IHx8IH5+Ym90dG9tICE9PSBib3R0b20pIHtcbiAgICAgICAgdGhyb3cgXCJCYWQgcmVjdFwiO1xuICAgIH1cbiAgICAqL1xuICAgIFxuICAgIHRoaXMubGVmdCA9IGxlZnQ7XG4gICAgdGhpcy50b3AgPSB0b3A7XG4gICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xuICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xufVxuXG5DUFJlY3QucHJvdG90eXBlLm1ha2VFbXB0eSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMubGVmdCA9IDA7XG4gICAgdGhpcy50b3AgPSAwO1xuICAgIHRoaXMucmlnaHQgPSAwO1xuICAgIHRoaXMuYm90dG9tID0gMDtcbn07XG5cbkNQUmVjdC5wcm90b3R5cGUudW5pb24gPSBmdW5jdGlvbih0aGF0KSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICAgIHRoaXMuc2V0KHRoYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubGVmdCA9IE1hdGgubWluKHRoaXMubGVmdCwgdGhhdC5sZWZ0KTtcbiAgICAgICAgdGhpcy50b3AgPSBNYXRoLm1pbih0aGlzLnRvcCwgdGhhdC50b3ApO1xuICAgICAgICB0aGlzLnJpZ2h0ID0gTWF0aC5tYXgodGhpcy5yaWdodCwgdGhhdC5yaWdodCk7XG4gICAgICAgIHRoaXMuYm90dG9tID0gTWF0aC5tYXgodGhpcy5ib3R0b20sIHRoYXQuYm90dG9tKTtcbiAgICB9XG59O1xuXG5DUFJlY3QucHJvdG90eXBlLmdldFVuaW9uID0gZnVuY3Rpb24odGhhdCkge1xuICAgIHZhclxuICAgICAgICByZXN1bHQgPSB0aGlzLmNsb25lKCk7XG5cbiAgICByZXN1bHQudW5pb24odGhhdCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqXG4gKiBDbGlwIHRoaXMgcmVjdGFuZ2xlIHRvIGZpdCB3aXRoaW4gYHRoYXRgLlxuICogXG4gKiBAcmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGlzIHJlY3RhbmdsZSBmb3IgY2hhaW5pbmdcbiAqL1xuQ1BSZWN0LnByb3RvdHlwZS5jbGlwID0gZnVuY3Rpb24odGhhdCkge1xuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgICAgaWYgKHRoYXQuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgICB0aGlzLm1ha2VFbXB0eSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sZWZ0ID0gTWF0aC5tYXgodGhpcy5sZWZ0LCB0aGF0LmxlZnQpO1xuICAgICAgICAgICAgdGhpcy50b3AgPSBNYXRoLm1heCh0aGlzLnRvcCwgdGhhdC50b3ApO1xuICAgICAgICAgICAgdGhpcy5yaWdodCA9IE1hdGgubWluKHRoaXMucmlnaHQsIHRoYXQucmlnaHQpO1xuICAgICAgICAgICAgdGhpcy5ib3R0b20gPSBNYXRoLm1pbih0aGlzLmJvdHRvbSwgdGhhdC5ib3R0b20pO1xuICAgICAgICB9XG4gICAgfVxuICAgIFxuICAgIHJldHVybiB0aGlzO1xufTtcblxuQ1BSZWN0LnByb3RvdHlwZS5jb250YWluc1BvaW50ID0gZnVuY3Rpb24ocCkge1xuICAgIHJldHVybiAhKHAueCA8IHRoaXMubGVmdCB8fCBwLnkgPCB0aGlzLnRvcCB8fCBwLnggPj0gdGhpcy5yaWdodCB8fCBwLnkgPj0gdGhpcy5ib3R0b20pO1xufTtcblxuQ1BSZWN0LnByb3RvdHlwZS5pc0luc2lkZSA9IGZ1bmN0aW9uKHRoYXQpIHtcbiAgICByZXR1cm4gdGhpcy5sZWZ0ID49IHRoYXQubGVmdCAmJiB0aGlzLnRvcCA+PSB0aGF0LnRvcCAmJiB0aGlzLnJpZ2h0IDw9IHRoYXQucmlnaHQgJiYgdGhpcy5ib3R0b20gPD0gdGhhdC5ib3R0b207XG59O1xuXG4vKipcbiAqIFVzZSB0aGlzIHJlY3RhbmdsZSBhcyBib3VuZHMgdG8gY2xpcCB0aGUgcGxhY2VtZW50IG9mIHRoZSBhcmVhIG9mIHNyY1JlY3QgYXQgdGhlIHBvc2l0aW9uIG9mIGRzdFJlY3QgaW5zaWRlXG4gKiBvdXIgYm91bmRzLlxuICpcbiAqIGRzdFJlY3QgaGFzIGl0cyByaWdodCBhbmQgYm90dG9tIHNldCBieSB0aGlzIG9wZXJhdGlvbiB0byBtYXRjaCB0aGUgYXJlYSB0aGF0IHdvdWxkIGJlIGNvcGllZCBmcm9tIHRoZSBzb3VyY2UuXG4gKiBzcmNSZWN0IGhhcyBpdHMgY29vcmRpbmF0ZXMgdHdlYWtlZCB0byBtYXRjaCB0aGUgYXJlYSB0aGF0IHdpbGwgYmUgY29waWVkLlxuICovXG5DUFJlY3QucHJvdG90eXBlLmNsaXBTb3VyY2VEZXN0ID0gZnVuY3Rpb24oc3JjUmVjdCwgZHN0UmVjdCkge1xuICAgIGRzdFJlY3QucmlnaHQgPSBkc3RSZWN0LmxlZnQgKyBzcmNSZWN0LmdldFdpZHRoKCk7XG4gICAgZHN0UmVjdC5ib3R0b20gPSBkc3RSZWN0LnRvcCArIHNyY1JlY3QuZ2V0SGVpZ2h0KCk7XG5cbiAgICBpZiAodGhpcy5pc0VtcHR5KCkgfHwgZHN0UmVjdC5sZWZ0ID49IHRoaXMucmlnaHQgfHwgZHN0UmVjdC50b3AgPj0gdGhpcy5ib3R0b20gfHwgZHN0UmVjdC5yaWdodCA8PSB0aGlzLmxlZnQgfHwgZHN0UmVjdC5ib3R0b20gPD0gdGhpcy50b3ApIHtcbiAgICAgICAgc3JjUmVjdC5tYWtlRW1wdHkoKTtcbiAgICAgICAgZHN0UmVjdC5tYWtlRW1wdHkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBib3R0b20vcmlnaHRcbiAgICAgICAgaWYgKGRzdFJlY3QucmlnaHQgPiB0aGlzLnJpZ2h0KSB7XG4gICAgICAgICAgICBzcmNSZWN0LnJpZ2h0IC09IGRzdFJlY3QucmlnaHQgLSB0aGlzLnJpZ2h0O1xuICAgICAgICAgICAgZHN0UmVjdC5yaWdodCA9IHRoaXMucmlnaHQ7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKGRzdFJlY3QuYm90dG9tID4gdGhpcy5ib3R0b20pIHtcbiAgICAgICAgICAgIHNyY1JlY3QuYm90dG9tIC09IGRzdFJlY3QuYm90dG9tIC0gdGhpcy5ib3R0b207XG4gICAgICAgICAgICBkc3RSZWN0LmJvdHRvbSA9IHRoaXMuYm90dG9tO1xuICAgICAgICB9XG4gICAgXG4gICAgICAgIC8vIHRvcC9sZWZ0XG4gICAgICAgIGlmIChkc3RSZWN0LmxlZnQgPCB0aGlzLmxlZnQpIHtcbiAgICAgICAgICAgIHNyY1JlY3QubGVmdCArPSB0aGlzLmxlZnQgLSBkc3RSZWN0LmxlZnQ7XG4gICAgICAgICAgICBkc3RSZWN0LmxlZnQgPSB0aGlzLmxlZnQ7XG4gICAgICAgIH1cbiAgICBcbiAgICAgICAgaWYgKGRzdFJlY3QudG9wIDwgdGhpcy50b3ApIHtcbiAgICAgICAgICAgIHNyY1JlY3QudG9wICs9IHRoaXMudG9wIC0gZHN0UmVjdC50b3A7XG4gICAgICAgICAgICBkc3RSZWN0LnRvcCA9IHRoaXMudG9wO1xuICAgICAgICB9XG4gICAgfVxufTtcblxuQ1BSZWN0LnByb3RvdHlwZS5nZXRXaWR0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xufTtcblxuQ1BSZWN0LnByb3RvdHlwZS5nZXRIZWlnaHQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5ib3R0b20gLSB0aGlzLnRvcDtcbn07XG5cbkNQUmVjdC5wcm90b3R5cGUuZ2V0QXJlYSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLmdldFdpZHRoKCkgKiB0aGlzLmdldEhlaWdodCgpO1xufTtcblxuQ1BSZWN0LnByb3RvdHlwZS5pc0VtcHR5ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucmlnaHQgPD0gdGhpcy5sZWZ0IHx8IHRoaXMuYm90dG9tIDw9IHRoaXMudG9wO1xufTtcblxuQ1BSZWN0LnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbihyKSB7XG4gICAgdGhpcy5sZWZ0ID0gci5sZWZ0O1xuICAgIHRoaXMudG9wID0gci50b3A7XG4gICAgdGhpcy5yaWdodCA9IHIucmlnaHQ7XG4gICAgdGhpcy5ib3R0b20gPSByLmJvdHRvbTtcbn07XG5cbkNQUmVjdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IENQUmVjdCh0aGlzLmxlZnQsIHRoaXMudG9wLCB0aGlzLnJpZ2h0LCB0aGlzLmJvdHRvbSk7XG59O1xuXG5DUFJlY3QucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLmxlZnQgKz0geDtcbiAgICB0aGlzLnJpZ2h0ICs9IHg7XG4gICAgdGhpcy50b3AgKz0geTtcbiAgICB0aGlzLmJvdHRvbSArPSB5O1xufTtcblxuQ1BSZWN0LnByb3RvdHlwZS5tb3ZlVG8gPSBmdW5jdGlvbih4LCB5KSB7XG4gICAgdGhpcy50cmFuc2xhdGUoeCAtIHRoaXMubGVmdCwgeSAtIHRoaXMudG9wKTtcbn07XG5cbkNQUmVjdC5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24odGhhdCkge1xuICAgIHJldHVybiB0aGlzLmxlZnQgPT0gdGhhdC5sZWZ0ICYmIHRoaXMucmlnaHQgPT0gdGhhdC5yaWdodCAmJiB0aGlzLnRvcCA9PSB0aGF0LnRvcCAmJiB0aGlzLmJvdHRvbSA9PSB0aGF0LmJvdHRvbTtcbn07XG5cbi8qKlxuICogQWRkIGggcGl4ZWxzIHRvIGJvdGggdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIG9mIHRoZSByZWN0YW5nbGUsIGFuZCB2IHBpeGVscyB0byBib3RoIHRoZSB0b3AgYW5kIGJvdHRvbSBzaWRlcy5cbiAqICBcbiAqIEBwYXJhbSBoXG4gKiBAcGFyYW0gdlxuICovXG5DUFJlY3QucHJvdG90eXBlLmdyb3cgPSBmdW5jdGlvbihoLCB2KSB7XG4gICAgLy8gVE9ETyBjaGVja3MgZm9yIHJlY3RhbmdsZXMgd2l0aCB6ZXJvLWV4dGVudFxuICAgIHRoaXMubGVmdCAtPSBoO1xuICAgIHRoaXMucmlnaHQgKz0gaDtcbiAgICB0aGlzLnRvcCAtPSB2O1xuICAgIHRoaXMuYm90dG9tICs9IHY7XG59O1xuXG5DUFJlY3QucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiKFwiICsgdGhpcy5sZWZ0ICsgXCIsXCIgKyB0aGlzLnRvcCArIFwiLFwiICsgdGhpcy5yaWdodCArIFwiLFwiICsgdGhpcy5ib3R0b20gKyBcIilcIjtcbn07XG5cbi8qKlxuICogQ29udmVydCB0aGUgcmVjdGFuZ2xlIGludG8gYW4gYXJyYXkgb2YgcG9pbnRzIG9mIHRoZSBjb3JuZXJzIG9mIHRoZSByZWN0YW5nbGUgKGNsb2Nrd2lzZSBzdGFydGluZyBmcm9tIHRoZSB0b3AgbGVmdFxuICogcG9pbnQpLlxuICovXG5DUFJlY3QucHJvdG90eXBlLnRvUG9pbnRzID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAge3g6IHRoaXMubGVmdCwgeTogdGhpcy50b3B9LFxuICAgICAgICB7eDogdGhpcy5yaWdodCwgeTogdGhpcy50b3B9LFxuICAgICAgICB7eDogdGhpcy5yaWdodCwgeTogdGhpcy5ib3R0b219LFxuICAgICAgICB7eDogdGhpcy5sZWZ0LCB5OiB0aGlzLmJvdHRvbX1cbiAgICBdO1xufTtcblxuLyoqXG4gKiBSb3VuZCB0aGUgcmVjdGFuZ2xlIGNvb3JkaW5hdGVzIHRvIHRoZSBuZWFyZXN0IGludGVnZXIuXG4gKi9cbkNQUmVjdC5wcm90b3R5cGUucm91bmROZWFyZXN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5sZWZ0ID0gTWF0aC5yb3VuZCh0aGlzLmxlZnQpO1xuICAgIHRoaXMudG9wID0gTWF0aC5yb3VuZCh0aGlzLnRvcCk7XG4gICAgdGhpcy5yaWdodCA9IE1hdGgucm91bmQodGhpcy5yaWdodCk7XG4gICAgdGhpcy5ib3R0b20gPSBNYXRoLnJvdW5kKHRoaXMuYm90dG9tKTtcbn07XG5cbi8qKlxuICogUm91bmQgdGhlIHJlY3RhbmdsZSBjb29yZGluYXRlcyB0byBpbnRlZ2VycyBzbyB0aGF0IHRoZSBvbGQgcmVjdGFuZ2xlIGlzIGNvbnRhaW5lZCBieSB0aGUgbmV3IG9uZS5cbiAqL1xuQ1BSZWN0LnByb3RvdHlwZS5yb3VuZENvbnRhaW4gPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLmxlZnQgPSBNYXRoLmZsb29yKHRoaXMubGVmdCk7XG4gICAgdGhpcy50b3AgPSBNYXRoLmZsb29yKHRoaXMudG9wKTtcbiAgICB0aGlzLnJpZ2h0ID0gTWF0aC5jZWlsKHRoaXMucmlnaHQpO1xuICAgIHRoaXMuYm90dG9tID0gTWF0aC5jZWlsKHRoaXMuYm90dG9tKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlIGFuIEFBQkIgQ1BSZWN0IHdoaWNoIGVuY2xvc2VzIHRoZSBnaXZlbiBhcnJheSBvZiBwb2ludHMuXG4gKi9cbkNQUmVjdC5jcmVhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIHZhclxuICAgICAgICByZXN1bHQgPSBuZXcgQ1BSZWN0KHBvaW50c1swXS54LCBwb2ludHNbMF0ueSwgcG9pbnRzWzBdLngsIHBvaW50c1swXS55KTtcblxuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5sZWZ0ID0gTWF0aC5taW4ocmVzdWx0LmxlZnQsIHBvaW50c1tpXS54KTtcbiAgICAgICAgcmVzdWx0LnRvcCA9IE1hdGgubWluKHJlc3VsdC50b3AsIHBvaW50c1tpXS55KTtcbiAgICAgICAgcmVzdWx0LnJpZ2h0ID0gTWF0aC5tYXgocmVzdWx0LnJpZ2h0LCBwb2ludHNbaV0ueCk7XG4gICAgICAgIHJlc3VsdC5ib3R0b20gPSBNYXRoLm1heChyZXN1bHQuYm90dG9tLCBwb2ludHNbaV0ueSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qIFxuICogQ2hyb21lIGlzIGluaXRpYWxseSBlYWdlciB0byBvcHRpbWl6ZSBDUFJlY3QgYW5kIHVzZXJzIGFzc3VtaW5nIHRoYXQgYWxsIHRoZSBmaWVsZHMgYXJlIFNNSXMsIHRoZW4gbGF0ZXIgb24gZGVjaWRlc1xuICogdGhhdCB0aGV5IHNob3VsZCBiZSB0YWdnZWQgbnVtYmVycyBhZnRlciBhbGwuIFRoaXMgY2F1c2VzIGFsbCB0aGUgYmxlbmRpbmcgb3BlcmF0aW9uIGZ1bmN0aW9ucyB0byBiZSByZW9wdGltaXplZFxuICogYSBjb3VwbGUgb2YgdGltZXMuIFxuICogXG4gKiBBdm9pZCB0aGF0IG1lc3MgYnkgc3RhcnRpbmcgdGhpbmdzIG9mZiB3aXRoIGZsb2F0cyBpbiB0aGUgbWVtYmVycy4gIFxuICovXG53aW5kb3cuY3BSZWN0R2FyYmFnZSA9IG5ldyBDUFJlY3QoMS41LCAyLjUsIDMuNSwgNC41KTsiLCIvLyBNb2RpZmljYXRpb25zIGJ5IE5pY2hvbGFzIFNoZXJsb2NrLiBPcmlnaW5hbCBkb2NzIGJlbG93OlxuXG4vLyBMYXN0IHVwZGF0ZWQgTm92ZW1iZXIgMjAxMVxuLy8gQnkgU2ltb24gU2FycmlzXG4vLyB3d3cuc2ltb25zYXJyaXMuY29tXG4vLyBzYXJyaXNAYWNtLm9yZ1xuLy9cbi8vIEZyZWUgdG8gdXNlIGFuZCBkaXN0cmlidXRlIGF0IHdpbGxcbi8vIFNvIGxvbmcgYXMgeW91IGFyZSBuaWNlIHRvIHBlb3BsZSwgZXRjXG5cbi8vIFNpbXBsZSBjbGFzcyBmb3Iga2VlcGluZyB0cmFjayBvZiB0aGUgY3VycmVudCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXhcblxuLy8gRm9yIGluc3RhbmNlOlxuLy8gICAgdmFyIHQgPSBuZXcgVHJhbnNmb3JtKCk7XG4vLyAgICB0LnJvdGF0ZSg1KTtcbi8vICAgIHZhciBtID0gdC5tO1xuLy8gICAgY3R4LnNldFRyYW5zZm9ybShtWzBdLCBtWzFdLCBtWzJdLCBtWzNdLCBtWzRdLCBtWzVdKTtcblxuLy8gSXMgZXF1aXZhbGVudCB0bzpcbi8vICAgIGN0eC5yb3RhdGUoNSk7XG5cbi8vIEJ1dCBub3cgeW91IGNhbiByZXRyaWV2ZSBpdCA6KVxuXG4vLyBSZW1lbWJlciB0aGF0IHRoaXMgZG9lcyBub3QgYWNjb3VudCBmb3IgYW55IENTUyB0cmFuc2Zvcm1zIGFwcGxpZWQgdG8gdGhlIGNhbnZhc1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUFRyYW5zZm9ybSgpIHtcbiAgICB0aGlzLnNldFRvSWRlbnRpdHkoKTtcbn1cblxuQ1BUcmFuc2Zvcm0ucHJvdG90eXBlLnNldFRvSWRlbnRpdHkgPSBmdW5jdGlvbigpIHtcbiAgICAvKiBNYXRyaXggY29tcG9uZW50cyBhcmUgc3RvcmVkIGluIHRoaXMgb3JkZXIgaW4gJ20nOlxuICAgICAqIFswIDIgNF1cbiAgICAgKiBbMSAzIDVdXG4gICAgICogW3ggeCB4XVxuICAgICAqXG4gICAgICogTGFzdCByb3cgaXMgYWx3YXlzIDAsIDAsIDEgc28gd2UgZG9uJ3Qgc3RvcmUgaXQuXG4gICAgICovXG4gICAgdGhpcy5tID0gWyAxLCAwLCAwLCAxLCAwLCAwIF07XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoaXMgbWF0cml4IHdpdGggdGhlIGdpdmVuIHRyYW5zZm9ybWF0aW9uIG9uZSBsaWtlIHNvOlxuICpcbiAqIFt0aGlzXSA9IFt0aGlzXSAqIFttYXRyaXhdXG4gKlxuICogQHBhcmFtIHtDUFRyYW5zZm9ybX0gbWF0cml4XG4gKi9cbkNQVHJhbnNmb3JtLnByb3RvdHlwZS5tdWx0aXBseSA9IGZ1bmN0aW9uKG1hdHJpeCkge1xuICAgIHZhciBcbiAgICAgICAgbTExID0gdGhpcy5tWzBdICogbWF0cml4Lm1bMF0gKyB0aGlzLm1bMl0gKiBtYXRyaXgubVsxXSxcbiAgICAgICAgbTEyID0gdGhpcy5tWzFdICogbWF0cml4Lm1bMF0gKyB0aGlzLm1bM10gKiBtYXRyaXgubVsxXSxcblxuICAgICAgICBtMjEgPSB0aGlzLm1bMF0gKiBtYXRyaXgubVsyXSArIHRoaXMubVsyXSAqIG1hdHJpeC5tWzNdLFxuICAgICAgICBtMjIgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVsyXSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzNdLFxuXG4gICAgICAgIGR4ID0gdGhpcy5tWzBdICogbWF0cml4Lm1bNF0gKyB0aGlzLm1bMl0gKiBtYXRyaXgubVs1XSArIHRoaXMubVs0XSxcbiAgICAgICAgZHkgPSB0aGlzLm1bMV0gKiBtYXRyaXgubVs0XSArIHRoaXMubVszXSAqIG1hdHJpeC5tWzVdICsgdGhpcy5tWzVdO1xuXG4gICAgdGhpcy5tWzBdID0gbTExO1xuICAgIHRoaXMubVsxXSA9IG0xMjtcbiAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgdGhpcy5tWzNdID0gbTIyO1xuICAgIHRoaXMubVs0XSA9IGR4O1xuICAgIHRoaXMubVs1XSA9IGR5O1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGlzIG1hdHJpeCB3aXRoIHRoZSBnaXZlbiB0cmFuc2Zvcm1hdGlvbiBvbmUgbGlrZSBzbzpcbiAqXG4gKiBbdGhpc10gPSBbbWF0cml4XSAqIFt0aGlzXVxuICpcbiAqIEBwYXJhbSB7Q1BUcmFuc2Zvcm19IG1hdHJpeFxuICovXG5DUFRyYW5zZm9ybS5wcm90b3R5cGUucHJlTXVsdGlwbHkgPSBmdW5jdGlvbihtYXRyaXgpIHtcbiAgICB2YXJcbiAgICAgICAgbTExID0gbWF0cml4Lm1bMF0gKiB0aGlzLm1bMF0gKyBtYXRyaXgubVsyXSAqIHRoaXMubVsxXSxcbiAgICAgICAgbTEyID0gbWF0cml4Lm1bMV0gKiB0aGlzLm1bMF0gKyBtYXRyaXgubVszXSAqIHRoaXMubVsxXSxcblxuICAgICAgICBtMjEgPSBtYXRyaXgubVswXSAqIHRoaXMubVsyXSArIG1hdHJpeC5tWzJdICogdGhpcy5tWzNdLFxuICAgICAgICBtMjIgPSBtYXRyaXgubVsxXSAqIHRoaXMubVsyXSArIG1hdHJpeC5tWzNdICogdGhpcy5tWzNdLFxuXG4gICAgICAgIGR4ID0gbWF0cml4Lm1bMF0gKiB0aGlzLm1bNF0gKyBtYXRyaXgubVsyXSAqIHRoaXMubVs1XSArIG1hdHJpeC5tWzRdLFxuICAgICAgICBkeSA9IG1hdHJpeC5tWzFdICogdGhpcy5tWzRdICsgbWF0cml4Lm1bM10gKiB0aGlzLm1bNV0gKyBtYXRyaXgubVs1XTtcblxuICAgIHRoaXMubVswXSA9IG0xMTtcbiAgICB0aGlzLm1bMV0gPSBtMTI7XG4gICAgdGhpcy5tWzJdID0gbTIxO1xuICAgIHRoaXMubVszXSA9IG0yMjtcbiAgICB0aGlzLm1bNF0gPSBkeDtcbiAgICB0aGlzLm1bNV0gPSBkeTtcbn07XG5cbkNQVHJhbnNmb3JtLnByb3RvdHlwZS5pbnZlcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgXG4gICAgICAgIGQgPSAxIC8gKHRoaXMubVswXSAqIHRoaXMubVszXSAtIHRoaXMubVsxXSAqIHRoaXMubVsyXSksXG4gICAgICAgIG0wID0gdGhpcy5tWzNdICogZCxcbiAgICAgICAgbTEgPSAtdGhpcy5tWzFdICogZCxcbiAgICAgICAgbTIgPSAtdGhpcy5tWzJdICogZCxcbiAgICAgICAgbTMgPSB0aGlzLm1bMF0gKiBkLFxuICAgICAgICBtNCA9IGQgKiAodGhpcy5tWzJdICogdGhpcy5tWzVdIC0gdGhpcy5tWzNdICogdGhpcy5tWzRdKSxcbiAgICAgICAgbTUgPSBkICogKHRoaXMubVsxXSAqIHRoaXMubVs0XSAtIHRoaXMubVswXSAqIHRoaXMubVs1XSk7XG4gICAgXG4gICAgdGhpcy5tWzBdID0gbTA7XG4gICAgdGhpcy5tWzFdID0gbTE7XG4gICAgdGhpcy5tWzJdID0gbTI7XG4gICAgdGhpcy5tWzNdID0gbTM7XG4gICAgdGhpcy5tWzRdID0gbTQ7XG4gICAgdGhpcy5tWzVdID0gbTU7XG59O1xuXG5DUFRyYW5zZm9ybS5wcm90b3R5cGUuZ2V0SW52ZXJ0ZWQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXJcbiAgICAgICAgcmVzdWx0ID0gbmV3IENQVHJhbnNmb3JtKCk7XG4gICAgXG4gICAgcmVzdWx0Lm1bMF0gPSB0aGlzLm1bMF07XG4gICAgcmVzdWx0Lm1bMV0gPSB0aGlzLm1bMV07XG4gICAgcmVzdWx0Lm1bMl0gPSB0aGlzLm1bMl07XG4gICAgcmVzdWx0Lm1bM10gPSB0aGlzLm1bM107XG4gICAgcmVzdWx0Lm1bNF0gPSB0aGlzLm1bNF07XG4gICAgcmVzdWx0Lm1bNV0gPSB0aGlzLm1bNV07XG4gICAgXG4gICAgcmVzdWx0LmludmVydCgpO1xuICAgIFxuICAgIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoaXMgdHJhbnNmb3JtIGJ5IGEgcm90YXRpb24gbWF0cml4IGZvciB0aGUgZ2l2ZW4gYW5nbGU6XG4gKlxuICogWyBjb3MoYSkgLXNpbihhKSAwXVxuICogWyBzaW4oYSkgIGNvcyhhKSAwXVxuICogWyAgIDAgICAgICAgMCAgICAxXVxuICovXG5DUFRyYW5zZm9ybS5wcm90b3R5cGUucm90YXRlID0gZnVuY3Rpb24ocmFkKSB7XG4gICAgdmFyIFxuICAgICAgICBjID0gTWF0aC5jb3MocmFkKSxcbiAgICAgICAgcyA9IE1hdGguc2luKHJhZCksXG5cbiAgICAgICAgbTExID0gdGhpcy5tWzBdICogYyArIHRoaXMubVsyXSAqIHMsXG4gICAgICAgIG0xMiA9IHRoaXMubVsxXSAqIGMgKyB0aGlzLm1bM10gKiBzLFxuICAgICAgICBtMjEgPSB0aGlzLm1bMF0gKiAtcyArIHRoaXMubVsyXSAqIGMsXG4gICAgICAgIG0yMiA9IHRoaXMubVsxXSAqIC1zICsgdGhpcy5tWzNdICogYztcbiAgICBcbiAgICB0aGlzLm1bMF0gPSBtMTE7XG4gICAgdGhpcy5tWzFdID0gbTEyO1xuICAgIHRoaXMubVsyXSA9IG0yMTtcbiAgICB0aGlzLm1bM10gPSBtMjI7XG59O1xuXG5DUFRyYW5zZm9ybS5wcm90b3R5cGUucm90YXRlQXJvdW5kUG9pbnQgPSBmdW5jdGlvbihyYWQsIHgsIHkpIHtcbiAgICB0aGlzLnRyYW5zbGF0ZSh4LCB5KTtcbiAgICB0aGlzLnJvdGF0ZShyYWQpO1xuICAgIHRoaXMudHJhbnNsYXRlKC14LCAteSk7XG59O1xuXG4vKipcbiAqIE11bHRpcGx5IHRoaXMgdHJhbnNmb3JtIGJ5IGEgdHJhbnNsYXRpb24gbWF0cml4OlxuICpcbiAqIFsxICAwICB4XVxuICogWzAgIDEgIHldXG4gKiBbMCAgMCAgMV1cbiAqXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHlcbiAqL1xuQ1BUcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zbGF0ZSA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICB0aGlzLm1bNF0gKz0gdGhpcy5tWzBdICogeCArIHRoaXMubVsyXSAqIHk7XG4gICAgdGhpcy5tWzVdICs9IHRoaXMubVsxXSAqIHggKyB0aGlzLm1bM10gKiB5O1xufTtcblxuLyoqXG4gKiBNdWx0aXBseSB0aGlzIHRyYW5zZm9ybSBieSBhIHNjYWxlIG1hdHJpeDpcbiAqXG4gKiBbc3ggMCAgMF1cbiAqIFswICBzeSAwXVxuICogWzAgIDAgIDFdXG4gKlxuICogQHBhcmFtIHN4XG4gKiBAcGFyYW0gc3lcbiAqL1xuQ1BUcmFuc2Zvcm0ucHJvdG90eXBlLnNjYWxlID0gZnVuY3Rpb24oc3gsIHN5KSB7XG4gICAgdGhpcy5tWzBdICo9IHN4O1xuICAgIHRoaXMubVsxXSAqPSBzeDtcbiAgICB0aGlzLm1bMl0gKj0gc3k7XG4gICAgdGhpcy5tWzNdICo9IHN5O1xufTtcblxuQ1BUcmFuc2Zvcm0ucHJvdG90eXBlLnNjYWxlQXJvdW5kUG9pbnQgPSBmdW5jdGlvbihzeCwgc3ksIHB4LCBweSkge1xuICAgIHRoaXMudHJhbnNsYXRlKHB4LCBweSk7XG4gICAgdGhpcy5zY2FsZShzeCwgc3kpO1xuICAgIHRoaXMudHJhbnNsYXRlKC1weCwgLXB5KTtcbn07XG5cbi8qKlxuICogTXVsdGlwbHkgdGhpcyB0cmFuc2Zvcm0gYnkgYSBzaGVhciBtYXRyaXg6XG4gKlxuICogWzEgIHN4IDBdXG4gKiBbc3kgMSAgMF1cbiAqIFswICAwICAxXVxuICpcbiAqIEBwYXJhbSBzeFxuICogQHBhcmFtIHN5XG4gKi9cbkNQVHJhbnNmb3JtLnByb3RvdHlwZS5zaGVhciA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyXG4gICAgICBtMTEgPSB0aGlzLm1bMF0gKyB0aGlzLm1bMl0gKiB5LFxuICAgICAgbTEyID0gdGhpcy5tWzFdICsgdGhpcy5tWzNdICogeSxcbiAgICAgIG0yMSA9IHRoaXMubVsyXSArIHRoaXMubVswXSAqIHgsXG4gICAgICBtMjIgPSB0aGlzLm1bM10gKyB0aGlzLm1bMV0gKiB4O1xuXG4gICAgdGhpcy5tWzBdID0gbTExO1xuICAgIHRoaXMubVsxXSA9IG0xMjtcbiAgICB0aGlzLm1bMl0gPSBtMjE7XG4gICAgdGhpcy5tWzNdID0gbTIyO1xufTtcblxuQ1BUcmFuc2Zvcm0ucHJvdG90eXBlLmdldFRyYW5zZm9ybWVkUG9pbnQgPSBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgeDogcC54ICogdGhpcy5tWzBdICsgcC55ICogdGhpcy5tWzJdICsgdGhpcy5tWzRdLFxuICAgICAgICB5OiBwLnggKiB0aGlzLm1bMV0gKyBwLnkgKiB0aGlzLm1bM10gKyB0aGlzLm1bNV1cbiAgICB9O1xufTtcblxuQ1BUcmFuc2Zvcm0ucHJvdG90eXBlLnRyYW5zZm9ybVBvaW50cyA9IGZ1bmN0aW9uKHBvaW50cykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHBvaW50c1tpXSA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludChwb2ludHNbaV0pO1xuICAgIH1cbn07XG5cbkNQVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRUcmFuc2xhdGVYID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubVs0XTtcbn07XG5cbkNQVHJhbnNmb3JtLnByb3RvdHlwZS5nZXRUcmFuc2xhdGVZID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubVs1XTtcbn07XG5cbkNQVHJhbnNmb3JtLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhclxuICAgICAgICByZXN1bHQgPSBuZXcgQ1BUcmFuc2Zvcm0oKTtcbiAgICBcbiAgICByZXN1bHQubVswXSA9IHRoaXMubVswXTtcbiAgICByZXN1bHQubVsxXSA9IHRoaXMubVsxXTtcbiAgICByZXN1bHQubVsyXSA9IHRoaXMubVsyXTtcbiAgICByZXN1bHQubVszXSA9IHRoaXMubVszXTtcbiAgICByZXN1bHQubVs0XSA9IHRoaXMubVs0XTtcbiAgICByZXN1bHQubVs1XSA9IHRoaXMubVs1XTtcbiAgICBcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuQ1BUcmFuc2Zvcm0ucHJvdG90eXBlLmdldERldGVybWluYW50ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMubVswXSAqIHRoaXMubVszXSAtIHRoaXMubVsxXSAqIHRoaXMubVsyXTtcbn07XG5cbi8qKlxuICogQnJlYWsgZG93biB0aGUgbWF0cml4IGludG8gYSB0cmFuc2xhdGlvbiwgc2NhbGUsIHJvdGF0aW9uLCB0aGVuIHNoZWFyIG9wZXJhdGlvbi5cbiAqXG4gKiB4IG9yIHkgc2NhbGUgbXVzdCBub3QgYmUgemVyby5cbiAqXG4gKiBodHRwOi8vd3d3Lm1hdGhzLWluZm9ybWF0aXF1ZS1qZXV4LmNvbS9ibG9nL2ZyZWRlcmljLz9wb3N0LzIwMTMvMTIvMDEvRGVjb21wb3NpdGlvbi1vZi0yRC10cmFuc2Zvcm0tbWF0cmljZXNcbiAqL1xuQ1BUcmFuc2Zvcm0ucHJvdG90eXBlLmRlY29tcG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhclxuICAgICAgICBkZXRlcm1pbmFudCA9IHRoaXMuZ2V0RGV0ZXJtaW5hbnQoKSxcbiAgICAgICAgciA9IE1hdGguc3FydCh0aGlzLm1bMF0gKiB0aGlzLm1bMF0gKyB0aGlzLm1bMV0gKiB0aGlzLm1bMV0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHJhbnNsYXRlOiB7eDogdGhpcy5tWzRdLCB5OiB0aGlzLm1bNV19LFxuICAgICAgICByb3RhdGU6IE1hdGguc2lnbih0aGlzLm1bMV0pICogTWF0aC5hY29zKHRoaXMubVswXSAvIHIpLFxuICAgICAgICBzY2FsZToge3g6IHIsIHk6IGRldGVybWluYW50IC8gcn0sXG4gICAgICAgIHNoZWFyOiB7eDogTWF0aC5hdGFuKCh0aGlzLm1bMF0gKiB0aGlzLm1bMl0gKyB0aGlzLm1bMV0gKiB0aGlzLm1bM10pIC8gKHIgKiByKSksIHk6IDB9XG4gICAgfTtcbn07XG5cbkNQVHJhbnNmb3JtLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnN0XG4gICAgICAgIFBMQUNFUyA9IDI7XG5cbiAgICByZXR1cm4gKFwiW1wiICsgdGhpcy5tWzBdLnRvRml4ZWQoUExBQ0VTKSArIFwiIFwiICsgdGhpcy5tWzJdLnRvRml4ZWQoUExBQ0VTKSArIFwiIFwiICsgdGhpcy5tWzRdLnRvRml4ZWQoUExBQ0VTKSArIFwiXVxcblwiICtcbiAgICAgICAgICAgXCJbXCIgKyB0aGlzLm1bMV0udG9GaXhlZChQTEFDRVMpICsgXCIgXCIgKyB0aGlzLm1bM10udG9GaXhlZChQTEFDRVMpICsgXCIgXCIgKyB0aGlzLm1bNV0udG9GaXhlZChQTEFDRVMpICsgXCJdXFxuXCIgK1xuICAgICAgICAgICBcIlswLjAwIDAuMDAgMS4wMF1cIik7XG59O1xuXG5NYXRoLnNpZ24gPSBNYXRoLnNpZ24gfHwgZnVuY3Rpb24oeCkge1xuICAgIHggPSAreDsgLy8gY29udmVydCB0byBhIG51bWJlclxuICAgIGlmICh4ID09PSAwIHx8IGlzTmFOKHgpKSB7XG4gICAgICAgIHJldHVybiB4O1xuICAgIH1cbiAgICByZXR1cm4geCA+IDAgPyAxIDogLTE7XG59OyIsIi8qXG5cdENoaWNrZW5QYWludFxuXG5cdENoaWNrZW5QYWludCBpcyBhIHRyYW5zbGF0aW9uIG9mIENoaWJpUGFpbnQgZnJvbSBKYXZhIHRvIEphdmFTY3JpcHRcblx0YnkgTmljaG9sYXMgU2hlcmxvY2sgLyBDaGlja2VuIFNtb290aGllLlxuXG5cdENoaWJpUGFpbnQgaXMgQ29weXJpZ2h0IChjKSAyMDA2LTIwMDggTWFyYyBTY2hlZmVyXG5cblx0Q2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcblx0aXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcblx0dGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcblx0KGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuXHRDaGlja2VuUGFpbnQgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcblx0YnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcblx0TUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuXHRHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG5cdFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG5cdGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUFZlY3Rvcih4LCB5KSB7XG5cdHRoaXMueCA9IHg7XG5cdHRoaXMueSA9IHk7XG59XG5cbkNQVmVjdG9yLnByb3RvdHlwZS5nZXRMZW5ndGggPSBmdW5jdGlvbigpIHtcblx0cmV0dXJuIE1hdGguc3FydCh0aGlzLnggKiB0aGlzLnggKyB0aGlzLnkgKiB0aGlzLnkpO1xufTtcblxuLyoqXG4gKlxuICogQHJldHVybnMge0NQVmVjdG9yfSBUaGlzIHZlY3RvciBmb3IgY2hhaW5pbmdcbiAqL1xuQ1BWZWN0b3IucHJvdG90eXBlLm5vcm1hbGl6ZSA9IGZ1bmN0aW9uKCkge1xuXHR2YXJcblx0XHRsZW5ndGggPSB0aGlzLmdldExlbmd0aCgpO1xuXG5cdHRoaXMueCAvPSBsZW5ndGg7XG5cdHRoaXMueSAvPSBsZW5ndGg7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge0NQVmVjdG9yfSB0aGF0XG4gKi9cbkNQVmVjdG9yLnByb3RvdHlwZS5nZXREb3RQcm9kdWN0ID0gZnVuY3Rpb24odGhhdCkge1xuXHRyZXR1cm4gdGhpcy54ICogdGhhdC54ICsgdGhpcy55ICogdGhhdC55O1xufTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHNjYWxlRmFjdG9yXG4gKiBAcmV0dXJucyB7Q1BWZWN0b3J9IFRoaXMgdmVjdG9yIGZvciBjaGFpbmluZ1xuICovXG5DUFZlY3Rvci5wcm90b3R5cGUuc2NhbGUgPSBmdW5jdGlvbihzY2FsZUZhY3Rvcikge1xuXHR0aGlzLnggKj0gc2NhbGVGYWN0b3I7XG5cdHRoaXMueSAqPSBzY2FsZUZhY3RvcjtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbkNQVmVjdG9yLnByb3RvdHlwZS5nZXRTY2FsZWQgPSBmdW5jdGlvbihzY2FsZUZhY3Rvcikge1xuXHR2YXJcblx0XHRyZXN1bHQgPSBuZXcgQ1BWZWN0b3IodGhpcy54LCB0aGlzLnkpO1xuXG5cdHJlc3VsdC5zY2FsZShzY2FsZUZhY3Rvcik7XG5cblx0cmV0dXJuIHJlc3VsdDtcbn07XG5cbkNQVmVjdG9yLnByb3RvdHlwZS5nZXRSb3VuZGVkID0gZnVuY3Rpb24oKSB7XG5cdHJldHVybiBuZXcgQ1BWZWN0b3IoTWF0aC5yb3VuZCh0aGlzLngpLCBNYXRoLnJvdW5kKHRoaXMueSkpO1xufTtcblxuQ1BWZWN0b3IucHJvdG90eXBlLmdldFRydW5jYXRlZCA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbmV3IENQVmVjdG9yKH5+dGhpcy54LCB+fnRoaXMueSk7XG59O1xuXG5DUFZlY3Rvci5wcm90b3R5cGUuZ2V0UGVycGVuZGljdWxhciA9IGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gbmV3IENQVmVjdG9yKC10aGlzLnksIHRoaXMueCk7XG59O1xuXG4vKipcbiAqIEFkZCB0aGF0IHZlY3RvciB0byB0aGlzIG9uZVxuICpcbiAqIEBwYXJhbSB7Q1BWZWN0b3J9IHRoYXRcbiAqIEByZXR1cm5zIHtDUFZlY3Rvcn0gVGhpcyB2ZWN0b3IgZm9yIGNoYWluaW5nXG4gKi9cbkNQVmVjdG9yLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbih0aGF0KSB7XG5cdHRoaXMueCArPSB0aGF0Lng7XG5cdHRoaXMueSArPSB0aGF0Lnk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFN1YnRyYWN0IHRoYXQgdmVjdG9yIGZyb20gdGhpcyBvbmVcbiAqXG4gKiBAcGFyYW0ge0NQVmVjdG9yfSB0aGF0XG4gKiBAcmV0dXJucyB7Q1BWZWN0b3J9IFRoaXMgdmVjdG9yIGZvciBjaGFpbmluZ1xuICovXG5DUFZlY3Rvci5wcm90b3R5cGUuc3VidHJhY3QgPSBmdW5jdGlvbih0aGF0KSB7XG5cdHRoaXMueCAtPSB0aGF0Lng7XG5cdHRoaXMueSAtPSB0aGF0Lnk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cbi8qKlxuICogR2V0IHRoZSBzdW0gb2YgdGhpcyB2ZWN0b3IgYW5kIHRoYXQgb25lLlxuICpcbiAqIEBwYXJhbSB7Q1BWZWN0b3J9IHRoYXRcbiAqIEByZXR1cm5zIHtDUFZlY3Rvcn1cbiAqL1xuQ1BWZWN0b3IucHJvdG90eXBlLmdldFN1bSA9IGZ1bmN0aW9uKHRoYXQpIHtcblx0cmV0dXJuIG5ldyBDUFZlY3Rvcih0aGlzLnggKyB0aGF0LngsIHRoaXMueSArIHRoYXQueSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB2ZWN0b3IgYnkgcDEgLSBwMlxuICpcbiAqIEBwYXJhbSBwMVxuICogQHBhcmFtIHAyXG4gKlxuICogQHJldHVybnMge0NQVmVjdG9yfVxuICovXG5DUFZlY3Rvci5zdWJ0cmFjdFBvaW50cyA9IGZ1bmN0aW9uKHAxLCBwMikge1xuXHRyZXR1cm4gbmV3IENQVmVjdG9yKHAxLnggLSBwMi54LCBwMS55IC0gcDIueSk7XG59OyIsIi8qXG4gICAgQ2hpY2tlblBhaW50XG4gICAgXG4gICAgQ2hpY2tlblBhaW50IGlzIGEgdHJhbnNsYXRpb24gb2YgQ2hpYmlQYWludCBmcm9tIEphdmEgdG8gSmF2YVNjcmlwdFxuICAgIGJ5IE5pY2hvbGFzIFNoZXJsb2NrIC8gQ2hpY2tlbiBTbW9vdGhpZS5cbiAgICBcbiAgICBDaGliaVBhaW50IGlzIENvcHlyaWdodCAoYykgMjAwNi0yMDA4IE1hcmMgU2NoZWZlclxuXG4gICAgQ2hpY2tlblBhaW50IGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAgICBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICAgIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4gICAgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgIENoaWNrZW5QYWludCBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICAgIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICAgIGFsb25nIHdpdGggQ2hpY2tlblBhaW50LiBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG4qL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDUFdhY29tVGFibGV0KCkge1xuICAgIHZhciBcbiAgICAgICAgcGVuQVBJID0gbnVsbCxcbiAgICAgICAgcGx1Z2luT2JqZWN0LFxuICAgICAgICBcbiAgICAgICAgdGhhdCA9IHRoaXM7XG5cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgcGVuIGN1cnJlbnRseSBpbnRlcmFjdGluZyB3aXRoIHRoZSB0YWJsZXQgc3VyZmFjZT9cbiAgICAgKi9cbiAgICB0aGlzLmlzUGVuID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhclxuICAgICAgICAgICAgcG9pbnRlclR5cGU7XG5cbiAgICAgICAgaWYgKHBlbkFQSSkge1xuICAgICAgICAgICAgcG9pbnRlclR5cGUgPSBwZW5BUEkucG9pbnRlclR5cGU7XG5cbiAgICAgICAgICAgIHJldHVybiBwb2ludGVyVHlwZSA9PSAxIC8qIFBlbiAqLyB8fCBwb2ludGVyVHlwZSA9PSAzIC8qIEVyYXNlciAqLztcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5nZXRQcmVzc3VyZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocGVuQVBJKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVuQVBJLnByZXNzdXJlO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gMS4wO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5wbHVnaW5Mb2FkZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJXYWNvbSB0YWJsZXQgc3VwcG9ydCBsb2FkZWQhXCIpO1xuXG4gICAgICAgIHBlbkFQSSA9IHBsdWdpbk9iamVjdC5wZW5BUEk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmlzVGFibGV0UHJlc2VudCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gISFwZW5BUEk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENhbGwgYWZ0ZXIgdGhlIGRvY3VtZW50IGJvZHkgaXMgcmVhZHkgKG5lZWRzIERPTSB0byBiZSByZWFkeSBmb3IgbG9hZGluZyB0aGUgV2Fjb20gcGx1Z2luKS5cbiAgICAgKi9cbiAgICB0aGlzLmRldGVjdFRhYmxldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBDaHJvbWUgaGFzIGRyb3BwZWQgTlBBUEkgc3VwcG9ydCwgc28gdGhlIFdhY29tIHBsdWdpbiBjYW5ub3QgYmUgaW5zdGFsbGVkXG4gICAgICAgIGlmICgvQ2hyb21lL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSAmJiAhL09QUi8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgICAgICAgLy8gUHJldmVudCBhbiB1Z2x5IFwidGhpcyBwYWdlIGhhcyB0cmllZCB0byBsb2FkIGEgcGx1Z2luIHdoaWNoIGlzIG5vdCBzdXBwb3J0ZWRcIiBlcnJvciBtZXNzYWdlXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIk5vdCBhdHRlbXB0aW5nIHRvIGxvYWQgV2Fjb20gdGFibGV0IHBsdWdpbiwgc2luY2UgdGhpcyBpcyBDaHJvbWVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXR0ZW1wdGluZyB0byBsb2FkIFdhY29tIHRhYmxldCBzdXBwb3J0Li4uXCIpO1xuICAgICAgICBcbiAgICAgICAgcGx1Z2luT2JqZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9iamVjdFwiKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChcImNsYXNzaWRcIiBpbiBwbHVnaW5PYmplY3QpIHsgLy8gSUVcbiAgICAgICAgICAgIHBsdWdpbk9iamVjdC5jbGFzc2lkID0gXCJDTFNJRDowOTJkZmE4Ni01ODA3LTVhOTQtYmYzYi01YTUzYmE5ZTUzMDhcIjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhclxuICAgICAgICAgICAgICAgIHBhcmFtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBhcmFtXCIpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJhbS5uYW1lID0gXCJvbmxvYWRcIjtcbiAgICAgICAgICAgIHBhcmFtLnZhbHVlID0gXCJvbldhY29tUGx1Z2luTG9hZGVkXCI7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBsdWdpbk9iamVjdC5hcHBlbmRDaGlsZChwYXJhbSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBsdWdpbk9iamVjdC50eXBlID0gXCJhcHBsaWNhdGlvbi94LXdhY29tdGFibGV0cGx1Z2luXCI7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHBsdWdpbk9iamVjdC5zdHlsZS5wb3NpdGlvbiA9IFwiYWJzb2x1dGVcIjtcbiAgICAgICAgcGx1Z2luT2JqZWN0LnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICAgICAgICBwbHVnaW5PYmplY3Qub25sb2FkID0gXCJvbldhY29tUGx1Z2luTG9hZGVkXCI7XG4gICAgICAgIFxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBsdWdpbk9iamVjdCk7XG4gICAgICAgIFxuICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgaWYgKCF0aGF0LmlzVGFibGV0UHJlc2VudCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMb29rcyBsaWtlIHRoZSBXYWNvbSBwbHVnaW4gaXNuJ3QgaW5zdGFsbGVkLCBvciBmYWlsZWQgdG8gbG9hZC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDUwMDApO1xuICAgIH07XG59XG5cbkNQV2Fjb21UYWJsZXQuZ2V0UmVmID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKENQV2Fjb21UYWJsZXQuaW5zdGFuY2UgPT0gbnVsbCkge1xuICAgICAgICBDUFdhY29tVGFibGV0Lmluc3RhbmNlID0gbmV3IENQV2Fjb21UYWJsZXQoKTtcbiAgICB9XG4gICAgcmV0dXJuIENQV2Fjb21UYWJsZXQuaW5zdGFuY2U7XG59XG5cbndpbmRvdy5vbldhY29tUGx1Z2luTG9hZGVkID0gZnVuY3Rpb24oKSB7XG4gICAgQ1BXYWNvbVRhYmxldC5nZXRSZWYoKS5wbHVnaW5Mb2FkZWQoKTtcbn0iLCIvKiFcbiAqIGpRdWVyeSB0aHJvdHRsZSAvIGRlYm91bmNlIC0gdjEuMSAtIDMvNy8yMDEwXG4gKiBodHRwOi8vYmVuYWxtYW4uY29tL3Byb2plY3RzL2pxdWVyeS10aHJvdHRsZS1kZWJvdW5jZS1wbHVnaW4vXG4gKiBcbiAqIENvcHlyaWdodCAoYykgMjAxMCBcIkNvd2JveVwiIEJlbiBBbG1hblxuICogRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXMuXG4gKiBodHRwOi8vYmVuYWxtYW4uY29tL2Fib3V0L2xpY2Vuc2UvXG4gKi9cblxuLy8gU2NyaXB0OiBqUXVlcnkgdGhyb3R0bGUgLyBkZWJvdW5jZTogU29tZXRpbWVzLCBsZXNzIGlzIG1vcmUhXG4vL1xuLy8gKlZlcnNpb246IDEuMSwgTGFzdCB1cGRhdGVkOiAzLzcvMjAxMCpcbi8vIFxuLy8gUHJvamVjdCBIb21lIC0gaHR0cDovL2JlbmFsbWFuLmNvbS9wcm9qZWN0cy9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UtcGx1Z2luL1xuLy8gR2l0SHViICAgICAgIC0gaHR0cDovL2dpdGh1Yi5jb20vY293Ym95L2pxdWVyeS10aHJvdHRsZS1kZWJvdW5jZS9cbi8vIFNvdXJjZSAgICAgICAtIGh0dHA6Ly9naXRodWIuY29tL2Nvd2JveS9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UvcmF3L21hc3Rlci9qcXVlcnkuYmEtdGhyb3R0bGUtZGVib3VuY2UuanNcbi8vIChNaW5pZmllZCkgICAtIGh0dHA6Ly9naXRodWIuY29tL2Nvd2JveS9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UvcmF3L21hc3Rlci9qcXVlcnkuYmEtdGhyb3R0bGUtZGVib3VuY2UubWluLmpzICgwLjdrYilcbi8vIFxuLy8gQWJvdXQ6IExpY2Vuc2Vcbi8vIFxuLy8gQ29weXJpZ2h0IChjKSAyMDEwIFwiQ293Ym95XCIgQmVuIEFsbWFuLFxuLy8gRHVhbCBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGFuZCBHUEwgbGljZW5zZXMuXG4vLyBodHRwOi8vYmVuYWxtYW4uY29tL2Fib3V0L2xpY2Vuc2UvXG4vLyBcbi8vIEFib3V0OiBFeGFtcGxlc1xuLy8gXG4vLyBUaGVzZSB3b3JraW5nIGV4YW1wbGVzLCBjb21wbGV0ZSB3aXRoIGZ1bGx5IGNvbW1lbnRlZCBjb2RlLCBpbGx1c3RyYXRlIGEgZmV3XG4vLyB3YXlzIGluIHdoaWNoIHRoaXMgcGx1Z2luIGNhbiBiZSB1c2VkLlxuLy8gXG4vLyBUaHJvdHRsZSAtIGh0dHA6Ly9iZW5hbG1hbi5jb20vY29kZS9wcm9qZWN0cy9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UvZXhhbXBsZXMvdGhyb3R0bGUvXG4vLyBEZWJvdW5jZSAtIGh0dHA6Ly9iZW5hbG1hbi5jb20vY29kZS9wcm9qZWN0cy9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UvZXhhbXBsZXMvZGVib3VuY2UvXG4vLyBcbi8vIEFib3V0OiBTdXBwb3J0IGFuZCBUZXN0aW5nXG4vLyBcbi8vIEluZm9ybWF0aW9uIGFib3V0IHdoYXQgdmVyc2lvbiBvciB2ZXJzaW9ucyBvZiBqUXVlcnkgdGhpcyBwbHVnaW4gaGFzIGJlZW5cbi8vIHRlc3RlZCB3aXRoLCB3aGF0IGJyb3dzZXJzIGl0IGhhcyBiZWVuIHRlc3RlZCBpbiwgYW5kIHdoZXJlIHRoZSB1bml0IHRlc3RzXG4vLyByZXNpZGUgKHNvIHlvdSBjYW4gdGVzdCBpdCB5b3Vyc2VsZikuXG4vLyBcbi8vIGpRdWVyeSBWZXJzaW9ucyAtIG5vbmUsIDEuMy4yLCAxLjQuMlxuLy8gQnJvd3NlcnMgVGVzdGVkIC0gSW50ZXJuZXQgRXhwbG9yZXIgNi04LCBGaXJlZm94IDItMy42LCBTYWZhcmkgMy00LCBDaHJvbWUgNC01LCBPcGVyYSA5LjYtMTAuMS5cbi8vIFVuaXQgVGVzdHMgICAgICAtIGh0dHA6Ly9iZW5hbG1hbi5jb20vY29kZS9wcm9qZWN0cy9qcXVlcnktdGhyb3R0bGUtZGVib3VuY2UvdW5pdC9cbi8vIFxuLy8gQWJvdXQ6IFJlbGVhc2UgSGlzdG9yeVxuLy8gXG4vLyAxLjEgLSAoMy83LzIwMTApIEZpeGVkIGEgYnVnIGluIDxqUXVlcnkudGhyb3R0bGU+IHdoZXJlIHRyYWlsaW5nIGNhbGxiYWNrc1xuLy8gICAgICAgZXhlY3V0ZWQgbGF0ZXIgdGhhbiB0aGV5IHNob3VsZC4gUmV3b3JrZWQgYSBmYWlyIGFtb3VudCBvZiBpbnRlcm5hbFxuLy8gICAgICAgbG9naWMgYXMgd2VsbC5cbi8vIDEuMCAtICgzLzYvMjAxMCkgSW5pdGlhbCByZWxlYXNlIGFzIGEgc3RhbmQtYWxvbmUgcHJvamVjdC4gTWlncmF0ZWQgb3ZlclxuLy8gICAgICAgZnJvbSBqcXVlcnktbWlzYyByZXBvIHYwLjQgdG8ganF1ZXJ5LXRocm90dGxlIHJlcG8gdjEuMCwgYWRkZWQgdGhlXG4vLyAgICAgICBub190cmFpbGluZyB0aHJvdHRsZSBwYXJhbWV0ZXIgYW5kIGRlYm91bmNlIGZ1bmN0aW9uYWxpdHkuXG5cbi8vIE1ldGhvZDogdGhyb3R0bGVcbi8vXG4vLyBUaHJvdHRsZSBleGVjdXRpb24gb2YgYSBmdW5jdGlvbi4gRXNwZWNpYWxseSB1c2VmdWwgZm9yIHJhdGUgbGltaXRpbmdcbi8vIGV4ZWN1dGlvbiBvZiBoYW5kbGVycyBvbiBldmVudHMgbGlrZSByZXNpemUgYW5kIHNjcm9sbC4gSWYgeW91IHdhbnQgdG9cbi8vIHJhdGUtbGltaXQgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24gdG8gYSBzaW5nbGUgdGltZSwgc2VlIHRoZVxuLy8gPGpRdWVyeS5kZWJvdW5jZT4gbWV0aG9kLlxuLy9cbi8vIEluIHRoaXMgdmlzdWFsaXphdGlvbiwgfCBpcyBhIHRocm90dGxlZC1mdW5jdGlvbiBjYWxsIGFuZCBYIGlzIHRoZSBhY3R1YWxcbi8vIGNhbGxiYWNrIGV4ZWN1dGlvbjpcbi8vXG4vLyA+IFRocm90dGxlZCB3aXRoIGBub190cmFpbGluZ2Agc3BlY2lmaWVkIGFzIGZhbHNlIG9yIHVuc3BlY2lmaWVkOlxuLy8gPiB8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8IChwYXVzZSkgfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fFxuLy8gPiBYICAgIFggICAgWCAgICBYICAgIFggICAgWCAgICAgICAgWCAgICBYICAgIFggICAgWCAgICBYICAgIFhcbi8vID5cbi8vID4gVGhyb3R0bGVkIHdpdGggYG5vX3RyYWlsaW5nYCBzcGVjaWZpZWQgYXMgdHJ1ZTpcbi8vID4gfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCAocGF1c2UpIHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHxcbi8vID4gWCAgICBYICAgIFggICAgWCAgICBYICAgICAgICAgICAgIFggICAgWCAgICBYICAgIFggICAgWFxuLy9cbi8vIFVzYWdlOlxuLy9cbi8vID4gdmFyIHRocm90dGxlZCA9IGpRdWVyeS50aHJvdHRsZSggZGVsYXksIFsgbm9fdHJhaWxpbmcsIF0gY2FsbGJhY2sgKTtcbi8vID5cbi8vID4galF1ZXJ5KCdzZWxlY3RvcicpLmJpbmQoICdzb21lZXZlbnQnLCB0aHJvdHRsZWQgKTtcbi8vID4galF1ZXJ5KCdzZWxlY3RvcicpLnVuYmluZCggJ3NvbWVldmVudCcsIHRocm90dGxlZCApO1xuLy9cbi8vIFRoaXMgYWxzbyB3b3JrcyBpbiBqUXVlcnkgMS40Kzpcbi8vXG4vLyA+IGpRdWVyeSgnc2VsZWN0b3InKS5iaW5kKCAnc29tZWV2ZW50JywgalF1ZXJ5LnRocm90dGxlKCBkZWxheSwgWyBub190cmFpbGluZywgXSBjYWxsYmFjayApICk7XG4vLyA+IGpRdWVyeSgnc2VsZWN0b3InKS51bmJpbmQoICdzb21lZXZlbnQnLCBjYWxsYmFjayApO1xuLy9cbi8vIEFyZ3VtZW50czpcbi8vXG4vLyAgZGVsYXkgLSAoTnVtYmVyKSBBIHplcm8tb3ItZ3JlYXRlciBkZWxheSBpbiBtaWxsaXNlY29uZHMuIEZvciBldmVudFxuLy8gICAgY2FsbGJhY2tzLCB2YWx1ZXMgYXJvdW5kIDEwMCBvciAyNTAgKG9yIGV2ZW4gaGlnaGVyKSBhcmUgbW9zdCB1c2VmdWwuXG4vLyAgbm9fdHJhaWxpbmcgLSAoQm9vbGVhbikgT3B0aW9uYWwsIGRlZmF1bHRzIHRvIGZhbHNlLiBJZiBub190cmFpbGluZyBpc1xuLy8gICAgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBvbmx5IGV4ZWN1dGUgZXZlcnkgYGRlbGF5YCBtaWxsaXNlY29uZHMgd2hpbGUgdGhlXG4vLyAgICB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgYmVpbmcgY2FsbGVkLiBJZiBub190cmFpbGluZyBpcyBmYWxzZSBvclxuLy8gICAgdW5zcGVjaWZpZWQsIGNhbGxiYWNrIHdpbGwgYmUgZXhlY3V0ZWQgb25lIGZpbmFsIHRpbWUgYWZ0ZXIgdGhlIGxhc3Rcbi8vICAgIHRocm90dGxlZC1mdW5jdGlvbiBjYWxsLiAoQWZ0ZXIgdGhlIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW5cbi8vICAgIGNhbGxlZCBmb3IgYGRlbGF5YCBtaWxsaXNlY29uZHMsIHRoZSBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KVxuLy8gIGNhbGxiYWNrIC0gKEZ1bmN0aW9uKSBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy5cbi8vICAgIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsIGFzLWlzLCB0b1xuLy8gICAgYGNhbGxiYWNrYCB3aGVuIHRoZSB0aHJvdHRsZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4vL1xuLy8gUmV0dXJuczpcbi8vXG4vLyAgKEZ1bmN0aW9uKSBBIG5ldywgdGhyb3R0bGVkLCBmdW5jdGlvbi5cblxuZXhwb3J0IGZ1bmN0aW9uIHRocm90dGxlKGRlbGF5LCBub190cmFpbGluZywgY2FsbGJhY2ssIGRlYm91bmNlX21vZGUpIHtcblx0Ly8gQWZ0ZXIgd3JhcHBlciBoYXMgc3RvcHBlZCBiZWluZyBjYWxsZWQsIHRoaXMgdGltZW91dCBlbnN1cmVzIHRoYXRcblx0Ly8gYGNhbGxiYWNrYCBpcyBleGVjdXRlZCBhdCB0aGUgcHJvcGVyIHRpbWVzIGluIGB0aHJvdHRsZWAgYW5kIGBlbmRgXG5cdC8vIGRlYm91bmNlIG1vZGVzLlxuXHR2YXIgdGltZW91dF9pZCxcblxuXHQvLyBLZWVwIHRyYWNrIG9mIHRoZSBsYXN0IHRpbWUgYGNhbGxiYWNrYCB3YXMgZXhlY3V0ZWQuXG5cdFx0bGFzdF9leGVjID0gMDtcblxuXHQvLyBgbm9fdHJhaWxpbmdgIGRlZmF1bHRzIHRvIGZhbHN5LlxuXHRpZiAodHlwZW9mIG5vX3RyYWlsaW5nICE9PSAnYm9vbGVhbicpIHtcblx0XHRkZWJvdW5jZV9tb2RlID0gY2FsbGJhY2s7XG5cdFx0Y2FsbGJhY2sgPSBub190cmFpbGluZztcblx0XHRub190cmFpbGluZyA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFRoZSBgd3JhcHBlcmAgZnVuY3Rpb24gZW5jYXBzdWxhdGVzIGFsbCBvZiB0aGUgdGhyb3R0bGluZyAvIGRlYm91bmNpbmdcblx0Ly8gZnVuY3Rpb25hbGl0eSBhbmQgd2hlbiBleGVjdXRlZCB3aWxsIGxpbWl0IHRoZSByYXRlIGF0IHdoaWNoIGBjYWxsYmFja2Bcblx0Ly8gaXMgZXhlY3V0ZWQuXG5cdGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0ZWxhcHNlZCA9ICtuZXcgRGF0ZSgpIC0gbGFzdF9leGVjLFxuXHRcdFx0YXJncyA9IGFyZ3VtZW50cztcblxuXHRcdC8vIEV4ZWN1dGUgYGNhbGxiYWNrYCBhbmQgdXBkYXRlIHRoZSBgbGFzdF9leGVjYCB0aW1lc3RhbXAuXG5cdFx0ZnVuY3Rpb24gZXhlYygpIHtcblx0XHRcdGxhc3RfZXhlYyA9ICtuZXcgRGF0ZSgpO1xuXHRcdFx0Y2FsbGJhY2suYXBwbHkodGhhdCwgYXJncyk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgYGRlYm91bmNlX21vZGVgIGlzIHRydWUgKGF0X2JlZ2luKSB0aGlzIGlzIHVzZWQgdG8gY2xlYXIgdGhlIGZsYWdcblx0XHQvLyB0byBhbGxvdyBmdXR1cmUgYGNhbGxiYWNrYCBleGVjdXRpb25zLlxuXHRcdGZ1bmN0aW9uIGNsZWFyKCkge1xuXHRcdFx0dGltZW91dF9pZCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHRpZiAoZGVib3VuY2VfbW9kZSAmJiAhdGltZW91dF9pZCkge1xuXHRcdFx0Ly8gU2luY2UgYHdyYXBwZXJgIGlzIGJlaW5nIGNhbGxlZCBmb3IgdGhlIGZpcnN0IHRpbWUgYW5kXG5cdFx0XHQvLyBgZGVib3VuY2VfbW9kZWAgaXMgdHJ1ZSAoYXRfYmVnaW4pLCBleGVjdXRlIGBjYWxsYmFja2AuXG5cdFx0XHRleGVjKCk7XG5cdFx0fVxuXG5cdFx0Ly8gQ2xlYXIgYW55IGV4aXN0aW5nIHRpbWVvdXQuXG5cdFx0dGltZW91dF9pZCAmJiBjbGVhclRpbWVvdXQodGltZW91dF9pZCk7XG5cblx0XHRpZiAoZGVib3VuY2VfbW9kZSA9PT0gdW5kZWZpbmVkICYmIGVsYXBzZWQgPiBkZWxheSkge1xuXHRcdFx0Ly8gSW4gdGhyb3R0bGUgbW9kZSwgaWYgYGRlbGF5YCB0aW1lIGhhcyBiZWVuIGV4Y2VlZGVkLCBleGVjdXRlXG5cdFx0XHQvLyBgY2FsbGJhY2tgLlxuXHRcdFx0ZXhlYygpO1xuXG5cdFx0fSBlbHNlIGlmIChub190cmFpbGluZyAhPT0gdHJ1ZSkge1xuXHRcdFx0Ly8gSW4gdHJhaWxpbmcgdGhyb3R0bGUgbW9kZSwgc2luY2UgYGRlbGF5YCB0aW1lIGhhcyBub3QgYmVlblxuXHRcdFx0Ly8gZXhjZWVkZWQsIHNjaGVkdWxlIGBjYWxsYmFja2AgdG8gZXhlY3V0ZSBgZGVsYXlgIG1zIGFmdGVyIG1vc3Rcblx0XHRcdC8vIHJlY2VudCBleGVjdXRpb24uXG5cdFx0XHQvL1xuXHRcdFx0Ly8gSWYgYGRlYm91bmNlX21vZGVgIGlzIHRydWUgKGF0X2JlZ2luKSwgc2NoZWR1bGUgYGNsZWFyYCB0byBleGVjdXRlXG5cdFx0XHQvLyBhZnRlciBgZGVsYXlgIG1zLlxuXHRcdFx0Ly9cblx0XHRcdC8vIElmIGBkZWJvdW5jZV9tb2RlYCBpcyBmYWxzZSAoYXQgZW5kKSwgc2NoZWR1bGUgYGNhbGxiYWNrYCB0b1xuXHRcdFx0Ly8gZXhlY3V0ZSBhZnRlciBgZGVsYXlgIG1zLlxuXHRcdFx0dGltZW91dF9pZCA9IHNldFRpbWVvdXQoZGVib3VuY2VfbW9kZSA/IGNsZWFyIDogZXhlYywgZGVib3VuY2VfbW9kZSA9PT0gdW5kZWZpbmVkID8gZGVsYXkgLSBlbGFwc2VkIDogZGVsYXkpO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgd3JhcHBlciBmdW5jdGlvbi5cblx0cmV0dXJuIHdyYXBwZXI7XG59XG5cbi8vIE1ldGhvZDogalF1ZXJ5LmRlYm91bmNlXG4vL1xuLy8gRGVib3VuY2UgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24uIERlYm91bmNpbmcsIHVubGlrZSB0aHJvdHRsaW5nLFxuLy8gZ3VhcmFudGVlcyB0aGF0IGEgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBhIHNpbmdsZSB0aW1lLCBlaXRoZXIgYXQgdGhlXG4vLyB2ZXJ5IGJlZ2lubmluZyBvZiBhIHNlcmllcyBvZiBjYWxscywgb3IgYXQgdGhlIHZlcnkgZW5kLiBJZiB5b3Ugd2FudCB0b1xuLy8gc2ltcGx5IHJhdGUtbGltaXQgZXhlY3V0aW9uIG9mIGEgZnVuY3Rpb24sIHNlZSB0aGUgPGpRdWVyeS50aHJvdHRsZT5cbi8vIG1ldGhvZC5cbi8vXG4vLyBJbiB0aGlzIHZpc3VhbGl6YXRpb24sIHwgaXMgYSBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbCBhbmQgWCBpcyB0aGUgYWN0dWFsXG4vLyBjYWxsYmFjayBleGVjdXRpb246XG4vL1xuLy8gPiBEZWJvdW5jZWQgd2l0aCBgYXRfYmVnaW5gIHNwZWNpZmllZCBhcyBmYWxzZSBvciB1bnNwZWNpZmllZDpcbi8vID4gfHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fCAocGF1c2UpIHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHxcbi8vID4gICAgICAgICAgICAgICAgICAgICAgICAgIFggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBYXG4vLyA+XG4vLyA+IERlYm91bmNlZCB3aXRoIGBhdF9iZWdpbmAgc3BlY2lmaWVkIGFzIHRydWU6XG4vLyA+IHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHwgKHBhdXNlKSB8fHx8fHx8fHx8fHx8fHx8fHx8fHx8fHx8XG4vLyA+IFggICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBYXG4vL1xuLy8gVXNhZ2U6XG4vL1xuLy8gPiB2YXIgZGVib3VuY2VkID0galF1ZXJ5LmRlYm91bmNlKCBkZWxheSwgWyBhdF9iZWdpbiwgXSBjYWxsYmFjayApO1xuLy8gPlxuLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykuYmluZCggJ3NvbWVldmVudCcsIGRlYm91bmNlZCApO1xuLy8gPiBqUXVlcnkoJ3NlbGVjdG9yJykudW5iaW5kKCAnc29tZWV2ZW50JywgZGVib3VuY2VkICk7XG4vL1xuLy8gVGhpcyBhbHNvIHdvcmtzIGluIGpRdWVyeSAxLjQrOlxuLy9cbi8vID4galF1ZXJ5KCdzZWxlY3RvcicpLmJpbmQoICdzb21lZXZlbnQnLCBqUXVlcnkuZGVib3VuY2UoIGRlbGF5LCBbIGF0X2JlZ2luLCBdIGNhbGxiYWNrICkgKTtcbi8vID4galF1ZXJ5KCdzZWxlY3RvcicpLnVuYmluZCggJ3NvbWVldmVudCcsIGNhbGxiYWNrICk7XG4vL1xuLy8gQXJndW1lbnRzOlxuLy9cbi8vICBkZWxheSAtIChOdW1iZXIpIEEgemVyby1vci1ncmVhdGVyIGRlbGF5IGluIG1pbGxpc2Vjb25kcy4gRm9yIGV2ZW50XG4vLyAgICBjYWxsYmFja3MsIHZhbHVlcyBhcm91bmQgMTAwIG9yIDI1MCAob3IgZXZlbiBoaWdoZXIpIGFyZSBtb3N0IHVzZWZ1bC5cbi8vICBhdF9iZWdpbiAtIChCb29sZWFuKSBPcHRpb25hbCwgZGVmYXVsdHMgdG8gZmFsc2UuIElmIGF0X2JlZ2luIGlzIGZhbHNlIG9yXG4vLyAgICB1bnNwZWNpZmllZCwgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIGBkZWxheWAgbWlsbGlzZWNvbmRzIGFmdGVyXG4vLyAgICB0aGUgbGFzdCBkZWJvdW5jZWQtZnVuY3Rpb24gY2FsbC4gSWYgYXRfYmVnaW4gaXMgdHJ1ZSwgY2FsbGJhY2sgd2lsbCBiZVxuLy8gICAgZXhlY3V0ZWQgb25seSBhdCB0aGUgZmlyc3QgZGVib3VuY2VkLWZ1bmN0aW9uIGNhbGwuIChBZnRlciB0aGVcbi8vICAgIHRocm90dGxlZC1mdW5jdGlvbiBoYXMgbm90IGJlZW4gY2FsbGVkIGZvciBgZGVsYXlgIG1pbGxpc2Vjb25kcywgdGhlXG4vLyAgICBpbnRlcm5hbCBjb3VudGVyIGlzIHJlc2V0KVxuLy8gIGNhbGxiYWNrIC0gKEZ1bmN0aW9uKSBBIGZ1bmN0aW9uIHRvIGJlIGV4ZWN1dGVkIGFmdGVyIGRlbGF5IG1pbGxpc2Vjb25kcy5cbi8vICAgIFRoZSBgdGhpc2AgY29udGV4dCBhbmQgYWxsIGFyZ3VtZW50cyBhcmUgcGFzc2VkIHRocm91Z2gsIGFzLWlzLCB0b1xuLy8gICAgYGNhbGxiYWNrYCB3aGVuIHRoZSBkZWJvdW5jZWQtZnVuY3Rpb24gaXMgZXhlY3V0ZWQuXG4vL1xuLy8gUmV0dXJuczpcbi8vXG4vLyAgKEZ1bmN0aW9uKSBBIG5ldywgZGVib3VuY2VkLCBmdW5jdGlvbi5cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYm91bmNlKGRlbGF5LCBhdF9iZWdpbiwgY2FsbGJhY2spIHtcblx0cmV0dXJuIGNhbGxiYWNrID09PSB1bmRlZmluZWRcblx0XHQ/IHRocm90dGxlKGRlbGF5LCBhdF9iZWdpbiwgZmFsc2UpXG5cdFx0OiB0aHJvdHRsZShkZWxheSwgY2FsbGJhY2ssIGF0X2JlZ2luICE9PSBmYWxzZSk7XG59XG4iXX0=
